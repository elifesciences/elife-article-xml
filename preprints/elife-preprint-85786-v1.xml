<?xml version="1.0" ?><!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.3 20210610//EN"  "JATS-archivearticle1-mathml3.dtd"><article xmlns:ali="http://www.niso.org/schemas/ali/1.0/" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article" dtd-version="1.3" xml:lang="en">
<front>
<journal-meta>
<journal-id journal-id-type="nlm-ta">elife</journal-id>
<journal-id journal-id-type="publisher-id">eLife</journal-id>
<journal-title-group>
<journal-title>eLife</journal-title>
</journal-title-group>
<issn publication-format="electronic" pub-type="epub">2050-084X</issn>
<publisher>
<publisher-name>eLife Sciences Publications, Ltd</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">85786</article-id>
<article-id pub-id-type="doi">10.7554/eLife.85786</article-id>
<article-id pub-id-type="doi" specific-use="version">10.7554/eLife.85786.1</article-id>
<article-version-alternatives>
<article-version article-version-type="publication-state">reviewed preprint</article-version>
<article-version article-version-type="preprint-version">1.1</article-version>
</article-version-alternatives>
<article-categories>
<subj-group subj-group-type="heading">
<subject>Neuroscience</subject>
</subj-group>
</article-categories>
<title-group>
<article-title>Pynapple: a toolbox for data analysis in neuroscience</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<name>
<surname>Viejo</surname>
<given-names>Guillaume</given-names>
</name>
<xref ref-type="aff" rid="a1">1</xref>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Levenstein</surname>
<given-names>Daniel</given-names>
</name>
<xref ref-type="aff" rid="a1">1</xref>
<xref ref-type="aff" rid="a2">2</xref>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Carrasco</surname>
<given-names>Sofia Skromne</given-names>
</name>
<xref ref-type="aff" rid="a1">1</xref>
</contrib>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">http://orcid.org/0000-0001-5813-3218</contrib-id>
<name>
<surname>Mehrotra</surname>
<given-names>Dhruv</given-names>
</name>
<xref ref-type="aff" rid="a1">1</xref>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Mahallati</surname>
<given-names>Sara</given-names>
</name>
<xref ref-type="aff" rid="a1">1</xref>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Vite</surname>
<given-names>Gilberto R</given-names>
</name>
<xref ref-type="aff" rid="a1">1</xref>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Denny</surname>
<given-names>Henry</given-names>
</name>
<xref ref-type="aff" rid="a1">1</xref>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Sjulson</surname>
<given-names>Lucas</given-names>
</name>
<xref ref-type="aff" rid="a3">3</xref>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Battaglia</surname>
<given-names>Francesco P</given-names>
</name>
<xref ref-type="aff" rid="a4">4</xref>
</contrib>
<contrib contrib-type="author" corresp="yes">
<name>
<surname>Peyrache</surname>
<given-names>Adrien</given-names>
</name>
<xref ref-type="aff" rid="a1">1</xref>
<xref ref-type="corresp" rid="cor1">*</xref>
</contrib>
<aff id="a1"><label>1</label><institution>Montreal Neurological Institute and Hospital, McGill University</institution>, Montreal, QC, <country>Canada</country></aff>
<aff id="a2"><label>2</label><institution>MILA – Quebec IA Institute</institution></aff>
<aff id="a3"><label>3</label><institution>Departments of Psychiatry and Neuroscience, Albert Einstein College of Medicine</institution>, Bronx, NY</aff>
<aff id="a4"><label>4</label><institution>Donders Institute for Brain, Cognition and Behaviour, Radboud University</institution>, 6525AJ Nijmegen, <country>The Netherlands</country></aff>
</contrib-group>
<contrib-group content-type="section">
<contrib contrib-type="editor">
<name>
<surname>Kemere</surname>
<given-names>Caleb</given-names>
</name>
<role>Reviewing Editor</role>
<aff>
<institution-wrap>
<institution>Rice University</institution>
</institution-wrap>
<city>Houston</city>
<country>United States of America</country>
</aff>
</contrib>
<contrib contrib-type="senior_editor">
<name>
<surname>Behrens</surname>
<given-names>Timothy E</given-names>
</name>
<role>Senior Editor</role>
<aff>
<institution-wrap>
<institution>University of Oxford</institution>
</institution-wrap>
<city>Oxford</city>
<country>United Kingdom</country>
</aff>
</contrib>
</contrib-group>
<author-notes>
<corresp id="cor1"><label>*</label><bold>Materials &amp; Correspondence</bold> All correspondence should be directed to Adrien Peyrache at <email>adrien.peyrache@mcgill.ca</email></corresp>
</author-notes>
<pub-date date-type="original-publication" iso-8601-date="2023-05-17">
<day>17</day>
<month>05</month>
<year>2023</year>
</pub-date>
<volume>12</volume>
<elocation-id>RP85786</elocation-id>
<history>
<date date-type="sent-for-review" iso-8601-date="2023-01-24">
<day>24</day>
<month>01</month>
<year>2023</year>
</date>
</history>
<pub-history>
<event>
<event-desc>Preprint posted</event-desc>
<date date-type="preprint" iso-8601-date="2022-12-07">
<day>07</day>
<month>12</month>
<year>2022</year>
</date>
<self-uri content-type="preprint" xlink:href="https://doi.org/10.1101/2022.12.06.519376"/>
</event>
</pub-history>
<permissions>
<copyright-statement>© 2023, Viejo et al</copyright-statement>
<copyright-year>2023</copyright-year>
<copyright-holder>Viejo et al</copyright-holder>
<ali:free_to_read/>
<license xlink:href="https://creativecommons.org/licenses/by/4.0/">
<ali:license_ref>https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
<license-p>This article is distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution License</ext-link>, which permits unrestricted use and redistribution provided that the original author and source are credited.</license-p>
</license>
</permissions>
<self-uri content-type="pdf" xlink:href="elife-preprint-85786-v1.pdf"/>
<abstract>
<title>Abstract</title>
<p>Datasets collected in neuroscientific studies are of ever-growing complexity, often combining high dimensional time series data from multiple data acquisition modalities. Handling and manipulating these various data streams in an adequate programming environment is crucial to ensure reliable analysis, and to facilitate sharing of reproducible analysis pipelines. Here, we present Pynapple, a lightweight python package designed to process a broad range of time-resolved data in systems neuroscience. The core feature of this package is a small number of versatile objects that support the manipulation of any data streams and task parameters. The package includes a set of methods to read common data formats and allows users to easily write their own. The resulting code is easy to read and write, avoids low-level data processing and other error-prone steps, and is fully open source. Libraries for higher-level analyses are developed within the Pynapple framework but are contained within in a collaborative repository of specialized and continuously updated analysis routines. This provides flexibility while ensuring long-term stability of the core package. In conclusion, Pynapple provides a common framework for data analysis in neuroscience.</p></abstract>
<abstract>
<title>Highlights</title>
<list list-type="bullet">
<list-item><p>An open-source framework for data analysis in systems neuroscience.</p></list-item>
<list-item><p>Easy-to-use object-oriented programming for data manipulation.</p></list-item>
<list-item><p>A lightweight and standalone package ensuring long-term backward compatibility.</p></list-item>
</list>
</abstract>

</article-meta>
<notes>
<notes notes-type="competing-interest-statement">
<title>Competing Interest Statement</title><p>The authors have declared no competing interest.</p></notes>
</notes>
</front>
<body>
<sec id="s1">
<title>Introduction</title>
<p>The increasing size of datasets across scientific disciplines has led to the development of specific tools to store <sup><xref ref-type="bibr" rid="c1">1</xref>,<xref ref-type="bibr" rid="c2">2</xref></sup>, analyze <sup><xref ref-type="bibr" rid="c3">3</xref></sup>, and visualize <sup><xref ref-type="bibr" rid="c4">4</xref></sup> them. While various programming environments such as Matlab and R have long been commonly used in data science, Python has progressively become one of the most popular programming languages <sup><xref ref-type="bibr" rid="c5">5</xref></sup>. This is due to its open nature, large community-driven development, and versatility of usage. As with virtually all other scientific fields, neuroscience faced the challenges of handling and analyzing large datasets by rapidly developing a wide range of specialized tools to deal with each of these types of data <sup><xref ref-type="bibr" rid="c6">6</xref>–<xref ref-type="bibr" rid="c11">11</xref></sup> and corresponding analyses.</p>
<p>In systems neuroscience, calcium imaging and high-density electrophysiology make it possible to simultaneously monitor the activity of an increasingly large number of neurons <sup><xref ref-type="bibr" rid="c12">12</xref>,<xref ref-type="bibr" rid="c13">13</xref></sup>. Often, this is combined with simultaneous behavioral recordings. As in all other fields, this has required the development of specific pipelines to process <sup><xref ref-type="bibr" rid="c14">14</xref>–<xref ref-type="bibr" rid="c25">25</xref></sup> and store <sup><xref ref-type="bibr" rid="c26">26</xref>,<xref ref-type="bibr" rid="c27">27</xref></sup> the data. Despite this rapid progress, data analysis often relies on custom made, lab-specific code, which is susceptible to error and can be difficult to compare across research groups. While several toolboxes are available to perform neuronal data analysis <sup><xref ref-type="bibr" rid="c8">8</xref>–<xref ref-type="bibr" rid="c11">11</xref>,<xref ref-type="bibr" rid="c28">28</xref></sup> (see ref. <sup><xref ref-type="bibr" rid="c29">29</xref></sup> for review), most of these programs focus on producing high-level analysis from specified types of data, and do not offer the versatility required for rapidly-changing analytical methods and experimental methods.</p>
<p>The key challenge for scientific code is balancing the need for flexibility and stability. This is especially true of science because results should be reproducible (between labs, between the past and the future, and between different experimental setups) while keeping up with rapidly changing requirements (e.g., due to new kinds of data, theories, and analysis methods). To meet these needs, a general toolbox for data analysis must be designed with a few principles in mind.</p>
<p>The first property of such a toolbox is that it should be object-oriented, organizing software around data. This makes the programming environment very efficient for data analysis, particularly in systems neuroscience where data streams can be of very different types. For example, to compute the rate of an event, one can write a function that takes an array of event times and divides the number of elements by the time between the first to the last event. However, this approach neglects to consider that the appropriate epoch in which to calculate the rate could start earlier, or end later, than the first or last event. Addressing these concerns requires another argument, which defines the boundaries of the epoch on which the rate should be computed. Overall, this approach is error prone. The epoch boundaries and event times must be stored in the same time unit and with the same reference (i.e., simultaneous time 0) and the rate function itself can be erroneously called with arrays storing another type of data. In contrast, an object which is specifically designed to represent a series of event times can ameliorate these concerns. For example, it can be created from a specific data loader that ensures proper definition of time units and support epochs (i.e., true beginning and end of the observation time). It will then be immune to the arithmetic operations that can change the values of a generic array (for example an addition that is misplaced in the code). Further, the object can be endowed with a rate property that is specifically written for this object, drastically diminishing the odds of a coding error. While this approach may discourage users who are not familiar with this type of coding, the benefit far exceeds the effort of learning object-oriented programming, especially if the naming of the methods and properties is explicit.</p>
<p>Another property of an efficient toolbox is that as much data as possible should be captured by only a small number of objects. This ensures that the same code can be used for various datasets and eliminates the need of adapting the structure of the package to handle rare or yet-to-be-developed data types. Then, these objects should then be able to interact via a small number of basic and foundational operations, which are sufficient for most analyses. This allows users to quickly write new code for new use-cases, and easily understand and adapt code written by others, as the same methods can be used for any kind of data.</p>
<p>The toolbox should be able to load common data storage types, and the flexibility to create loaders for future and custom/lab-specific data. It should also support the development of yet-unknown, lab-specific, and specialized analysis methods. In other words, the customization of the package to adapt to any dataset should happen at the input stage and the development of high-level analytical methods should take place outside the core package. The properties listed above ensure the long-term stability of a toolbox, a crucial aspect for maintaining the code repository. Toolboxes built around these principles will be maximally flexible and will have the most general application.</p>
<p>In this paper we introduce the Python Neural Analysis Package (Pynapple), designed with these axioms in mind. The core of Pynapple is five versatile timeseries objects, each with a limited number of methods. We show how Pynapple can be used with most raw neuroscience data types to produce the most common analyses used in contemporary neuroscience. Additionally, we introduce Pynacollada, a collaborative repository for higher level analyses built from the basic functionality provided by Pynapple. A complete neuroscience data analysis pipeline using a common language supports open and reproducible code and provides a foundation upon which novel analyses can be shared and collectively built by the neuroscience community.</p>
<sec id="s1a">
<title>Core features of Pynapple</title>
<p>At its core, Pynapple is object-oriented. This approach limits the chances of coding error while providing the user with a simple environment in which all streams of data are by construction expressed in the same time base. Pynapple is built around only five objects that are divided into three categories: two objects represent event timestamps (one or several), two represent time-varying data (one or several time series at the same sampling times), and one represents time epochs. Raw or pre-processed data are loaded into these objects in the coding environment (<bold><xref rid="fig1" ref-type="fig">Fig. 1</xref></bold>). The data loaders ensure that all loaded objects have the same time base. Hence, once objects are constructed, the user does not have to remember properties of the data such as the sampling frequency or alignment of data indices to clock time. Then, these objects can be manipulated with their own methods (i.e., object-specific functions). A large majority of data manipulations needed for most users can be achieved with a small number of methods. From there, Pynapple offer some foundational analyses, such as cross-correlation of event times. On top of this, the user may write analytical code that is project specific.</p>
<fig id="fig1" position="float" fig-type="figure">
<label>Fig. 1</label>
<caption><title>Data analysis with the Pynapple package.</title>
<p><italic>Left</italic>, any type of input data can be loaded in a small number of core objects. For example (from top to bottom): intracellular recordings in slice during which current is injected and drug is applied to the bath solution; extracellular recordings in freely moving mice whose position is video-tracked; calcium imaging in head-fixed mice during presentation of different visual stimuli and delivery of precisely timed rewards; extracellular recordings in non-human primates during the execution of cognitive tasks.</p>
<p><italic>Middle</italic>, object-specific methods allow the user to perform a wide variety of basic operations and to manipulate the data manipulations.</p>
<p><italic>Right</italic>, at a higher level, the package contains a set of foundational analysis methods, which do not depend on any external package, such as (from top to bottom) peri-event alignment of the data (top), 1- and 2-D tuning curves, 1- and 2-D decoding; auto- and cross-correlation of event times (e.g., action potentials).</p></caption>
<graphic xlink:href="519376v1_fig1.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
<p>The most basic objects are timestamps (<italic>Ts</italic>), which are typically used for any discrete events, for example spike or lick times. The timestamped data (<italic>Tsd</italic>) object holds timestamps and associated data associated with each timestamp. For example, this object is used to represent an animal’s position in its environment, electroencephalogram data, or average calcium fluorescence as a function of time. Two objects were designed to represent arrays of <italic>Ts</italic> and <italic>Tsd</italic>, namely <italic>TsGroup</italic> and <italic>TsdFrame</italic>. The main difference between the two objects is that <italic>TsdFrame</italic> has common timestamps for all the data (and therefore, all data have the same number of samples). <italic>TsGroup</italic> is more generic as each element has its own timestamps. These objects are typically used for ensembles of simultaneously recorded spike trains (<italic>TsGroup</italic>) or simultaneously acquired calcium fluorescence (<italic>TsdFrame</italic>). They are useful when operations need to be performed on a common time basis, for example binning multiple spike trains. Note however that they can be used for many other data types, for example the position of the animal (<italic>TsdFrame</italic>). Last, <italic>IntervalSet</italic> objects represent time epochs, for example the start and end times of intervals in which the animal is running.</p>
<p>Pynapple is built with objects from the Pandas library <sup><xref ref-type="bibr" rid="c5">5</xref></sup>. As such, Pynapple objects inherit the computational stability and flexibility from this widely used package. Specifically, a <italic>Tsd</italic> object is an extension of (or “inherits” in object-orienting programming) Pandas <italic>Series</italic> object and <italic>TsdFrame</italic> of Pandas <italic>DataFrame</italic> object. A <italic>TsGroup</italic> is a child of <italic>UserDict</italic>, a built-in python object for inheriting dictionaries. Finally, <italic>IntervalSet</italic> inherits Pandas <italic>DataFrame</italic>. Timestamps are by default in units of seconds but can be readily converted to other time units using the <monospace>as_units</monospace> method in any object.</p>
<p>Pynapple objects have a limited number of core methods (<bold><xref rid="fig2" ref-type="fig">Fig. 2A</xref></bold>), which form the foundation of further operations. These operations provide a general framework by which users can manipulate the timestamps and their corresponding values as needed for analysis. For example, the time series objects have built-in methods: <monospace><italic>value_from</italic></monospace>, which gets the value from one time series object at the (closest) timestamps from another; <monospace><italic>restrict</italic></monospace>, which “restricts” a time series object; extracting only the data contained within a set of time intervals defined by an <italic>IntervalSet</italic> object; <monospace><italic>count</italic></monospace>, which counts the number of timestamps from a time series object in windows of a given bin size; <monospace><italic>threshold</italic></monospace>, which applies a threshold to the data within a <italic>Ts</italic> or <italic>Tsd</italic> object and returns a <italic>Tsd</italic> containing the data above or below the threshold. All operations can be restricted to a given epoch, specified by an <italic>IntervalSet</italic>.</p>
<fig id="fig2" position="float" fig-type="figure">
<label>Fig. 2</label>
<caption><title>Core methods of the Pynapple objects.</title>
<p><bold>A)</bold> Methods of Timestamps (<italic>Ts)</italic> and Timestamped Data (<italic>Tsd)</italic> objects. The same methods can be called for different objects, leading to qualitatively similar results. For example, <monospace>object.restrict(intervalset)</monospace> returns an object now defined on the intersection of its original time support and the input <italic>IntervalSet</italic>. Objects can be any of the timestamps and timestamped data objects. These methods can be called with only one argument, as shown here, since the default parameters are typically the same for most analyses. Yet the methods include additional arguments for more specific operations.</p>
<p><bold>B)</bold> Logical operations on pairs of <italic>IntervalSet</italic> objects to compute (from top to bottom) the intersection, union, and difference between epochs. These operations are commonly used to analyze data during specific epochs in a combinatorial manner, such as “exploration period AND running speed is above 5cm/s NOT left arm”.</p>
<p><bold>C)</bold> Methods of <italic>TsGroup</italic> objects. Each timestamp is associated by default with its occurrence rate. Additional custom metadata such as recording location can be added. These metadata can then be used to select and filter timestamps using <monospace>getby_category</monospace> for discrete labels, <monospace>getby_threshold</monospace> or <monospace>getby_intervals</monospace> for numerical values.</p></caption>
<graphic xlink:href="519376v1_fig2.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
<p>Furthermore, all objects have a <monospace>time_support</monospace> property, which keeps track of the time interval over which the data is valid. The time support is an <italic>IntervalSet</italic> object that is attached by default to <italic>Ts, Tsd, TsdFrame</italic> and <italic>TsGroup</italic> objects. This is a crucial property as, otherwise, it is impossible to know whether periods without data correspond to an epoch during which the underlying event was not observed or because this period has previously been excluded by a <monospace>restrict</monospace> method.</p>
<p>In addition to the ability to restrict methods of time series objects, the <italic>IntervalSet</italic> object has methods for logical operations on combinations of <italic>IntervalSets</italic>, all returning other <italic>IntervalSets</italic> (<bold><xref rid="fig2" ref-type="fig">Fig. 2B</xref></bold>): <monospace><italic>intersect</italic></monospace>, which returns the set intersection of two <italic>IntervalSet</italic> objects; <monospace><italic>union</italic></monospace>, which returns the set union of two <italic>IntervalSets</italic>; <monospace><italic>set_diff</italic></monospace>, which returns the set difference of two IntervalSet; <monospace><italic>drop_short_intervals</italic></monospace>, <monospace><italic>drop_long_intervals</italic></monospace>, which eliminate interval subsets that are shorter or longer than a desired duration; and <monospace><italic>merge_close_intervals</italic></monospace>, which merge intervals that are closer in time than a given duration.</p>
<p>Many experiments in neuroscience are based on trials, each associated with different conditions. <italic>IntervalSets</italic> are perfectly suited for this, as one <italic>IntervalSet</italic> can represent all start and end times of trials. The nature of each trial (e.g., left/right, correct/error) can be stored as a third column within the <italic>IntervalSet</italic> dataframe object. Thus, subsets of trials can be easily selected to restrict data of interest on the corresponding epochs. An alternative approach is to store different <italic>IntervalSets</italic> for different types of trials.</p>
<p>In addition to the ability to apply any methods of the <italic>Ts</italic> object to its members, <italic>TsGroup</italic> has a set of methods to calculate and store metadata about the elements of the group (<bold><xref rid="fig2" ref-type="fig">Fig. 2c</xref></bold>). For example, one can store and retrieve the anatomical structure from which a neuron was recorded, or the result from downstream analysis, perform operations on each element, and filter by various properties. These methods allow the user to, for example, calculate, store, and compare the properties of multiple neurons in a population. Additional methods for all objects are extensively documented in the documentation, and examples for usage are given in the tutorials.</p>
<p>While these objects and methods are relatively few, they are the foundation of almost any analysis in systems neuroscience. However, if not implemented correctly, they can be both computationally intensive and highly susceptible to user error. The implementation of core features in Pynapple addresses this concern. Crucially, all units are indexed by seconds across the entire package, which limits the need for users to account for indexing and alignment between different streams of data at different sampling rates. For example, a user can simply use <monospace>spikes.value_from(position)</monospace> to get the animal’s position at each spike time, rather than costly and error-prone routines in which a user needs to identify matching indices for the corresponding timestamps across arrays containing spikes and behavioral information. Another common issue in data analysis is to analyze two timeseries that are not recorded at the same sampling rate. Once data are loaded in the same time base (i.e., the same time 0), they can keep their original sampling times. Using the function <monospace>value_from</monospace> from one object with the other object as argument will provide two time series with the same number of samples and the same sampling times, which will simplify further analyses. However, this means it is essential that all objects are loaded in the same time base for these methods to function correctly. Pynapple anticipates this by providing a customizable data loader, ensuring time bases are always loaded correctly.</p>
</sec>
<sec id="s1b">
<title>Importing data from common and custom pipelines</title>
<p>The proliferation of experimental methods has come with a proliferation of data formats, as well as the need to rapidly develop new formats that meet new experimental needs. Usually, these data formats are dependent on the software that was used to preprocess the raw data, making them difficult to load for further analysis. Additionally, an experimental setup can generate multiple streams of data that are saved within multiple files of various types. Thus, a universal toolbox should be able to load popular data formats into a common framework and offer the user the ability to write functions to load their own data types.</p>
<p>To ease the process of loading and synchronizing data from various streams, Pynapple includes an I/O layer that allows the user to load multiple types of datasets and write them to a common format for further analysis and sharing. The primary way by which a user interacts with the I/O layer is an object that represents an experimental session, with the properties of the object being the various time series. This I/O object is created by calling the function <monospace>load_session</monospace>, which will load all data associated with that session (<bold><xref rid="fig3" ref-type="fig">Fig. 3A</xref></bold>). For example, calling <monospace>load_session</monospace> for an <italic>in vivo</italic> electrophysiology recording would return an object called <monospace>data</monospace>, which will have properties <monospace>data.spikes</monospace>, <monospace>data.position</monospace>, and <monospace>data.epochs</monospace> which respectively store a <italic>TsGroup</italic>, containing the spike times, a <italic>TsdFrame</italic> containing the position of the animal, and an <italic>IntervalSet</italic> containing the times when the animal is on the track. With this object-oriented I/O method, the user can interact with the various data streams associated with a given experimental session and load multiple sessions at once without the risk of mixing data as each time series is attached to only one I/O object.</p>
<fig id="fig3" position="float" fig-type="figure">
<label>Fig. 3</label>
<caption><title>Built-in and customizable loading function for Pynapple.</title>
<p><bold>A)</bold> Data is originally organized as separate files in a folder. A built-in or custom-made load_session function is called to load the data into a Data class.</p>
<p><bold>B)</bold> Data can be loaded through a customizable GUI to enter all relevant information regarding the experiment, for example animal strain, among others. The main epochs of the recording (e.g., behavioral states, stimuli category, etc.) can be loaded from standard tabular data files (such as CSV). Behavioral tracking data extracted from various common systems and saved as a CSV file can also be loaded.</p>
<p><bold>C)</bold> Pynapple offers various built-in loaders for commonly used data formats, as well as a template to easily design a customizable loader to adapt to any other format or specific task design.</p></caption>
<graphic xlink:href="519376v1_fig3.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
<p>Data synchronization is the crux of any analysis pipeline. The <monospace>load_session</monospace> function is thus a crucial step in using the package. For unsupported data types, it is the responsibility of the users to design the preprocessing scripts that align the data streams in the same absolute time base. The data loading and synchronizing functions already included in the package for supported data types is a good starting point for any user writing a custom loading function (details this process are provided later).</p>
<p>While data types are usually specific to a recording modality (i.e., calcium imaging and electrophysiology), there are several pieces of metadata that are common to many experiments, such as the strain of the animal, age, sex, and name of the experimenter. When loading a session for the first time, the I/O process starts with a graphical user interface (GUI) in which the user can quickly and easily input the general information as well as any session epoch and behavioral tracking data (<xref rid="fig3" ref-type="fig">Fig. 3b</xref>). This information is saved in a <italic>BaseLoader</italic> class.</p>
<p>General session information is common across experimental sessions, however specialized data streams are usually specific to recording modalities. To cover the variety of preprocessing analysis pipelines currently used in systems neuroscience, the Pynapple I/O can load data formats from popular preprocessing pipelines (e.g., CNMF-E, Phy, NeuroSuite or Suite2P). This is implemented via a set of specialized object subclasses of the <italic>BaseLoader</italic> class. To avoid code redundancy, these I/O classes inherit the properties of the <italic>BaseLoader</italic> class. This is a core aspect of object-oriented programing, and it means that these specialized I/O classes have all the methods and properties of the parent <italic>BaseLoader</italic> objects. This ensures compatibility across various loading functions. However, once generated, these specialized I/O classes are unique and independent from each other, ensuring stability. Like the <italic>BaseLoader</italic> class, a specialized GUI for electrophysiology and calcium imaging is provided, with relevant metadata fields, for example electrode position in electrophysiology and type of fluorescence indicator in calcium imaging (<bold><xref rid="fig3" ref-type="fig">Fig. 3B</xref></bold>).</p>
<p>To avoid repeating the process of inputting session information and synchronization of multiple data streams, Pynapple saves all synchronized data into a unique file and can accommodate a wide range of neuroscientific data types. Recently, Neurodata Without Borders (NWB) <sup><xref ref-type="bibr" rid="c26">26</xref>,<xref ref-type="bibr" rid="c27">27</xref></sup> has emerged as a flexible data format used for public data sharing and large databases such as those collected by the Allen Institute. Thus, we chose to use the NWB format for fast and universal data loading and saving with Pynapple. The <italic>BaseLoader</italic> is responsible for initializing the NWB file within the session folder (i.e. it creates a new NWB file if none is present) (<bold><xref rid="fig3" ref-type="fig">Fig. 3C</xref></bold>). Converting user’s data to NWB format encourages standardization and can facilitate sharing both data and analysis pipelines written with Pynapple.</p>
<p>Many other preprocessing pipelines exist and can often be unique to a lab or even to an individual project. To accommodate present and future needs for these specific pipelines, the documentation of Pynapple provides an easy-to-follow recipe for creating a custom I/O class that inherits the <italic>BaseLoader</italic> and can interact with a pre-existing NWB file. There are multiple benefits of the inheritance approach of data loading classes within the I/O layer of Pynapple. First, future development of new I/O classes will not affect the core and processing layers of Pynapple. This ensures long-term stability of the package. Second, users can develop their own custom I/O using chain inheritance of pre-existing classes. Using preexisting code to load data in a specific manner instead of rewriting already existing functions avoids preprocessing errors. Third, users can still use Pynapple without using the I/O layer of Pynapple. Last, in order to apply previous analyses, or analyses developed in another lab, to new data or data types a user only needs to develop a new I/O class for their data. This will import the data to the common Pynapple core from which the same analysis pipeline can be used.</p>
</sec>
<sec id="s1c">
<title>Foundational data processing</title>
<p>The basic methods that manipulate the core objects in Pynapple allow users to perform common, but powerful, neuroscience analyses (<bold><xref rid="fig2" ref-type="fig">Fig. 2</xref></bold>). These analyses are powerful because they are able to describe the relationships between time series objects, while requiring the fewest number of parameters to be set by the user. This minimizes complexity, while maximizing generalizability. The operations in Pynapple can recreate neuroscience analyses from a broad number of subdisciplines. These analyses form the foundation of neuroscience data analysis in Pynapple. To illustrate the versatility of Pynapple and how it can be used, we reanalyzed five openly available datasets.</p>
<p>The first foundational analysis is computing neural tuning curves. Tuning curves relate specific stimuli to the firing rate of neurons. To this end, Pynapple computes the firing rate of a neuron (or any other timestamped data) during each epoch in an <italic>IntervalSet</italic> object, for example for discrete conditions such as “ON/OFF’’ stimuli. Tuning curves can also be computed with respect to a continuous feature. Once computed, Pynapple is able to use tuning curves from a population of neurons to decode stimuli using a Bayesian decoder <sup><xref ref-type="bibr" rid="c30">30</xref>,<xref ref-type="bibr" rid="c31">31</xref></sup> (<bold><xref rid="fig4" ref-type="fig">Fig. 4A</xref></bold>).</p>
<fig id="fig4" position="float" fig-type="figure">
<label>Fig. 4</label>
<caption><title>Examples of foundational analysis across various electrophysiological datasets using Pynapple.</title>
<p><bold>A)</bold> Analysis of an ensemble of head-direction cells. From left to right: data were collected in a freely moving mouse randomly foraging for food; all data are restricted to the wake epoch (i.e., during exploration); the tuning curve of two neurons relative to the animal’s head-direction; animal’s head-direction is decoded from the neuronal ensemble. Data from refs. <sup><xref ref-type="bibr" rid="c32">32</xref>,<xref ref-type="bibr" rid="c33">33</xref></sup></p>
<p><bold>B)</bold> Analysis of V1 neurons during visual stimulation. From left to right: the mouse was recorded while being head-fixed and presented with drifting gratings; spikes, stimulation and epochs are shown; example tuning curves of two V1 neurons, showing their firing rates for different grating orientations; example cross-correlation between two V1 neurons, showing an oscillatory co-modulation at about 5Hz during visual stimulation. Data from ref. <sup><xref ref-type="bibr" rid="c34">34</xref></sup></p>
<p><bold>C)</bold> Analysis of medial temporal lobe neurons in human epileptic subjects. From left to right: subjects, implanted with hybrid deep electrodes, were shown a series of short clips; raster plot of a single neuron around continuous movie shot trials (green) and hard boundary trials, which are transitions between two unrelated movies (orange); peri-event neuronal firing rate for both trial types. Data from ref. <sup><xref ref-type="bibr" rid="c35">35</xref></sup></p>
<p>Images in panels b and c are from ref. <sup><xref ref-type="bibr" rid="c36">36</xref></sup></p></caption>
<graphic xlink:href="519376v1_fig4.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
<p>The second foundational analysis is computing auto- and cross-correlograms of event data. In the most abstract sense, these correlograms show the relationship between previous and future events and a current event at time 0. In Pynapple, cross-correlograms can be generated for any two series of events by computing the event rate for each time bin of a target time series relative to each event of a reference time series. Commonly, this is used to examine the likelihood of an action potential in a neuron relating to a previous or future action potential in the same neuron (auto-correlogram) or in another neuron (cross-correlogram) (<bold><xref rid="fig4" ref-type="fig">Fig. 4B</xref></bold>). However, Pynapple does not limit this function to spiking data and correlograms may be performed on any event-based data.</p>
<p>The third and final foundational analysis is peri-event alignment. This involves aligning a specified window from <italic>Ts</italic>/<italic>Tsd</italic>/<italic>TsGroup</italic> data to a specific <italic>Ts</italic>, known as “TimeStamp Reference’’. This allows users to align data to specific points in time, and measure changes in rates around this specified time point (<bold><xref rid="fig4" ref-type="fig">Fig. 4C</xref></bold>). One example where this function is useful is aligning neuronal spikes to specific stimuli, such as optogenetic illumination, presentation of a tone, or electrical stimulation.</p>
<p>Some of the analyses presented so far are designed for spikes (and discrete events in general) and cannot be applied for continuous traces such as calcium imaging data. Pynapple includes specialized functions that can compute the tuning of a continuous value with respect to a feature, as shown for the modulation of fluorescence in calcium imaging with respect to the speed of the animal (<bold><xref rid="fig5" ref-type="fig">Fig. 5A</xref></bold>) or of the position of a vertical bar on a screen in the fly’s ellipsoid body (<bold><xref rid="fig5" ref-type="fig">Fig. 5B</xref></bold>).</p>
<fig id="fig5" position="float" fig-type="figure">
<label>Fig. 5</label>
<caption><title>Examples of foundational analysis across various calcium imaging datasets using Pynapple.</title>
<p><bold>A)</bold> Analysis of a V1 neuron during visual stimulation. From left to right: the mouse was recorded while being head-fixed on a running wheel and presented with natural scene movies; fluorescence traces from a pre-processed region of interest and running speed are loaded; continuous tuning curve is directly obtained from fluorescence and speed. Data from ref. <sup><xref ref-type="bibr" rid="c37">37</xref></sup>. Image is from ref. <sup><xref ref-type="bibr" rid="c36">36</xref></sup></p>
<p><bold>B)</bold> Analysis of neuronal activity in the fly central complex. From left to right: a <italic>Drosophila melanogaster</italic> is tethered to a calcium imaging setup while the position of a vertical bar is in closed loop with the fly’s movements on a ball; calcium activity in the ellipsoid body is divided into 16 wedges; example fluorescence trace and direction of the fly. Tuning curves are obtained as in <bold>A</bold>, with the direction as feature. Data from ref. <sup><xref ref-type="bibr" rid="c38">38</xref></sup></p></caption>
<graphic xlink:href="519376v1_fig5.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
<p>The examples shown in <xref rid="fig4" ref-type="fig">Figures 4</xref> and <xref rid="fig5" ref-type="fig">5</xref> show how these core analyses are useful for rapid data screening with just a few lines of code in a Jupyter notebook, for example. Overall, these foundational functions form the building blocks of most other analyses in systems neuroscience. Importantly, they are built-in and thus do not have any external dependencies, ensuring that they can be used stand-alone without relying on any third-party software. All other developments of analysis pipelines take place outside Pynapple, ensuring the core package is only updated rarely and remains lightweight.</p>
</sec>
<sec id="s1d">
<title>Pynacollada: a collaborative library for specialized and continuously updated data analyses</title>
<p>Pynapple is designed to be stable in the foreseeable future and its core functionality is not meant to be modified. However, actual data analysis usually requires more than the available core functions. This type of data analysis is “fluid”, constantly updated by new software developments and theoretical work. Furthermore, this kind of development is collaborative in nature and the supervision of such projects is less sensitive than that of a stable package. To balance the needs for stability and flexibility, high-level functions were separated from Pynapple and included instead in Pynacollada: the Pynapple Collaborative repository hosted on GitHub.</p>
<p>Complex analyses are added to Pynacollada in the form of libraries. Each library developed for Pynacollada takes the form of a Jupyter notebook (or python scripts) which guides the user through the analysis step-by-step. As such, libraries built for Pynacollada should provide training, promote good practice in programming, and allow users to easily adapt code to their own project. Examples of complex analyses currently handled by Pynacollada are outlined below (<bold><xref rid="fig6" ref-type="fig">Fig. 6</xref></bold>).</p>
<fig id="fig6" position="float" fig-type="figure">
<label>Fig. 6</label>
<caption><title>The Pynapple collaborative data analysis repository (Pynacollada) environment.</title>
<p>Unlike Pynapple, which is designed for long-term stability, Pynacollada is a repository of project-oriented libraries. This way, the community can collaborate on constantly evolving data analysis code without affecting the functionality of the core pipeline. Each project should include a script that can be called for specific functions and/or Jupyter notebooks to showcase the use of the code, as well as proper documentation. Pynacollada already includes several libraries and/or tutorials, including but not limited to: (1) a tutorial on manifold analysis, covering how to project neuronal data on low-dimensional subspace using various machine learning techniques; (2) a library for oscillation detection in local field potentials, which takes raw broadband traces as inputs and outputs <italic>IntervalSet</italic> objects corresponding to the start and end times of oscillation bouts.</p></caption>
<graphic xlink:href="519376v1_fig6.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
<p>Recent advances in the application of manifold theory to neural data analysis have allowed neuroscientists to project high-dimensional data into three or fewer dimensions <sup><xref ref-type="bibr" rid="c39">39</xref>–<xref ref-type="bibr" rid="c41">41</xref></sup>. The structure of these projections reflects the structure of these higher dimensional processes, allowing us to infer the information encoded by the population. The Pynacollada “neural_manifold” library contains a Jupyter notebook that provides a step-by-step process for recreating a ring manifold using spiking data recorded from a population of head-direction neurons (<bold><xref rid="fig6" ref-type="fig">Fig. 6</xref></bold>). This code can be adapted by the end-user for analysis of their own data by simply importing their own data and refactoring the parameters to suit their needs.</p>
<p>A second complex analysis handled by Pynacollada is sharp wave-ripple (SWR) detection. Detecting oscillatory events is a routine procedure in electrophysiology, yet usually depends on many arbitrary choices of parameters. In this case, the Jupyter notebook showcases an example of detecting SWRs, a well-characterized oscillation of the hippocampus (<bold><xref rid="fig6" ref-type="fig">Fig. 6</xref></bold>).</p>
<p>In addition, Pynacollada currently includes libraries for spike waveform processing, EEG analysis, and video tracking, among others. We invite the community to contribute to this repository by improving current libraries or upload new ones. For new libraries, only rapid screening and tests will be performed, but the code will not go through the kind of validation that is in place for Pynapple as an external library will never affect the functioning of the core package. The documentation describes what is expected in each library to simplify readability, sharing, and maintenance and, overall, how libraries should conform to Pynacollada standards. We hope this will be broadly adopted by the community, allowing researchers across labs to easily share their code.</p>
</sec>
</sec>
<sec id="s2">
<title>Discussion</title>
<p>Here we introduced Pynapple, a lightweight and open-source python toolbox for neural data analysis. The goal of this package is to offer a versatile set of tools to study typical neurophysiological and behavioral data, specifically time series (e.g., spike times, behavioral events, and continuous time series) and time intervals (e.g., trials and brain states). It also provides users with generic functions for neuroscience analyses such as tuning curves and cross-correlograms. Finally, Pynapple was designed to rely on a minimum number of dependencies, which are themselves very common and thus highly stable. As such, accessibility is the guiding axiom of Pynapple.</p>
<p>The design of Pynapple is centered around the manipulation of simple, abstract objects that are common to most neurophysiological and behavioral datasets. The core of Pynapple is built around five objects: Timestamps (<italic>Ts</italic>) and group of Timestamps (<italic>TsGroup</italic>), Time Series Data (<italic>Tsd</italic>) and ensemble of co-registered Tsd (<italic>TsdFrame</italic>), as well as <italic>IntervalSets</italic>. These objects can be manipulated with properties that are, in most cases, common to all objects. Building around these fundamental objects and properties means Pynapple is highly flexible and able to handle most neurophysiological and behavioral datasets, making it accessible to most systems neuroscientists.</p>
<p>To simplify analysis for users, Pynapple offers simple wrappers for loading data with popular preprocessing pipelines. However, to be fully accessible, it is not sufficient for a package’s core operations to be able to process all data types in theory. Data produced in neuroscience has a wide variety of file types, which are often only loaded by specific analysis software. Data is also largely experiment-specific. To unify these disparate file types and configurations, Pynapple’s data loader is customizable. In addition to being able to load current popular data formats, this customizable data-loader means emerging file formats may continue to be loaded in the future, without significant overhauls to the main package. This offers Pynapple long-term stability and means that Pynapple will continue to remain accessible in the foreseeable future.</p>
<p>In further pursuit of accessibility, from these simple objects and properties, Pynapple has several built-in, foundational analyses that are common across the field of systems neuroscience. These foundational analyses include computing neural tuning curves, computing auto-/cross-correlograms, peri-event alignment, and performing Bayesian decoding. From these foundational analyses, higher order analyses can be developed. However, these higher order analyses are more prone to customization, thereby making them relatively more flexible. As such, higher order analyses are stored in the collaborative repository known as Pynacollada. This keeps the core Pynapple package stable, while allowing the user to integrate new advances in neurophysiological and behavioral analysis into their workflow.</p>
<p>Other software provide programming environments which deal with common neuroscientific data and an interface between stored data and analytical methods <sup><xref ref-type="bibr" rid="c10">10</xref></sup>. However, one problem that arises from this structure is that objects and data structures are rigidly defined, leading to a lack of versatility for new types of data or task design. In contrast, Pynapple offers a more flexible working environment and will remain accessible even as user requirements change.</p>
<p>While Pynapple expands accessibility to data analysis, it has some limitations inherent to its design. The first issue is that Pynapple is currently only available through Python. Thus, some transition is required for those primarily trained in other programming languages commonly used in neuroscience, including MATLAB and Julia. The design of the package around objects is a strength in many regards but could represent a challenge for users who are not accustomed to this programming approach. We have addressed this concern by providing users with detailed documentation, which includes a broad variety of examples. We will also keep on providing training opportunities for all future users. Last, Python code may run slower than similar code written in other languages. Pynapple is based on Pandas, whose methods are already highly optimized. Yet, current development is underway to improve computation speed and these developments are transparent for the users as they won’t change the organization of the package.</p>
<p>Soon, Pynapple will be part of an entire suite of plugin libraries that we are developing to further enhance Pynapple. To keep Pynapple robust and stable, we will develop these plugins as standalone packages. These external packages will include an automated datalogger for recapitulating analyses, an on-line visualizer for Pynapple objects, and a package for parallel computing in Pynapple. This will address the speed issue inherent to code written in Python by allowing multiple analyses to be performed simultaneously. These packages will begin to address the limitations of Pynapple we described previously, enhancing the long-term stability of Pynapple, and streamlining accessibility for its users.</p>
</sec>
</body>
<back>
<ref-list>
<title>References</title>
<ref id="c1"><label>1.</label><mixed-citation publication-type="book"><string-name><surname>Folk</surname>, <given-names>M.</given-names></string-name>, <string-name><surname>Heber</surname>, <given-names>G.</given-names></string-name>, <string-name><surname>Koziol</surname>, <given-names>Q.</given-names></string-name>, <string-name><surname>Pourmal</surname>, <given-names>E.</given-names></string-name> &amp; <string-name><surname>Robinson</surname>, <given-names>D.</given-names></string-name> <chapter-title>An overview of the HDF5 technology suite and its applications</chapter-title>. <source>in Proceedings of the EDBT/ICDT 2011 Workshop on Array Databases</source> <fpage>36</fpage>–<lpage>47</lpage> (<publisher-name>Association for Computing Machinery</publisher-name>, <year>2011</year>). doi:<pub-id pub-id-type="doi">10.1145/1966895.1966900</pub-id>.</mixed-citation></ref>
<ref id="c2"><label>2.</label><mixed-citation publication-type="other"><string-name><surname>Wells</surname>, <given-names>D. C.</given-names></string-name> &amp; <string-name><surname>Greisen</surname>, <given-names>E. W.</given-names></string-name> <source>FITS - a Flexible Image Transport System</source>. <volume>445</volume> (<year>1979</year>).</mixed-citation></ref>
<ref id="c3"><label>3.</label><mixed-citation publication-type="journal"><string-name><surname>Pedregosa</surname>, <given-names>F.</given-names></string-name> <etal>et al.</etal> <article-title>Scikit-learn: Machine learning in Python</article-title>. <source>J. Mach. Learn. Res</source>. <volume>12</volume>, <fpage>2825</fpage>– <lpage>2830</lpage> (<year>2011</year>).</mixed-citation></ref>
<ref id="c4"><label>4.</label><mixed-citation publication-type="journal"><string-name><surname>van der Maaten</surname>, <given-names>L. J. P.</given-names></string-name> &amp; <string-name><surname>Hinton</surname>, <given-names>G. E.</given-names></string-name> <article-title>Visualizing High-Dimensional Data Using t-SNE</article-title>. <source>J. Mach. Learn. Res</source>. <volume>9</volume>, <fpage>2579</fpage>–<lpage>2605</lpage> (<year>2008</year>).</mixed-citation></ref>
<ref id="c5"><label>5.</label><mixed-citation publication-type="journal"><string-name><surname>McKinney</surname>, <given-names>W.</given-names></string-name> &amp; others. <article-title>pandas: a foundational Python library for data analysis and statistics</article-title>. <source>Python High Perform. Sci. Comput</source>. <volume>14</volume>, <fpage>1</fpage>–<lpage>9</lpage> (<year>2011</year>).</mixed-citation></ref>
<ref id="c6"><label>6.</label><mixed-citation publication-type="journal"><string-name><surname>Abraham</surname>, <given-names>A.</given-names></string-name> <etal>et al.</etal> <article-title>Machine learning for neuroimaging with scikit-learn</article-title>. <source>Front. Neuroinformatics</source> <volume>14</volume> (<year>2014</year>).</mixed-citation></ref>
<ref id="c7"><label>7.</label><mixed-citation publication-type="journal"><string-name><surname>Tadel</surname>, <given-names>F.</given-names></string-name>, <string-name><surname>Baillet</surname>, <given-names>S.</given-names></string-name>, <string-name><surname>Mosher</surname>, <given-names>J. C.</given-names></string-name>, <string-name><surname>Pantazis</surname>, <given-names>D.</given-names></string-name> &amp; <string-name><surname>Leahy</surname>, <given-names>R. M.</given-names></string-name> <article-title>Brainstorm: A User-Friendly Application for MEG/EEG Analysis</article-title>. <source>Comput. Intell. Neurosci</source>. <volume>2011</volume>, <fpage>879716</fpage> (<year>2011</year>).</mixed-citation></ref>
<ref id="c8"><label>8.</label><mixed-citation publication-type="journal"><string-name><surname>Oostenveld</surname>, <given-names>R.</given-names></string-name>, <string-name><surname>Fries</surname>, <given-names>P.</given-names></string-name>, <string-name><surname>Maris</surname>, <given-names>E.</given-names></string-name> &amp; <string-name><surname>Schoffelen</surname>, <given-names>J.-M.</given-names></string-name> <article-title>FieldTrip: Open Source Software for Advanced Analysis of MEG, EEG, and Invasive Electrophysiological Data</article-title>. <source>Comput. Intell. Neurosci</source>. <volume>2011</volume>, <fpage>e156869</fpage> (<year>2010</year>).</mixed-citation></ref>
<ref id="c9"><label>9.</label><mixed-citation publication-type="journal"><string-name><surname>Bokil</surname>, <given-names>H.</given-names></string-name>, <string-name><surname>Andrews</surname>, <given-names>P.</given-names></string-name>, <string-name><surname>Kulkarni</surname>, <given-names>J. E.</given-names></string-name>, <string-name><surname>Mehta</surname>, <given-names>S.</given-names></string-name> &amp; <string-name><surname>Mitra</surname>, <given-names>P. P.</given-names></string-name> <article-title>Chronux: A platform for analyzing neural signals</article-title>. <source>J. Neurosci. Methods</source> <volume>192</volume>, <fpage>146</fpage>–<lpage>151</lpage> (<year>2010</year>).</mixed-citation></ref>
<ref id="c10"><label>10.</label><mixed-citation publication-type="journal"><string-name><surname>Garcia</surname>, <given-names>S.</given-names></string-name> <etal>et al.</etal> <article-title>Neo: an object model for handling electrophysiology data in multiple formats</article-title>. <source>Front. Neuroinformatics</source> <volume>8</volume>, (<year>2014</year>).</mixed-citation></ref>
<ref id="c11"><label>11.</label><mixed-citation publication-type="journal"><string-name><surname>Freeman</surname>, <given-names>J.</given-names></string-name> <etal>et al.</etal> <article-title>Mapping brain activity at scale with cluster computing</article-title>. <source>Nat. Methods</source> <volume>11</volume>, <fpage>941</fpage>–<lpage>950</lpage> (<year>2014</year>).</mixed-citation></ref>
<ref id="c12"><label>12.</label><mixed-citation publication-type="journal"><string-name><surname>Stevenson</surname>, <given-names>I. H.</given-names></string-name> &amp; <string-name><surname>Kording</surname>, <given-names>K. P.</given-names></string-name> <article-title>How advances in neural recording affect data analysis</article-title>. <source>Nat. Neurosci</source>. <volume>14</volume>, <fpage>139</fpage>–<lpage>142</lpage> (<year>2011</year>).</mixed-citation></ref>
<ref id="c13"><label>13.</label><mixed-citation publication-type="journal"><string-name><surname>Urai</surname>, <given-names>A. E.</given-names></string-name>, <string-name><surname>Doiron</surname>, <given-names>B.</given-names></string-name>, <string-name><surname>Leifer</surname>, <given-names>A. M.</given-names></string-name> &amp; <string-name><surname>Churchland</surname>, <given-names>A. K.</given-names></string-name> <article-title>Large-scale neural recordings call for new insights to link brain and behavior</article-title>. <source>Nat. Neurosci</source>. <volume>25</volume>, <fpage>11</fpage>–<lpage>19</lpage> (<year>2022</year>).</mixed-citation></ref>
<ref id="c14"><label>14.</label><mixed-citation publication-type="other"><string-name><surname>Pachitariu</surname>, <given-names>M.</given-names></string-name>, <string-name><surname>Steinmetz</surname>, <given-names>N.</given-names></string-name>, <string-name><surname>Kadir</surname>, <given-names>S.</given-names></string-name>, <string-name><surname>Carandini</surname>, <given-names>M.</given-names></string-name> &amp; <string-name><surname>Harris</surname>, <given-names>K. D.</given-names></string-name> <article-title>Kilosort: realtime spike-sorting for extracellular electrophysiology with hundreds of channels</article-title>. <source>bioRxiv</source> 061481 (<year>2016</year>) doi:<pub-id pub-id-type="doi">10.1101/061481</pub-id>.</mixed-citation></ref>
<ref id="c15"><label>15.</label><mixed-citation publication-type="web"><string-name><surname>Pachitariu</surname>, <given-names>M.</given-names></string-name> <etal>et al.</etal> <source>Suite2p: beyond 10,000 neurons with standard two-photon microscopy</source>. 061507 Preprint at <pub-id pub-id-type="doi">10.1101/061507</pub-id> (<year>2017</year>).</mixed-citation></ref>
<ref id="c16"><label>16.</label><mixed-citation publication-type="journal"><string-name><surname>Hazan</surname>, <given-names>L.</given-names></string-name>, <string-name><surname>Zugaro</surname>, <given-names>M.</given-names></string-name> &amp; <string-name><surname>Buzsáki</surname>, <given-names>G.</given-names></string-name> <article-title>Klusters, NeuroScope, NDManager: A free software suite for neurophysiological data processing and visualization</article-title>. <source>J. Neurosci. Methods</source> <volume>155</volume>, <fpage>207</fpage>–<lpage>216</lpage> (<year>2006</year>).</mixed-citation></ref>
<ref id="c17"><label>17.</label><mixed-citation publication-type="journal"><string-name><surname>Fee</surname>, <given-names>M. S.</given-names></string-name>, <string-name><surname>Mitra</surname>, <given-names>P. P.</given-names></string-name> &amp; <string-name><surname>Kleinfeld</surname>, <given-names>D.</given-names></string-name> <article-title>Automatic sorting of multiple unit neuronal signals in the presence of anisotropic and non-Gaussian variability</article-title>. <source>J. Neurosci. Methods</source> <volume>69</volume>, <fpage>175</fpage>– <lpage>188</lpage> (<year>1996</year>).</mixed-citation></ref>
<ref id="c18"><label>18.</label><mixed-citation publication-type="journal"><string-name><surname>Harris</surname>, <given-names>K. D.</given-names></string-name>, <string-name><surname>Henze</surname>, <given-names>D. A.</given-names></string-name>, <string-name><surname>Csicsvari</surname>, <given-names>J.</given-names></string-name>, <string-name><surname>Hirase</surname>, <given-names>H.</given-names></string-name> &amp; <string-name><surname>Buzsáki</surname>, <given-names>G.</given-names></string-name> <article-title>Accuracy of tetrode spike separation as determined by simultaneous intracellular and extracellular measurements</article-title>. <source>J. Neurophysiol</source>. <volume>84</volume>, <fpage>401</fpage>–<lpage>414</lpage> (<year>2000</year>).</mixed-citation></ref>
<ref id="c19"><label>19.</label><mixed-citation publication-type="journal"><string-name><surname>Yger</surname>, <given-names>P.</given-names></string-name> <etal>et al.</etal> <article-title>A spike sorting toolbox for up to thousands of electrodes validated with ground truth recordings in vitro and in vivo</article-title>. <source>eLife</source> <volume>7</volume>, <fpage>e34518</fpage> (<year>2018</year>).</mixed-citation></ref>
<ref id="c20"><label>20.</label><mixed-citation publication-type="journal"><string-name><surname>Mathis</surname>, <given-names>A.</given-names></string-name> <etal>et al.</etal> <article-title>DeepLabCut: markerless pose estimation of user-defined body parts with deep learning</article-title>. <source>Nat. Neurosci</source>. <volume>21</volume>, <fpage>1281</fpage>–<lpage>1289</lpage> (<year>2018</year>).</mixed-citation></ref>
<ref id="c21"><label>21.</label><mixed-citation publication-type="journal"><string-name><surname>Zhou</surname>, <given-names>P.</given-names></string-name> <etal>et al.</etal> <article-title>Efficient and accurate extraction of in vivo calcium signals from microendoscopic video data</article-title>. <source>eLife</source> <volume>7</volume>, <fpage>e28728</fpage> (<year>2018</year>).</mixed-citation></ref>
<ref id="c22"><label>22.</label><mixed-citation publication-type="journal"><string-name><surname>Mukamel</surname>, <given-names>E. A.</given-names></string-name>, <string-name><surname>Nimmerjahn</surname>, <given-names>A.</given-names></string-name> &amp; <string-name><surname>Schnitzer</surname>, <given-names>M. J.</given-names></string-name> <article-title>Automated Analysis of Cellular Signals from Large-Scale Calcium Imaging Data</article-title>. <source>Neuron</source> <volume>63</volume>, <fpage>747</fpage>–<lpage>760</lpage> (<year>2009</year>).</mixed-citation></ref>
<ref id="c23"><label>23.</label><mixed-citation publication-type="journal"><string-name><surname>Romano</surname>, <given-names>S. A.</given-names></string-name> <etal>et al.</etal> <article-title>An integrated calcium imaging processing toolbox for the analysis of neuronal population dynamics</article-title>. <source>PLOS Comput. Biol</source>. <volume>13</volume>, <fpage>e1005526</fpage> (<year>2017</year>).</mixed-citation></ref>
<ref id="c24"><label>24.</label><mixed-citation publication-type="journal"><string-name><surname>Kaifosh</surname>, <given-names>P.</given-names></string-name>, <string-name><surname>Zaremba</surname>, <given-names>J. D.</given-names></string-name>, <string-name><surname>Danielson</surname>, <given-names>N. B.</given-names></string-name> &amp; <string-name><surname>Losonczy</surname>, <given-names>A.</given-names></string-name> <article-title>SIMA: Python software for analysis of dynamic fluorescence imaging data</article-title>. <source>Front. Neuroinformatics</source> <volume>8</volume>, (<year>2014</year>).</mixed-citation></ref>
<ref id="c25"><label>25.</label><mixed-citation publication-type="journal"><string-name><surname>Pnevmatikakis</surname>, <given-names>E. A.</given-names></string-name> &amp; <string-name><surname>Giovannucci</surname>, <given-names>A.</given-names></string-name> <article-title>NoRMCorre: An online algorithm for piecewise rigid motion correction of calcium imaging data</article-title>. <source>J. Neurosci. Methods</source> <volume>291</volume>, <fpage>83</fpage>–<lpage>94</lpage> (<year>2017</year>).</mixed-citation></ref>
<ref id="c26"><label>26.</label><mixed-citation publication-type="journal"><string-name><surname>Teeters</surname>, <given-names>J. L.</given-names></string-name> <etal>et al.</etal> <article-title>Neurodata Without Borders: Creating a Common Data Format for Neurophysiology</article-title>. <source>Neuron</source> <volume>88</volume>, <fpage>629</fpage>–<lpage>634</lpage> (<year>2015</year>).</mixed-citation></ref>
<ref id="c27"><label>27.</label><mixed-citation publication-type="journal"><string-name><surname>Rübel</surname>, <given-names>O.</given-names></string-name> <etal>et al.</etal> <article-title>The Neurodata Without Borders ecosystem for neurophysiological data science</article-title>. <source>eLife</source> <volume>11</volume>, <fpage>e78362</fpage> (<year>2022</year>).</mixed-citation></ref>
<ref id="c28"><label>28.</label><mixed-citation publication-type="journal"><string-name><surname>Nasiotis</surname>, <given-names>K.</given-names></string-name> <etal>et al.</etal> <article-title>Integrated open-source software for multiscale electrophysiology</article-title>. <source>Sci. Data</source> <volume>6</volume>, <fpage>231</fpage> (<year>2019</year>).</mixed-citation></ref>
<ref id="c29"><label>29.</label><mixed-citation publication-type="journal"><string-name><surname>Unakafova</surname>, <given-names>V. A.</given-names></string-name> &amp; <string-name><surname>Gail</surname>, <given-names>A.</given-names></string-name> <article-title>Comparing Open-Source Toolboxes for Processing and Analysis of Spike and Local Field Potentials Data</article-title>. <source>Front. Neuroinformatics</source> <volume>13</volume>, (<year>2019</year>).</mixed-citation></ref>
<ref id="c30"><label>30.</label><mixed-citation publication-type="journal"><string-name><surname>Zhang</surname>, <given-names>K.</given-names></string-name>, <string-name><surname>Ginzburg</surname>, <given-names>I.</given-names></string-name>, <string-name><surname>McNaughton</surname>, <given-names>B. L.</given-names></string-name> &amp; <string-name><surname>Sejnowski</surname>, <given-names>T. J.</given-names></string-name> <article-title>Interpreting Neuronal Population Activity by Reconstruction: Unified Framework With Application to Hippocampal Place Cells</article-title>. <source>J. Neurophysiol</source>. <volume>79</volume>, <fpage>1017</fpage>–<lpage>1044</lpage> (<year>1998</year>).</mixed-citation></ref>
<ref id="c31"><label>31.</label><mixed-citation publication-type="journal"><string-name><surname>Brown</surname>, <given-names>E. N.</given-names></string-name>, <string-name><surname>Frank</surname>, <given-names>L. M.</given-names></string-name>, <string-name><surname>Tang</surname>, <given-names>D.</given-names></string-name>, <string-name><surname>Quirk</surname>, <given-names>M. C.</given-names></string-name> &amp; <string-name><surname>Wilson</surname>, <given-names>M. A.</given-names></string-name> <article-title>A statistical paradigm for neural spike train decoding applied to position prediction from ensemble firing patterns of rat hippocampal place cells</article-title>. <source>J. Neurosci</source>. <volume>18</volume>, <fpage>7411</fpage> (<year>1998</year>).</mixed-citation></ref>
<ref id="c32"><label>32.</label><mixed-citation publication-type="journal"><string-name><surname>Peyrache</surname>, <given-names>A.</given-names></string-name>, <string-name><surname>Lacroix</surname>, <given-names>M. M.</given-names></string-name>, <string-name><surname>Petersen</surname>, <given-names>P. C.</given-names></string-name> &amp; <string-name><surname>Buzsáki</surname>, <given-names>G.</given-names></string-name> <article-title>Internally organized mechanisms of the head direction sense</article-title>. <source>Nat. Neurosci</source>. <volume>18</volume>, <fpage>569</fpage>–<lpage>575</lpage> (<year>2015</year>).</mixed-citation></ref>
<ref id="c33"><label>33.</label><mixed-citation publication-type="web"><string-name><surname>Peyrache</surname>, <given-names>A.</given-names></string-name>, <string-name><surname>Petersen</surname>, <given-names>P. C.</given-names></string-name> &amp; <string-name><surname>Buzsaki</surname>, <given-names>G.</given-names></string-name> <article-title>Extracellular recordings from multi-site silicon probes in the anterior thalamus and subicular formation of freely moving mice</article-title>. <source>CRCNS.org</source> doi:<pub-id pub-id-type="doi">10.6080/K0G15XS1</pub-id>.</mixed-citation></ref>
<ref id="c34"><label>34.</label><mixed-citation publication-type="journal"><string-name><surname>Siegle</surname>, <given-names>J. H.</given-names></string-name> <etal>et al.</etal> <article-title>Survey of spiking in the mouse visual system reveals functional hierarchy</article-title>. <source>Nature</source> <volume>592</volume>, <fpage>86</fpage>–<lpage>92</lpage> (<year>2021</year>).</mixed-citation></ref>
<ref id="c35"><label>35.</label><mixed-citation publication-type="journal"><string-name><surname>Zheng</surname>, <given-names>J.</given-names></string-name> <etal>et al.</etal> <article-title>Neurons detect cognitive boundaries to structure episodic memories in humans</article-title>. <source>Nat. Neurosci</source>. <volume>25</volume>, <fpage>358</fpage>–<lpage>368</lpage> (<year>2022</year>).</mixed-citation></ref>
<ref id="c36"><label>36.</label><mixed-citation publication-type="journal"><string-name><surname>Olmos</surname>, <given-names>A.</given-names></string-name> &amp; <string-name><surname>Kingdom</surname>, <given-names>F. A. A.</given-names></string-name> <article-title>A Biologically Inspired Algorithm for the Recovery of Shading and Reflectance Images</article-title>. <source>Perception</source> <volume>33</volume>, <fpage>1463</fpage>–<lpage>1473</lpage> (<year>2004</year>).</mixed-citation></ref>
<ref id="c37"><label>37.</label><mixed-citation publication-type="other"><string-name><surname>Zhou</surname>, <given-names>P.</given-names></string-name> <etal>et al.</etal> <article-title>EASE: EM-Assisted Source Extraction from calcium imaging data</article-title>. <source>bioRxiv</source> (<year>2020</year>).</mixed-citation></ref>
<ref id="c38"><label>38.</label><mixed-citation publication-type="journal"><string-name><surname>Turner-Evans</surname>, <given-names>D. B.</given-names></string-name> <etal>et al.</etal> <article-title>The Neuroanatomical Ultrastructure and Function of a Biological Ring Attractor</article-title>. <source>Neuron</source> <volume>108</volume>, <fpage>145</fpage>-<lpage>163.e10</lpage> (<year>2020</year>).</mixed-citation></ref>
<ref id="c39"><label>39.</label><mixed-citation publication-type="journal"><string-name><surname>Chaudhuri</surname>, <given-names>R.</given-names></string-name>, <string-name><surname>Gercek</surname>, <given-names>B.</given-names></string-name>, <string-name><surname>Pandey</surname>, <given-names>B.</given-names></string-name>, <string-name><surname>Peyrache</surname>, <given-names>A.</given-names></string-name> &amp; <string-name><surname>Fiete</surname>, <given-names>I.</given-names></string-name> <article-title>The intrinsic attractor manifold and population dynamics of a canonical cognitive circuit across waking and sleep</article-title>. <source>Nat. Neurosci</source>. <volume>22</volume>, <fpage>1512</fpage>–<lpage>1520</lpage> (<year>2019</year>).</mixed-citation></ref>
<ref id="c40"><label>40.</label><mixed-citation publication-type="journal"><string-name><surname>Viejo</surname>, <given-names>G.</given-names></string-name> &amp; <string-name><surname>Peyrache</surname>, <given-names>A.</given-names></string-name> <article-title>Precise coupling of the thalamic head-direction system to hippocampal ripples</article-title>. <source>Nat. Commun</source>. <volume>11</volume>, <fpage>2524</fpage> (<year>2020</year>).</mixed-citation></ref>
<ref id="c41"><label>41.</label><mixed-citation publication-type="journal"><string-name><surname>Gardner</surname>, <given-names>R. J.</given-names></string-name> <etal>et al.</etal> <article-title>Toroidal topology of population activity in grid cells</article-title>. <source>Nature</source> <volume>602</volume>, <fpage>123</fpage>– <lpage>128</lpage> (<year>2022</year>).</mixed-citation></ref>
</ref-list>
<sec id="s3">
<title>Data Availability</title>
<p>All data used in this manuscript are publicly available.</p>
</sec>
<sec id="s4">
<title>Code Availability</title>
<p>All code is publicly available online.</p>
<p>Pynapple: <ext-link ext-link-type="uri" xlink:href="https://github.com/PeyracheLab/pynapple">https://github.com/PeyracheLab/pynapple</ext-link></p>
<p>Pynacollada: <ext-link ext-link-type="uri" xlink:href="https://github.com/PeyracheLab/pynacollada">https://github.com/PeyracheLab/pynacollada</ext-link></p>
</sec>
<ack>
<title>Acknowledgment</title>
<p>This work was supported by a Canadian Research Chair in Systems Neuroscience, CIHR Project Grant 155957, NSERC Discovery Grant RGPIN-2018-04600, and the Canada-Israel Health Research Initiative, jointly funded by the Canadian Institutes of Health Research, the Israel Science Foundation, the International Development Research Centre, Canada and the Azrieli Foundation 108877-001 (AP).</p>
</ack>
<sec id="s5">
<title>Author Contributions</title>
<p>G.V., A.P., and F.P.B. designed and developed Pynapple, with contribution from L.S. All authors contributed to the writing of the manuscript and the design of the figures; A.P. supervised the project.</p>
</sec>
<sec id="s6">
<title>Competing Interests</title>
<p>No competing interests disclosed</p>
</sec>
</back>
<sub-article id="sa0" article-type="editor-report">
<front-stub>
<article-id pub-id-type="doi">10.7554/eLife.85786.1.sa3</article-id>
<title-group>
<article-title>eLife Assessment</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<name>
<surname>Kemere</surname>
<given-names>Caleb</given-names>
</name>
<role specific-use="editor">Reviewing Editor</role>
<aff>
<institution-wrap>
<institution>Rice University</institution>
</institution-wrap>
<city>Houston</city>
<country>United States of America</country>
</aff>
</contrib>
</contrib-group>
<kwd-group kwd-group-type="evidence-strength">
<kwd>Incomplete</kwd>
</kwd-group>
<kwd-group kwd-group-type="claim-importance">
<kwd>Valuable</kwd>
</kwd-group>
</front-stub>
<body>
<p>This paper introduces the python software package Pynapple and a separate package of more advanced routines (Pynacollada) to the Neuroscience/Neural Engineering community. Pynapple provides a set of data objects and methods that have the potential to simplify data analysis for neural and behavioral data types. This represents a <bold>valuable</bold> contribution to the field. The evidence was judged to be <bold>incomplete</bold> due to the fact that key details were missing.</p>
</body>
</sub-article>
<sub-article id="sa1" article-type="referee-report">
<front-stub>
<article-id pub-id-type="doi">10.7554/eLife.85786.1.sa2</article-id>
<title-group>
<article-title>Reviewer #1 (Public Review):</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<anonymous/>
<role specific-use="referee">Reviewer</role>
</contrib>
</contrib-group>
</front-stub>
<body>
<p>A typical path from preprocessed data to findings in systems neuroscience often includes a set of analyses that often share common components. For example, an investigator might want to generate plots that relate one time series (e.g., a set of spike times) to another (measurements of a behavioral parameter such as pupil diameter or running speed). In most cases, each individual scientist writes their own code to carry out these analyses, and thus the same basic analysis is coded repeatedly. This is problematic for several reasons, including the waste of time, the potential for errors, and the greater difficulty inherent in sharing highly customized code.</p>
<p>This paper presents Pynapple, a python package that aims to address those problems.</p>
<p>Strengths:</p>
<p>The authors have identified a key need in the community - well-written analysis routines that carry out a core set of functions and can import data from multiple formats. In addition, they recognized that there are some common elements of many analyses, particularly those involving timeseries, and their object-oriented architecture takes advantage of those commonalities to simplify the overall analysis process.</p>
<p>The package is separated into a core set of applications and another with more advanced applications, with the goal of both providing a streamlined base for analyses and allowing for implementations/inclusion of more experimental approaches.</p>
<p>Weaknesses:</p>
<p>There are two main weaknesses of the paper in its present form.</p>
<p>First, the claims relating to the value of the library in everyday use are not demonstrated clearly. There are no comparisons of, for example, the number of lines of code required to carry out a specific analysis with and without Pynapple or Pynacollada. Similarly, the paper does not give the reader a good sense of how analyses are carried out and how the object-oriented architecture provides a simplified user interaction experience. This contrasts with their GitHub page and associated notebooks which do a better job of showing the package in action.</p>
<p>Second, the paper makes several claims about the values of object-oriented programming and the overall design strategy that are not entirely accurate. For example, object-oriented programming does not inherently reduce coding errors, although it can be part of good software engineering. Similarly, there is a claim that the design strategy &quot;ensures stability&quot; when it would be much more accurate to say that these strategies make it easier to maintain the stability of the code. And the authors state that the package has no dependencies, which is not true in the codebase. These and other claims are made without a clear definition of the properties that good scientific analysis software should have (e.g., stability, extensibility, testing infrastructure, etc.).</p>
<p>There is also a minor issue - these packages address an important need for high-level analysis tools but do not provide associated tools for preprocessing (e.g., spike sorting) or for creating reproducible pipelines for these analyses. This is entirely reasonable, in that no one package can be expected to do everything, but a bit deeper account of the process that takes raw data and produces scientific results would be helpful. In addition, some discussion of how this package could be combined with other tools (e.g., DataJoint, Code Ocean) would help provide context for where Pynapple and Pynacollada could fit into a robust and reliable data analysis ecosystem.</p>
</body>
</sub-article>
<sub-article id="sa2" article-type="referee-report">
<front-stub>
<article-id pub-id-type="doi">10.7554/eLife.85786.1.sa1</article-id>
<title-group>
<article-title>Reviewer #2 (Public Review):</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<anonymous/>
<role specific-use="referee">Reviewer</role>
</contrib>
</contrib-group>
</front-stub>
<body>
<p>Pynapple and Pynacollada have the potential to become very valuable and foundational tools for the analysis of neurophysiological data. NWB still has a steep learning curve and Pynapple offers a user-friendly toolset that can also serve as a wrapper for NWB.</p>
<p>The scope of the manuscript is not clear to me, and the authors could help clarify if Pynacollada and other toolsets in the making become a future aspect of this paper (and Pynapple), or are the authors planning on building these as separate publications.</p>
<p>The author writes that Pynapple can be used without the I/O layer, but the author should clarify how or if Pynapple may work outside NWB.</p>
<p>This brings us to an important fundamental question. What are the advantages of the current approach, where data is imported into the Ts objects, compared to doing the data import into NWB files directly, and then making Pynapple secondary objects loaded from the NWB file? Does NWB natively have the ability to store the 5 object types or are they initialized on every load call?</p>
<p>Many of these functions and objects have a long history in MATLAB - which documents their usefulness, and I believe it would be fitting to put further stress on this aspect - what aspects already existed in MATLAB and what is completely novel. A widely used MATLAB toolset, the FMA toolbox (the Freely moving animal toolbox) has not been cited, which I believe is a mistake.</p>
<p>A limitation in using NWB files is its standardization with limited built-in options for derived data and additional metadata. How are derived data stored in the NWB files?</p>
<p>How is Pynapple handling an existing NWB dataset, where spikes, behavioral traces, and other data types have already been imported?</p>
</body>
</sub-article>
<sub-article id="sa3" article-type="author-comment">
<front-stub>
<article-id pub-id-type="doi">10.7554/eLife.85786.1.sa0</article-id>
<title-group>
<article-title>Author Response:</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<name>
<surname>Viejo</surname>
<given-names>Guillaume</given-names>
</name>
<role specific-use="author">Author</role>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Levenstein</surname>
<given-names>Daniel</given-names>
</name>
<role specific-use="author">Author</role>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Carrasco</surname>
<given-names>Sofia Skromne</given-names>
</name>
<role specific-use="author">Author</role>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Mehrotra</surname>
<given-names>Dhruv</given-names>
</name>
<role specific-use="author">Author</role>
<contrib-id contrib-id-type="orcid">http://orcid.org/0000-0001-5813-3218</contrib-id></contrib>
<contrib contrib-type="author">
<name>
<surname>Mahallati</surname>
<given-names>Sara</given-names>
</name>
<role specific-use="author">Author</role>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Vite</surname>
<given-names>Gilberto R</given-names>
</name>
<role specific-use="author">Author</role>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Denny</surname>
<given-names>Henry</given-names>
</name>
<role specific-use="author">Author</role>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Sjulson</surname>
<given-names>Lucas</given-names>
</name>
<role specific-use="author">Author</role>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Battaglia</surname>
<given-names>Francesco P</given-names>
</name>
<role specific-use="author">Author</role>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Peyrache</surname>
<given-names>Adrien</given-names>
</name>
<role specific-use="author">Author</role>
</contrib>
</contrib-group>
</front-stub>
<body>
<p>We would like to thank the reviewers and editor for their insightful comments and suggestions. We will update the manuscript accordingly. We are particularly glad to read that our software package constitutes a set of “well-written analysis routines” which have “the potential to become very valuable and foundational tools for the analysis of neurophysiological data”. Both reviewers have identified a number of weaknesses in the manuscript, and we would like to take this opportunity to provide a response to some of the remarks and clarify the objectives of our work. We would like to stress that this kind of toolkit is in continual development, and the manuscript offered a snapshot of the package at one point during this process. Since the initial submission several months ago, several improvements have been implemented and further improvements are in development by our group and a growing community of contributors. The manuscript will be updated to reflect these more recent changes, some which will directly address the reviewers’ remarks.</p>
<p>It was first suggested that the manuscript should better showcase the value of the analysis pipeline. As noted by the first reviewer, the online repository (i.e. GitHub page) conveys a better sense of how the toolbox can be used than the present manuscript. Our original intention was to illustrate some examples of data analysis in Figure 4 by adding the corresponding Pynapple command above each processing step. Each step takes a single line of code, meaning that, for example, one only needs to write three lines of code to decode a feature from population activity using a Bayesian decoder (Fig. 4a), or to compute a cross-correlograms of two neurons during specific stimulus presentation (Fig. 4b), or to compute the average firing rate of two neurons around a specific time of the experimental task (Fig. 4c). In our revision, we will include code snippets which will clearly show the required steps for each of these analyses. In addition, we will more clearly point the reader to the online tools (e.g. Jupyter notebooks), which offer an easier and clearer way to demonstrate the use of the toolbox.</p>
<p>Another remark concerns our claim that the package does not have dependencies. We agree that this claim was not well-worded. Our intention was to say that the package exclude dependencies such as scikit-learn, tensorflow or pytorch, which are often used in signal processing and which can be tedious to install. Pynapple still depends on a few packages including the most common ones: Numpy, Scipy, and Pandas. We will rephrase this statement in the manuscript and emphasize the importance of minimal dependencies for long-term backwards-compatibility in scientific computing.</p>
<p>We will complete the bibliography to make sure we properly reference all the packages designed for similar purpose. To note, some are not citable <italic>per se</italic> (i.e. no associated paper) but will be discussed.</p>
<p>It was suggested that the manuscript should better describe the integration of Pynapple into a full experimental data pipeline. This is an interesting point, which was briefly mentioned in the third paragraph of the discussion. Pynapple was not originally designed to pre-process data. However, it can load any type of data stream after the necessary pre-processing steps. Overall, this modularity is a key aspect of the Pynapple framework, and this is also the case for the integration with data pre-processing pipelines, for example spike sorting in electrophysiology and detection of region of interest in calcium imaging. We do not think there should be an integrated solution to the problem but, instead, to make it possible that any piece of code can be used for data irrespective of how the dataset was acquired. This is why we focused on making data loading straightforward and easy to adapt to any situation. This feature enables any user with any data modality and any long-established (often in-house) pre-processing scripts/software to utilize Pynapple in the analysis phase of their pipeline. Overall, not imposing a certain format compatibility from data acquisition phase is a strength for any analysis package.</p>
<p>Finally, the reviews raised the issue of data and intermediate result storage. We agree that this is a critical issue. In the long term, we do not believe that the current implementation of NWB is the right answer for data involved in active analysis, as it is not possible to overwrite a NWB file. This would require the creation of a new NWB file each time an intermediate result is saved, which will be computationally intensive and time consuming, further increasing the odds of writing error. Theoretically, users who need to store intermediate results in a flexible way could use any methods they prefer, writing their own data files and wrappers to reload these data into Pynapple object. However, it is desirable for the Pynapple ecosystem to have a standardized format for storing data. We are currently improving this feature by developing save and loads methods for each Pynapple core object. We aim to provide an output format that is very simple to read in future Pynapple releases. This feature will be available in the coming weeks and will be described in the revised manuscript.</p>
</body>
</sub-article>
</article>