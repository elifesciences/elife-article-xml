<?xml version="1.0" ?><!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.3 20210610//EN"  "JATS-archivearticle1-mathml3.dtd"><article xmlns:ali="http://www.niso.org/schemas/ali/1.0/" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article" dtd-version="1.3" xml:lang="en">
<front>
<journal-meta>
<journal-id journal-id-type="nlm-ta">elife</journal-id>
<journal-id journal-id-type="publisher-id">eLife</journal-id>
<journal-title-group>
<journal-title>eLife</journal-title>
</journal-title-group>
<issn publication-format="electronic" pub-type="epub">2050-084X</issn>
<publisher>
<publisher-name>eLife Sciences Publications, Ltd</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">91597</article-id>
<article-id pub-id-type="doi">10.7554/eLife.91597</article-id>
<article-id pub-id-type="doi" specific-use="version">10.7554/eLife.91597.2</article-id>
<article-version-alternatives>
<article-version article-version-type="publication-state">reviewed preprint</article-version>
<article-version article-version-type="preprint-version">1.3</article-version>
</article-version-alternatives>
<article-categories>
<subj-group subj-group-type="heading">
<subject>Computational and Systems Biology</subject>
</subj-group>
<subj-group subj-group-type="heading">
<subject>Cancer Biology</subject>
</subj-group>
</article-categories>
<title-group>
<article-title>Optimal transport for automatic alignment of untargeted metabolomic data</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<name>
<surname>Breeur</surname>
<given-names>Marie</given-names>
</name>
<xref ref-type="aff" rid="a1">1</xref>
<xref ref-type="author-notes" rid="cor2">†</xref>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Stepaniants</surname>
<given-names>George</given-names>
</name>
<xref ref-type="aff" rid="a2">2</xref>
<xref ref-type="author-notes" rid="cor2">†</xref>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Keski-Rahkonen</surname>
<given-names>Pekka</given-names>
</name>
<xref ref-type="aff" rid="a1">1</xref>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Rigollet</surname>
<given-names>Philippe</given-names>
</name>
<xref ref-type="aff" rid="a2">2</xref>
</contrib>
<contrib contrib-type="author" corresp="yes">
<name>
<surname>Viallon</surname>
<given-names>Vivian</given-names>
</name>
<xref ref-type="aff" rid="a1">1</xref>
<email xlink:href="mailto:viallonv@iarc.who.int">viallonv@iarc.who.int</email> 
</contrib>
<aff id="a1"><label>1</label><institution>Nutrition and Metabolism Branch, International Agency for Research on Cancer</institution>, <city>Lyon</city>, <country>France</country></aff>
<aff id="a2"><label>2</label><institution>Massachusetts Institute of Technology, Department of Mathematics</institution>, <city>Cambridge MA</city>, <country>United States</country></aff>
</contrib-group>
<contrib-group content-type="section">
<contrib contrib-type="editor">
<name>
<surname>Fernandez</surname>
<given-names>Paula</given-names>
</name>
<role>Reviewing Editor</role>
<aff>
<institution-wrap>
<institution>INTA</institution>
</institution-wrap>
<city>Buenos Aires</city>
<country>Argentina</country>
</aff>
</contrib>
<contrib contrib-type="senior_editor">
<name>
<surname>Choi</surname>
<given-names>Murim</given-names>
</name>
<role>Senior Editor</role>
<aff>
<institution-wrap>
<institution>Seoul National University</institution>
</institution-wrap>
<city>Seoul</city>
<country>Republic of Korea</country>
</aff>
</contrib>
</contrib-group>
<author-notes>
<fn id="cor2"><label>†</label><p>These authors contributed equally to this work and are joint first authors</p></fn>
</author-notes>
<pub-date pub-type="epub">
<day>14</day>
<month>02</month>
<year>2024</year>
</pub-date>
<pub-date date-type="original-publication" iso-8601-date="2023-12-11">
<day>11</day>
<month>12</month>
<year>2023</year>
</pub-date>
<pub-date date-type="update" iso-8601-date="2024-04-09">
<day>09</day>
<month>04</month>
<year>2024</year>
</pub-date>
<volume>12</volume>
<elocation-id>RP91597</elocation-id>
<history><date date-type="sent-for-review" iso-8601-date="2023-09-11">
<day>11</day>
<month>09</month>
<year>2023</year>
</date>
</history>
<pub-history>
<event>
<event-desc>Preprint posted</event-desc>
<date date-type="preprint" iso-8601-date="2023-09-13">
<day>13</day>
<month>09</month>
<year>2023</year>
</date>
<self-uri content-type="preprint" xlink:href="https://doi.org/10.48550/arXiv.2306.03218"/>
</event>
<event>
<event-desc>Reviewed preprint v1</event-desc>
<date date-type="reviewed-preprint" iso-8601-date="2023-12-11">
<day>11</day>
<month>12</month>
<year>2023</year>
</date>
<self-uri content-type="reviewed-preprint" xlink:href="https://doi.org/10.7554/eLife.91597.1"/>
<self-uri content-type="editor-report" xlink:href="https://doi.org/10.7554/eLife.91597.1.sa2">eLife assessment</self-uri>
<self-uri content-type="referee-report" xlink:href="https://doi.org/10.7554/eLife.91597.1.sa1">Reviewer #1 (Public Review):</self-uri>
<self-uri content-type="referee-report" xlink:href="https://doi.org/10.7554/eLife.91597.1.sa0">Reviewer #2 (Public Review):</self-uri>
</event>
</pub-history>
<permissions>
<copyright-statement>© 2023, Breeur et al</copyright-statement>
<copyright-year>2023</copyright-year>
<copyright-holder>Breeur et al</copyright-holder>
<ali:free_to_read/>
<license xlink:href="https://creativecommons.org/licenses/by/4.0/">
<ali:license_ref>https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
<license-p>This article is distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution License</ext-link>, which permits unrestricted use and redistribution provided that the original author and source are credited.</license-p>
</license>
</permissions>
<self-uri content-type="pdf" xlink:href="elife-preprint-91597-v2.pdf"/>
<abstract>
<title>Abstract</title>
<p>Untargeted metabolomic profiling through liquid chromatography-mass spectrometry (LC-MS) measures a vast array of metabolites within biospecimens, advancing drug development, disease diagnosis, and risk prediction. However, the low throughput of LC-MS poses a major challenge for biomarker discovery, annotation, and experimental comparison, necessitating the merging of multiple datasets. Current data pooling methods encounter practical limitations due to their vulnerability to data variations and hyperparameter dependence. Here we introduce GromovMatcher, a flexible and user-friendly algorithm that automatically combines LC-MS datasets using optimal transport. By capitalizing on feature intensity correlation structures, GromovMatcher delivers superior alignment accuracy and robustness compared to existing approaches. This algorithm scales to thousands of features requiring minimal hyperparameter tuning. Applying our method to experimental patient studies of liver and pancreatic cancer, we discover shared metabolic features related to patient alcohol intake, demonstrating how GromovMatcher facilitates the search for biomarkers associated with lifestyle risk factors linked to several cancer types.</p>
</abstract>

</article-meta>
<notes>
<notes notes-type="competing-interest-statement">
<title>Competing interests</title>
<p>The authors declare no competing interests.</p>
</notes>
</notes>
</front>
<body>
<sec id="s1" sec-type="intro">
<title>Introduction</title>
<p>Untargeted metabolomics is a powerful analytical technique used to identify and measure a large number of metabolites in a biological sample without preselecting targets <xref ref-type="bibr" rid="c28">Patti (2011)</xref>. This approach allows for a comprehensive overview of an individual’s metabolic profile, provides insights into the biochemical processes involved in cellular and organismal physiology <xref ref-type="bibr" rid="c48">Wishart (2019)</xref>; <xref ref-type="bibr" rid="c31">Pirhaji et al. (2016</xref>), and allows for the exploration of how environmental factors impact metabolism <xref ref-type="bibr" rid="c32">Rappaport et al. (2014)</xref>; <xref ref-type="bibr" rid="c5">Bedia (2022)</xref>. It creates new opportunities to investigate health-related conditions, including diabetes <xref ref-type="bibr" rid="c47">Wang et al. (2011)</xref>, inflammatory bowel diseases <xref ref-type="bibr" rid="c14">Franzosa et al. (2019)</xref>, and various cancer types <xref ref-type="bibr" rid="c24">Loftfield et al. (2021)</xref>; <xref ref-type="bibr" rid="c22">Li et al. (2020)</xref>. However, a major challenge in biomarker discovery, metabolic signature identification and other untargeted metabolomic analyses lies in the low throughput of experimental data, necessitating the development of efficient pooling algorithms capable of merging datasets from multiple sources <xref ref-type="bibr" rid="c24">Loftfield et al. (2021)</xref>.</p>
<p>A common experimental technique in untargeted metabolomics is liquid chromatography-mass spectrometry (LC-MS) which assembles a list of thousands of unlabeled metabolic features characterized by their mass-to-charge ratio (<italic>m/z</italic>), retention time (RT) <xref ref-type="bibr" rid="c50">Zhou et al. (2012)</xref>, and intensity across all biological samples. Combining LC-MS datasets from multiple experimental studies remains challenging due to variation in the <italic>m/z</italic> and RT of a feature from one study to another <xref ref-type="bibr" rid="c50">Zhou et al. (2012)</xref>; <xref ref-type="bibr" rid="c20">Ivanisevic and Want (2019)</xref>. This problem is further compounded by differing instruments and analytical protocols across laboratories, resulting in seemingly incompatible metabolomic datasets.</p>
<p>Manual matching of metabolic features can be a laborious and error-prone task <xref ref-type="bibr" rid="c24">Loftfield et al. (2021)</xref>. To address this challenge, several automated methods have been developed for metabolic feature alignment. One such method is MetaXCMS, which matches LC-MS features based on user-defined <italic>m/z</italic> and RT thresholds <xref ref-type="bibr" rid="c44">Tautenhahn et al. (2011)</xref>. More advanced tools use information on feature intensities measured in samples. For instance, PAIRUP-MS uses known shared metabolic features to impute the intensities of all features from one dataset to another <xref ref-type="bibr" rid="c19">Hsu et al. (2019)</xref>. MetabCombiner <xref ref-type="bibr" rid="c18">Habra et al. (2021)</xref> and M2S <xref ref-type="bibr" rid="c11">Climaco Pinto et al. (2022)</xref> compare average feature intensities, along with their <italic>m/z</italic> and RT values, to align datasets without requiring extensive knowledge of shared features. These automated alignment methods have accelerated our ability to pool and annotate datasets as well as extract biologically meaningful biomarkers. However, they demand substantial fine-tuning of user-defined parameters and ignore correlations among metabolic features which provide a wealth of additional information on shared features.</p>
<p>Here we introduce GromovMatcher, a user-friendly flexible algorithm which automates the matching of metabolic features across experiments. The main technical innovation of GromovMatcher lies in its ability to incorporate the correlation information between metabolic feature intensities, building upon the powerful mathematical framework of computational optimal transport (OT) <xref ref-type="bibr" rid="c30">Peyré et al. (2019)</xref>; <xref ref-type="bibr" rid="c46">Villani (2021)</xref>. OT has proven effective in solving various matching problems and has found applications in multiomics analysis <xref ref-type="bibr" rid="c13">Demetci et al. (2022)</xref>, cell development <xref ref-type="bibr" rid="c35">Schiebinger et al. (2019)</xref>; <xref ref-type="bibr" rid="c49">Yang et al. (2020)</xref>, and chromatogram alignment <xref ref-type="bibr" rid="c38">Skoraczyński et al. (2022)</xref>. Here we leverage the Gromov-Wasserstein (GW) method <xref ref-type="bibr" rid="c25">Mémoli (2011)</xref>; <xref ref-type="bibr" rid="c29">Solomon et al. (2016)</xref>, which matches datasets based on their distance structure and has been seminally applied to spatial reconstruction problems in genomics <xref ref-type="bibr" rid="c27">Nitzan et al. (2019)</xref>. GromovMatcher builds upon the GW algorithm to automatically uncover the shared correlation structure among metabolic feature intensities while also incorporating <italic>m/z</italic> and RT information in the final matching process.</p>
<p>To assess the performance of GromovMatcher, we systematically benchmark it on synthetic data with varying levels of noise, feature overlap, and data normalizations, outperforming prior state-of-the-art methods of metabCombiner <xref ref-type="bibr" rid="c18">Habra et al. (2021)</xref> and M2S <xref ref-type="bibr" rid="c11">Climaco Pinto et al. (2022)</xref>. Next we apply GromovMatcher to align experimental patient studies of liver and pancreatic cancer to a reference dataset and associate the shared metabolic features to each patient’s alcohol intake. Through these efforts, we demonstrate how GromovMatcher data pooling improves our ability to discover biomarkers of lifestyle risk factors associated with several types of cancer.</p>
</sec>
<sec id="s2" sec-type="results">
<title>Results</title>
<sec id="s2-1">
<title>GromovMatcher algorithm</title>
<p>GromovMatcher uses the mathematical framework of OT to find all matching metabolic features between two untargeted metabolomic datasets (<xref ref-type="fig" rid="fig1">Fig. 1</xref>). It accepts two LC-MS datasets with possibly different numbers of metabolic features and samples. Each feature, fx<sub><italic>i</italic></sub>. in Dataset 1 and fy<sub><italic>j</italic></sub> in Dataset 2, is identified by its <italic>m/z</italic>, RT, and vector of feature intensities across samples (<xref ref-type="fig" rid="fig1">Fig. 1a</xref>). The primary tenet of GromovMatcher is that shared metabolic features have similar correlation patterns in both datasets and can be matched based on the distance/correlations between their feature intensity vectors. Specifically, GromovMatcher computes the pairwise distances between the feature intensity vectors of each metabolic feature in a dataset and saves them into a distance matrix, one per dataset (<xref ref-type="fig" rid="fig1">Fig. 1b</xref>). In practice, we use either the Euclidean distance or the cosine distance (negative of correlation) to perform this step (Methods). The resulting distance matrices contain information about the feature intensity similarity within each study. Using optimal transport, we can deduce shared subsets of metabolic features in both datasets which have corresponding feature intensity distance structures.</p>
<fig id="fig1" position="float" fig-type="figure">
<label>Figure 1.</label>
<caption><title>An optimal transport approach for combining untargeted metabolomics datasets (GromovMatcher).</title><p>(<bold>a</bold>) Inputs are two LC-MS datasets of unlabeled metabolic features (rows) identified by their <italic>m/z</italic>, RT, and feature intensities across biospecimen samples. Both studies can have differing numbers of metabolic features and samples. (<bold>b</bold>) In both datasets, the intensities across samples of each metabolic feature are formed into a vector and Euclidean distances between these feature vectors are computed and stored in a distance matrix. (<bold>c</bold>) Based on the technique of optimal transport, the unbalanced GW algorithm learns a coupling matrix <inline-formula id="ID1"><alternatives>
<mml:math display="block" id="I1">
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>˜</mml:mo>
</mml:mover>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq1.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> that places large weights <inline-formula id="ID2"><alternatives>
<mml:math display="block" id="I2">
<mml:mrow>
<mml:msub>
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>˜</mml:mo>
</mml:mover>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
<mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq2.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> when fx<sub><italic>i</italic></sub> and fy<sub><italic>y</italic></sub> likely correspond to the same metabolic feature. It optimizes <inline-formula id="ID3"><alternatives>
<mml:math display="block" id="I3">
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>˜</mml:mo>
</mml:mover>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq3.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> to match features with similar pairwise distances (red outlined boxes) whose <italic>m/z</italic> ratios are close. (<bold>d</bold>) The final step of GromovMatcher plots the retention times of features from both datasets against each other and fits a spline interpolation <italic>f</italic> weighted by the estimated coupling weights n. This retention time drift function is then used to set all entries <inline-formula id="ID4"><alternatives>
<mml:math display="block" id="I4">
<mml:mrow>
<mml:msub>
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>˜</mml:mo>
</mml:mover>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq4.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> to zero for those outlier pairs (fx<sub><italic>i</italic></sub>, fy<sub><italic>y</italic></sub>) which exceed twice the median absolute deviation (MAD) around <inline-formula id="ID5"><alternatives>
<mml:math display="block" id="I5">
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>˜</mml:mo>
</mml:mover>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq5.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> (green highlighted region). Finally, the coupling matrix <inline-formula id="ID6"><alternatives>
<mml:math display="block" id="I6">
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>˜</mml:mo>
</mml:mover>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq6.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> is filtered and/or thresholded to obtain a refined coupling <inline-formula id="ID7"><alternatives>
<mml:math display="block" id="I7">
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>˜</mml:mo>
</mml:mover>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq7.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> which is then binarized to obtain a one-to-one matching <italic>M</italic> between a subset of metabolite pairs in both datasets.</p>
</caption>
<graphic xlink:href="2306.03218v3_fig1.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
<p>OT was originally developed to optimize the transportation of soil for the construction of forts <xref ref-type="bibr" rid="c26">Monge (1781)</xref> and was later generalized through the language of probability theory and linear programming <xref ref-type="bibr" rid="c21">Kantorovich (2006)</xref>, leading to efficient numerical algorithms and direct applications to planning problems in economics. The ability of OT to efficiently match source to target locations found applications in data science for the alignment of distributions <xref ref-type="bibr" rid="c12">Courty et al. (2017)</xref>; <xref ref-type="bibr" rid="c4">Alvarez-Melis et al. (2019)</xref> and was generalized by the Gromov-Wasserstein (GW) method <xref ref-type="bibr" rid="c29">Peyré et al. (2016)</xref>; <xref ref-type="bibr" rid="c3">Alvarez-Melis and Jaakkola (2018)</xref> to align datasets with features of differing dimensions.</p>
<p>In practice, a sizeable fraction of the metabolic features measured in one study may not be present in the other. Hence, in most cases only a subset of features in both datasets can be matched. Recent GW formulations for unbalanced matching problems <xref ref-type="bibr" rid="c37">Sejourne et al. (2021)</xref> allow for matching only subsets of metabolic features with similar intensity structures (<xref ref-type="fig" rid="fig1">Fig. 1c</xref>). To incorporate additional feature information, we modify the optimization objective of unbalanced GW to penalize feature matches whose <italic>m/z</italic> differences exceed a fixed threshold (Methods, <xref ref-type="app" rid="app1">Appendix 1</xref>). The optimization of this objective computes a <italic>coupling matrix</italic> <inline-formula id="ID8"><alternatives>
<mml:math display="block" id="I8">
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>˜</mml:mo>
</mml:mover>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq8.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> where each entry <inline-formula id="ID9"><alternatives>
<mml:math display="block" id="I9">
<mml:mrow>
<mml:msub>
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>˜</mml:mo>
</mml:mover>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
<mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq9.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> indicates the level of confidence in matching metabolic feature fx<sub><italic>i</italic></sub> in Dataset 1 to fy<sub><italic>j</italic></sub> in Dataset 2.</p>
<p>Differences in experimental conditions can induce variations in RT between datasets that can be nonlinear and large in magnitude <xref ref-type="bibr" rid="c50">Zhou et al. (2012)</xref>; <xref ref-type="bibr" rid="c11">Climaco Pinto et al. (2022)</xref>; <xref ref-type="bibr" rid="c18">Habra et al. (2021)</xref>. In the spirit of previous methods for LC-MS batch or dataset alignment <xref ref-type="bibr" rid="c40">Smith et al. (2006)</xref>; <xref ref-type="bibr" rid="c8">Brunius et al. (2016)</xref>; <xref ref-type="bibr" rid="c22">Liu et al. (2020)</xref>; <xref ref-type="bibr" rid="c45">Vaughan et al. (2012)</xref>; <xref ref-type="bibr" rid="c18">Habra et al. (2021)</xref>; <xref ref-type="bibr" rid="c11">Climaco Pinto et al. (2022)</xref>; <xref ref-type="bibr" rid="c38">Skoraczynski et al. (2022)</xref>, the learned coupling <inline-formula id="ID10"><alternatives>
<mml:math display="block" id="I10">
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>˜</mml:mo>
</mml:mover>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq10.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> is used to estimate a nonlinear map (drift function) between RTs of both datasets by weighted spline regression, which allows us to filter unlikely matches from the coupling matrix to obtain a refined coupling matrix <inline-formula id="ID11"><alternatives>
<mml:math display="block" id="I11">
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>˜</mml:mo>
</mml:mover>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq11.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> (<xref ref-type="fig" rid="fig1">Fig. 1d</xref>, Methods). An optional thresholding step removes matches with small weights from the coupling matrix. The final output of GromovMatcher is a binary matching matrix <italic>M</italic> where <italic>M<sub>ij</sub></italic> is equal to 1 if features fx<sub><italic>i</italic></sub> and fy<sub>j</sub> are matched and 0 otherwise. Throughout the paper, we refer to the two variants of GromovMatcher, with and without the optional thresholding step as GMT and GM respectively.</p>
</sec>
<sec id="s2-2">
<title>Validation on ground-truth data</title>
<p>We first evaluate the performance of GromovMatcher using a real-world untargeted metabolomics study of cord blood across 499 newborns containing 4,712 metabolic features characterized by their <italic>m/z</italic>, RT, and feature intensities <xref ref-type="bibr" rid="c2">Alfano et al. (2020)</xref>. To generate ground-truth data, we randomly divide the initial dataset into two smaller datasets sharing a subset of features (<xref ref-type="fig" rid="fig2">Fig. 2</xref>). We simulate diverse acquisition conditions by adding noise to the <italic>m/z</italic> and RT of dataset 2, and to the feature intensities in both datasets. Moreover, we introduce an RT drift in dataset 2 to replicate the retention time variations observed in real LC-MS experiments (Methods and Materials). For comparison, we also test M2S <xref ref-type="bibr" rid="c11">Climaco Pinto et al. (2022)</xref> and metabCombiner <xref ref-type="bibr" rid="c18">Habra et al. (2021)</xref>, both of which use <italic>m/z</italic>, RT, and median or mean feature intensities to match features (<xref ref-type="fig" rid="fig3">Fig. 3</xref>). MetabCombiner is supplied with 100 known shared metabolic features to automatically set its hyperparameters, while M2S parameters are manually fine-tuned to optimize the F1-score in each scenario (<xref ref-type="app" rid="app2">Appendix 2</xref>). We assess the performance of GM, GMT, metabCombiner, and M2S across 20 randomly generated dataset pairs in terms of their precision (fraction of true matches among the detected matches) and recall/sensitivity (fraction of true matches detected) averaged across 20 dataset pairs.</p>
<p>To investigate how the number of shared features affects dataset alignment, we generate pairs of LC-MS datasets with low, medium, and high feature overlap (25%, 50%, and 75%), while maintaining a medium noise level (Methods). Here we find that GM and GMT generally outperform existing alignment methods, with a recall above 0.95 while metabCombiner and M2S tend to be less sensitive (<xref ref-type="fig" rid="fig3">Fig. 3b</xref>). All methods drop in precision as the feature overlap is decreased, with GM and GMT still maintaining an average precision above 0.8.</p>
<fig id="fig2" position="float" fig-type="figure">
<label>Figure 2.</label>
<caption><title>Simulated data for testing untargeted metabolomics alignment methods.</title><p>(<bold>a</bold>) Initial LC-MS dataset taken from the EXPOsOMICS project with <italic>m</italic>/<italic>z</italic>, RT, and feature intensities of <italic>p =</italic> 4, 712 metabolites identified in cord blood across <italic>n =</italic> 499 newborns. (<bold>b</bold>) Newborns (rows) are split into two disjoint groups of sizes <italic>n</italic><sub>1</sub> = 249 and <italic>n</italic><sub>2</sub><italic> =</italic> 250 respectively and metabolic features (columns) are split into two equal groups of size <italic>p</italic><sub>1</sub> = <italic>p</italic><sub>2</sub> with overlap <italic>λ<sub>p</sub></italic> where <italic>λ</italic> = 0.25, 0.5, 0.75 (Methods). Datasets are perturbed by additive noise of magnitude (<italic>σ</italic><sub>M</sub>, <italic>σ</italic><sub>RT</sub>, <italic>σ</italic><sub>Fl</sub>) and a nonlinear drift <italic>f</italic> (<italic>x</italic>) is applied to the RTs of dataset 2. (<bold>c</bold>) The two resulting datasets share <italic>λ</italic> = 25%, 50%, or 75% of the original dataset’s metabolic features.</p>
</caption>
<graphic xlink:href="2306.03218v3_fig2.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
<p>Next we evaluate all four methods at low, moderate, and high noise levels for pairs of datasets with 50% overlap in their features (Methods). Our results show that GMT, GM, and M2S maintain an average recall above 0.89, while metabCombiner’s recall drops below 0.6 for high noise. At large noise levels, RT drift estimation becomes more challenging, leading to a higher rate of false matches between metabolites (lower precision) for all four methods (<xref ref-type="fig" rid="figS2">Fig. 3 - figure supplement 1</xref>). Nevertheless, GMT obtains a high average precision and recall of 0.86 and 0.92 respectively.</p>
<p>A notable difference between GM, metabCombiner, and M2S lies in their use of feature intensities. MetabCombiner expects that the mean feature intensity rankings are identical across studies, while M2S assumes that shared features have similar median intensities. In contrast, GM uses both the mean feature intensities and their variances and covariances. In practice, differences in experimental assays or study populations can lead to greater variation in feature intensities, making matchings based on these statistics less reliable. Centering and scaling the feature intensities to unit variance avoids potential biases arising from inconsistent feature intensity magnitudes, but preserves correlations that GM leverages.</p>
<p>Exploring this further, we test how sensitive all four methods are to centering and scaling of feature intensities. MetabCombiner and M2S are tuned using the same methodology as for non-centered and non-scaled data. For M2S, we match features solely based on their <italic>m</italic>/<italic>z</italic> and RT. In this experiment (<xref ref-type="fig" rid="figS2">Figure 3 - figure supplement 2</xref>), the absence of intensity magnitude information significantly affects metabCombiner’s performance and, to a lesser extent, M2S. GM and GMT still obtain accurate matchings, due to their use of correlation structures which are preserved under centering and scaling.</p>
</sec>
<sec id="s2-3">
<title>Application to EPIC data</title>
<p>Next, we apply GM, metabCombiner and M2S to align datasets from the European Prospective Investigation into Cancer and Nutrition (EPIC) cohort, a prospective study conducted across 23 European centers. EPIC comprises more than 500,000 participants who provided blood samples at recruitment <xref ref-type="bibr" rid="c34">Riboli et al. (2002)</xref>. Untargeted metabolomics data were successively acquired in several studies nested within the full cohort.</p>
<p>In the present work, we use LC-MS data from the EPIC cross-sectional (CS) study <xref ref-type="bibr" rid="c39">Slimani et al. (2003)</xref> and two matched case-control studies nested within EPIC, on hepatocellular carcinoma (HCC) <xref ref-type="bibr" rid="c42">Stepien et al. (2016</xref>, <xref ref-type="bibr" rid="c24">2021</xref>) and pancreatic cancer (PC) <xref ref-type="bibr" rid="c15">Gasull et al. (2019)</xref>. LC-MS untargeted metabolomic data were acquired at the International Agency for Research on Cancer, making use of the same platform and methodology (Methods). The number of samples and features in each study is displayed in <xref ref-type="fig" rid="fig4">Fig. 4a</xref>.</p>
<fig id="fig3" position="float" fig-type="figure">
<label>Figure 3.</label>
<caption><title>Comparison of MetabCombiner, M2S, and GromovMatcher on simulated data.</title><p>(<bold>a</bold>) Ground-truth matchings, and matchings inferred by metabCombiner, M2S, GM, and GMT. Pairs of datasets are generated for three levels of overlap (low, medium and high), with a medium noise level (Methods). Matches correctly recovered (true positives) are represented in green. True matches that are not recovered (false negatives) are highlighted in grey. Incorrect matches (false positives) are plotted in red. Features in rows and columns of matching matrices are reordered for visual clarity. (<bold>b</bold>) Average precision and recall on 20 randomly generated pairs of datasets, for three levels of overlap (low, medium and high) with a medium noise level.</p>
</caption>
<graphic xlink:href="2306.03218v3_fig3.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
<p>Loftfield et al. <xref ref-type="bibr" rid="c24">Loftfield et al. (2021)</xref> previously matched features from the CS, HCC, and PC studies in EPIC for alcohol biomarker discovery. The authors first identified 205 features (163 in positive and 42 in negative mode) associated with alcohol intake in the CS study. These features were then manually matched by an expert to features in both the HCC and PC studies (Methods). In our analysis, we use these features as a validation set and compare each method’s matchings to the expert manual matchings on this subset. Due to the imbalance between the number of positive and negative mode features in the validation subset, our main analysis focuses on the alignment results of CS with HCC and CS with PC in positive mode. We delegate the matching results between the negative mode studies to <xref ref-type="app" rid="app4">Appendix 4</xref>.</p>
<p>In this section, we use the same settings for GM as in our simulation study, and do not apply an additional thresholding step. The parameters of metabCombiner and M2S are calibrated using the validation subset as prior knowledge (<xref ref-type="app" rid="app2">Appendix 2</xref>).</p>
<p>Preliminary analysis of the validation subset reveals inconsistencies in the mean feature intensities (<xref ref-type="fig" rid="figS3">Figure 4 - figure supplement 1</xref>), but Figure 4b shows that on centered and scaled data, the 90 expert matched features shared between the CS and HCC studies have similar correlation structures. Hence, to avoid potential errors we center and scale the feature intensities which improves the performance of all three methods tested below (<xref ref-type="app" rid="app4">Appendix 4</xref>, <xref ref-type="table" rid="apptbl2">Appendix 4 - Table 1</xref>).</p>
<sec id="s2-3-1">
<title>Hepatocellular carcinoma</title>
<p>Here we analyze the quality of the matchings obtained by GM, M2S, and metabCombiner between the CS and HCC datasets in positive mode. Both GM and M2S identify approximately 1000 shared features while metabCombiner finds a smaller number of about 700 shared features. We refer the reader to <xref ref-type="fig" rid="figS4">Figure 4- figure supplement 2a</xref> for the precise matched feature sizes and details on the agreement between the feature matchings of all three methods.</p>
<p>We evaluate the performance of metabCombiner, M2S, and GM on the validation subset in positive mode (<xref ref-type="fig" rid="fig4">Fig. 4c</xref>), which consist of 90 features from the CS study manually matched to features from the HCC study and 73 features specific to the CS study. MetabCombiner demonstrates precise matching but lacks sensitivity. M2S’s precision and recall are comparable with GM, in contrast to its performance on simulated data. This can be attributed to the RT drift shape between the CS and HCC studies (<xref ref-type="app" rid="app2">Appendix 2</xref>), which is estimated to be close to linear (<xref ref-type="fig" rid="figS4">Figure 4 - figure supplement 3</xref>). Because the parameters of M2S are fine-tuned in the validation subset, it is able to learn this linear drift and apply tight RT thresholds to achieve accurate matchings. In contrast to metabCombiner and M2S, the GM algorithm is not given any prior knowledge of the validation subset, and nevertheless demonstrates the highest precision and recall rates of the three methods (<xref ref-type="fig" rid="fig4">Fig. 4c</xref>). Figure 4b shows how GM recovers the majority of the expert matched pairs by leveraging the shared correlations.</p>
</sec>
<sec id="s2-3-2">
<title>Pancreatic cancer</title>
<p>Matching features between the CS and PC studies in positive mode, GM and M2S identify approximately 1000 common features, while metabCombiner detects approximately 600 matches (<xref ref-type="fig" rid="figS4">Figure 4- figure supplement 2b</xref>). We examine the performance of all three methods on the validation subset consisting of 66 manually matched features between CS and PC along with 97 features specific to the CS study. As before, GM and M2S have high recall while the recall of metabCombiner is less than 0.5.</p>
<p>A decrease in precision is observed for both GM and M2S compared to the previous CS-HCC matchings. We therefore manually inspect the false positive matches; the set of CS features matched by the method to the PC study but explicitly examined and left unmatched in the expert manual matching. Assessing the GM results, we identify 7 false positive feature matches. Upon secondary inspection, 3 pairs are revealed as correct matches that were not initially identified in the expert matching. M2S finds 11 false positive matches which include the 7 false positives recovered by GM. Manual examination of the 4 remaining pairs reveals 2 clear mismatches. These results highlight the advantage of using automated methods for data alignment, as both GM and M2S detect correct matches that were not identified by experts, with GM being more precise than M2S.</p>
<fig id="fig4" position="float" fig-type="figure">
<label>Figure 4.</label>
<caption><title>Application of GromovMatcher and comparison to existing methods on EPIC dataset.</title><p>(<bold>a</bold>) Dimensions of the three EPIC studies used. For each ionization mode, the cross-sectional (CS) study is aligned successively with the hepatocellular carcinoma (HCC) study and the pancreatic cancer (PC) study. (<bold>b</bold>) Demonstration of expert manual matching and GromovMatcher (GM) matching between the CS and HCC studies in positive mode. Experts manually match 90 features from <xref ref-type="bibr" rid="c24">Loftfield et al. (2021)</xref> and the correlation matrices of these features in both datasets have similar structure (bottom two matrices). GM discovers 996 shared features between the CS and HCC datasets which have similar correlation structure (top two matrices). We validate that 88 of the 90 features from the manually expert matched subset are contained in the set of features matched by GM. (<bold>c</bold>) Performance of metabCombiner (mC), M2S and GM in positive mode. Precisions and recalls are measured on a validation subset of 163 manually examined features, and 95% confidence intervals are computed using modified Wilson score intervals. (<bold>d</bold>) Performance of mC, M2S and GM in negative mode. Precision and recall are measured on a validation subset of42 manually examined features, and 95% confidence intervals are computed using modified Wilson score intervals. See <xref ref-type="table" rid="tbl2">Table 2</xref> and <xref ref-type="table" rid="tbl3">Table 3</xref> for exact precisions, recalls, and confidence intervals in positive and negative mode respectively.</p>
</caption>
<graphic xlink:href="2306.03218v3_fig4.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
<table-wrap id="tbl1" orientation="portrait" position="float">
<label>Table 1</label>
<caption><title>Results from the manual matching conducted for Loftfield et al. <xref ref-type="bibr" rid="c24"><italic>Loftfield et al.</italic> (<italic>2021</italic>)</xref>.</title><p>Features from the CS study (163 features in positive mode, 42 features in negative mode) were manually investigated for matches in the HCC and PC studies.</p></caption>
<alternatives>
<graphic xlink:href="2306.03218v3_tbl1.tif" mimetype="image" mime-subtype="tiff"/>
<table frame="hsides" rules="groups">
<thead>
<tr>
<th align="left" valign="bottom">Study</th>
<th align="center" valign="bottom">Manual matches found in positive mode</th>
<th align="center" valign="bottom">Manual matches found in negative mode</th>
</tr>
</thead>
<tbody>
<tr>
<td valign="bottom" align="left"><bold>Hepatocellular carcinoma (HCC)</bold></td>
<td valign="bottom" align="center">90</td>
<td valign="bottom" align="center">19</td>
</tr>
<tr>
<td valign="bottom" align="left"><bold>Pancreatic cancer (PC)</bold></td>
<td valign="bottom" align="center">66</td>
<td valign="bottom" align="center">28</td>
</tr>
</tbody>
</table>
</alternatives>
</table-wrap>
<table-wrap id="tbl2" orientation="portrait" position="float">
<label>Table 2</label>
<caption><title>Precision and recall on the EPIC validation subset in positive mode.</title><p>95% confidence intervals were computed using modified Wilson score intervals <xref ref-type="bibr" rid="c7">Brown et al. (2001)</xref>; <xref ref-type="bibr" rid="c1">Agresti and Coull (1998)</xref>.</p></caption>
<alternatives>
<graphic xlink:href="2306.03218v3_tbl2.tif" mimetype="image" mime-subtype="tiff"/>
<table frame="hsides" rules="groups">
<thead>
<tr>
<th valign="bottom" align="center"/>
<th colspan="2" valign="bottom" align="center">CS ↔ HCC</th>
<th colspan="2" valign="bottom" align="center">CS ↔ PC</th>
</tr>
<tr>
<th valign="bottom" align="left">Method</th>
<th valign="bottom" align="center">Precision</th>
<th valign="bottom" align="center">Recall</th>
<th valign="bottom" align="center">Precision</th>
<th valign="bottom" align="center">Recall</th>
</tr>
</thead>
<tbody>
<tr>
<td valign="bottom" align="left"><bold>GromovMatcher</bold></td>
<td valign="bottom" align="center">0.989 (0.939, 0.999)</td>
<td valign="bottom" align="center">0.978 (0.923, 0.996)</td>
<td valign="bottom" align="center">0.903 (0.813, 0.952)</td>
<td valign="bottom" align="center">0.985 (0.919, 0.999)</td>
</tr>
<tr>
<td valign="bottom" align="left"><bold>M2S</bold></td>
<td valign="bottom" align="center">0.967 (0.908, 0.991)</td>
<td valign="bottom" align="center">0.978 (0.923, 0.996)</td>
<td valign="bottom" align="center">0.855 (0.759, 0.917)</td>
<td valign="bottom" align="center">0.985 (0.919, 0.999)</td>
</tr>
<tr>
<td valign="bottom" align="left"><bold>metabCombiner</bold></td>
<td valign="bottom" align="center">0.961 (0.868, 0.993)</td>
<td valign="bottom" align="center">0.544 (0.442, 0.643)</td>
<td valign="bottom" align="center">0.967 (0.833, 0.998)</td>
<td valign="bottom" align="center">0.439 (0.326, 0.559)</td>
</tr>
</tbody>
</table>
</alternatives>
</table-wrap>
<table-wrap id="tbl3" orientation="portrait" position="float">
<label>Table 3</label>
<caption><title>Precision and recall on the EPIC validation subset in positive mode.</title><p>95% confidence intervals were computed using modified Wilson score intervals <xref ref-type="bibr" rid="c7">Brown et al. (2001)</xref>; <xref ref-type="bibr" rid="c1">Agresti and Coull (1998)</xref>.</p></caption>
<alternatives>
<graphic xlink:href="2306.03218v3_tbl3.tif" mimetype="image" mime-subtype="tiff"/>
<table frame="hsides" rules="groups">
<thead>
<tr>
<th valign="bottom" align="center"/>
<th colspan="2" valign="bottom" align="center">CS ↔ HCC</th>
<th colspan="2" valign="bottom" align="center">CS ↔ PC</th>
</tr>
<tr>
<th valign="bottom" align="left">Method</th>
<th valign="bottom" align="center">Precision</th>
<th valign="bottom" align="center">Recall</th>
<th valign="bottom" align="center">Precision</th>
<th valign="bottom" align="center">Recall</th>
</tr>
</thead>
<tbody>
<tr>
<td valign="bottom" align="left"><bold>GromovMatcher</bold></td>
<td valign="bottom" align="center">0.950 (0.764, 0.997)</td>
<td valign="bottom" align="center">1.000 (0.832, 1.000)</td>
<td valign="bottom" align="center">0.929 (0.774, 0.987)</td>
<td valign="bottom" align="center">0.929 (0.774, 0.987)</td>
</tr>
<tr>
<td valign="bottom" align="left"><bold>M2S</bold></td>
<td valign="bottom" align="center">1.000 (0.824, 1.000)</td>
<td valign="bottom" align="center">0.947 (0.754, 0.997)</td>
<td valign="bottom" align="center">0.931 (0.780, 0.988)</td>
<td valign="bottom" align="center">0.964 (0.823, 0.998)</td>
</tr>
<tr>
<td valign="bottom" align="left"><bold>metabCombiner</bold></td>
<td valign="bottom" align="center">0.875 (0.529, 0.993)</td>
<td valign="bottom" align="center">0.368 (0.191, 0.590)</td>
<td valign="bottom" align="center">1.000 (0.845, 1.000)</td>
<td valign="bottom" align="center">0.750 (0.566, 0.873)</td>
</tr>
</tbody>
</table>
</alternatives>
</table-wrap>
</sec>
<sec id="s2-3-3">
<title>Illustration for alcohol biomarker discovery</title>
<p>Loftfield et al. <xref ref-type="bibr" rid="c24">Loftfield et al. (2021</xref>) identified biomarkers of habitual alcohol intake by first performing a discovery step, where they examined the relationship between alcohol intake and metabolic features in the CS study. They then manually matched the significant features in CS to features from the HCC and PC studies, and repeated the analysis with samples from the HCC and PC studies to determine whether the association with alcohol intake persisted. This led to the identification of 10 features possibly associated with alcohol intake (<xref ref-type="fig" rid="fig5">Fig. 5a</xref>).</p>
<p>To extend this analysis and illustrate the benefit of GM automatic matching for biomarker discovery, we use GM to pool features from the CS, HCC, and PC studies, and examine the relationship between metabolic features and alcohol intake in the pooled study (Methods and <xref ref-type="fig" rid="fig5">Fig. 5b</xref>).</p>
<p>Applying an FDR correction on the pooled study, we identify 243 features associated with alcohol intake, including 185 features consistent with the discovery step of Loftfield et al. <xref ref-type="bibr" rid="c24">Loftfield et al. (2021)</xref>, and 55 newly discovered features (<xref ref-type="fig" rid="fig5">Fig. 5c</xref>). Using the more stringent Bonferroni correction on the pooled data, we identify 36 features shared by all three studies that are significantly associated with alcohol intake. These features include all 10 features identified in Loftfield et al. (<xref ref-type="fig" rid="fig5">Fig. 5c</xref>). These findings highlight the potential benefits of using GM automatic matching for biomarker discovery in untargeted metabolomics data. Additional information regarding the methodology and findings of our GM and Loftfield et al. analyses can be found in Methods and <xref ref-type="app" rid="app4">Appendix 4</xref>.</p>
</sec>
</sec>
</sec>
<sec id="s3" sec-type="discussions">
<title>Discussion</title>
<p>LC-MS metabolomics has emerged as an increasingly powerful tool for biological and biomedical research, offering promising opportunities for epidemiological and clinical investigations. However, integrating data from different sources remains challenging. To address this issue, we introduce GromovMatcher, a method based on optimal transport that automatically aligns LC-MS data from pairs of studies. Our method exhibits superior performance on both simulated and real data when compared to existing approaches. Additionally, it presents a user-friendly interface with few hyperparameters.</p>
<p>While GromovMatcher is robust to noise and variations in data, it may face limitations when aligning LC-MS studies from populations with different characteristics, where the correlation structures between features may be inconsistent across studies. In this case, the base assumption of GromovMatcher can be relaxed by focusing on subsamples with similar characteristics, as exemplified in a recent study <xref ref-type="bibr" rid="c16">Gomari et al. (2022)</xref>.</p>
<p>A current limitation is that GromovMatcher does not account for more than two datasets simultaneously, although this can be overcome by aligning multiple studies to a chosen reference dataset, as demonstrated in our biomarker experiments. The extension of Gromov-Wasserstein to multiple distributions <xref ref-type="bibr" rid="c6">Beier et al. (2022)</xref> is another promising approach for generalizing GromovMatcher to multiple dataset alignment. Further improvements can be made by incorporating existing knowledge about the studies being matched, such as known shared features, samples in common, or MS/MS data.</p>
<p>The results obtained from GromovMatcher are highly promising, opening the door for various analyses of metabolomic datasets acquired in different experimental laboratories. Here we demonstrated the potential of GromovMatcher in expediting the combination and meta-analysis of data for biomarker and metabolic signature discovery. The matchings learned by GromovMatcher also allow for comparison between experimental protocols by assessing the drift in <italic>m/z</italic>, RT, and feature intensities across studies. Finally, inter-institutional annotation efforts can directly benefit from incorporating this method to transfer annotations between aligned datasets. Bridging the gap between otherwise incompatible LC-MS data, GromovMatcher enables seamless comparison of untargeted metabolomics experiments.</p>
<fig id="fig5" position="float" fig-type="figure">
<label>Figure 5.</label>
<caption><title>Comparison of GromovMatcher and Loftfield et al. <xref ref-type="bibr" rid="c24">Loftfield et al. (2021)</xref> analysis for alcohol biomarker discovery on EPIC data.</title><p>(<bold>a</bold>) Loftfield study implemented a discovery step, examining the relationship between alcohol intake and metabolic features in the CS study. The significant features in CS were manually matched to features from the HCC and PC and the analysis was repeated using samples from the HCC and PC studies. After this step, 10 features associated with alcohol intake were identified. (<bold>b</bold>) GromovMatcher analysis begins by matching features from CS study to HCC and PC studies respectively (top blue, yellow, and red boxes). Samples corresponding to each CS feature are combined with the samples of its matched feature in the HCC study, PC study, or both. This generates a larger pooled data matrix with the same number of features as the CS study but with more samples pooled across the three original studies (center matrix). Because some features in the CS study may not have matches in HCC or PC, the corresponding entries in the pooled matrix are set to NaN/missing values (white regions in matrix). Each column/feature in this matrix is statistically tested for association with alcohol intake (ignoring missing values) and an FDR or a stricter Bonferroni correction is performed to retain only a subset of features from the pooled study that have a strong association. (<bold>c</bold>) Venn diagrams show intersection of feature sets (in positive and negative mode) found to be associated with alcohol intake by one of the four different analyses.</p></caption>
<graphic xlink:href="2306.03218v3_fig5.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
</sec>
<sec id="s4" sec-type="methods|materials">
<title>Methods and Materials</title>
<sec id="s4-1">
<title>GromovMatcher method overview</title>
<p>GromovMatcher accepts as input two feature tables from separate LC-MS untargeted metabolomics studies. Each feature table for dataset 1 and dataset 2 consists of <italic>n</italic><sub>1</sub>,<italic> n</italic><sub>2</sub> biospecimen samples respectively and <italic>p</italic><sub>1</sub>, <italic>p</italic><sub>2</sub> metabolic features respectively detected in the study. Features in dataset 1 are given the label fx<sub><italic>i</italic></sub> for <italic>i =</italic> 1<italic>,… ,p</italic><sub>1</sub>. Every feature is characterized by a mass-to-charge ratio (<italic>m/z</italic>) denoted by <inline-formula id="ID12"><alternatives>
<mml:math display="block" id="I12">
<mml:msubsup>
<mml:mi>n</mml:mi>
<mml:mi>i</mml:mi>
<mml:mi>x</mml:mi>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq12.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula>, a retention time (RT) denoted by <inline-formula id="ID13"><alternatives>
<mml:math display="block" id="I13">
<mml:mi>R</mml:mi><mml:msubsup>
<mml:mi>T</mml:mi>
<mml:mi>i</mml:mi>
<mml:mi>x</mml:mi>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq13.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula>, and a vector of intensities across all samples written as <inline-formula id="ID14"><alternatives>
<mml:math display="block" id="I14">
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>∈</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>n</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq14.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula>. Similarly, features in dataset 2 are labeled as fy<sub><italic>j</italic></sub> for <italic>j =</italic> 1<italic>,… ,p</italic><sub>2</sub> and are characterized by their <inline-formula id="ID15"><alternatives>
<mml:math display="block" id="I15">
<mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mi>z</mml:mi><mml:msubsup>
<mml:mi>m</mml:mi>
<mml:mi>j</mml:mi>
<mml:mi>y</mml:mi>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq15.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula>
, retention time <inline-formula id="ID16"><alternatives>
<mml:math display="block" id="I16">
<mml:mi>R</mml:mi><mml:msubsup>
<mml:mi>T</mml:mi>
<mml:mi>j</mml:mi>
<mml:mi>y</mml:mi>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq16.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula>, and a vector of intensities across all samples <inline-formula id="ID17"><alternatives>
<mml:math display="block" id="I17">
<mml:msub>
<mml:mi>Y</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>∈</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>n</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq17.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula>.</p>
<p>Our goal is to identify pairs of indexes (<italic>i, j</italic>) with <italic>i</italic> ϵ {1<italic>, . . . , p</italic><sub>1</sub>} and <italic>j</italic> ϵ {1<italic>, . . ., p</italic><sub>2</sub>}, such that fx<sub><italic>i</italic></sub> and fy<sub><italic>j</italic></sub> correspond to the same metabolic feature. More formally, we aim to identify a <italic>matching matrix</italic> <inline-formula id="ID18"><alternatives>
<mml:math display="block" id="I18">
<mml:mrow>
<mml:mi>M</mml:mi><mml:mo>∈</mml:mo><mml:msup>
<mml:mrow>
<mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>×</mml:mo><mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq18.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> such that <italic>M<sub>ij</sub> =</italic> 1 if fx<sub><italic>i</italic></sub> and fy<sub><italic>j</italic></sub> correspond to the same feature, hereafter referred to as <italic>matched</italic> features. Otherwise, we set <italic>M<sub>ij</sub> =</italic> 0.</p>
<p>Because the <italic>m/z</italic> and RT values of metabolomic features are often noisy and subject to experimental bias, our matching algorithm leverages metabolite feature intensities <italic>X<sub>i</sub>,Y<sub>j</sub></italic> to produce accurate dataset alignments. The GromovMatcher method is based on the idea that signal intensities of the same metabolites measured in two different studies should exhibit similar correlation structures, in addition to having compatible <italic>m/z</italic> and RT values. Here we define the Pearson correlation for vectors <italic>u</italic>, <italic>v</italic>, ϵ ℝ<sup><italic>n</italic></sup> as</p>
<disp-formula id="FD1">
<alternatives>
<mml:math display="block" id="M1">
<mml:mi mathvariant="normal">corr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac>
<mml:mrow>
<mml:mo>〈</mml:mo><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mover accent="true">
<mml:mi>u</mml:mi>
<mml:mo>¯</mml:mo>
</mml:mover>
<mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>−</mml:mo><mml:mover accent="true">
<mml:mi>v</mml:mi>
<mml:mo>¯</mml:mo>
</mml:mover>
<mml:mo>〉</mml:mo></mml:mrow>
<mml:mrow>
<mml:mo>‖</mml:mo><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mover accent="true">
<mml:mi>u</mml:mi>
<mml:mo>¯</mml:mo>
</mml:mover>
<mml:mo>‖</mml:mo><mml:mo>‖</mml:mo><mml:mi>v</mml:mi><mml:mo>−</mml:mo><mml:mover accent="true">
<mml:mi>v</mml:mi>
<mml:mo>¯</mml:mo>
</mml:mover>
<mml:mo>‖</mml:mo></mml:mrow>
</mml:mfrac>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn1.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(1)</label>
</disp-formula>
<p>where we define</p>
<disp-formula id="FD2">
<alternatives>
<mml:math display="block" id="M2">
<mml:mover accent="true">
<mml:mi>u</mml:mi>
<mml:mo>¯</mml:mo>
</mml:mover>
<mml:mo>=</mml:mo><mml:mfrac>
<mml:mn>1</mml:mn>
<mml:mi>n</mml:mi>
</mml:mfrac>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mi>n</mml:mi>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>u</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle><mml:mo>,</mml:mo><mml:mo>‖</mml:mo><mml:mi>u</mml:mi><mml:mo>‖</mml:mo><mml:mo>=</mml:mo><mml:msqrt>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mi>n</mml:mi>
</mml:munderover>
<mml:mrow>
<mml:msubsup>
<mml:mi>u</mml:mi>
<mml:mi>i</mml:mi>
<mml:mn>2</mml:mn>
</mml:msubsup>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:msqrt>
<mml:mo>,</mml:mo><mml:mo>〈</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>〉</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mi>n</mml:mi>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>u</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>v</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn2.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(2)</label>
</disp-formula>
<p>as the mean value, Euclidean norm and inner product respectively. If measurements <italic>X<sub>i</sub>,Y<sub>j</sub></italic> correspond to the same underlying feature, and similarly, measurements <italic>X<sub>k</sub>,Y<sub>l</sub>,</italic> share the same an underlying feature, we expect that</p>
<disp-formula id="FD3">
<alternatives>
<mml:math display="block" id="M3">
<mml:mi mathvariant="normal">corr</mml:mi><mml:mfenced>
<mml:mrow>
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>,</mml:mo><mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>k</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfenced><mml:mo>≈</mml:mo><mml:mi mathvariant="normal">corr</mml:mi><mml:mfenced>
<mml:mrow>
<mml:msub>
<mml:mi>Y</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mo>,</mml:mo><mml:msub>
<mml:mi>Y</mml:mi>
<mml:mi>l</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfenced><mml:mo>.</mml:mo>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn3.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(3)</label>
</disp-formula>
<p>This idea that the feature intensities of shared metabolites have the same correlation structure in both datasets also holds more generally for distances, under a suitable choice of distance. For example, the correlation coefficient corr( <italic>u, V</italic>) can be turned into a dissimilarity metric by defining</p>
<disp-formula id="FD4">
<alternatives>
<mml:math display="block" id="M4">
<mml:msup>
<mml:mi>d</mml:mi>
<mml:mrow>
<mml:mi>cos</mml:mi></mml:mrow>
</mml:msup>
<mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msqrt>
<mml:mrow>
<mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi mathvariant="normal">corr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
</mml:msqrt>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn4.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(4)</label>
</disp-formula>
<p>commonly referred to as the <italic>cosine distance</italic>. Preservation of feature intensity correlations then trivially amounts to the preservation of cosine distances.</p>
<p>Another classical notion of distance between vectors <italic>u</italic>, <italic>v</italic>, ϵ ℝ<sup><italic>n</italic></sup> is the normalized Euclidean distance</p>
<disp-formula id="FD5">
<alternatives>
<mml:math display="block" id="M5">
<mml:msup>
<mml:mi>d</mml:mi>
<mml:mrow>
<mml:mtext>euc</mml:mtext></mml:mrow>
</mml:msup>
<mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac>
<mml:mn>1</mml:mn>
<mml:mrow>
<mml:msqrt>
<mml:mi>n</mml:mi>
</mml:msqrt>
</mml:mrow>
</mml:mfrac>
<mml:mo>‖</mml:mo><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mi>v</mml:mi><mml:mo>‖</mml:mo><mml:mo>=</mml:mo><mml:msqrt>
<mml:mrow>
<mml:mfrac>
<mml:mn>1</mml:mn>
<mml:mi>n</mml:mi>
</mml:mfrac>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mi>n</mml:mi>
</mml:munderover>
<mml:mrow>
<mml:msup>
<mml:mrow>
<mml:mfenced>
<mml:mrow>
<mml:msub>
<mml:mi>u</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>−</mml:mo><mml:msub>
<mml:mi>v</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfenced></mml:mrow>
<mml:mn>2</mml:mn>
</mml:msup>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:msqrt>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn5.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(5)</label>
</disp-formula>
<p>which is equal to the cosine distance (up to constants) when the vectors <italic>u, v</italic> are centered and scaled to have zero mean and a standard deviation of one. The Euclidean distance depends on the magnitude or mean intensity of metabolic features, and hence is a useful metric for matching metabolites as long as these mean feature intensities are reliably collected.</p>
<p>To summarize, the main tenant of GromovMatcher is that if measurements <italic>X<sub>l</sub>,Y<sub>j</sub></italic> correspond to the same feature and <italic>X<sub>k</sub>, Y<sub>l</sub>,</italic> correspond to the same feature, then for suitably chosen distances <inline-formula id="ID19"><alternatives>
<mml:math display="block" id="I19">
<mml:msub>
<mml:mi>d</mml:mi>
<mml:mi>x</mml:mi>
</mml:msub>
<mml:mo>:</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>n</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
<mml:mo>×</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>n</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
<mml:mo>→</mml:mo><mml:mi>ℝ</mml:mi>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq19.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> and <inline-formula id="ID20"><alternatives>
<mml:math display="block" id="I20">
<mml:msub>
<mml:mi>d</mml:mi>
<mml:mi>y</mml:mi>
</mml:msub>
<mml:mo>:</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>n</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
<mml:mo>×</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>n</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
<mml:mo>→</mml:mo><mml:mi>ℝ</mml:mi>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq20.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula>, these distances are preserved</p>
<disp-formula id="FD6">
<alternatives>
<mml:math display="block" id="M6">
<mml:msub>
<mml:mi>d</mml:mi>
<mml:mi>x</mml:mi>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>,</mml:mo><mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>k</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfenced><mml:mo>≈</mml:mo><mml:msub>
<mml:mi>d</mml:mi>
<mml:mi>y</mml:mi>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:msub>
<mml:mi>Y</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mo>,</mml:mo><mml:msub>
<mml:mi>Y</mml:mi>
<mml:mi>l</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfenced>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn6.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(6)</label>
</disp-formula>
<p>across both datasets. In this paper, the distances <italic>d<sub>x</sub>,d<sub>y</sub></italic> are taken to be the normalized Euclidean distances in (5). We take care to specify those experiments where the metabolic features <italic>X</italic> and <italic>Y</italic> are centered and scaled. In these cases, implicitly the Euclidean distance between normalized feature vectors becomes the cosine distance (4) between the original (unnormalized) feature vectors.</p>
<sec id="s4-1-1">
<title>Unbalanced Gromov–Wasserstein</title>
<p>The goal of GromovMatcher is to learn a matching matrix <inline-formula id="ID21"><alternatives>
<mml:math display="block" id="I21">
<mml:mrow><mml:mi>M</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq21.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> that gives an alignment between a subset of metabolites in both datasets. However, searching over the combinatorially large set of binary matrices would be an inefficient approach for dataset alignment. The mathematical framework of optimal transport <xref ref-type="bibr" rid="c30">Peyré et al. (2019)</xref> instead enlarges this space of binary matrices to the set of <italic>coupling matrices</italic> with real nonnegative entries <inline-formula id="ID22"><alternatives>
<mml:math display="block" id="I22">
<mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>×</mml:mo><mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq22.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula>. The entries ∏<sub><italic>ij</italic></sub> with large weights indicate that feature fx<sub><italic>i</italic></sub> in dataset 1 and feature fy<sub><italic>j</italic></sub> in dataset 2 are a likely match. Taking inspiration from (6), we minimize the following objective function</p>
<disp-formula id="FD7">
<alternatives>
<mml:math display="block" id="M7">
<mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow>
</mml:msub>
<mml:mfenced close="|" open="|">
<mml:mrow>
<mml:msub>
<mml:mi>d</mml:mi>
<mml:mi>x</mml:mi>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>,</mml:mo><mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>k</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfenced><mml:mo>−</mml:mo><mml:msub>
<mml:mi>d</mml:mi>
<mml:mi>y</mml:mi>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:msub>
<mml:mi>Y</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mo>,</mml:mo><mml:msub>
<mml:mi>Y</mml:mi>
<mml:mi>l</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mfenced>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn7.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(7)</label>
</disp-formula>
<p>to estimate the coupling matrix ∏.</p>
<p>A standard approach is to optimize this objective over all coupling matrices ∏ under exact marginal constraints <inline-formula id="ID24"><alternatives>
<mml:math display="block" id="I24">
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>=</mml:mo><mml:mi>Π</mml:mi><mml:msub>
<mml:mn>1</mml:mn>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo><mml:msub>
<mml:mi>Π</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
<mml:mo>=</mml:mo><mml:msup>
<mml:mi>Π</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq24.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula>. Here we define <bold>1</bold><sub><italic>n</italic></sub> is the ones vector of length <italic>n</italic>, and <inline-formula id="ID25"><alternatives>
<mml:math display="block" id="I25">
<mml:msubsup>
<mml:mfenced close="}" open="{">
<mml:mrow>
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfenced>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
<mml:mo>,</mml:mo><mml:msubsup>
<mml:mfenced close="}" open="{">
<mml:mrow>
<mml:msub>
<mml:mi>Y</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfenced>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq25.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> denote the column and row sums of the coupling matrix. Objective (7) under these exact marginal constraints defines a distance between the two sets of metabolic feature vectors <inline-formula id="ID26"><alternatives>
<mml:math display="block" id="I26">
<mml:msubsup>
<mml:mfenced close="}" open="{">
<mml:mrow>
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfenced>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
<mml:mo>,</mml:mo><mml:msubsup>
<mml:mfenced close="}" open="{">
<mml:mrow>
<mml:msub>
<mml:mi>Y</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfenced>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq26.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> known as the Gromov–Wasserstein distance <xref ref-type="bibr" rid="c25">Mémoli (2011)</xref>, a generalization of optimal transport to metric spaces. Note that for pairs <italic>X<sub>i</sub></italic>, <italic>Y<sub>j</sub></italic> and <italic>X<sub>k</sub></italic>, <italic>Y<sub>j</sub></italic><sub>,</sub> for which <italic>d<sub>x</sub></italic>(<italic>X<sub>i</sub></italic>, <italic>X<sub>k</sub></italic>) ≈ <italic>d<sub>y</sub></italic>(<italic>Y<sub>j</sub>,Y<sub>l</sub>),</italic> the entries ∏<sub><italic>lj</italic></sub>, ∏<sub><italic>kl</italic></sub>, are penalized less and hence matches between features fx<sub><italic>i</italic></sub>, fy<sub><italic>j</italic></sub> and features fx<sub><italic>k</italic></sub>, fy<sub><italic>l</italic></sub>, are more favored. In our optimization, we avoid enforcing exact marginal constraints on the marginal distributions ∏<bold>1</bold> <sub><italic>p</italic>2</sub> and ∏<bold>1</bold><sub><italic>p</italic>1</sub> of our coupling matrix as this would enforce that all metabolites in both datasets are matched (<xref ref-type="app" rid="app1">Appendix 1</xref>). However, without any marginal constraints on the coupling ∏, the objective function (7) is trivially minimized by ∏ = 0, leaving all metabolites in both datasets unmatched.</p>
<p>To account for this, we follow the ideas of unbalanced Gromov–Wasserstein (UGW) <xref ref-type="bibr" rid="c37">Sejourne et al. (2021)</xref> and add three regularization terms to our objective</p>
<disp-formula id="FD8">
<alternatives>
<mml:math display="block" id="M8">
<mml:mtable columnalign="left" equalrows="true" equalcolumns="true">
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msub>
<mml:mi mathvariant="script">L</mml:mi>
<mml:mrow>
<mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>+</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mo>−</mml:mo><mml:mi>ρ</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>⊗</mml:mo><mml:msub>
<mml:mi>Π</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>a</mml:mi></mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow/>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>+</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mi>ρ</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
<mml:mo>⊗</mml:mo><mml:msub>
<mml:mi>Π</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
<mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow/>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>+</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mi>ε</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:mo>⊗</mml:mo><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:msup>
<mml:mrow>
<mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
<mml:mrow>
<mml:mo>⊗</mml:mo><mml:mn>2</mml:mn></mml:mrow>
</mml:msup>
</mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn8.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(8)</label>
</disp-formula>
<p>where <italic>ρ,</italic> <italic>ϵ &gt;</italic> 0 and we define <italic>a</italic> = <bold>1</bold><sub><italic>p</italic>1</sub>, <italic>b</italic> = <bold>1</bold><sub><italic>p</italic>2</sub>. Here ⊗ denotes the Kronecker product. We define <italic>D</italic><sub>KL</sub> as the Kullback-Leibler (KL) divergence between two discrete distributions <inline-formula id="ID27"><alternatives>
<mml:math display="block" id="I27">
<mml:mi>μ</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mi>p</mml:mi>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq27.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> by</p>
<disp-formula id="FD9">
<alternatives>
<mml:math display="block" id="M9">
<mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mi>p</mml:mi>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>μ</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle><mml:mi>ln</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mi>μ</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>ν</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:mfenced><mml:mo>−</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mi>p</mml:mi>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>μ</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle><mml:mo>+</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mi>p</mml:mi>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>v</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn9.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(9)</label>
</disp-formula>
<p>which measures the closeness of probability distributions.</p>
<p>The first two regularization terms in (8) enforce that the row sums and column sums of the coupling matrix ∏ do not deviate too much from a uniform distribution, leading our optimization to match as many metabolic features as possible. The magnitude of the regularizer <italic>ρ</italic> roughly enforces the fraction of metabolites in both datasets that are matched where large ρ implies most metabolites are matched across datasets. The final regularization term <italic>ϵ</italic> in (8) controls the smoothness (entropy) of the coupling matrix ∏ where larger values of <italic>ϵ</italic> encourage ∏ to put uniform weights on many of its entries, leading to less precision in the metabolite matches. However, increasing <italic>ϵ</italic> also leads to better numerical stability and a significant speedup of the alternating minimization algorithm used to optimize the objective function (<xref ref-type="app" rid="app1">Appendix 1</xref>). In our implementation, we set <italic>ρ</italic> and <italic>ϵ</italic> to the lowest possible values under which our optimization converges, with <italic>ρ</italic> = 0.05 and <italic>ϵ</italic> = 0.005.</p>
<p>Our full optimization problem can now be written as</p>
<disp-formula id="FD10">
<alternatives>
<mml:math display="block" id="M10">
<mml:msub>
<mml:mtext>UGW</mml:mtext>
<mml:mrow>
<mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo><mml:msub>
<mml:mi>min</mml:mi>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>×</mml:mo><mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
</mml:msub>
<mml:msub>
<mml:mi mathvariant="script">L</mml:mi>
<mml:mrow>
<mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn10.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(10)</label>
</disp-formula>
<p>The UGW objective function is optimized through alternating minimization based on the code of <xref ref-type="bibr" rid="c37">Sejourne et al. (2021)</xref> using the unbalanced Sinkhorn algorithm <xref ref-type="bibr" rid="c4">Séjourné et al. (2019)</xref> from optimal transport (<xref ref-type="app" rid="app1">Appendix 1</xref>).</p>
</sec>
<sec id="s4-1-2">
<title>Constraint on <italic>m</italic>/<italic>z</italic> ratios</title>
<p>Matched metabolic features must have compatible <italic>m</italic> / <italic>z</italic> so we enforce that ∏ <sub><italic>ij</italic></sub> =0 when <inline-formula id="ID28"><alternatives>
<mml:math display="block" id="I28">
<mml:mfenced close="|" open="|">
<mml:mrow>
<mml:msubsup>
<mml:mi>m</mml:mi>
<mml:mi>i</mml:mi>
<mml:mi>x</mml:mi>
</mml:msubsup>
<mml:mo>−</mml:mo><mml:msubsup>
<mml:mi>m</mml:mi>
<mml:mi>j</mml:mi>
<mml:mi>y</mml:mi>
</mml:msubsup>
</mml:mrow>
</mml:mfenced><mml:mo>&gt;</mml:mo><mml:msub>
<mml:mi>m</mml:mi>
<mml:mrow>
<mml:mtext>gap </mml:mtext></mml:mrow>
</mml:msub>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq28.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> where <italic>m</italic> <sub>gap</sub> is a user-specified threshold. Based on prior literature <xref ref-type="bibr" rid="c24">Loftfield et al. (2021)</xref>; <xref ref-type="bibr" rid="c19">Hsu et al. (2019)</xref>; <xref ref-type="bibr" rid="c11">Climaco Pinto et al. (2022)</xref>; <xref ref-type="bibr" rid="c18">Habra et al. (2021)</xref>; <xref ref-type="bibr" rid="c9">Chen et al. (2021)</xref> we set <italic>m</italic><sub>gap</sub> = 0.01ppm. Note that <italic>m</italic> <sub>gap</sub> is not explicitly used in (10) but is rather enforced in each iteration of our alternating minimization algorithm for the UGW objective (<xref ref-type="app" rid="app1">Appendix 1</xref>).</p>
<p>Unlike the <italic>m</italic>/<italic>z</italic> ratios discussed above, RTs often exhibit a non-linear deviation (drift) between studies so we cannot enforce compatibility of RTs directly in our optimization. Instead, in the following step of our pipeline we ensure matched metabolite pairs have compatible RTs by estimating the drift function and subsequently using it to filter out metabolite matches whose RT values are inconsistent with the estimated drift.</p>
</sec>
<sec id="s4-1-3">
<title>Estimation of the RT drift and filtering</title>
<p>Estimating the drift between RTs of two studies is a crucial step in assessing the validity of metabolite matches and discarding those pairs which are incompatible with the estimated drift.</p>
<p>Let <inline-formula id="ID29"><alternatives>
<mml:math display="block" id="I29">
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>˜</mml:mo>
</mml:mover>
<mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>×</mml:mo><mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq29.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> be the minimizer of (10) obtained after optimization. We seek to estimate the RT drift function <inline-formula id="ID30"><alternatives>
<mml:math display="block" id="I30">
<mml:mi>f</mml:mi><mml:mo>:</mml:mo><mml:msub>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
</mml:msub>
<mml:mo>→</mml:mo><mml:msub>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
</mml:msub>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq30.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> which relates the retention times of matched features between the two studies. Namely, if feature fx<sub><italic>i</italic></sub> and feature fy<sub><italic>j</italic></sub> correspond to the same metabolic feature, then we must have that <inline-formula id="ID31"><alternatives>
<mml:math display="block" id="I31">
<mml:mi>R</mml:mi><mml:msubsup>
<mml:mi>T</mml:mi>
<mml:mi>j</mml:mi>
<mml:mi>y</mml:mi>
</mml:msubsup>
<mml:mo>≈</mml:mo><mml:mi>f</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mi>R</mml:mi><mml:msubsup>
<mml:mi>T</mml:mi>
<mml:mi>i</mml:mi>
<mml:mi>x</mml:mi>
</mml:msubsup>
</mml:mrow>
</mml:mfenced>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq31.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula>.</p>
<p>We propose to learn the drift <italic>f</italic> through the weighted spline regression</p>
<disp-formula id="FD11">
<alternatives>
<mml:math display="block" id="M11">
<mml:msub>
<mml:mi>min</mml:mi>
<mml:mrow>
<mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:msub>
<mml:mi mathvariant="script">B</mml:mi>
<mml:mrow>
<mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>˜</mml:mo>
</mml:mover>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:mfenced close="|" open="|">
<mml:mrow>
<mml:mi>f</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mi>R</mml:mi><mml:msubsup>
<mml:mi>T</mml:mi>
<mml:mi>i</mml:mi>
<mml:mi>x</mml:mi>
</mml:msubsup>
</mml:mrow>
</mml:mfenced><mml:mo>−</mml:mo><mml:mi>R</mml:mi><mml:msubsup>
<mml:mi>T</mml:mi>
<mml:mi>j</mml:mi>
<mml:mi>y</mml:mi>
</mml:msubsup>
</mml:mrow>
</mml:mfenced>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn11.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(11)</label>
</disp-formula>
<p>where <italic>B<sub>n</sub>,<sub>k</sub></italic> is the set of <italic>n</italic>-order B-splines with <italic>k</italic> knots. All pairs <inline-formula id="ID32"><alternatives>
<mml:math display="block" id="I32">
<mml:mfenced>
<mml:mrow>
<mml:mi>R</mml:mi><mml:msubsup>
<mml:mi>T</mml:mi>
<mml:mi>i</mml:mi>
<mml:mi>x</mml:mi>
</mml:msubsup>
<mml:mo>,</mml:mo><mml:mi>R</mml:mi><mml:msubsup>
<mml:mi>T</mml:mi>
<mml:mi>j</mml:mi>
<mml:mi>y</mml:mi>
</mml:msubsup>
</mml:mrow>
</mml:mfenced>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq32.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> in objective (11) are weighted by the coefficients of <inline-formula id="ID33"><alternatives>
<mml:math display="block" id="I33">
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>˜</mml:mo>
</mml:mover>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq33.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> so that larger weights are given to pairs identified with high confidence in the first step of our procedure. The order of the B-splines was set to <italic>n</italic> = 3 by default, while the number of knots <italic>k</italic> was selected by 10-fold cross-validation.</p>
<p>Pairs identified as incompatible with the estimated RT drift are then discarded from the coupling matrix. To do this, we first take the estimated RT drift <inline-formula id="ID34"><alternatives>
<mml:math display="block" id="I34">
<mml:mover accent="true">
<mml:mi>f</mml:mi>
<mml:mo>^</mml:mo>
</mml:mover>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq34.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula>
, and the set of pairs <inline-formula id="ID35"><alternatives>
<mml:math display="block" id="I35">
<mml:mi>S</mml:mi><mml:mo>=</mml:mo><mml:mfenced close="}" open="{">
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>:</mml:mo><mml:msub>
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>˜</mml:mo>
</mml:mover>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
<mml:mo>≠</mml:mo><mml:mn>0</mml:mn></mml:mrow>
</mml:mfenced>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq35.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> recovered in <inline-formula id="ID36"><alternatives>
<mml:math display="block" id="I36">
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>˜</mml:mo>
</mml:mover>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq36.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula>. We then define the residual associated with (<italic>i, j</italic>) ϵ <italic>s</italic> as</p>
<disp-formula id="FD12">
<alternatives>
<mml:math display="block" id="M12">
<mml:msub>
<mml:mi>r</mml:mi>
<mml:mover accent="true">
<mml:mi>f</mml:mi>
<mml:mo>^</mml:mo>
</mml:mover>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfenced close="|" open="|">
<mml:mrow>
<mml:mover accent="true">
<mml:mi>f</mml:mi>
<mml:mo>^</mml:mo>
</mml:mover>
<mml:mfenced>
<mml:mrow>
<mml:mi>R</mml:mi><mml:msubsup>
<mml:mi>T</mml:mi>
<mml:mi>i</mml:mi>
<mml:mi>x</mml:mi>
</mml:msubsup>
</mml:mrow>
</mml:mfenced><mml:mo>−</mml:mo><mml:mi>R</mml:mi><mml:msubsup>
<mml:mi>T</mml:mi>
<mml:mi>j</mml:mi>
<mml:mi>y</mml:mi>
</mml:msubsup>
</mml:mrow>
</mml:mfenced><mml:mo>.</mml:mo>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn12.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(12)</label>
</disp-formula>
<p>The 95% prediction interval and the median absolute deviation (MAD) of these residuals are given by</p>
<disp-formula id="FD13">
<alternatives>
<mml:math display="block" id="M13">
<mml:mtable columnalign="left" equalrows="true" equalcolumns="true">
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mtext>PI</mml:mtext></mml:mrow>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>=</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mn>1.96</mml:mn><mml:mo>×</mml:mo><mml:mi mathvariant="normal">std</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfenced close="}" open="{">
<mml:mrow>
<mml:msub>
<mml:mi>r</mml:mi>
<mml:mover accent="true">
<mml:mi>f</mml:mi>
<mml:mo>^</mml:mo>
</mml:mover>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mtext>MAD</mml:mtext></mml:mrow>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>=</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mi mathvariant="normal">median</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfenced close="}" open="{">
<mml:mrow>
<mml:mfenced close="|" open="|">
<mml:mrow>
<mml:msub>
<mml:mi>r</mml:mi>
<mml:mover accent="true">
<mml:mi>f</mml:mi>
<mml:mo>^</mml:mo>
</mml:mover>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msub>
<mml:mi>μ</mml:mi>
<mml:mi>r</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfenced><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msub>
<mml:mi>μ</mml:mi>
<mml:mi>r</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>=</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mi mathvariant="normal">median</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfenced close="}" open="{">
<mml:mrow>
<mml:mfenced close="|" open="|">
<mml:mrow>
<mml:msub>
<mml:mi>r</mml:mi>
<mml:mover accent="true">
<mml:mi>f</mml:mi>
<mml:mo>^</mml:mo>
</mml:mover>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
</mml:mfenced><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn13.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(13)</label>
</disp-formula>
<p>where <bold>|</bold><italic>S</italic><bold>|</bold> is the size of <italic>S</italic> and the functions std and median denote the standard deviation and median respectively. Similar to the approach in <xref ref-type="bibr" rid="c11">Climaco Pinto et al. (2022)</xref>, we create a new filtered coupling matrix <inline-formula id="ID37"><alternatives>
<mml:math display="block" id="I37">
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>^</mml:mo>
</mml:mover>
<mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>×</mml:mo><mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq37.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> given by</p>
<disp-formula id="FD14">
<alternatives>
<mml:math display="block" id="M14">
<mml:msub>
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>^</mml:mo>
</mml:mover>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo><mml:mfenced open="{">
<mml:mrow>
<mml:mtable columnalign="left" equalrows="true" equalcolumns="true">
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msub>
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>^</mml:mo>
</mml:mover>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mtext> if </mml:mtext><mml:msub>
<mml:mi>r</mml:mi>
<mml:mover accent="true">
<mml:mi>f</mml:mi>
<mml:mo>^</mml:mo>
</mml:mover>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&lt;</mml:mo><mml:msub>
<mml:mi>μ</mml:mi>
<mml:mi>r</mml:mi>
</mml:msub>
<mml:mo>+</mml:mo><mml:msub>
<mml:mi>r</mml:mi>
<mml:mrow>
<mml:mtext>thresh </mml:mtext></mml:mrow>
</mml:msub>
<mml:mo>.</mml:mo></mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mn>0</mml:mn>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mtext> otherwise </mml:mtext></mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable></mml:mrow>
</mml:mfenced>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn14.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(14)</label>
</disp-formula>
<p>where <italic>r</italic><sub>thresh</sub> is a given filtering threshold. Following <xref ref-type="bibr" rid="c18">Habra et al. (2021)</xref>, the estimation and outlier detection step can be repeated for multiple iterations, to remove pairs that deviate significantly from the estimated drift and improve the robustness of the drift estimation. In our main algorithm, we use two preliminary iterations where estimate the RT drift and discard outliers outside of the 95% prediction interval by setting <italic>r</italic><sub>thresh</sub> = PI. We the re-estimate the drift and perform a final filtering step with the more stringent MAD by setting <italic>r</italic><sub>thresh</sub> = 2 × MAD.</p>
<p>At this stage, it is possible for <inline-formula id="ID38"><alternatives>
<mml:math display="block" id="I38">
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>˜</mml:mo>
</mml:mover>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq38.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> to still contain coefficients of very small magnitude. As an optional postprocessing step, we discard these coefficients by setting all entries smaller than <inline-formula id="ID39"><alternatives>
<mml:math display="block" id="I39">
<mml:mi>τ</mml:mi><mml:mi>max</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>^</mml:mo>
</mml:mover>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq39.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> to zero, for some user-defined <italic>τ</italic> ϵ [0,1]. Lastly, a feature from either study could have multiple possible matches, since <inline-formula id="ID40"><alternatives>
<mml:math display="block" id="I40">
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>˜</mml:mo>
</mml:mover>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq40.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> can have more than one non-zero coefficient per row or column. Although reporting multiple matches can be helpful in an exploratory context, for the sake of simplicity in our analysis, the final output of GromovMatcher returns a one-to-one matching, as we only keep those metabolite pairs (<italic>i,j</italic>) where the entry <inline-formula id="ID41"><alternatives>
<mml:math display="block" id="I41">
<mml:msub>
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>^</mml:mo>
</mml:mover>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq41.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> is largest in its corresponding row and column. All nonzero entries of <inline-formula id="ID42"><alternatives>
<mml:math display="block" id="I42">
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>˜</mml:mo>
</mml:mover>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq42.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> which do not satisfy this criterion are set to zero. Finally, we convert <inline-formula id="ID43"><alternatives>
<mml:math display="block" id="I43">
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>˜</mml:mo>
</mml:mover>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq43.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> into a binary matching matrix <inline-formula id="ID44"><alternatives>
<mml:math display="block" id="I44">
<mml:mrow><mml:mi>M</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq44.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> with ones in place of its nonzero entries and this final output is returned to the user.</p>
<p>As a naming convention, we use the abbreviation GM for our GromovMatcher method, and use the abbreviation GMT when running GromovMatcher with the optional <italic>τ</italic> -thresholding step with <italic>τ</italic> = 0.3.</p>
</sec>
</sec>
<sec id="s4-2">
<title>Metrics for dataset alignment</title>
<p>Every alignment method studied in this paper returns a binary <italic>partial matching</italic> matrix <inline-formula id="ID45"><alternatives>
<mml:math display="block" id="I45">
<mml:mrow><mml:mi>M</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq45.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> which has at most one nonzero entry in each row and column. Specifically, <italic>M<sub>ij</sub></italic> = 1 if metabolic features <italic>i</italic> and <italic>j</italic> in both datasets correspond to each other and <italic>M<sub>ij</sub></italic> = 0 otherwise. In our simulated experiments, we compare the partial matching <italic>M</italic> to a known ground-truth partial matching matrix <inline-formula id="ID46"><alternatives>
<mml:math display="block" id="I46">
<mml:mrow><mml:mi>M</mml:mi><mml:mo>*</mml:mo><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq46.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula>.</p>
<p>To do this, we first compute the number of true positives, false positives, true negatives, and false negatives as</p>
<disp-formula id="FD15">
<alternatives>
<mml:math display="block" id="M15">
<mml:mtable columnalign="left">
<mml:mtr>
<mml:mtd>
<mml:mtext>TP</mml:mtext><mml:mo>=</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>M</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msubsup>
<mml:mi>M</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
<mml:mo>*</mml:mo>
</mml:msubsup>
<mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
</mml:msub>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mtext>FP</mml:mtext><mml:mo>=</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>M</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msubsup>
<mml:mi>M</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
<mml:mo>*</mml:mo>
</mml:msubsup>
<mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow>
</mml:msub>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mtext>TN</mml:mtext><mml:mo>=</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>M</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msubsup>
<mml:mi>M</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
<mml:mo>*</mml:mo>
</mml:msubsup>
<mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow>
</mml:msub>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mtext>FN</mml:mtext><mml:mo>=</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>M</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msubsup>
<mml:mi>M</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
<mml:mo>*</mml:mo>
</mml:msubsup>
<mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
</mml:msub>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn15.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(15)</label>
</disp-formula>
<p>where <bold>1</bold> denotes the indicator function. Then we use these values to compute the precision and recall as</p>
<disp-formula id="FD16">
<alternatives>
<mml:math display="block" id="M16">
<mml:mtable columnalign="left" equalrows="true" equalcolumns="true">
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mtext>Precision</mml:mtext></mml:mrow>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>=</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:mtext>TP</mml:mtext></mml:mrow>
<mml:mrow>
<mml:mtext>TP+FP</mml:mtext></mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mtext>Recall</mml:mtext></mml:mrow>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>=</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:mtext>TP</mml:mtext></mml:mrow>
<mml:mrow>
<mml:mtext>TP</mml:mtext><mml:mo>+</mml:mo><mml:mtext>FN</mml:mtext></mml:mrow>
</mml:mfrac>
<mml:mo>.</mml:mo></mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn16.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(16)</label>
</disp-formula>
<p>Precision measures the fraction of correctly found matches out of all discovered metabolite matches, while recall, also know as sensitivity, measures the fraction of correctly matched pairs out of all truly matched pairs. These two statistics can be summarized into one metric called the F1-score by taking their harmonic mean</p>
<disp-formula id="FD17">
<alternatives>
<mml:math display="block" id="M17">
<mml:mtext>F</mml:mtext><mml:mn>1</mml:mn><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>⋅</mml:mo><mml:mfrac>
<mml:mrow>
<mml:mtext> Precision </mml:mtext><mml:mo>⋅</mml:mo><mml:mtext> Recall </mml:mtext></mml:mrow>
<mml:mrow>
<mml:mtext> Precision </mml:mtext><mml:mo>+</mml:mo><mml:mtext> Recall </mml:mtext></mml:mrow>
</mml:mfrac>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn17.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(17)</label>
</disp-formula>
<p>These three metrics, precision, recall, and the F1-score, are used throughout the paper to assess the performance of dataset alignment methods, both on simulated data where the ground-truth matching is known, and on the validation subset in EPIC, using results from the manual examination as the ground-truth benchmark.</p>
</sec>
<sec id="s4-3">
<title>Validation on simulated data</title>
<p>To assess the performance of GromovMatcher and compare it to existing dataset alignment methods, we simulate realistic pairs of untargeted metabolomics feature with known ground-truth matchings. This allows us to analyze the dependence of alignment methods on the number of shared metabolites, dataset noise level, and feature intensity centering and scaling.</p>
<sec id="s4-3-1">
<title>Dataset generation</title>
<p>Our pairs of synthetic feature tables are generated from one real untargeted metabolomics study of 500 newborns within the EXPOsOMICS project, which uses reversed phase liquid chromatography-quadrupole time-of-flight mass spectrometry (UHPLC-QTOF-MS) system in positive ion mode <xref ref-type="bibr" rid="c2">Alfano et al. (2020)</xref>. The original dataset is first preprocessed following the procedure detailed in Alfano et al. <xref ref-type="bibr" rid="c2">Alfano et al. (2020)</xref>, resulting in <italic>p</italic> = 4,712 features measured in <italic>n</italic> = 499 samples available for subsequent analysis. Features and samples from the original study are then divided into two feature tables of respective size (<italic>n</italic><sub>1</sub> <italic>,p</italic><sub>1</sub>) and (<italic>n</italic><sub>2</sub><italic>,p</italic><sub>2</sub>), with <italic>n</italic><sub>1</sub> + <italic>n</italic><sub>2</sub> = <italic>n</italic> and <italic>p</italic><sub>1</sub> <italic>,p</italic><sub>2</sub> ≤ <italic>p</italic>. In order to do this, <italic>n</italic><sub>1</sub> = <bold>[</bold><italic>n</italic>/2] randomly chosen samples from the original study are placed into dataset 1 and the remaining <italic>n</italic><sub>2</sub> = [<italic>n</italic>/2] samples from the original study are placed into dataset 2. Here [.] and [.] denote integer floor and ceiling functions. The features of the original study are randomly assigned to dataset 1, dataset 2, or both, allowing the resulting studies to have both common and study-specific features (<xref ref-type="fig" rid="fig2">Fig. 2</xref>). Specifically, for a fixed overlap parameter <italic>λ</italic> ϵ [0,1], we assign a random subset of ≈ <italic>λp</italic> features into both dataset 1 and dataset 2 while the remaining ≈ (1 – <italic>λp</italic>) features are divided equally between the two studies such that <italic>p</italic><sub>1</sub> = <italic>p</italic><sub>2</sub>. We choose <italic>λ</italic> ϵ {0.25, 0.5, 0.75} corresponding to low, medium and high overlap. For more detailed information on how the dataset split is performed and for additional validation experiments with unbalanced dataset splits (e.g. <italic>n</italic><sub>1</sub> ≠ <italic>n</italic><sub>2</sub>, <italic>p</italic><sub>1</sub> ≠ <italic>p</italic><sub>2</sub>) we refer the reader to <xref ref-type="app" rid="app3">Appendix 3</xref>.</p>
<p>After generating a pair of studies, random noise is added to the <italic>m</italic>/<italic>z</italic>, RT and intensity levels of features in dataset 2 to mimic variations in data acquisition across two different experiments. The noise added to each <italic>m</italic>/<italic>z</italic> value in study 2 is sampled from a uniform distribution on the interval [–<italic>σ</italic><sub>M</sub>, <italic>σ</italic><sub>M</sub>] with <italic>σ</italic><sub>M</sub> = 0.01 <xref ref-type="bibr" rid="c11">Climaco Pinto et al. (2022)</xref>. The RTs of dataset 2 are first deviated by the function <inline-formula id="ID47"><alternatives>
<mml:math display="block" id="I47">
<mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1.1</mml:mn><mml:mi>x</mml:mi><mml:mo>+</mml:mo><mml:mn>1.3</mml:mn><mml:mi>sin</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>1.2</mml:mn><mml:msqrt>
<mml:mi>x</mml:mi>
</mml:msqrt>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq47.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula>
, corresponding to a systematic inter-dataset drift <xref ref-type="bibr" rid="c18">Habra et al. (2021)</xref>; <xref ref-type="bibr" rid="c11">Climaco Pinto et al. (2022)</xref>; <xref ref-type="bibr" rid="c8">Brunius et al. (2016)</xref>. A uniformly distributed noise on the interval [–<italic>σ</italic><sub>RT</sub>, <italic>σ</italic><sub>RT</sub>] is added to the deviated RTs of dataset 2, with <italic>σ</italic><sub>RT</sub> ϵ {0.2, 0.5, 1} (in minutes) corresponding to low, moderate and high variations <xref ref-type="bibr" rid="c11">Climaco Pinto et al. (2022)</xref>; <xref ref-type="bibr" rid="c18">Habra et al. (2021)</xref>; <xref ref-type="bibr" rid="c45">Vaughan et al. (2012)</xref>. Finally, we add a Gaussian noise <inline-formula id="ID48"><alternatives>
<mml:math display="block" id="I48">
<mml:mi mathvariant="script">N</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:msubsup>
<mml:mi>σ</mml:mi>
<mml:mrow>
<mml:mtext>FI</mml:mtext></mml:mrow>
<mml:mn>2</mml:mn>
</mml:msubsup>
</mml:mrow>
</mml:mfenced>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq48.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> to the feature intensities of both studies where <italic>σ<sub>FI</sub></italic> is the scalar variance of the noise. This noise perturbs the correlation matrices of dataset 1 and dataset 2, making matching based on feature intensity correlations more challenging. We vary <italic>σ<sub>FI</sub></italic> over the set of values {0.1, 0.5, 1}.</p>
<p>Given this data generation process, we test the performance of the four alignment methods (M2S, metabCombiner, GM, and GMT) under the parameter settings described below.</p>
</sec>
<sec id="s4-3-2">
<title>Dependence on overlap</title>
<p>We first assess how the performance of the four methods is affected by the number of metabolic features shared in both datasets. For each value of <italic>λ</italic> = 0.25, 0.5, 0.75 (low, medium and high overlap), we randomly generate 20 pairs of datasets with noise on the <italic>m/z</italic>, RT and feature intensities set to <italic>σ</italic><sub>M</sub> = 0.01 <italic>, σ</italic><sub>RT</sub> = 0<italic>.5, σ</italic><sub>FI</sub> = 0.5. The precision and recall of each method at low, medium, and high overlap is recorded for each of the repetitions.</p>
</sec>
<sec id="s4-3-3">
<title>Noise robustness</title>
<p>Next we test the robustness to noise of each method by fixing the metabolite overlap fraction at <italic>λ</italic> = 0.5 and generating 20 random pairs of datasets at low (<italic>σ</italic><sub>RT</sub> = 0.2<italic>, σ</italic><sub>FI</sub> = 0.1), medium (<italic>σ</italic><sub>RT</sub> = 0.5<italic>, σ</italic><sub>FI</sub> = 0.5), and high <italic>σ</italic><sub>RT</sub> = 1<italic>, σ</italic><sub>FI</sub> = 1) noise levels. Similarly, the precision and recall of each method is saved for each noise level across the 20 repetitions.</p>
<sec id="s4-3-4">
<title>Feature intensity centering and scaling</title>
<p>In order to test how all four methods are affected when the mean feature intensities and variance are not comparable across studies, we assess their performance when the feature intensities in both studies are mean centered and standardized to have unit standard deviation across all samples. We again generate 20 random pairs of datasets with medium overlap and medium noise, normalize the feature intensities in each pair of datasets, and compute the precision and recall of each method across the 20 repetitions.</p>
</sec>
</sec>
<sec id="s4-4">
<title>EPIC data</title>
<p>We also evaluate our method on data collected within the European Prospective Investigation into Cancer and Nutrition (EPIC) cohort, an ongoing multicentric prospective study with over 500,000 participants recruited between 1992 and 2000 from 23 centers in 10 European countries, and who provided blood samples at the inclusion in the study <xref ref-type="bibr" rid="c34">Riboli et al. (2002)</xref>. In EPIC, untargeted metabolomics data were successively acquired in several studies nested within the full cohort.</p>
<p>In the present work, we use untargeted metabolomics data acquired in three studies nested in EPIC, namely the EPIC cross-sectional (CS) study <xref ref-type="bibr" rid="c39">Slimani et al. (2003)</xref> and two matched case-control studies nested within EPIC, on hepatocellular carcinoma (HCC) <xref ref-type="bibr" rid="c42">Stepien et al. (2016</xref>, <xref ref-type="bibr" rid="c24">2021</xref>) and pancreatic cancer (PC) <xref ref-type="bibr" rid="c15">Gasull et al. (2019)</xref>, respectively. All data were acquired at the International Agency for Research on Cancer, making use of the same plateform and methodology: UHPLC-QTOF-MS (1290 Binary Liquid chromatography system, 6550 quadrupole time-of-flight mass spectrometer, Agilent Technologies, Santa Clara, CA) using reversed phase chromatography and electrospray ionization in both positive and negative ionization mode.</p>
<p>In a previous analysis aiming at identifying biomarkers of habitual alcohol intake in EPIC, the 205 features associated with alcohol intake in the CS study were manually matched to features in both the HCC and PC studies <xref ref-type="bibr" rid="c24">Loftfield et al. (2021)</xref>. The results from this manual matching are presented in <xref ref-type="table" rid="tbl1">Table 1</xref>. This matching process was based on the proximity of <italic>m/z</italic> and RT, using a matching tolerance of ±15 ppm and ±0.2 min, and on the comparison of the chromatograms of features in a quality control samples from both studies.</p>
<sec id="s4-4-1">
<title>Preprocessing</title>
<p>In the HCC and PC studies, samples corresponding to participants selected as cases in either study (i.e., participants selected in the study because of a diagnosis of incident HCC or PC) are excluded. Indeed, the metabolic profiles of participants selected as controls are expected to be more comparable across studies than those of cases, especially if certain features are associated with the risk of HCC or PC. Apart from this additional exclusion criterion, the untargeted metabolomics data of each study is pre-processed following the steps described in Loftfield et al. <xref ref-type="bibr" rid="c24">Loftfield et al. (2021)</xref>, to eliminate unreliable features and samples, impute missing values and minimize technical variations in the feature intensity levels.</p>
</sec>
<sec id="s4-4-2">
<title>Alcohol biomarker discovery</title>
<p>Loftfield et al. <xref ref-type="bibr" rid="c24">Loftfield et al. (2021)</xref> used the untargeted metabolomics data of the CS, HCC and PC studies in their alcohol biomarker discovery study in EPIC, without being able to automatically match their common features and pool the 3 datasets. Instead, the authors first implemented a discovery step, examining the relationship between alcohol intake and metabolic features measured in the CS study and accounting for multiple testing using a false discovery rate (FDR) correction. This led to the identification of 205 features significantly associated with alcohol intake in the CS study. In order to gauge the robustness of these associations, the authors of Loftfield et al. <xref ref-type="bibr" rid="c24">Loftfield et al. (2021)</xref> then implemented a validation step using data from two independent test sets. The first test set was composed of data from the EPIC HCC and PC studies, while the second was derived from the Finnish Alpha-Tocopherol, Beta-Carotene Cancer Prevention (ATBC) study. The 205 features identified in the discovery step were manually investigated for matches in the EPIC test set, and 67 features were effectively matched to features in the HCC or PC study, or both. The authors then evaluated the association between alcohol intake and those 67 features, applying a more conservative Bonferroni correction to determine whether the association with alcohol intake persisted. This step led to the identification of 10 features associated with alcohol intake (Extended Data <xref ref-type="fig" rid="fig5">Fig. 5a</xref>). The second test set was then used to determine whether those 10 features were also significant in the ATBC population, which was indeed the case.</p>
<p>To conduct a more in-depth investigation of the matchings produced by the GromovMatcher algorithm, we build upon the analysis previously conducted by Loftfield et al. <xref ref-type="bibr" rid="c24">Loftfield et al. (2021)</xref> by exploring potential alcohol biomarkers using a pooled dataset created from the CS, HCC, and PC studies. Our goal is to assess whether pooling the data leads to increased statistical power and allows for the detection of more features associated with alcohol intake. Namely, we generate the pooled dataset by aligning a chosen reference dataset (CS study) with the HCC and PC studies successively using the GM matchings computed in both positive and negative mode (Methods and Extended Data <xref ref-type="fig" rid="fig5">Fig. 5b</xref>). Features that are not detected in either the HCC or PC studies are designated as ‘missing’ in the final pooled dataset for samples belonging to the respective studies where the feature is not found.</p>
<p>To evaluate the potential relationship between alcohol consumption and pooled metabolic features, we use a methodology akin to that of Loftfield et al. <xref ref-type="bibr" rid="c24">Loftfield et al. (2021)</xref>. The self-reported alcohol intake data is adjusted for various demographic and lifestyle factors (age, sex, country, body-mass-index, smoking status and intensity, coffee consumption, and study) via the residual method in linear regression models. Feature intensities are also adjusted for technical variables (plate number and position within the plate) via linear mixed effect models. The significance of the association is assessed using correlation coefficients computed from the residuals for both selfreported alcohol intake and feature intensities. P-values are corrected using either false discovery rate (FDR) or Bonferroni correction to account for multiple testing. Corrected p-values less than 5% are considered significant.</p>
</sec>
</sec>
</sec>
</sec>
</body>
<back>
<ack>
<title>Acknowledgments</title>
<p>We thank Jörn Dunkel for helpful advice on our manuscript. We acknowledge the MIT Super-Cloud and Lincoln Laboratory Supercomputing Center <xref ref-type="bibr" rid="c33">Reuther et al. (2018)</xref> for providing HPC resources that have contributed to the research results reported within this paper. G.S. acknowledges support through a National Science Foundation Graduate Research Fellowship under Grant No. 1745302. P.R. is supported by NSF grants IIS-1838071, DMS-2022448, and CCF-2106377. We are grateful to the Principal Investigators of each of the EPIC centers for sharing the data for our experimental application.</p>
</ack>
<sec id="s5" sec-type="data-availability">
<title>Data availability</title>
<p>The LC-MS data used to generate our simulated validation experiments is located at the bottom of the “Files” section in <ext-link ext-link-type="uri" xlink:href="https://www.ebi.ac.uk/metabolights/MTBLS1684/files">https://www.ebi.ac.uk/metabolights/MTBLS1684/files</ext-link> under filename ‘metabolomics_normalized_data.xlsx’. The EPIC data is not publicly available, but access requests can be submitted to the Steering Committee <ext-link ext-link-type="uri" xlink:href="https://epic.iarc.fr/access/index.php">https://epic.iarc.fr/access/index.php</ext-link>.</p>
<p>All code for the data preprocessing, figure generation, as well as the GromovMatcher algorithm and its comparison to other methods are available at: <ext-link ext-link-type="uri" xlink:href="https://github.com/sgstepaniants/GromovMatcher">https://github.com/sgstepaniants/GromovMatcher</ext-link>. Instructions and examples for how to run the GromovMatcher method are provided in the Github repository. The metabCombiner implementation written by the original authors was taken from their Github codebase: <ext-link ext-link-type="uri" xlink:href="https://github.com/hhabra/metabCombiner">https://github.com/hhabra/metabCombiner</ext-link>. The M2S implementation of the original authors was taken from their Github codebase: <ext-link ext-link-type="uri" xlink:href="https://github.com/rjdossan/M2S">https://github.com/rjdossan/M2S</ext-link>.</p>
</sec>
<sec id="s6">
<title>Author contributions</title>
<p>M.B. and G.S. contributed equally and are joint first authors. P.R. and V.V. conceived the project. M.B. and G.S. developed the algorithms as well as performed the comparison to other alignment methods. P.K.R. analyzed and postprocessed the EPIC data and the analysis of our method on this data was performed by M.B. The manuscript was prepared by M.B., G.S., P.K.R, P.R., and V.V.</p>
</sec>
<sec id="s7">
<title>Materials and Correspondence</title>
<p>All correspondence and material requests should be addressed to V.V.</p>
</sec>
<sec id="s8">
<title>IARC disclaimer</title>
<p>Where authors are identified as personnel of the International Agency for Research on Cancer/World Health Organization, the authors alone are responsible for the views expressed in this article and they do not necessarily represent the decisions, policy, or views of the International Agency for Research on Cancer/World Health Organization.</p>
</sec>
<ref-list>
<title>References</title>
<ref id="c1"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>A</given-names> <surname>Agresti</surname></string-name>, <string-name><given-names>BA.</given-names> <surname>Coull</surname></string-name></person-group> <article-title>Approximate is better than “exact” for interval estimation of binomial proportions.</article-title> <source>Am Stat</source>. <year>1998</year>; <volume>52</volume>(<issue>2</issue>):<fpage>119</fpage>–<lpage>126</lpage>. doi: <pub-id pub-id-type="doi">10.2307/2685469</pub-id>.</mixed-citation></ref>
<ref id="c2"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>R</given-names> <surname>Alfano</surname></string-name>, <string-name><given-names>M</given-names> <surname>Chadeau-Hyam</surname></string-name>, <string-name><given-names>A</given-names> <surname>Ghantous</surname></string-name>, <string-name><given-names>P</given-names> <surname>Keski-Rahkonen</surname></string-name>, <string-name><given-names>L</given-names> <surname>Chatzi</surname></string-name>, <string-name><given-names>AE</given-names> <surname>Perez</surname></string-name>, <string-name><given-names>Z</given-names> <surname>Herceg</surname></string-name>, <string-name><given-names>M</given-names> <surname>Kogevinas</surname></string-name>, <string-name><surname>de Kok</surname> <given-names>TM</given-names></string-name>, <string-name><given-names>TS</given-names> <surname>Nawrot</surname></string-name>, <string-name><given-names>A</given-names> <surname>Novoloaca</surname></string-name>, <string-name><given-names>CJ</given-names> <surname>Patel</surname></string-name>, <string-name><given-names>C</given-names> <surname>Pizzi</surname></string-name>, <string-name><given-names>N</given-names> <surname>Robinot</surname></string-name>, <string-name><given-names>F</given-names> <surname>Rusconi</surname></string-name>, <string-name><given-names>A</given-names> <surname>Scalbert</surname></string-name>, <string-name><given-names>J</given-names> <surname>Sunyer</surname></string-name>, <string-name><given-names>R</given-names> <surname>Vermeulen</surname></string-name>, <string-name><given-names>M</given-names> <surname>Vrijheid</surname></string-name>, <string-name><given-names>P</given-names> <surname>Vineis</surname></string-name></person-group>, <etal>et al.</etal> <article-title>A multi-omic analysis of birthweight in newborn cord blood reveals new underlying mechanisms related to cholesterol metabolism.</article-title> <source>Metabolism</source>. <year>2020</year>; <volume>110</volume>:<fpage>154</fpage>–<lpage>292</lpage>. doi: <pub-id pub-id-type="doi">10.1016/j.metabol.2020.154292</pub-id></mixed-citation></ref>
<ref id="c3"><mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><given-names>D</given-names> <surname>Alvarez-Melis</surname></string-name>, <string-name><given-names>T.</given-names> <surname>Jaakkola</surname></string-name></person-group> <chapter-title>Gromov-Wasserstein Alignment of Word Embedding Spaces.</chapter-title> <source>In: EMNLP Brussels</source>, <publisher-loc>Belgium</publisher-loc>: <publisher-name>Association for Computational Linguistics;</publisher-name> <year>2018</year>. p. <fpage>1881</fpage>–<lpage>1890</lpage>. <ext-link ext-link-type="uri" xlink:href="https://aclanthology.org/D18-1214">https://aclanthology.org/D18-1214</ext-link>, doi: <pub-id pub-id-type="doi">10.18653/v1/D18-1214.</pub-id></mixed-citation></ref>
<ref id="c4"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>D</given-names> <surname>Alvarez-Melis</surname></string-name>, <string-name><given-names>S</given-names> <surname>Jegelka</surname></string-name>, <string-name><given-names>TS.</given-names> <surname>Jaakkola</surname></string-name></person-group> <article-title>Towards optimal transport with global invariances.</article-title> <source>In: AISTATS PMLR;</source> <year>2019</year>. p. <fpage>1870</fpage>–<lpage>1879</lpage>. <ext-link ext-link-type="uri" xlink:href="https://proceedings.mlr.press/v89/alvarez-melis19a.html">proceedings.mlr.press/v89/alvarez-melis19a.html</ext-link>.</mixed-citation></ref>
<ref id="c5"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bedia</surname> <given-names>C.</given-names></string-name></person-group> <article-title>Metabolomics in environmental toxicology: Applications and challenges</article-title>. <source>Trends Environ Anal Chem.</source> <year>2022</year>; <volume>34</volume>:<fpage>e00161</fpage>. doi: <pub-id pub-id-type="doi">https://doi.org/10.1016/j.teac.2022.e00161</pub-id>.</mixed-citation></ref>
<ref id="c6"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>F</given-names> <surname>Beier</surname></string-name>, <string-name><given-names>R</given-names> <surname>Beinert</surname></string-name>, <string-name><given-names>G.</given-names> <surname>Steidl</surname></string-name></person-group> <article-title>Multi-marginal Gromov-Wasserstein transport and barycenters.</article-title> <source>arXiv</source> preprint <elocation-id>arXiv:220506725</elocation-id>. <year>2022</year>; doi: <pub-id pub-id-type="doi">https://doi.org/10.48550/arXiv.2205.06725</pub-id>.</mixed-citation></ref>
<ref id="c7"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>LD</given-names> <surname>Brown</surname></string-name>, <string-name><given-names>TT</given-names> <surname>Cai</surname></string-name>, <string-name><given-names>A.</given-names> <surname>DasGupta</surname></string-name></person-group> <article-title>Interval Estimation for a Binomial Proportion.</article-title> <source>Stat Sci</source>. <year>2001</year>; <volume>16</volume>(<issue>2</issue>):<fpage>101</fpage>–<lpage>133</lpage>. doi: <pub-id pub-id-type="doi">10.1214/ss/1009213286</pub-id>.</mixed-citation></ref>
<ref id="c8"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>C</given-names> <surname>Brunius</surname></string-name>, <string-name><given-names>L</given-names> <surname>Shi</surname></string-name>, <string-name><given-names>R.</given-names> <surname>Landberg</surname></string-name></person-group> <article-title>Large-scale untargeted LC-MS metabolomics data correction using between-batch feature alignment and cluster-based within-batch signal intensity drift correction.</article-title> <source>Metabolomics.</source> <year>2016</year> <month>Sep;</month> <volume>12</volume>(<issue>11</issue>):<fpage>173</fpage>. doi: <pub-id pub-id-type="doi">10.1007/s11306-016-1124-4</pub-id></mixed-citation></ref>
<ref id="c9"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>L</given-names> <surname>Chen</surname></string-name>, <string-name><given-names>W</given-names> <surname>Lu</surname></string-name>, <string-name><given-names>L</given-names> <surname>Wang</surname></string-name>, <string-name><given-names>X</given-names> <surname>Xing</surname></string-name>, <string-name><given-names>Z</given-names> <surname>Chen</surname></string-name>, <string-name><given-names>X</given-names> <surname>Teng</surname></string-name>, <string-name><given-names>X</given-names> <surname>Zeng</surname></string-name>, <string-name><given-names>AD</given-names> <surname>Muscarella</surname></string-name>, <string-name><given-names>Y</given-names> <surname>Shen</surname></string-name>, <string-name><given-names>A</given-names> <surname>Cowan</surname></string-name>, <string-name><given-names>MR</given-names> <surname>McReynolds</surname></string-name>, <string-name><given-names>BJ</given-names> <surname>Kennedy</surname></string-name>, <string-name><given-names>AM</given-names> <surname>Lato</surname></string-name>, <string-name><given-names>SR</given-names> <surname>Campagna</surname></string-name>, <string-name><given-names>M</given-names> <surname>Singh</surname></string-name>, <string-name><given-names>JD.</given-names> <surname>Rabinowitz</surname></string-name></person-group> <article-title>Metabolite discovery through global annotation of untargeted metabolomics data</article-title>. <source>Nat Methods</source>. <year>2021</year> <month>Nov;</month> <volume>18</volume>(<issue>11</issue>):<fpage>1377</fpage>–<lpage>1385</lpage>. doi: <pub-id pub-id-type="doi">10.1038/s41592-021-01303-3</pub-id>.</mixed-citation></ref>
<ref id="c10"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>L</given-names> <surname>Chizat</surname></string-name>, <string-name><surname>Peyré</surname> <given-names>G</given-names></string-name>, <string-name><given-names>B</given-names> <surname>Schmitzer</surname></string-name>, <string-name><surname>Vialard</surname> <given-names>FX.</given-names></string-name></person-group><article-title>Unbalanced optimal transport: Dynamic and Kantorovich formulations</article-title>. <source>J Funct Anal.</source> <year>2018</year>; <volume>274</volume>(<issue>11</issue>):<fpage>3090</fpage>–<lpage>3123</lpage>. doi: <pub-id pub-id-type="doi">10.1016/j.jfa.2018.03.008</pub-id>.</mixed-citation></ref>
<ref id="c11"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Climaco</surname> <given-names>Pinto R</given-names></string-name>, <string-name><given-names>I</given-names> <surname>Karaman</surname></string-name>, <string-name><given-names>MR</given-names> <surname>Lewis</surname></string-name>, <string-name><given-names>J</given-names> <surname>Hallqvist</surname></string-name>, <string-name><given-names>M</given-names> <surname>Kaluarachchi</surname></string-name>, <string-name><surname>Graça</surname> <given-names>G</given-names></string-name>, <string-name><given-names>E</given-names> <surname>Chekmeneva</surname></string-name>, <string-name><surname>Du-</surname> <given-names>rainayagam B</given-names></string-name>, <string-name><given-names>M</given-names> <surname>Ghanbari</surname></string-name>, <string-name><given-names>MA</given-names> <surname>Ikram</surname></string-name>, <string-name><given-names>H</given-names> <surname>Zetterberg</surname></string-name>, <string-name><given-names>J</given-names> <surname>Griffin</surname></string-name>, <string-name><given-names>P</given-names> <surname>Elliott</surname></string-name>, <string-name><given-names>I</given-names> <surname>Tzoulaki</surname></string-name>, <string-name><given-names>A</given-names> <surname>Dehghan</surname></string-name>, <string-name><given-names>D</given-names> <surname>Herrington</surname></string-name>, <string-name><given-names>T.</given-names> <surname>Ebbels</surname></string-name></person-group> <article-title>Finding Correspondence between Metabolomic Features in Untargeted Liquid Chromatography-Mass Spectrometry Metabolomics Datasets.</article-title> <source>Anal Chem</source>. <year>2022</year>; <volume>94</volume>(<issue>14</issue>):<fpage>5493</fpage>–<lpage>5503</lpage>. doi: <pub-id pub-id-type="doi">10.1021/acs.analchem.1c03592</pub-id>.</mixed-citation></ref>
<ref id="c12"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>N</given-names> <surname>Courty</surname></string-name>, <string-name><given-names>R</given-names> <surname>Flamary</surname></string-name>, <string-name><given-names>A</given-names> <surname>Habrard</surname></string-name>, <string-name><given-names>A.</given-names> <surname>Rakotomamonjy</surname></string-name></person-group> <article-title>Joint distribution optimal transportation for domain adaptation.</article-title> <source>NeurIPS</source>. <year>2017</year>; <day>30.</day> <ext-link ext-link-type="uri" xlink:href="https://dl.acm.org/doi/10.5555/3294996.3295130">dl.acm.org/doi/10.5555/3294996.3295130</ext-link>.</mixed-citation></ref>
<ref id="c13"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>P</given-names> <surname>Demetci</surname></string-name>, <string-name><given-names>R</given-names> <surname>Santorella</surname></string-name>, <string-name><given-names>B</given-names> <surname>Sandstede</surname></string-name>, <string-name><given-names>WS</given-names> <surname>Noble</surname></string-name>, <string-name><surname>Singh</surname> <given-names>R.</given-names></string-name></person-group> <article-title>SCOT: Single-Cell Multi-Omics Alignment with Optimal Transport</article-title>. <source>J Comput Biol.</source> <year>2022</year>; <volume>29</volume>(<issue>1</issue>):<fpage>3</fpage>–<lpage>18</lpage>. doi: <pub-id pub-id-type="doi">10.1089/cmb.2021.0446</pub-id>.</mixed-citation></ref>
<ref id="c14"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>EA</given-names> <surname>Franzosa</surname></string-name>, <string-name><given-names>A</given-names> <surname>Sirota-Madi</surname></string-name>, <string-name><given-names>J</given-names> <surname>Avila-Pacheco</surname></string-name>, <string-name><given-names>N</given-names> <surname>Fornelos</surname></string-name>, <string-name><given-names>HJ</given-names> <surname>Haiser</surname></string-name>, <string-name><given-names>S</given-names> <surname>Reinker</surname></string-name>, <string-name><given-names>T</given-names> <surname>Vatanen</surname></string-name>, <string-name><given-names>AB</given-names> <surname>Hall</surname></string-name>, <string-name><given-names>H</given-names> <surname>Mallick</surname></string-name>, <string-name><given-names>LJ</given-names> <surname>McIver</surname></string-name>, <string-name><given-names>JS</given-names> <surname>Sauk</surname></string-name>, <string-name><given-names>RG</given-names> <surname>Wilson</surname></string-name>, <string-name><given-names>BW</given-names> <surname>Stevens</surname></string-name>, <string-name><given-names>JM</given-names> <surname>Scott</surname></string-name>, <string-name><given-names>K</given-names> <surname>Pierce</surname></string-name>, <string-name><given-names>AA</given-names> <surname>Deik</surname></string-name>, <string-name><given-names>K</given-names> <surname>Bullock</surname></string-name>, <string-name><given-names>F</given-names> <surname>Imhann</surname></string-name>, <string-name><given-names>JA</given-names> <surname>Porter</surname></string-name>, <string-name> <given-names>A</given-names> <surname>Zhernakova</surname></string-name></person-group>, <etal>et al.</etal> <article-title>Gut microbiome structure and metabolic activity in inflammatory bowel disease.</article-title> <source>Nat Microbiol</source>. <year>2019</year>; <volume>4</volume>(<issue>2</issue>):<fpage>293</fpage>–<lpage>305</lpage>. doi: <pub-id pub-id-type="doi">10.1038/s41564-018-0306-4</pub-id>.</mixed-citation></ref>
<ref id="c15"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>M</given-names> <surname>Gasull</surname></string-name>, <string-name><given-names>J</given-names> <surname>Pumarega</surname></string-name>, <string-name><given-names>H</given-names> <surname>Kiviranta</surname></string-name>, <string-name><given-names>P</given-names> <surname>Rantakokko</surname></string-name>, <string-name><given-names>O</given-names> <surname>Raaschou-Nielsen</surname></string-name>, <string-name><given-names>IA</given-names> <surname>Bergdahl</surname></string-name>, <string-name><given-names>TM</given-names> <surname>Sandanger</surname></string-name>, <string-name><given-names>F</given-names> <surname>Goni</surname></string-name>, <string-name><given-names>L</given-names> <surname>Cirera</surname></string-name>, <string-name><given-names>C</given-names> <surname>Donat-Vargas</surname></string-name>, <string-name><given-names>J</given-names> <surname>Alguacil</surname></string-name>, <string-name><given-names>M</given-names> <surname>Iglesias</surname></string-name>, <string-name><surname>Tjønneland</surname> <given-names>A</given-names></string-name>, <string-name><given-names>K</given-names> <surname>Overvad</surname></string-name>, <string-name><given-names>FR</given-names> <surname>Mancini</surname></string-name>, <string-name><given-names>MC</given-names> <surname>Boutron-Ruault</surname></string-name>, <string-name><given-names>G</given-names> <surname>Severi</surname></string-name>, <string-name><given-names>T</given-names> <surname>Johnson</surname></string-name>, <string-name><surname>Kühn</surname> <given-names>T</given-names></string-name>, <string-name><given-names>A</given-names> <surname>Trichopoulou</surname></string-name></person-group>, <etal>et al.</etal> <article-title>Methodological issues in a prospective study on plasma concentrations of persistent organic pollutants and pancreatic cancer risk within the EPIC cohort.</article-title> <source>Environmental Research</source>. <year>2019</year>; <volume>169</volume>:<fpage>417</fpage>–<lpage>433</lpage>. doi: <pub-id pub-id-type="doi">10.1016/j.envres.2018.11.027</pub-id>.</mixed-citation></ref>
<ref id="c16"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>DP</given-names> <surname>Gomari</surname></string-name>, <string-name><given-names>A</given-names> <surname>Schweickart</surname></string-name>, <string-name><given-names>L</given-names> <surname>Cerchietti</surname></string-name>, <string-name><given-names>E</given-names> <surname>Paietta</surname></string-name>, <string-name><given-names>H</given-names> <surname>Fernandez</surname></string-name>, <string-name><given-names>H</given-names> <surname>Al-Amin</surname></string-name>, <string-name><given-names>K</given-names> <surname>Suhre</surname></string-name>, <string-name><given-names>J.</given-names> <surname>Krumsiek</surname></string-name></person-group> <article-title>Variational autoencoders learn transferrable representations of metabolomics data.</article-title> <source>Commun Biol.</source> <year>2022</year> <month>Jun</month>; <volume>5</volume>(<issue>1</issue>):<fpage>645</fpage>. doi: <pub-id pub-id-type="doi">10.1038/s42003-022-03579-3</pub-id>.</mixed-citation></ref>
<ref id="c17"><mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><given-names>M.</given-names> <surname>Gromov</surname></string-name></person-group> <source>Metric Structures for Riemannian and Non-Riemannian Spaces.</source> <publisher-name>Birkhäuser Boston, Inc.</publisher-name>, <publisher-loc>Boston, MA</publisher-loc>; <year>2001</year>. doi: <pub-id pub-id-type="doi">10.1007/978-0-8176-4583-0</pub-id>.</mixed-citation></ref>
<ref id="c18"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>H</given-names> <surname>Habra</surname></string-name>, <string-name><given-names>M</given-names> <surname>Kachman</surname></string-name>, <string-name><given-names>K</given-names> <surname>Bullock</surname></string-name>, <string-name><given-names>C</given-names> <surname>Clish</surname></string-name>, <string-name><given-names>CR</given-names> <surname>Evans</surname></string-name>, <string-name><surname>Karnovsky</surname> <given-names>A.</given-names></string-name></person-group> <article-title>metabCombiner: Paired Untargeted LC-HRMS Metabolomics Feature Matching and Concatenation of Disparately Acquired Data Sets</article-title>. <source>Anal Chem.</source> <year>2021</year>; <volume>93</volume>(<issue>12</issue>):<fpage>5028</fpage>–<lpage>5036</lpage>. doi: <pub-id pub-id-type="doi">10.1021/acs.analchem.0c03693</pub-id>.</mixed-citation></ref>
<ref id="c19"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>YHH</given-names> <surname>Hsu</surname></string-name>, <string-name><given-names>C</given-names> <surname>Churchhouse</surname></string-name>, <string-name><given-names>TH</given-names> <surname>Pers</surname></string-name>, <string-name><given-names>JM</given-names> <surname>Mercader</surname></string-name>, <string-name><given-names>A</given-names> <surname>Metspalu</surname></string-name>, <string-name><given-names>K</given-names> <surname>Fischer</surname></string-name>, <string-name><given-names>K</given-names> <surname>Fortney</surname></string-name>, <string-name><given-names>EK</given-names> <surname>Morgen</surname></string-name>, <string-name><given-names>C</given-names> <surname>Gonzalez</surname></string-name>, <string-name><given-names>ME</given-names> <surname>Gonzalez</surname></string-name>, <string-name><given-names>T</given-names> <surname>Esko</surname></string-name>, <string-name><surname>Hirschhorn</surname> <given-names>JN.</given-names></string-name></person-group> <article-title>PAIRUP-MS: Pathway analysis and imputation to relate unknowns in profiles from mass spectrometry-based metabolite data</article-title>. <source>PLoS Comput Biol.</source> <year>2019</year> <day>01</day>; <volume>15</volume>(<issue>1</issue>):<fpage>1</fpage>–<lpage>26</lpage>. doi: <pub-id pub-id-type="doi">10.1371/journal.pcbi.1006734</pub-id>.</mixed-citation></ref>
<ref id="c20"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>J</given-names> <surname>Ivanisevic</surname></string-name>, <string-name><given-names>EJ.</given-names> <surname>Want</surname></string-name></person-group> <article-title>From Samples to Insights into Metabolism: Uncovering Biologically Relevant Information in LC-HRMS Metabolomics Data</article-title>. <source>Metabolites.</source> <year>2019</year>; <volume>9</volume>(<issue>2</issue>). doi: <pub-id pub-id-type="doi">10.3390/metabo9120308</pub-id>.</mixed-citation></ref>
<ref id="c21"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>LV.</given-names> <surname>Kantorovich</surname></string-name></person-group> <article-title>On the translocation of masses.</article-title> <source>J Math Sci</source>. <year>2006</year>; <volume>133</volume>(<issue>4</issue>):<fpage>1381</fpage>–<lpage>1382</lpage>. doi: <pub-id pub-id-type="doi">10.1007/s10958-006-0049-2</pub-id>.</mixed-citation></ref>
<ref id="c22"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>L</given-names> <surname>Li</surname></string-name>, <string-name><given-names>X</given-names> <surname>Zheng</surname></string-name>, <string-name><given-names>Q</given-names> <surname>Zhou</surname></string-name>, <string-name><given-names>N</given-names> <surname>Villanueva</surname></string-name>, <string-name><given-names>W</given-names> <surname>Nian</surname></string-name>, <string-name><given-names>X</given-names> <surname>Liu</surname></string-name>, <string-name><given-names>T.</given-names> <surname>Huan</surname></string-name></person-group> <article-title>Metabolomics-Based Discovery of Molecular Signatures for Triple Negative Breast Cancer in Asian Female Population</article-title>. <source>Sci Rep.</source> <year>2020</year> <month>Jan;</month> <volume>10</volume>(<issue>1</issue>):<fpage>370</fpage>. doi: <pub-id pub-id-type="doi">10.1038/s41598-019-57068-5</pub-id>.</mixed-citation></ref>
<ref id="c23"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Q</given-names> <surname>Liu</surname></string-name>, <string-name><given-names>D</given-names> <surname>Walker</surname></string-name>, <string-name><given-names>K</given-names> <surname>Uppal</surname></string-name>, <string-name><given-names>Z</given-names> <surname>Liu</surname></string-name>, <string-name><given-names>C</given-names> <surname>Ma</surname></string-name>, <string-name><given-names>V</given-names> <surname>Tran</surname></string-name>, <string-name><given-names>S</given-names> <surname>Li</surname></string-name>, <string-name><given-names>DP</given-names> <surname>Jones</surname></string-name>, <string-name> <given-names>T.</given-names> <surname>Yu</surname></string-name></person-group> <article-title>Addressing the batch effect issue for LC/MS metabolomics data in data preprocessing.</article-title> <source>Sci Rep.</source> <year>2020</year> <month>Aug;</month> <volume>10</volume>(<issue>1</issue>):<fpage>13856</fpage>. doi: <pub-id pub-id-type="doi">10.1038/s41598-020-70850-0</pub-id>.</mixed-citation></ref>
<ref id="c24"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>E</given-names> <surname>Loftfield</surname></string-name>, <string-name><given-names>M</given-names> <surname>Stepien</surname></string-name>, <string-name><given-names>V</given-names> <surname>Viallon</surname></string-name>, <string-name><given-names>L</given-names> <surname>Trijsburg</surname></string-name>, <string-name><given-names>JA</given-names> <surname>Rothwell</surname></string-name>, <string-name><given-names>N</given-names> <surname>Robinot</surname></string-name>, <string-name><given-names>C</given-names> <surname>Biessy</surname></string-name>, <string-name><given-names>IA</given-names> <surname>Bergdahl</surname></string-name>, <string-name><surname>Bodén</surname> <given-names>S</given-names></string-name>, <string-name><given-names>MB</given-names> <surname>Schulze</surname></string-name></person-group>, <etal>et al.</etal> <article-title>Novel biomarkers of habitual alcohol intake and associations with risk of pancreatic and liver cancers and liver disease mortality.</article-title> <source>J Natl Cancer Inst</source>. <year>2021</year>; <volume>113</volume>(<issue>11</issue>):<fpage>1542</fpage>–<lpage>1550</lpage>. doi: <pub-id pub-id-type="doi">10.1093/jnci/djab078</pub-id>.</mixed-citation></ref>
<ref id="c25"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>F.</given-names> <surname>Mémoli</surname></string-name></person-group> <article-title>Gromov-Wasserstein Distances and the Metric Approach to Object Matching.</article-title> <source>Found Comput Math.</source> <year>2011</year> <month>Aug;</month> <volume>11</volume>(<issue>4</issue>):<fpage>417</fpage>–<lpage>487</lpage>. doi: <pub-id pub-id-type="doi">10.1007/s10208-011-9093-5</pub-id>.</mixed-citation></ref>
<ref id="c26"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>G.</given-names> <surname>Monge</surname></string-name></person-group> <article-title>Mémoire sur la théorie des déblais et des remblais.</article-title> <source>Mem Math Phys Acad Royale Sci</source>. <year>1781</year>; p. <fpage>666</fpage>–<lpage>704</lpage>.</mixed-citation></ref>
<ref id="c27"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>M</given-names> <surname>Nitzan</surname></string-name>, <string-name><given-names>N</given-names> <surname>Karaiskos</surname></string-name>, <string-name><given-names>N</given-names> <surname>Friedman</surname></string-name>, <string-name><given-names>N.</given-names> <surname>Rajewsky</surname></string-name></person-group> <article-title>Gene expression cartography.</article-title> <source>Nature.</source> <year>2019</year> <month>Dec;</month> <volume>576</volume>(<issue>7785</issue>):<fpage>132</fpage>–<lpage>137</lpage>. doi: <pub-id pub-id-type="doi">10.1038/s41586-019-1773-3</pub-id>.</mixed-citation></ref>
<ref id="c28"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>GJ.</given-names> <surname>Patti</surname></string-name></person-group> <article-title>Separation strategies for untargeted metabolomics.</article-title> <source>J Sep Sci</source>. <year>2011</year>; <volume>34</volume>(<issue>24</issue>):<fpage>3460</fpage>–<lpage>3469</lpage>. doi: <pub-id pub-id-type="doi">10.1002/jssc.201100532</pub-id>.</mixed-citation></ref>
<ref id="c29"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Peyré</surname> <given-names>G</given-names></string-name>, <string-name><given-names>M</given-names> <surname>Cuturi</surname></string-name>, <string-name><given-names>J.</given-names> <surname>Solomon</surname></string-name></person-group> <article-title>Gromov-wasserstein averaging of kernel and distance matrices.</article-title> <source>In: ICML PMLR;</source> <year>2016</year>. p. <fpage>2664</fpage>–<lpage>2672</lpage>. doi: <pub-id pub-id-type="doi">10.5555/3045390.3045671</pub-id>.</mixed-citation></ref>
<ref id="c30"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Peyré</surname> <given-names>G</given-names></string-name>, <string-name><given-names>M</given-names> <surname>Cuturi</surname></string-name></person-group>, <etal>et al.</etal> <article-title>Computational optimal transport: With applications to data science.</article-title> <source>Found Trends Mach Learn.</source> <year>2019</year>; <volume>11</volume>(<issue>5-6</issue>):<fpage>355</fpage>–<lpage>607</lpage>. doi: <pub-id pub-id-type="doi">10.1561/2200000073</pub-id>.</mixed-citation></ref>
<ref id="c31"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>L</given-names> <surname>Pirhaji</surname></string-name>, <string-name><given-names>P</given-names> <surname>Milani</surname></string-name>, <string-name><given-names>M</given-names> <surname>Leidl</surname></string-name>, <string-name><given-names>T</given-names> <surname>Curran</surname></string-name>, <string-name><given-names>J</given-names> <surname>Avila-Pacheco</surname></string-name>, <string-name><given-names>CB</given-names> <surname>Clish</surname></string-name>, <string-name><given-names>FM</given-names> <surname>White</surname></string-name>, <string-name><given-names>A</given-names> <surname>Saghatelian</surname></string-name>, <string-name><given-names>E.</given-names> <surname>Fraenkel</surname></string-name></person-group> <article-title>Revealing disease-associated pathways by network integration of untargeted metabolomics.</article-title> <source>Nat Methods</source>. <year>2016</year>; <volume>13</volume>(<issue>9</issue>):<fpage>770</fpage>–<lpage>776</lpage>. doi: <pub-id pub-id-type="doi">10.1038/nmeth.3940</pub-id>.</mixed-citation></ref>
<ref id="c32"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>SM</given-names> <surname>Rappaport</surname></string-name>, <string-name><given-names>DK</given-names> <surname>Barupal</surname></string-name>, <string-name><given-names>D</given-names> <surname>Wishart</surname></string-name>, <string-name><given-names>P</given-names> <surname>Vineis</surname></string-name>, <string-name><given-names>A.</given-names> <surname>Scalbert</surname></string-name></person-group> <article-title>The Blood Exposome and Its Role in Discovering Causes of Disease.</article-title> <source>Environ Health Perspect</source>. <year>2014</year>; <volume>122</volume>(<issue>8</issue>):<fpage>769</fpage>–<lpage>774</lpage>. doi: <pub-id pub-id-type="doi">10.1289/ehp.1308015</pub-id>.</mixed-citation></ref>
<ref id="c33"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>A</given-names> <surname>Reuther</surname></string-name>, <string-name><given-names>J</given-names> <surname>Kepner</surname></string-name>, <string-name><given-names>C</given-names> <surname>Byun</surname></string-name>, <string-name><given-names>S</given-names> <surname>Samsi</surname></string-name>, <string-name><given-names>W</given-names> <surname>Arcand</surname></string-name>, <string-name><given-names>D</given-names> <surname>Bestor</surname></string-name>, <string-name><given-names>B</given-names> <surname>Bergeron</surname></string-name>, <string-name><given-names>V</given-names> <surname>Gadepally</surname></string-name>, <string-name><given-names>M</given-names> <surname>Houle</surname></string-name>, <string-name><given-names>M</given-names> <surname>Hubbell</surname></string-name>, <string-name><given-names>M</given-names> <surname>Jones</surname></string-name>, <string-name><given-names>A</given-names> <surname>Klein</surname></string-name>, <string-name><given-names>L</given-names> <surname>Milechin</surname></string-name>, <string-name><given-names>J</given-names> <surname>Mullen</surname></string-name>, <string-name><given-names>A</given-names> <surname>Prout</surname></string-name>, <string-name><given-names>A</given-names> <surname>Rosa</surname></string-name>, <string-name><given-names>C</given-names> <surname>Yee</surname></string-name>, <string-name><given-names>P.</given-names> <surname>Michaleas</surname></string-name></person-group> <article-title>&gt;Interactive supercomputing on 40,000 cores for machine learning and data analysis.</article-title> <source>In: HPEC IEEE;</source> <year>2018</year>. p. <fpage>1</fpage>–<lpage>6</lpage>. doi: <pub-id pub-id-type="doi">10.1109/HPEC.2018.8547629</pub-id>.</mixed-citation></ref>
<ref id="c34"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>E</given-names> <surname>Riboli</surname></string-name>, <string-name><given-names>K</given-names> <surname>Hunt</surname></string-name>, <string-name><given-names>N</given-names> <surname>Slimani</surname></string-name>, <string-name><given-names>P</given-names> <surname>Ferrari</surname></string-name>, <string-name><given-names>T</given-names> <surname>Norat</surname></string-name>, <string-name><given-names>M</given-names> <surname>Fahey</surname></string-name>, <string-name><surname>Charrondière</surname> <given-names>U</given-names></string-name>, <string-name><surname>Hémon</surname> <given-names>B</given-names></string-name>, <string-name><given-names>C</given-names> <surname>Casagrande</surname></string-name>, <string-name><given-names>J</given-names> <surname>Vignat</surname></string-name></person-group>, <etal>et al.</etal> <article-title>European Prospective Investigation into Cancer and Nutrition (EPIC): study populations and data collection.</article-title> <source>Public Health Nutr</source>. <year>2002</year>; <volume>5</volume>(<issue>6b</issue>):<fpage>1113</fpage>–<lpage>1124</lpage>. doi: <pub-id pub-id-type="doi">10.1079/PHN2002394</pub-id>.</mixed-citation></ref>
<ref id="c35"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>G</given-names> <surname>Schiebinger</surname></string-name>, <string-name><given-names>J</given-names> <surname>Shu</surname></string-name>, <string-name><given-names>M</given-names> <surname>Tabaka</surname></string-name>, <string-name><given-names>B</given-names> <surname>Cleary</surname></string-name>, <string-name><given-names>V</given-names> <surname>Subramanian</surname></string-name>, <string-name><given-names>A</given-names> <surname>Solomon</surname></string-name>, <string-name><given-names>J</given-names> <surname>Gould</surname></string-name>, <string-name><given-names>S</given-names> <surname>Liu</surname></string-name>, <string-name><given-names>S</given-names> <surname>Lin</surname></string-name>, <string-name><given-names>P</given-names> <surname>Berube</surname></string-name></person-group>, <etal>et al.</etal> <article-title>Optimal-transport analysis of single-cell gene expression identifies developmental trajectories in reprogramming.</article-title> <source>Cell</source>. <year>2019</year>; <volume>176</volume>(<issue>4</issue>):<fpage>928</fpage>–<lpage>943</lpage>. doi: <pub-id pub-id-type="doi">10.1016/j.cell.2019.01.006</pub-id>.</mixed-citation></ref>
<ref id="c36"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>T</given-names> <surname>Séjourné</surname></string-name>, <string-name><given-names>J</given-names> <surname>Feydy</surname></string-name>, <string-name><given-names>FX</given-names> <surname>Vialard</surname></string-name>, <string-name><given-names>A</given-names> <surname>Trouvé</surname></string-name>, <string-name><given-names>G.</given-names> <surname>Peyré</surname></string-name></person-group> <article-title>Sinkhorn divergences for unbalanced optimal transport.</article-title> <source>arXiv preprint arXiv:191012958</source>. <year>2019</year>; doi: <pub-id pub-id-type="doi">10.48550/arXiv.1910.12958</pub-id>.</mixed-citation></ref>
<ref id="c37"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>T</given-names> <surname>Sejourne</surname></string-name>, <string-name><given-names>FX</given-names> <surname>Vialard</surname></string-name>, <string-name><surname>Peyré</surname> <given-names>G.</given-names></string-name></person-group> <article-title>The Unbalanced Gromov Wasserstein Distance: Conic Formulation and Relaxation. In: NeurIPS</article-title>, vol. <volume>34</volume> <source>Curran Associates, Inc.</source>; <year>2021</year>. p. <fpage>8766</fpage>–<lpage>8779</lpage>. <ext-link ext-link-type="uri" xlink:href="https://proceedings.neurips.cc/paper/2021/hash/4990974d150d0de5e6e15a1454fe6b0f-Abstract.html">https://proceedings.neurips.cc/paper/2021/hash/4990974d150d0de5e6e15a1454fe6b0f-Abstract.html.</ext-link></mixed-citation></ref>
<ref id="c38"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>G</given-names> <surname>Skoraczynski</surname></string-name>, <string-name><given-names>A</given-names> <surname>Gambin</surname></string-name>, <string-name> <given-names>B.</given-names> <surname>Miasojedow</surname></string-name></person-group> <article-title>Alignstein: Optimal transport for improved LC-MS retention time alignment</article-title>. <source>GigaScience</source>. <year>2022</year> <volume>11</volume>; <issue>11</issue>. doi: <pub-id pub-id-type="doi">10.1093/gigascience/giac101</pub-id>.</mixed-citation></ref>
<ref id="c39"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>N</given-names> <surname>Slimani</surname></string-name>, <string-name><given-names>S</given-names> <surname>Bingham</surname></string-name>, <string-name><given-names>S</given-names> <surname>Runswick</surname></string-name>, <string-name><given-names>P</given-names> <surname>Ferrari</surname></string-name>, <string-name><given-names>NE</given-names> <surname>Day</surname></string-name>, <string-name><given-names>AA</given-names> <surname>Welch</surname></string-name>, <string-name><given-names>TJ</given-names> <surname>Key</surname></string-name>, <string-name><given-names>AB</given-names> <surname>Miller</surname></string-name>, <string-name><given-names>H</given-names> <surname>Boeing</surname></string-name>, <string-name><given-names>S</given-names> <surname>Sieri</surname></string-name>, <string-name><given-names>F</given-names> <surname>Veglia</surname></string-name>, <string-name><given-names>D</given-names> <surname>Palli</surname></string-name>, <string-name><given-names>S</given-names> <surname>Panico</surname></string-name>, <string-name><given-names>R</given-names> <surname>Tumino</surname></string-name>, <string-name><surname>Bueno-De-Mesquita</surname> <given-names>B</given-names></string-name>, <string-name><surname>Ocké</surname> <given-names>MC</given-names></string-name>, <string-name><given-names>F</given-names> <surname>Clavel-Chapelon</surname></string-name>, <string-name><given-names>A</given-names> <surname>Trichopoulou</surname></string-name>, <string-name><surname>Van</surname> <given-names>Staveren WA</given-names></string-name>, <string-name><given-names>E.</given-names> <surname>Riboli</surname></string-name></person-group> <article-title>Group level validation of protein intakes estimated by 24-hour diet recall and dietary questionnaires against 24-hour urinary nitrogen in the European Prospective Investigation into Cancer and Nutrition (EPIC) calibration study.</article-title> <source>Cancer Epidemiol Biomarkers Prev.</source> <year>2003</year> <month>Aug;</month> <volume>12</volume>(<issue>8</issue>):<fpage>784</fpage>–<lpage>795</lpage>. <ext-link ext-link-type="uri" xlink:href="https://pubmed.ncbi.nlm.nih.gov/12917211/">https://pubmed.ncbi.nlm.nih.gov/12917211/</ext-link>.</mixed-citation></ref>
<ref id="c40"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>CA</given-names> <surname>Smith</surname></string-name>, <string-name><given-names>EJ</given-names> <surname>Want</surname></string-name>, <string-name><surname>O’Maille</surname> <given-names>G</given-names></string-name>, <string-name><given-names>R</given-names> <surname>Abagyan</surname></string-name>, <string-name><given-names>G.</given-names> <surname>Siuzdak</surname></string-name></person-group> <article-title>XCMS: Processing Mass Spectrometry Data for Metabolite Profiling Using Nonlinear Peak Alignment, Matching, and Identification.</article-title> <source>Anal Chem.</source> <year>2006</year>; <volume>78</volume>(<issue>3</issue>):<fpage>779</fpage>–<lpage>787</lpage>. doi: <pub-id pub-id-type="doi">10.1021/ac051437y</pub-id>.</mixed-citation></ref>
<ref id="c41"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>J</given-names> <surname>Solomon</surname></string-name>, <string-name><surname>Peyré</surname> <given-names>G</given-names></string-name>, <string-name><given-names>VG</given-names> <surname>Kim</surname></string-name>, <string-name><given-names>S.</given-names> <surname>Sra</surname></string-name></person-group> <article-title>Entropic Metric Alignment for Correspondence Problems.</article-title> <source>ACM Trans Graph</source>. <year>2016</year> <month>jul;</month> <volume>35</volume>(<issue>4</issue>). doi: <pub-id pub-id-type="doi">10.1145/2897824.2925903</pub-id>.</mixed-citation></ref>
<ref id="c42"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>M</given-names> <surname>Stepien</surname></string-name>, <string-name><given-names>T</given-names> <surname>Duarte-Salles</surname></string-name>, <string-name><given-names>V</given-names> <surname>Fedirko</surname></string-name>, <string-name><given-names>A</given-names> <surname>Floegel</surname></string-name>, <string-name><given-names>DK</given-names> <surname>Barupal</surname></string-name>, <string-name><given-names>S</given-names> <surname>Rinaldi</surname></string-name>, <string-name><given-names>D</given-names> <surname>Achaintre</surname></string-name>, <string-name><given-names>N</given-names> <surname>Assi</surname></string-name>, <string-name><surname>Tjønneland</surname> <given-names>A</given-names></string-name>, <string-name><given-names>K</given-names> <surname>Overvad</surname></string-name>, <string-name><given-names>N</given-names> <surname>Bastide</surname></string-name>, <string-name><given-names>MC</given-names> <surname>Boutron-Ruault</surname></string-name>, <string-name><given-names>G</given-names> <surname>Severi</surname></string-name>, <string-name><surname>Kühn</surname> <given-names>T</given-names></string-name>, <string-name><given-names>R</given-names> <surname>Kaaks</surname></string-name>, <string-name><given-names>K</given-names> <surname>Aleksandrova</surname></string-name>, <string-name><given-names>H</given-names> <surname>Boeing</surname></string-name>, <string-name><surname>Tri-</surname> <given-names>chopoulou A</given-names></string-name>, <string-name><given-names>C</given-names> <surname>Bamia</surname></string-name>, <string-name><given-names>P</given-names> <surname>Lagiou</surname></string-name></person-group>, <etal>et al.</etal> <article-title>Alteration of amino acid and biogenic amine metabolism in hepatobiliary cancers: Findings from a prospective cohort stud</article-title>. <source>Int J Cancer.</source> <year>2016</year>; <volume>138</volume>(<issue>2</issue>):<fpage>348</fpage>–<lpage>360</lpage>. doi: <pub-id pub-id-type="doi">10.1002/ijc.29718</pub-id>.</mixed-citation></ref>
<ref id="c43"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>M</given-names> <surname>Stepien</surname></string-name>, <string-name><given-names>P</given-names> <surname>Keski-Rahkonen</surname></string-name>, <string-name><given-names>A</given-names> <surname>Kiss</surname></string-name>, <string-name><given-names>N</given-names> <surname>Robinot</surname></string-name>, <string-name><given-names>T</given-names> <surname>Duarte-Salles</surname></string-name>, <string-name><given-names>N</given-names> <surname>Murphy</surname></string-name>, <string-name><given-names>G</given-names> <surname>Perlemuter</surname></string-name>, <string-name><given-names>V</given-names> <surname>Viallon</surname></string-name>, <string-name><given-names>A</given-names> <surname>Tjønneland</surname></string-name>, <string-name><given-names>AL</given-names> <surname>Rostgaard-Hansen</surname></string-name>, <string-name><given-names>CC</given-names> <surname>Dahm</surname></string-name>, <string-name><given-names>K</given-names> <surname>Overvad</surname></string-name>, <string-name><given-names>MC</given-names> <surname>Boutron-Ruault</surname></string-name>, <string-name><given-names>FR</given-names> <surname>Mancini</surname></string-name>, <string-name><given-names>Y</given-names> <surname>Mahamat-Saleh</surname></string-name>, <string-name><given-names>K</given-names> <surname>Aleksandrova</surname></string-name>, <string-name><given-names>R</given-names> <surname>Kaaks</surname></string-name>, <string-name><surname>Kühn</surname> <given-names>T</given-names></string-name>, <string-name><given-names>A</given-names> <surname>Trichopoulou</surname></string-name>, <string-name><given-names>A</given-names> <surname>Karakatsani</surname></string-name></person-group>, <etal>et al.</etal> <article-title>Metabolic perturbations prior to hepatocellular carcinoma diagnosis: Findings from a prospective observational cohort study</article-title>. <source>Int J Cancer.</source> <year>2021</year>; <volume>148</volume>(<issue>3</issue>):<fpage>609</fpage>–<lpage>625</lpage>. doi: <pub-id pub-id-type="doi">10.1002/ijc.33236</pub-id>.</mixed-citation></ref>
<ref id="c44"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>R</given-names> <surname>Tautenhahn</surname></string-name>, <string-name><given-names>GJ</given-names> <surname>Patti</surname></string-name>, <string-name><given-names>E</given-names> <surname>Kalisiak</surname></string-name>, <string-name><given-names>T</given-names> <surname>Miyamoto</surname></string-name>, <string-name><given-names>M</given-names> <surname>Schmidt</surname></string-name>, <string-name><given-names>FY</given-names> <surname>Lo</surname></string-name>, <string-name><given-names>J</given-names> <surname>McBee</surname></string-name>, <string-name><given-names>NS</given-names> <surname>Baliga</surname></string-name>, <string-name><surname>Siuzdak</surname> <given-names>G.</given-names></string-name></person-group> <article-title>metaX-CMS: second-order analysis of untargeted metabolomics data</article-title>. <source>Anal Chem.</source> <year>2011</year>; <volume>83</volume>(<issue>3</issue>):<fpage>696</fpage>–<lpage>700</lpage>. doi: <pub-id pub-id-type="doi">10.1021/ac102980g</pub-id>.</mixed-citation></ref>
<ref id="c45"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>AA</given-names> <surname>Vaughan</surname></string-name>, <string-name><given-names>WB</given-names> <surname>Dunn</surname></string-name>, <string-name><given-names>JW</given-names> <surname>Allwood</surname></string-name>, <string-name><given-names>DC</given-names> <surname>Wedge</surname></string-name>, <string-name><given-names>FH</given-names> <surname>Blackhall</surname></string-name>, <string-name><given-names>AD</given-names> <surname>Whetton</surname></string-name>, <string-name><given-names>C</given-names> <surname>Dive</surname></string-name>, <string-name><given-names>R.</given-names> <surname>Goodacre</surname></string-name></person-group> <article-title>Liquid Chromatography-Mass Spectrometry Calibration Transfer and Metabolomics Data Fusion</article-title>. <source>Anal Chem.</source> <year>2012</year>; <volume>84</volume>(<issue>22</issue>):<fpage>9848</fpage>–<lpage>9857</lpage>. doi: <pub-id pub-id-type="doi">10.1021/ac302227c</pub-id>.</mixed-citation></ref>
<ref id="c46"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>C.</given-names> <surname>Villani</surname></string-name></person-group> <article-title>Topics in optimal transportation</article-title>, vol. 58. <source>American Mathematical Soc.</source>; <year>2021</year>.</mixed-citation></ref>
<ref id="c47"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>TJ</given-names> <surname>Wang</surname></string-name>, <string-name><given-names>MG</given-names> <surname>Larson</surname></string-name>, <string-name><given-names>RS</given-names> <surname>Vasan</surname></string-name>, <string-name><given-names>S</given-names> <surname>Cheng</surname></string-name>, <string-name><given-names>EP</given-names> <surname>Rhee</surname></string-name>, <string-name><given-names>E</given-names> <surname>McCabe</surname></string-name>, <string-name><given-names>GD</given-names> <surname>Lewis</surname></string-name>, <string-name><given-names>CS</given-names> <surname>Fox</surname></string-name>, <string-name><given-names>PF</given-names> <surname>Jacques</surname></string-name>, <string-name><given-names>C</given-names> <surname>Fernandez</surname></string-name>, <string-name> <given-names>CJ</given-names> <surname>O’Donnell</surname></string-name>, <string-name><given-names>SA</given-names> <surname>Carr</surname></string-name>, <string-name><given-names>VK</given-names> <surname>Mootha</surname></string-name>, <string-name><given-names>JC</given-names> <surname>Florez</surname></string-name>, <string-name><given-names>A</given-names> <surname>Souza</surname></string-name>, <string-name><given-names>O</given-names> <surname>Melander</surname></string-name>, <string-name><given-names>CB</given-names> <surname>Clish</surname></string-name>, <string-name><given-names>RE.</given-names> <surname>Gerszten</surname></string-name></person-group> <article-title>Metabolite profiles and the risk of developing diabetes.</article-title> <source>Nat Med</source>. <year>2011</year>; <volume>17</volume>(<issue>4</issue>):<fpage>448</fpage>–<lpage>453</lpage>. doi: <pub-id pub-id-type="doi">10.1038/nm.2307</pub-id>.</mixed-citation></ref>
<ref id="c48"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>DS.</given-names> <surname>Wishart</surname></string-name></person-group> <article-title>Metabolomics for Investigating Physiological and Pathophysiological Processes.</article-title> <source>Physiol Rev</source>. <year>2019</year>; <volume>99</volume>(<issue>4</issue>):<fpage>1819</fpage>–<lpage>1875</lpage>. doi: <pub-id pub-id-type="doi">10.1152/physrev.00035.2018</pub-id>.</mixed-citation></ref>
<ref id="c49"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>KD</given-names> <surname>Yang</surname></string-name>, <string-name><given-names>K</given-names> <surname>Damodaran</surname></string-name>, <string-name><given-names>S</given-names> <surname>Venkatachalapathy</surname></string-name>, <string-name><given-names>AC</given-names> <surname>Soylemezoglu</surname></string-name>, <string-name><given-names>G</given-names> <surname>Shivashankar</surname></string-name>, <string-name><given-names>C.</given-names> <surname>Uhler</surname></string-name></person-group> <article-title>Predicting cell lineages using autoencoders and optimal transport.</article-title> <source>PLoS Comput Biol</source>. <year>2020</year>; <volume>16</volume>(<issue>4</issue>):<fpage>1</fpage>–<lpage>20</lpage>. doi: <pub-id pub-id-type="doi">10.1371/journal.pcbi.1007828</pub-id>.</mixed-citation></ref>
<ref id="c50"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>B</given-names> <surname>Zhou</surname></string-name>, <string-name><given-names>JF</given-names> <surname>Xiao</surname></string-name>, <string-name><given-names>L</given-names> <surname>Tuli</surname></string-name>, <string-name><given-names>HW.</given-names> <surname>Ressom</surname></string-name></person-group> <article-title>LC-MS-based metabolomics.</article-title> <source>Mol BioSyst.</source> <year>2012</year>; <volume>8</volume>:<fpage>470</fpage>–<lpage>481</lpage>. doi: <pub-id pub-id-type="doi">10.1039/C1MB05350G</pub-id>.</mixed-citation></ref>
</ref-list>
<app-group> 
<app id="app1">
<title>Appendix 1</title>
<p>In this paper, we study how to match metabolic features across two datasets where Dataset 1 has <italic>p</italic> 1 metabolic features measured across <italic>n</italic><sub>1</sub> patients and Dataset 2 has <italic>p</italic><sub>2</sub> metabolic features measured across <italic>n</italic><sub>2</sub> patients. Our goal is to identify pairs of indexes (<italic>i,j</italic>) with <italic>i</italic> e {1<italic>,… ,p</italic><sub>1</sub>} and <italic>j</italic> e {1<italic>,… ,p</italic><sub>2</sub>}, such that feature <italic>i</italic> in Dataset 1 and feature <italic>j</italic> in Dataset 2 correspond to the same metabolic feature. More formally, we aim to identify a <italic>matching matrix</italic> <inline-formula id="ID49">
<alternatives>
<mml:math display="block" id="I49">
<mml:mrow><mml:mi>M</mml:mi><mml:mo>*</mml:mo><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq49.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> such that <inline-formula id="ID50">
<alternatives>
<mml:math display="block" id="I50">
<mml:msubsup>
<mml:mi>M</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow>
<mml:mo>*</mml:mo>
</mml:msubsup>
<mml:mo>=</mml:mo><mml:mn>1</mml:mn>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq50.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> if features <italic>i</italic> in Dataset 1 and feature <italic>j</italic> in Dataset 2 correspond to the same feature, hereafter referred to as <italic>matched</italic> features. Otherwise we set <inline-formula id="ID51">
<alternatives>
<mml:math display="block" id="I51">
<mml:msubsup>
<mml:mi>M</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow>
<mml:mo>*</mml:mo>
</mml:msubsup>
<mml:mo>=</mml:mo><mml:mn>0</mml:mn>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq51.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> otherwise. We emphasize that a matching matrix <italic>M</italic> <sup>*</sup> can have at most one nonzero entry in each row and column.</p>
<p>Both of the datasets we aim to match are obtained from liquid chromatography-mass spectrometry (LC-MS) experiments. Hence, for Dataset 1 each metabolite <italic>i</italic> ϵ [<italic>p</italic><sub>1</sub>] is labeled with a mass-to-charge (<italic>m</italic>/<italic>z</italic>) ratio <inline-formula id="ID52">
<alternatives>
<mml:math display="block" id="I52">
<mml:msubsup>
<mml:mi>m</mml:mi>
<mml:mi>i</mml:mi>
<mml:mn>1</mml:mn>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq52.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula>
. as well as a retention time (RT) given by <inline-formula id="ID53">
<alternatives>
<mml:math display="block" id="I53">
<mml:mi>R</mml:mi><mml:msubsup>
<mml:mi>T</mml:mi>
<mml:mi>i</mml:mi>
<mml:mn>1</mml:mn>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq53.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula>. Additionally, each metabolite has a vector of intensities across patients denoted by <inline-formula id="ID54">
<alternatives>
<mml:math display="block" id="I54">
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>∈</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>n</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq54.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula>. Similarly, each metabolite <italic>j ϵ</italic> [<italic>p</italic><sub>2</sub>] in Dataset 2 is labeled by its <italic>m</italic>/<italic>z</italic> ratio <inline-formula id="ID55">
<alternatives>
<mml:math display="block" id="I55">
<mml:msubsup>
<mml:mi>m</mml:mi>
<mml:mi>j</mml:mi>
<mml:mn>2</mml:mn>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq55.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula>
, its retention time <inline-formula id="ID56">
<alternatives>
<mml:math display="block" id="I56">
<mml:mi>R</mml:mi><mml:msubsup>
<mml:mi>T</mml:mi>
<mml:mi>j</mml:mi>
<mml:mn>2</mml:mn>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq56.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> and its vector of intensities across samples <inline-formula id="ID57">
<alternatives>
<mml:math display="block" id="I57">
<mml:msub>
<mml:mi>Y</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mo>∈</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>n</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq57.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula>.</p>
<sec id="s11">
<title>Correlations and distances between metabolomic features</title>
<p>Features cannot be aligned based on their <italic>m</italic>/<italic>z</italic> and RT alone as they are often too inconsistent across studies. Our method is based on the idea that, in addition to their <italic>m</italic>/<italic>z</italic> and RT being compatible, the signal intensities of metabolites measured in two different studies should exhibit similar correlation structures, or more generally exhibit similar distances between their intensity vectors. In other words, if feature intensity vectors <inline-formula id="ID58">
<alternatives>
<mml:math display="block" id="I58">
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>∈</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>n</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
<mml:mo>,</mml:mo><mml:msub>
<mml:mi>Y</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mo>∈</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>n</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq58.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> correspond to the same underlying feature <inline-formula id="ID59">
<alternatives>
<mml:math display="block" id="I59">
<mml:mfenced>
<mml:mrow>
<mml:msubsup>
<mml:mi>M</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
<mml:mo>*</mml:mo>
</mml:msubsup>
<mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
</mml:mfenced>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq59.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> and similarly if <inline-formula id="ID60">
<alternatives>
<mml:math display="block" id="I60">
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>k</mml:mi>
</mml:msub>
<mml:mo>∈</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>n</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
<mml:mo>,</mml:mo><mml:msub>
<mml:mi>Y</mml:mi>
<mml:mi>l</mml:mi>
</mml:msub>
<mml:mo>∈</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>n</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq60.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> correspond to the same feature <inline-formula id="ID61">
<alternatives>
<mml:math display="block" id="I61">
<mml:mfenced>
<mml:mrow>
<mml:msubsup>
<mml:mi>M</mml:mi>
<mml:mrow>
<mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow>
<mml:mo>*</mml:mo>
</mml:msubsup>
<mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
</mml:mfenced>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq61.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula>
, then we expect that</p>
<disp-formula id="FD18">
<alternatives>
<mml:math display="block" id="M18">
<mml:mi mathvariant="normal">corr</mml:mi><mml:mfenced>
<mml:mrow>
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>,</mml:mo><mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>k</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfenced><mml:mo>≈</mml:mo><mml:mi mathvariant="normal">corr</mml:mi><mml:mfenced>
<mml:mrow>
<mml:msub>
<mml:mi>Y</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mo>,</mml:mo><mml:msub>
<mml:mi>Y</mml:mi>
<mml:mi>l</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfenced><mml:mtext>if</mml:mtext><mml:msubsup>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mtext>ij</mml:mtext></mml:mrow>
<mml:mo>*</mml:mo>
</mml:msubsup>
<mml:mo>=</mml:mo><mml:msubsup>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mtext>k</mml:mtext><mml:mn>1</mml:mn></mml:mrow>
<mml:mo>*</mml:mo>
</mml:msubsup>
<mml:mo>=</mml:mo><mml:mn>1.</mml:mn>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn18.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(18)</label>
</disp-formula>
<p>Here we define corr(<italic>u, v</italic>) to be the Pearson correlation coefficient between two feature intensity vectors <italic>u, v</italic> ϵ <bold>ℝ</bold><sup><italic>n</italic></sup> by</p>
<disp-formula id="FD19">
<alternatives>
<mml:math display="block" id="M19">
<mml:mi mathvariant="normal">corr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac>
<mml:mrow>
<mml:mo>〈</mml:mo><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mover accent="true">
<mml:mi>u</mml:mi>
<mml:mo>¯</mml:mo>
</mml:mover>
<mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>−</mml:mo><mml:mover accent="true">
<mml:mi>v</mml:mi>
<mml:mo>¯</mml:mo>
</mml:mover>
<mml:mo>〉</mml:mo></mml:mrow>
<mml:mrow>
<mml:mo>‖</mml:mo><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mover accent="true">
<mml:mi>u</mml:mi>
<mml:mo>¯</mml:mo>
</mml:mover>
<mml:mo>‖</mml:mo><mml:mo>‖</mml:mo><mml:mi>v</mml:mi><mml:mo>−</mml:mo><mml:mover accent="true">
<mml:mi>v</mml:mi>
<mml:mo>¯</mml:mo>
</mml:mover>
<mml:mo>‖</mml:mo></mml:mrow>
</mml:mfrac>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn19.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(19)</label>
</disp-formula>
<p>where we define</p>
<disp-formula id="FD20">
<alternatives>
<mml:math display="block" id="M20">
<mml:mover accent="true">
<mml:mi>u</mml:mi>
<mml:mo>¯</mml:mo>
</mml:mover>
<mml:mo>=</mml:mo><mml:mfrac>
<mml:mn>1</mml:mn>
<mml:mi>n</mml:mi>
</mml:mfrac>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mi>n</mml:mi>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>u</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle><mml:mo>,</mml:mo><mml:mo>‖</mml:mo><mml:mi>u</mml:mi><mml:mo>‖</mml:mo><mml:mo>=</mml:mo><mml:msqrt>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mi>n</mml:mi>
</mml:munderover>
<mml:mrow>
<mml:msubsup>
<mml:mi>u</mml:mi>
<mml:mi>i</mml:mi>
<mml:mn>2</mml:mn>
</mml:msubsup>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:msqrt>
<mml:mo>,</mml:mo><mml:mo>〈</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>〉</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mi>n</mml:mi>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>u</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>v</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn20.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(20)</label>
</disp-formula>
<p>as the mean value, Euclidean norm and inner product respectively. More generally, with <italic>d<sub>x</sub></italic> and <italic>d<sub>y</sub></italic> denoting two given distances on <inline-formula id="ID62">
<alternatives>
<mml:math display="block" id="I62">
<mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>n</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq62.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> and <inline-formula id="ID63">
<alternatives>
<mml:math display="block" id="I63">
<mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>n</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq63.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> respectively, we expect that</p>
<disp-formula id="FD21">
<alternatives>
<mml:math display="block" id="M21">
<mml:msub>
<mml:mi>d</mml:mi>
<mml:mi>x</mml:mi>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>,</mml:mo><mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>k</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfenced><mml:mo>≈</mml:mo><mml:msub>
<mml:mi>d</mml:mi>
<mml:mi>y</mml:mi>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:msub>
<mml:mi>Y</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mo>,</mml:mo><mml:msub>
<mml:mi>Y</mml:mi>
<mml:mi>l</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfenced><mml:mtext>if</mml:mtext><mml:msubsup>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mtext>ij</mml:mtext></mml:mrow>
<mml:mo>*</mml:mo>
</mml:msubsup>
<mml:mo>=</mml:mo><mml:msubsup>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mtext>kl</mml:mtext></mml:mrow>
<mml:mo>*</mml:mo>
</mml:msubsup>
<mml:mo>=</mml:mo><mml:mn>1</mml:mn>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn21.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(21)</label>
</disp-formula>
<p>Throughout this paper, we use the normalized Euclidean distance defined for any <italic>u, v</italic> ϵ ℝ<sup><italic>n</italic></sup> as</p>
<disp-formula id="FD22">
<alternatives>
<mml:math display="block" id="M22">
<mml:msup>
<mml:mi>d</mml:mi>
<mml:mrow>
<mml:mtext>euc</mml:mtext></mml:mrow>
</mml:msup>
<mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac>
<mml:mn>1</mml:mn>
<mml:mrow>
<mml:msqrt>
<mml:mi>n</mml:mi>
</mml:msqrt>
</mml:mrow>
</mml:mfrac>
<mml:mo>‖</mml:mo><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mi>v</mml:mi><mml:mo>‖</mml:mo>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn22.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(22)</label>
</disp-formula>
<p>where for <italic>d<sub>x</sub></italic> and <italic>d<sub>y</sub></italic> we take <italic>n</italic> = <italic>n</italic><sub>1</sub>, <italic>n</italic><sub>2</sub> respectively. If the signal intensity vectors <italic>u, v</italic> are mean centered and normalized by their standard deviation as</p>
<disp-formula id="FD23">
<alternatives>
<mml:math display="block" id="M23">
<mml:mi>u</mml:mi><mml:mo>↦</mml:mo><mml:msqrt>
<mml:mi>n</mml:mi>
</mml:msqrt>
<mml:mo>⋅</mml:mo><mml:mfrac>
<mml:mrow>
<mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mfrac>
<mml:mn>1</mml:mn>
<mml:mi>n</mml:mi>
</mml:mfrac>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mi>n</mml:mi>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>u</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
<mml:mrow>
<mml:mfenced close="‖" open="‖">
<mml:mrow>
<mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mfrac>
<mml:mn>1</mml:mn>
<mml:mi>n</mml:mi>
</mml:mfrac>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mi>n</mml:mi>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>u</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mfrac>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn23.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(23)</label>
</disp-formula>
<p>and likewise for <italic>v</italic>, then it follows that</p>
<disp-formula id="FD24">
<alternatives>
<mml:math display="block" id="M24">
<mml:msup>
<mml:mi>d</mml:mi>
<mml:mrow>
<mml:mtext>euc</mml:mtext></mml:mrow>
</mml:msup>
<mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msqrt>
<mml:mrow>
<mml:mn>2</mml:mn><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi mathvariant="normal">corr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow>
</mml:msqrt>
<mml:mo>=</mml:mo><mml:msqrt>
<mml:mn>2</mml:mn>
</mml:msqrt>
<mml:msup>
<mml:mi>d</mml:mi>
<mml:mrow>
<mml:mi>cos</mml:mi></mml:mrow>
</mml:msup>
<mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn24.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(24)</label>
</disp-formula>
<p>where we denote <inline-formula id="ID64">
<alternatives>
<mml:math display="block" id="I64">
<mml:msup>
<mml:mi>d</mml:mi>
<mml:mrow>
<mml:mi>cos</mml:mi></mml:mrow>
</mml:msup>
<mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msqrt>
<mml:mrow>
<mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi mathvariant="normal">corr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
</mml:msqrt>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq64.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> as the cosine distance. For the purposes of this paper, we will always assume that <italic>d<sub>x</sub></italic> and <italic>d<sub>y</sub></italic> denote the normalized Euclidean distance from (22). As shown above, this will be implicitly equal to the cosine distance from (24) on centered and scaled data.</p>
<p>The goal of metabolomic feature matching is to learn the binary matching matrix <italic>M*</italic> that aligns the distances between pairs of features in the most consistent way possible as shown in (21). To formalize this notion into a practical algorithm, we use the mathematical theory of optimal transport <xref ref-type="bibr" rid="c30">Peyré et al. (2019)</xref> which we discuss next.</p>
</sec>
<sec id="s12">
<title>Optimal transport</title>
<p>Optimal transport (OT) applies in the setting when the points <inline-formula id="ID65">
<alternatives>
<mml:math display="block" id="I65">
<mml:msubsup>
<mml:mfenced close="}" open="{">
<mml:mrow>
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfenced>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq65.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> and <inline-formula id="ID66">
<alternatives>
<mml:math display="block" id="I66">
<mml:msubsup>
<mml:mfenced close="}" open="{">
<mml:mrow>
<mml:msub>
<mml:mi>Y</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfenced>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq66.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> being matched live in the same dimensional space <italic>n</italic><sub>1</sub> = <italic>n</italic><sub>2</sub> = <italic>n</italic>. It aims to find a matching between each point <italic>X<sub>i</sub></italic> and its corresponding point <italic>Y<sub>j</sub></italic> such that the sum of distances between matches is minimized. Matches between each pair of points can be stored in a matching matrix <inline-formula id="ID67">
<alternatives>
<mml:math display="block" id="I67">
<mml:mrow><mml:mi>M</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math><inline-graphic xlink:href="2306.03218v3_ieq67.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> such that <italic>M<sub>ij</sub></italic> = 1 if <italic>X<sub>i</sub></italic> and <italic>Y<sub>j</sub></italic> are matched, and <italic>M<sub>ij</sub></italic> = 0 otherwise. Again we note that <italic>M</italic> must have at most one nonzero entry in each row and column to be a valid matching matrix.</p>
<p>Instead of searching over this space of binary matching matrices, optimal transport places masses <italic>a<sub>i</sub> ≥</italic> 0 at all points <italic>X<sub>i</sub></italic> for <italic>i</italic> = 1<italic>,…,p</italic> 1 and masses <italic>b<sub>j</sub> ≥</italic> 0 at all points <italic>Y<sub>y</sub></italic> for <italic>j</italic> = 1<italic>, …, p</italic><sub>2</sub> and optimizes over the space of probabilistic <italic>couplings</italic> <inline-formula id="ID68">
<alternatives>
<mml:math display="block" id="I68">
<mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>×</mml:mo><mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq68.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> which move a n<sub><italic>ij</italic></sub> amount of mass from <italic>X<sub>i</sub></italic> to <italic>Y<sub>j</sub></italic>. We assume here for simplicity that the sum of masses in both datasets are equal to one <inline-formula id="ID69">
<alternatives>
<mml:math display="block" id="I69">
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle><mml:mo>=</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle><mml:mo>=</mml:mo><mml:mn>1</mml:mn>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq69.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> and that the coupling ∏ transports all mass from <italic>a</italic> into <italic>b</italic>. More formally, optimal transport optimizes over the constrained set of couplings</p>
<disp-formula id="FD25">
<alternatives>
<mml:math display="block" id="M25">
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>U</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfenced open="{">
<mml:mrow>
<mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>×</mml:mo><mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
<mml:mo>:</mml:mo><mml:mi>Π</mml:mi><mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo><mml:mi>a</mml:mi></mml:mrow>
</mml:mfenced><mml:mtext>and</mml:mtext><mml:mfenced close="}">
<mml:mrow>
<mml:msup>
<mml:mi>Π</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo><mml:mi>b</mml:mi></mml:mrow>
</mml:mfenced>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn25.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(25)</label>
</disp-formula>
<p>where <bold>1</bold><sub><italic>p</italic></sub> denotes the all ones vector of length <italic>p</italic>. In practice, the points <italic>X<sub>i</sub></italic> and <italic>Y<sub>j</sub></italic> in each dataset are all treated the same and the masses placed on the data are chosen to be uniform <inline-formula id="ID70">
<alternatives>
<mml:math display="block" id="I70">
<mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mfrac>
<mml:mn>1</mml:mn>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:mfrac>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq70.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> and <inline-formula id="ID71">
<alternatives>
<mml:math display="block" id="I71">
<mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mfrac>
<mml:mn>1</mml:mn>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:mfrac>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq71.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula>.</p>
<p>The cost function which optimal transport minimizes is the sum of squared distances of its transported mass</p>
<disp-formula id="FD26">
<alternatives>
<mml:math display="block" id="M26">
<mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:mi>d</mml:mi><mml:mfenced>
<mml:mrow>
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>,</mml:mo><mml:msub>
<mml:mi>Y</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfenced>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn26.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(26)</label>
</disp-formula>
<p>where <inline-formula id="ID72">
<alternatives>
<mml:math display="block" id="I72">
<mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msup>
<mml:mi>d</mml:mi>
<mml:mrow>
<mml:mtext>euc</mml:mtext></mml:mrow>
</mml:msup>
<mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac>
<mml:mn>1</mml:mn>
<mml:mrow>
<mml:msqrt>
<mml:mi>n</mml:mi>
</mml:msqrt>
</mml:mrow>
</mml:mfrac>
<mml:mo>‖</mml:mo><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mi>v</mml:mi><mml:mo>‖</mml:mo>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq72.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> is the Euclidean distance. The distance matrix <italic>d</italic>(<italic>X<sub>i</sub>,Y<sub>j</sub></italic>) in the OT objective can be replaced more generally with a cost matrix <inline-formula id="ID73">
<alternatives>
<mml:math display="block" id="I73">
<mml:mi>C</mml:mi><mml:mo>∈</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>×</mml:mo><mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq73.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> that is not necessarily a distance matrix. In this case the cost function becomes</p><disp-formula id="FD27">
<alternatives>
<mml:math display="block" id="M27">
<mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>C</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn27.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(27)</label>
</disp-formula>
<p>When the transport cost <italic>C<sub>ij</sub></italic> is a distance, the OT optimization defines a valid distance metric known as the <italic>optimal transport distance</italic> between discrete distributions <inline-formula id="ID74">
<alternatives>
<mml:math display="block" id="I74">
<mml:msubsup>
<mml:mfenced close="}" open="{">
<mml:mrow>
<mml:mfenced>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>,</mml:mo><mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mfenced>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq74.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> and <inline-formula id="ID75">
<alternatives>
<mml:math display="block" id="I75">
<mml:msubsup>
<mml:mfenced close="}" open="{">
<mml:mrow>
<mml:mfenced>
<mml:mrow>
<mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mo>,</mml:mo><mml:msub>
<mml:mi>Y</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mfenced>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq75.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> in ℝ<sup><italic>n</italic></sup> given by</p><disp-formula id="FD28">
<alternatives>
<mml:math display="block" id="M28">
<mml:mtext>OT</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub>
<mml:mi>min</mml:mi>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>U</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
</mml:msub>
<mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn28.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(28)</label>
</disp-formula>
<p>When <italic>d</italic>(<italic>u, v</italic>) is Euclidean, this OT distance is also referred to as the <italic>L</italic><sup>1</sup> optimal transport distance, the Wasserstein 1-distance, or the Earth mover’s distance. As formulated, the computation of the optimal transport objective involves an optimization over coupling matrices ∏ which can be solved by linear programming <xref ref-type="bibr" rid="c30">Peyré et al. (2019)</xref>. The OT optimization problem becomes time consuming for problems with many points <italic>p</italic><sub>1</sub>, <italic>p</italic><sub>2</sub> ≫ 1. We show in the next section how augmenting this distance with a regularization term leads to a more efficient algorithm for learning the optimal coupling ∏.</p>
</sec>
<sec id="s13">
<title>Entropic regularization</title>
<p>Define the Kullback-Leibler (KL) divergence between two positive vectors <inline-formula id="ID76">
<alternatives>
<mml:math display="block" id="I76">
<mml:mi>μ</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mi>p</mml:mi>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq76.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> as</p>
<disp-formula id="FD29">
<alternatives>
<mml:math display="block" id="M29">
<mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mi>p</mml:mi>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>μ</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle><mml:mi>ln</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mi>μ</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>v</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:mfenced><mml:mo>−</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mi>p</mml:mi>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>μ</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle><mml:mo>+</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mi>p</mml:mi>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>v</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn29.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(29)</label>
</disp-formula>
<p>Given fixed marginals <inline-formula id="ID77">
<alternatives>
<mml:math display="block" id="I77">
<mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq77.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> and <inline-formula id="ID78">
<alternatives>
<mml:math display="block" id="I78">
<mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq78.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> from the previous section, we can define the entropy of a coupling matrix <inline-formula id="ID79">
<alternatives>
<mml:math display="block" id="I79">
<mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>×</mml:mo><mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq79.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> with respect to these fixed marginals as</p>
<disp-formula id="FD30">
<alternatives>
<mml:math display="block" id="M30">
<mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:mi>ln</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:mfenced><mml:mo>−</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:mo>+</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mo>.</mml:mo>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn30.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(30)</label>
</disp-formula>
<p>where (<italic>a</italic> ⊗<italic> b</italic>)<sub><italic>iJ</italic></sub> = <italic>a<sub>i</sub>b<sub>j</sub></italic> denotes the outer product. This can be further simplified as</p>
<disp-formula id="FD31">
<alternatives>
<mml:math display="block" id="M31">
<mml:mtable columnalign="left" equalrows="true" equalcolumns="true">
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>=</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mo>=</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:mi>ln</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:mfenced><mml:mo>−</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:mo>+</mml:mo><mml:mfenced>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mfenced><mml:mfenced>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow/>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>=</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:mi>ln</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow/>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>=</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mi>H</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>ln</mml:mi><mml:mfenced>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:mfenced><mml:mo>+</mml:mo><mml:mi>ln</mml:mi><mml:mfenced>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn31.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(31)</label>
</disp-formula>
<p>where we define <italic>H</italic>(∏) by</p><disp-formula id="FD32">
<alternatives>
<mml:math display="block" id="M32">
<mml:mi>H</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:mi>ln</mml:mi><mml:mfenced>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mfenced><mml:mo>.</mml:mo>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn32.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(32)</label>
</disp-formula>
<p>In the second line of the derivation above, we used the fact that the entries of <italic>a, b</italic>, and ∏ summed to one, and in the third line we used the fact that the marginals <italic>a</italic> and <italic>b</italic> were uniform. Under these assumptions, we see that the KL divergence <italic>D</italic> <sub>KL</sub>(∏ <italic>,a</italic> ⊗<italic> b</italic>) is independent of the values of the marginals <italic>a, b</italic> and is equal to <italic>H</italic>(∏) up to constants.</p>
<p>Although here the general definition of entropy through the KL divergence reduces to the simpler formula of <italic>H</italic>(∏), in the following sections we will need to extend our analysis to cases when <italic>a, b</italic>, and ∏ have positive values that do not sum to one (i.e. not distributions). In this context, we will no longer have that <italic>D</italic> <sub>KL</sub>(∏, <italic>a</italic> ⊗ <italic>b</italic>) = <italic>H</italic> (∏) + <italic>const</italic> but we will still be able to use <italic>D</italic> <sub>KL</sub>(∏<italic>, a</italic> ⊗ <italic>b</italic>) as a general notion of entropy for n.</p>
<p>The entropy of a coupling <italic>D</italic><sub>KL</sub>(n<italic>, a</italic>⊗<italic>b</italic>) is an important notion because it quantifies how uniform or smooth ∏ is with respect to the product distribution <italic>a</italic> ⊗<italic> b</italic>. In particular, if <italic>a</italic> and <italic>b</italic> are set to uniform distributions as commonly done in practice, then <italic>D</italic> <sub>KL</sub>(∏<italic>, a</italic> ⊗ <italic>b</italic>) is small when ∏ has close to uniform entries and is large otherwise. This notion of smoothness allows us to use <italic>D</italic> <sub>KL</sub>(∏<italic>, a</italic> ⊗ <italic>b</italic>) as a regularizer in our optimal transport distance as</p>
<disp-formula id="FD33">
<alternatives>
<mml:math display="block" id="M33">
<mml:msub>
<mml:mi mathvariant="script">L</mml:mi>
<mml:mi>ε</mml:mi>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>C</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn33.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(33)</label>
</disp-formula>
<p>where <italic>e</italic> is a small regularization parameter. Note that here we have denoted the transport cost matrix by <inline-formula id="ID80">
<alternatives>
<mml:math display="block" id="I80">
<mml:mi>C</mml:mi><mml:mo>∈</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>×</mml:mo><mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq80.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> which is not necessarily a distance matrix. The introduction of the regularizer <italic>ϵ D</italic><sc><sub>KL</sub></sc>(∏<italic>, a</italic>⊗<italic>b</italic>) gives us an efficient iterative algorithm known as the <italic>Sinkhorn algorithm</italic> for optimizing ∏ which we describe in the following sections.</p>
</sec>
<sec id="s15">
<title>Unbalanced optimal transport</title>
<p>Before we introduce the Sinkhorn algorithm, we introduce a final modification to our optimal transport distance that allows us to learn couplings between distributions <inline-formula id="ID81">
<alternatives>
<mml:math display="block" id="I81">
<mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mi>p</mml:mi>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq81.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> that do not preserve mass. In other words, the coupling ∏ is not required to perfectly satisfy the marginal constraints <inline-formula id="ID82">
<alternatives>
<mml:math display="block" id="I82">
<mml:mi>Π</mml:mi><mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo><mml:mi>a</mml:mi>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq82.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> and <inline-formula id="ID83">
<alternatives>
<mml:math display="block" id="I83">
<mml:msup>
<mml:mi>Π</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo><mml:mi>b</mml:mi>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq83.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula>. In our metabolite matching problem, this is particularly useful as not all metabolites in one dataset necessarily appear in the other dataset and hence should be left unmatched. This modification of optimal transport, known as unbalanced optimal transport (UOT) <xref ref-type="bibr" rid="c10">Chizat et al. (2018)</xref>, optimizes the following cost function</p>
<disp-formula id="FD34">
<alternatives>
<mml:math display="block" id="M34">
<mml:mrow>
<mml:msub>
<mml:mi mathvariant="script">L</mml:mi>
<mml:mrow>
<mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>C</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:msub>
<mml:mn>1</mml:mn>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo><mml:mi>a</mml:mi></mml:mrow>
</mml:mfenced><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:msup>
<mml:mi>Π</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow>
</mml:mfenced><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn34.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(34)</label>
</disp-formula>
<p>where we have added two KL terms with regularization parameter <italic>p</italic> to enforce that the marginals of the coupling <inline-formula id="ID84">
<alternatives>
<mml:math display="block" id="I84">
<mml:mi>Π</mml:mi><mml:msub>
<mml:mn>1</mml:mn>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo><mml:msup>
<mml:mi>Π</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq84.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> are approximately close to the prescribed marginals <italic>a, b</italic> respectively. We have also kept the smoothness/entropy regularizer <italic>ϵD</italic> <sub>KL</sub>(∏<italic>, a</italic>⊗<italic>b</italic>) from the previous section.</p>
</sec>
<sec id="s16">
<title>Unbalanced Sinkhorn algorithm</title>
<p>Now we are ready to present the unbalanced Sinkhorn algorithm <xref ref-type="bibr" rid="c30">Peyré etal. (2019)</xref> for optimizing the unbalanced optimal transport cost defined above. First we rewrite our optimization as</p><disp-formula id="UFD1">
<alternatives>
<mml:math display="block" id="UM1">
<mml:mtable columnalign="left" equalrows="true" equalcolumns="true">
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>min</mml:mi></mml:mrow>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>×</mml:mo><mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
</mml:msub>
<mml:msub>
<mml:mi mathvariant="script">L</mml:mi>
<mml:mrow>
<mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>=</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>min</mml:mi></mml:mrow>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>×</mml:mo><mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
</mml:msub>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>C</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo><mml:mi>a</mml:mi></mml:mrow>
</mml:mfenced><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:msup>
<mml:mi>Π</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow>
</mml:mfenced><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow/>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>=</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>min</mml:mi></mml:mrow>
<mml:mrow>
<mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
</mml:msub>
<mml:msub>
<mml:mrow>
<mml:mi>min</mml:mi></mml:mrow>
<mml:mtable>
<mml:mtr>
<mml:mtd>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>×</mml:mo><mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:msup>
<mml:mi>Π</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo><mml:mi>v</mml:mi></mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:msub>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>C</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:math>
<graphic xlink:href="2306.03218v3_ueqn1.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</disp-formula>
<p>The inner minimization can be solved exactly by introducing dual variables <inline-formula id="ID85">
<alternatives>
<mml:math display="block" id="I85">
<mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
<mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo>∈</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq85.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> and writing out the Lagrange dual problem</p><disp-formula id="UFD2">
<alternatives>
<mml:math display="block" id="UM2">
<mml:msub>
<mml:mi>min</mml:mi>
<mml:mtable>
<mml:mtr>
<mml:mtd>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>×</mml:mo><mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:msup>
<mml:mi>Π</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo><mml:mi>v</mml:mi></mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:msub>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>C</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msup>
<mml:mi>f</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:mfenced>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>−</mml:mo><mml:mi>u</mml:mi></mml:mrow>
</mml:mfenced><mml:mo>−</mml:mo><mml:msup>
<mml:mi>g</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:mfenced>
<mml:mrow>
<mml:msup>
<mml:mi>Π</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>−</mml:mo><mml:mi>v</mml:mi></mml:mrow>
</mml:mfenced><mml:mo>=</mml:mo><mml:mtext> </mml:mtext><mml:msub>
<mml:mi>max</mml:mi>
<mml:mrow>
<mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
<mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo>∈</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:msub>
<mml:msub>
<mml:mi>min</mml:mi>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>×</mml:mo><mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
</mml:msub>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>C</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msup>
<mml:mi>f</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:mfenced>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>−</mml:mo><mml:mi>u</mml:mi></mml:mrow>
</mml:mfenced><mml:mo>−</mml:mo><mml:msup>
<mml:mi>g</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:mfenced>
<mml:mrow>
<mml:msup>
<mml:mi>Π</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>−</mml:mo><mml:mi>v</mml:mi></mml:mrow>
</mml:mfenced><mml:mo>.</mml:mo>
</mml:math>
<graphic xlink:href="2306.03218v3_ueqn2.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</disp-formula>
<p>where we have removed the terms <italic>ρD</italic><sc><sub>kl</sub>(</sc><italic>u<sc>,</sc> a</italic>) and <italic>ρD</italic><sub>kl</sub>(<italic>v, b</italic>) since they do not depend on ∏. Taking the gradient in ∏ in the inner minimization and setting it to zero we get</p><disp-formula id="UFD3">
<alternatives>
<mml:math display="block" id="UM3">
<mml:msub>
<mml:mi>C</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:mi>log</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:mfenced><mml:mo>−</mml:mo><mml:msub>
<mml:mi>f</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>−</mml:mo><mml:msub>
<mml:mi>g</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mo>=</mml:mo><mml:mn>0</mml:mn>
</mml:math>
<graphic xlink:href="2306.03218v3_ueqn3.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</disp-formula>
<p>which implies that</p><disp-formula id="UFD4">
<alternatives>
<mml:math display="block" id="UM4">
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo><mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mi>exp</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mi>f</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>+</mml:mo><mml:msub>
<mml:mi>g</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mo>−</mml:mo><mml:msub>
<mml:mi>C</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mi>ε</mml:mi>
</mml:mfrac>
</mml:mrow>
</mml:mfenced>
</mml:math>
<graphic xlink:href="2306.03218v3_ueqn4.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</disp-formula>
<p>Now we can substitute this expression for ∏ back into our Lagrange dual problem. First we compute</p>
<disp-formula id="UFD5">
<alternatives>
<mml:math display="block" id="UM5">
<mml:mi>ε</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:mfenced>
<mml:mrow>
<mml:msub>
<mml:mi>f</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>+</mml:mo><mml:msub>
<mml:mi>g</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mo>−</mml:mo><mml:msub>
<mml:mi>C</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mfenced><mml:mo>−</mml:mo><mml:mi>ε</mml:mi><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:math>
<graphic xlink:href="2306.03218v3_ueqn5.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</disp-formula>
<p>which implies that</p>
<disp-formula id="UFD6">
<alternatives>
<mml:math display="block" id="UM6">
<mml:mtable columnalign="left">
<mml:mtr>
<mml:mtd>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>C</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msup>
<mml:mi>f</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:mfenced>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>−</mml:mo><mml:mi>u</mml:mi></mml:mrow>
</mml:mfenced><mml:mo>−</mml:mo><mml:msup>
<mml:mi>g</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:mfenced>
<mml:mrow>
<mml:msup>
<mml:mi>Π</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>−</mml:mo><mml:mi>v</mml:mi></mml:mrow>
</mml:mfenced><mml:mtext> </mml:mtext><mml:mo>=</mml:mo><mml:msup>
<mml:mi>u</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:mi>f</mml:mi><mml:mo>+</mml:mo><mml:msup>
<mml:mi>v</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:mi>g</mml:mi><mml:mo>−</mml:mo><mml:mi>ε</mml:mi><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mi>exp</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mi>f</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>+</mml:mo><mml:msub>
<mml:mi>g</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mo>−</mml:mo><mml:msub>
<mml:mi>C</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mi>ε</mml:mi>
</mml:mfrac>
</mml:mrow>
</mml:mfenced><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mo>.</mml:mo>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mrow/>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mi mathvariant="normal">ma</mml:mi>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:math>
<graphic xlink:href="2306.03218v3_ueqn6.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</disp-formula>
<p>Hence, the outer maximization in our Lagrange dual problem for <italic>f</italic> and <italic>g</italic> can now be written as</p><disp-formula id="UFD7">
<alternatives>
<mml:math display="block" id="UM7">
<mml:msub>
<mml:mi>x</mml:mi>
<mml:mrow>
<mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
<mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo>∈</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:msub>
<mml:msup>
<mml:mi>u</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:mi>f</mml:mi><mml:mo>+</mml:mo><mml:msup>
<mml:mi>v</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:mi>g</mml:mi><mml:mo>−</mml:mo><mml:mi>ε</mml:mi><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mi>exp</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mi>f</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>+</mml:mo><mml:msub>
<mml:mi>g</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mo>−</mml:mo><mml:msub>
<mml:mi>C</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mi>ε</mml:mi>
</mml:mfrac>
</mml:mrow>
</mml:mfenced>
</mml:math>
<graphic xlink:href="2306.03218v3_ueqn7.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</disp-formula>
<p>where we have removed the last constant sum in <italic>a<sub>i</sub>b<sub>j</sub></italic>. Finally we can rewrite our entire minimization from the start of this section as</p><disp-formula id="UFD8">
<alternatives>
<mml:math display="block" id="UM8">
<mml:mtable columnalign="left">
<mml:mtr>
<mml:mtd>
<mml:mtable columnalign="left" equalrows="true" equalcolumns="true">
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>min</mml:mi></mml:mrow>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>×</mml:mo><mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
</mml:msub>
<mml:msub>
<mml:mi mathvariant="script">L</mml:mi>
<mml:mrow>
<mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>=</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>min</mml:mi></mml:mrow>
<mml:mrow>
<mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
<mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
</mml:msub>
<mml:msub>
<mml:mrow>
<mml:mi>min</mml:mi></mml:mrow>
<mml:mtable>
<mml:mtr>
<mml:mtd>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>×</mml:mo><mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:msub>
<mml:mn>1</mml:mn>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:msup>
<mml:mi>Π</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo><mml:mi>v</mml:mi></mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:msub>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>C</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow/>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>=</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>min</mml:mi></mml:mrow>
<mml:mrow>
<mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
<mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
</mml:msub>
<mml:msub>
<mml:mrow>
<mml:mi>max</mml:mi></mml:mrow>
<mml:mrow>
<mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
<mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo>∈</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:msub>
<mml:msup>
<mml:mi>u</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:mi>f</mml:mi><mml:mo>+</mml:mo><mml:msup>
<mml:mi>v</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:mi>g</mml:mi><mml:mo>−</mml:mo><mml:mi>ε</mml:mi><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mi>exp</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mi>f</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>+</mml:mo><mml:msub>
<mml:mi>g</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mo>−</mml:mo><mml:msub>
<mml:mi>C</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mi>ε</mml:mi>
</mml:mfrac>
</mml:mrow>
</mml:mfenced><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mrow/>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mtable columnalign="left" equalrows="true" equalcolumns="true">
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>min</mml:mi></mml:mrow>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:mi>p</mml:mi><mml:mo>⊥</mml:mo><mml:mo>×</mml:mo><mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
</mml:msub>
<mml:msub>
<mml:mi mathvariant="script">L</mml:mi>
<mml:mrow>
<mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>=</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>max</mml:mi></mml:mrow>
<mml:mrow>
<mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
<mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo>∈</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:msub>
<mml:msub>
<mml:mrow>
<mml:mi>min</mml:mi></mml:mrow>
<mml:mrow>
<mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
<mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
</mml:msub>
<mml:msup>
<mml:mi>u</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:mi>f</mml:mi><mml:mo>+</mml:mo><mml:msup>
<mml:mi>v</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:mi>g</mml:mi><mml:mo>−</mml:mo><mml:mi>ε</mml:mi><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mi>exp</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mi>f</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>+</mml:mo><mml:msub>
<mml:mi>g</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mo>−</mml:mo><mml:msub>
<mml:mi>C</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mi>ε</mml:mi>
</mml:mfrac>
</mml:mrow>
</mml:mfenced><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow/>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>=</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msup>
<mml:mi>U</mml:mi>
<mml:mo>*</mml:mo>
</mml:msup>
<mml:mo stretchy="false">(</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msup>
<mml:mi>V</mml:mi>
<mml:mo>*</mml:mo>
</mml:msup>
<mml:mo stretchy="false">(</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>ε</mml:mi><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mi>exp</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mi>f</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>+</mml:mo><mml:msub>
<mml:mi>g</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mo>−</mml:mo><mml:msub>
<mml:mi>C</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mi>ε</mml:mi>
</mml:mfrac>
</mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:math>
<graphic xlink:href="2306.03218v3_ueqn8.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</disp-formula>
<p>By strong duality, we can interchange the minimum and maximum above to write</p><disp-formula id="UFD9">
<alternatives>
<mml:math display="block" id="UM9">
<mml:mtable columnalign="left" equalrows="true" equalcolumns="true">
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>min</mml:mi></mml:mrow>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:mi>p</mml:mi><mml:mo>⊥</mml:mo><mml:mo>×</mml:mo><mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
</mml:msub>
<mml:msub>
<mml:mi mathvariant="script">L</mml:mi>
<mml:mrow>
<mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>=</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>max</mml:mi></mml:mrow>
<mml:mrow>
<mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
<mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo>∈</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:msub>
<mml:msub>
<mml:mrow>
<mml:mi>min</mml:mi></mml:mrow>
<mml:mrow>
<mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
<mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
</mml:msub>
<mml:msup>
<mml:mi>u</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:mi>f</mml:mi><mml:mo>+</mml:mo><mml:msup>
<mml:mi>v</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:mi>g</mml:mi><mml:mo>−</mml:mo><mml:mi>ε</mml:mi><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mi>exp</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mi>f</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>+</mml:mo><mml:msub>
<mml:mi>g</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mo>−</mml:mo><mml:msub>
<mml:mi>C</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mi>ε</mml:mi>
</mml:mfrac>
</mml:mrow>
</mml:mfenced><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow/>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>=</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msup>
<mml:mi>U</mml:mi>
<mml:mo>*</mml:mo>
</mml:msup>
<mml:mo stretchy="false">(</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msup>
<mml:mi>V</mml:mi>
<mml:mo>*</mml:mo>
</mml:msup>
<mml:mo stretchy="false">(</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>ε</mml:mi><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mi>exp</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mi>f</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>+</mml:mo><mml:msub>
<mml:mi>g</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mo>−</mml:mo><mml:msub>
<mml:mi>C</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mi>ε</mml:mi>
</mml:mfrac>
</mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:math>
<graphic xlink:href="2306.03218v3_ueqn9.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</disp-formula>
<p>where we define the functions</p><disp-formula id="FD35">
<alternatives>
<mml:math display="block" id="M35">
<mml:mtable columnalign="left">
<mml:mtr>
<mml:mtd>
<mml:msup>
<mml:mi>U</mml:mi>
<mml:mo>*</mml:mo>
</mml:msup>
<mml:mo stretchy="false">(</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub>
<mml:mi>min</mml:mi>
<mml:mrow>
<mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
</mml:msub>
<mml:msup>
<mml:mi>u</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:mi>f</mml:mi><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:msup>
<mml:mi>V</mml:mi>
<mml:mo>*</mml:mo>
</mml:msup>
<mml:mo stretchy="false">(</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub>
<mml:mi>min</mml:mi>
<mml:mrow>
<mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
</mml:msub>
<mml:msup>
<mml:mi>v</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:mi>g</mml:mi><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn35.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(35)</label>
</disp-formula>
<p>In fact, we can solve the minimizations in <italic>U*</italic> and <italic>V*</italic> in closed form to get the minimizers <italic>u*</italic> = <italic>a</italic> ⊙ exp(–<italic>f</italic> /<italic>ρ</italic>) and <italic>v</italic>* = <italic>b</italic> ⊙ exp(–<italic>g</italic>/<italic>ρ</italic>) which we can substitute back in to get</p><disp-formula id="UFD10">
<alternatives>
<mml:math display="block" id="UM10">
<mml:mtable columnalign="left" equalrows="true" equalcolumns="true">
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msup>
<mml:mi>U</mml:mi>
<mml:mo>*</mml:mo>
</mml:msup>
<mml:mo stretchy="false">(</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>=</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msubsup>
<mml:mi>u</mml:mi>
<mml:mi>i</mml:mi>
<mml:mo>*</mml:mo>
</mml:msubsup>
</mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>f</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msubsup>
<mml:mi>u</mml:mi>
<mml:mi>i</mml:mi>
<mml:mo>*</mml:mo>
</mml:msubsup>
</mml:mrow>
</mml:mstyle><mml:mi>ln</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msubsup>
<mml:mi>u</mml:mi>
<mml:mi>i</mml:mi>
<mml:mo>*</mml:mo>
</mml:msubsup>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:mfenced><mml:mo>−</mml:mo><mml:mi>ρ</mml:mi><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msubsup>
<mml:mi>u</mml:mi>
<mml:mi>i</mml:mi>
<mml:mo>*</mml:mo>
</mml:msubsup>
</mml:mrow>
</mml:mstyle><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow/>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>=</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msubsup>
<mml:mi>u</mml:mi>
<mml:mi>i</mml:mi>
<mml:mo>*</mml:mo>
</mml:msubsup>
</mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>f</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>−</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msubsup>
<mml:mi>u</mml:mi>
<mml:mi>i</mml:mi>
<mml:mo>*</mml:mo>
</mml:msubsup>
</mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>f</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>−</mml:mo><mml:mi>ρ</mml:mi><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle><mml:mi>exp</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mo>−</mml:mo><mml:msub>
<mml:mi>f</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>/</mml:mo><mml:mi>ρ</mml:mi></mml:mrow>
</mml:mfenced><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow/>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>=</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mo>−</mml:mo><mml:mi>ρ</mml:mi><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle><mml:mi>exp</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mo>−</mml:mo><mml:msub>
<mml:mi>f</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>/</mml:mo><mml:mi>ρ</mml:mi></mml:mrow>
</mml:mfenced><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>ρ</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>.</mml:mo></mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:math>
<graphic xlink:href="2306.03218v3_ueqn10.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</disp-formula>
<p>Likewise we can see that</p><disp-formula id="UFD11">
<alternatives>
<mml:math display="block" id="UM11">
<mml:msup>
<mml:mi>V</mml:mi>
<mml:mo>*</mml:mo>
</mml:msup>
<mml:mo stretchy="false">(</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mi>ρ</mml:mi><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle><mml:mi>exp</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mo>−</mml:mo><mml:msub>
<mml:mi>g</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>/</mml:mo><mml:mi>ρ</mml:mi></mml:mrow>
</mml:mfenced><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle>
</mml:math>
<graphic xlink:href="2306.03218v3_ueqn11.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</disp-formula>
<p>Thus, we can rewrite our full optimization as</p><disp-formula id="UFD12">
<alternatives>
<mml:math display="block" id="UM12">
<mml:mtable columnalign="left" equalrows="true" equalcolumns="true">
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>min</mml:mi></mml:mrow>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>×</mml:mo><mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
</mml:msub>
<mml:msub>
<mml:mi mathvariant="script">L</mml:mi>
<mml:mrow>
<mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>=</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>max</mml:mi></mml:mrow>
<mml:mrow>
<mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
<mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo>∈</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:msub>
<mml:mo>−</mml:mo><mml:mi>ρ</mml:mi><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle><mml:mi>exp</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mo>−</mml:mo><mml:msub>
<mml:mi>f</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>/</mml:mo><mml:mi>ρ</mml:mi></mml:mrow>
</mml:mfenced><mml:mo>−</mml:mo><mml:mi>ρ</mml:mi><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle><mml:mi>exp</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mo>−</mml:mo><mml:msub>
<mml:mi>g</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>/</mml:mo><mml:mi>ρ</mml:mi></mml:mrow>
</mml:mfenced><mml:mo>−</mml:mo><mml:mi>ε</mml:mi><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mi>exp</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mi>f</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>+</mml:mo><mml:msub>
<mml:mi>g</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mo>−</mml:mo><mml:msub>
<mml:mi>C</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mi>ε</mml:mi>
</mml:mfrac>
</mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow/>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>=</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mi>min</mml:mi></mml:mrow>
<mml:mrow>
<mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
<mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo>∈</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
</mml:mrow>
</mml:msub>
<mml:mi>ρ</mml:mi><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle><mml:mi>exp</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mo>−</mml:mo><mml:msub>
<mml:mi>f</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>/</mml:mo><mml:mi>ρ</mml:mi></mml:mrow>
</mml:mfenced><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle><mml:mi>exp</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mo>−</mml:mo><mml:msub>
<mml:mi>g</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>/</mml:mo><mml:mi>ρ</mml:mi></mml:mrow>
</mml:mfenced><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mi>exp</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mi>f</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>+</mml:mo><mml:msub>
<mml:mi>g</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mo>−</mml:mo><mml:msub>
<mml:mi>C</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mi>ε</mml:mi>
</mml:mfrac>
</mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:math>
<graphic xlink:href="2306.03218v3_ueqn12.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</disp-formula>
<p>where we have removed the terms independent of <italic>f</italic> and <italic>g</italic>.</p>
<p>Note that now we can optimize the cost function above by performing an alternating minimization on the dual variables <italic>f</italic> and <italic>g</italic>. Taking the gradient in <italic>f</italic> and setting it to zero we see that</p><disp-formula id="UFD13">
<alternatives>
<mml:math display="block" id="UM13">
<mml:mo>−</mml:mo><mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mi>exp</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mo>−</mml:mo><mml:msub>
<mml:mi>f</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>/</mml:mo><mml:mi>ρ</mml:mi></mml:mrow>
</mml:mfenced><mml:mo>+</mml:mo><mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle><mml:mi>exp</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mi>f</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>+</mml:mo><mml:msub>
<mml:mi>g</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mo>−</mml:mo><mml:msub>
<mml:mi>C</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mi>ε</mml:mi>
</mml:mfrac>
</mml:mrow>
</mml:mfenced><mml:mo>=</mml:mo><mml:mn>0</mml:mn>
</mml:math>
<graphic xlink:href="2306.03218v3_ueqn13.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</disp-formula>
<p>which implies that</p><disp-formula id="UFD14">
<alternatives>
<mml:math display="block" id="UM14">
<mml:msub>
<mml:mi>f</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mfrac>
<mml:mrow>
<mml:mi>ε</mml:mi><mml:mi>ρ</mml:mi></mml:mrow>
<mml:mrow>
<mml:mi>ε</mml:mi><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi></mml:mrow>
</mml:mfrac>
<mml:mi>ln</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle><mml:mi>exp</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mi>g</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mo>−</mml:mo><mml:msub>
<mml:mi>C</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mi>ε</mml:mi>
</mml:mfrac>
</mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mfenced><mml:mo>.</mml:mo>
</mml:math>
<graphic xlink:href="2306.03218v3_ueqn14.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</disp-formula>
<p>Similarly, we can write out</p><disp-formula id="UFD15">
<alternatives>
<mml:math display="block" id="UM15">
<mml:msub>
<mml:mi>g</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mfrac>
<mml:mrow>
<mml:mi>ε</mml:mi><mml:mi>ρ</mml:mi></mml:mrow>
<mml:mrow>
<mml:mi>ε</mml:mi><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi></mml:mrow>
</mml:mfrac>
<mml:mi>ln</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle><mml:mi>exp</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mi>f</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>−</mml:mo><mml:msub>
<mml:mi>C</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mi>ε</mml:mi>
</mml:mfrac>
</mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mfenced><mml:mo>.</mml:mo>
</mml:math>
<graphic xlink:href="2306.03218v3_ueqn15.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</disp-formula>
<p>We are now ready to write out the full unbalanced Sinkhorn algorithm which performs an alternating minimization on the dual potentials <italic>f, g</italic> as outlined above. We remind the reader that the coupling matrix can be recovered from the dual potentials by the formula</p><disp-formula id="UFD16">
<alternatives>
<mml:math display="block" id="UM16">
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo><mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mi>exp</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mi>f</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>+</mml:mo><mml:msub>
<mml:mi>g</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mo>−</mml:mo><mml:msub>
<mml:mi>C</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mi>ε</mml:mi>
</mml:mfrac>
</mml:mrow>
</mml:mfenced><mml:mo>.</mml:mo>
</mml:math>
<graphic xlink:href="2306.03218v3_ueqn16.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</disp-formula>
<p>The unbalanced Sinkhorn algorithm proceeds as follows.</p>
<fig id="alg1" position="float" fig-type="figure">
<label>Algorithm 1</label>
<caption><title>UnbalancedSinkhorn</title></caption>
<graphic xlink:href="2306.03218v3_alg1.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
<p>The final output of the Sinkhorn algorithm optimization is a real-valued coupling matrix <inline-formula id="ID86">
<alternatives>
<mml:math display="block" id="I86">
<mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>×</mml:mo><mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq86.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula>. In some cases, it is desirable to transform the coupling matrix into a binary-valued matching matrix <inline-formula id="ID87">
<alternatives>
<mml:math display="block" id="I87">
<mml:mrow><mml:mi>M</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq87.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> with possibly an added restriction that there is at most one nonzero element in each row and column (to obtain a valid partial matching). This can be done by either thresholding the real matrix ∏ or by assigning all maximal entries in each row (or column) to one and setting the remaining entries to zero. For our metabolomics matching problem, we describe our procedure for transforming our real-valued coupling into a binary matching matrix in the section on the GromovMatcher algorithm below.</p>
</sec>
<sec id="s17">
<title>Gromov-Wasserstein</title>
<p>Now that we have introduced the general formulation of unbalanced optimal transport and its corresponding Sinkhorn algorithm, we can extend this formulation to matching problems between distributions of points that live in different dimensional spaces. In our metabolomics setting, we aim to match two datasets of <italic>p</italic><sub>1</sub> and <italic>p</italic><sub>2</sub> metabolic features respectively where each feature in a dataset is associated with a feature intensity vector <inline-formula id="ID88">
<alternatives>
<mml:math display="block" id="I88">
<mml:msubsup>
<mml:mfenced close="}" open="{">
<mml:mrow>
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfenced>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
<mml:mo>⊂</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>n</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq88.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> and <inline-formula id="ID89">
<alternatives>
<mml:math display="block" id="I89">
<mml:msubsup>
<mml:mfenced close="}" open="{">
<mml:mrow>
<mml:msub>
<mml:mi>Y</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfenced>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
<mml:mo>⊂</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>n</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq89.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> respectively across samples. We assume that there exists a true matching matrix <inline-formula id="ID90">
<alternatives>
<mml:math display="block" id="I90">
<mml:mrow><mml:mi>M</mml:mi><mml:mo>*</mml:mo><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq90.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> with at most one nonzero entry in each row and column such that two metabolites (<italic>i, j</italic>) are matched if <inline-formula id="ID91">
<alternatives>
<mml:math display="block" id="I91">
<mml:msubsup>
<mml:mi>M</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
<mml:mo>*</mml:mo>
</mml:msubsup>
<mml:mo>=</mml:mo><mml:mn>1</mml:mn>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq91.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula>.</p>
<p>We make the further assumption that if feature vectors <italic>X<sub>i</sub>, Y<sub>j</sub></italic> are matched and feature vectors <italic>X<sub>k</sub>, Y<sub>l</sub>,</italic> are matched under <italic>M</italic>*, then we expect that</p><disp-formula id="FD36">
<alternatives>
<mml:math display="block" id="M36">
<mml:msub>
<mml:mi>d</mml:mi>
<mml:mi>x</mml:mi>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>,</mml:mo><mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>k</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfenced><mml:mo>≈</mml:mo><mml:msub>
<mml:mi>d</mml:mi>
<mml:mi>y</mml:mi>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:msub>
<mml:mi>Y</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mo>,</mml:mo><mml:msub>
<mml:mi>Y</mml:mi>
<mml:mi>l</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfenced><mml:mtext>if</mml:mtext><mml:msubsup>
<mml:mtext>M</mml:mtext>
<mml:mrow>
<mml:mtext>ij</mml:mtext></mml:mrow>
<mml:mo>*</mml:mo>
</mml:msubsup>
<mml:mo>=</mml:mo><mml:msubsup>
<mml:mtext>M</mml:mtext>
<mml:mrow>
<mml:mtext>kl</mml:mtext></mml:mrow>
<mml:mo>*</mml:mo>
</mml:msubsup>
<mml:mo>=</mml:mo><mml:mn>1.</mml:mn>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn36.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(36)</label>
</disp-formula>
<p>where <italic>d<sub>x</sub></italic> is a distance metric on <inline-formula id="ID92">
<alternatives>
<mml:math display="block" id="I92">
<mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>n</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq92.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> and <italic>d<sub>y</sub></italic> is a distance metric <inline-formula id="ID93">
<alternatives>
<mml:math display="block" id="I93">
<mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>n</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq93.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula>. In practice, we always choose these distance metrics to be the normalized Euclidean distance defined for any <italic>u,v</italic> ϵ <bold>ℝ</bold><sup><italic>n</italic></sup> as</p><disp-formula id="FD37">
<alternatives>
<mml:math display="block" id="M37">
<mml:msup>
<mml:mi>d</mml:mi>
<mml:mrow>
<mml:mtext>euc </mml:mtext></mml:mrow>
</mml:msup>
<mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac>
<mml:mn>1</mml:mn>
<mml:mrow>
<mml:msqrt>
<mml:mi>n</mml:mi>
</mml:msqrt>
</mml:mrow>
</mml:mfrac>
<mml:mo>‖</mml:mo><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mi>v</mml:mi><mml:mo>‖</mml:mo>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn37.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(37)</label>
</disp-formula>
<p>which is equal to the cosine distance <italic>d</italic> <sup>cos</sup> (i.e. one minus the correlation) for centered and scaled data. Given these two distance matrices <inline-formula id="ID94">
<alternatives>
<mml:math display="block" id="I94">
<mml:msup>
<mml:mi>D</mml:mi>
<mml:mi>x</mml:mi>
</mml:msup>
<mml:mo>=</mml:mo><mml:msubsup>
<mml:mfenced close="]" open="[">
<mml:mrow>
<mml:msub>
<mml:mi>d</mml:mi>
<mml:mi>x</mml:mi>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:mo>,</mml:mo><mml:msub>
<mml:mi>X</mml:mi>
<mml:mi>k</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mfenced>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
<mml:mo>∈</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>×</mml:mo><mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq94.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> and <inline-formula id="ID95">
<alternatives>
<mml:math display="block" id="I95">
<mml:msup>
<mml:mi>D</mml:mi>
<mml:mi>y</mml:mi>
</mml:msup>
<mml:mo>=</mml:mo><mml:msubsup>
<mml:mfenced close="]" open="[">
<mml:mrow>
<mml:msub>
<mml:mi>d</mml:mi>
<mml:mi>y</mml:mi>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:msub>
<mml:mi>Y</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mo>,</mml:mo><mml:msub>
<mml:mi>Y</mml:mi>
<mml:mi>l</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mfenced>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
<mml:mo>∈</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
<mml:mo>×</mml:mo><mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq95.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> we would like to infer the true matching matrix <italic>M</italic>* by solving an optimization problem.</p>
<p>Consider the following objective function</p><disp-formula id="FD38">
<alternatives>
<mml:math display="block" id="M38">
<mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>M</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>M</mml:mi>
<mml:mrow>
<mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow>
</mml:msub>
<mml:mfenced close="|" open="|">
<mml:mrow>
<mml:msubsup>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow>
<mml:mi>x</mml:mi>
</mml:msubsup>
<mml:mo>−</mml:mo><mml:msubsup>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mi>l</mml:mi></mml:mrow>
<mml:mi>y</mml:mi>
</mml:msubsup>
</mml:mrow>
</mml:mfenced><mml:mo>.</mml:mo>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn38.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(38)</label>
</disp-formula>
<p>where the matching matrices <inline-formula id="ID96">
<alternatives>
<mml:math display="block" id="I96">
<mml:mrow><mml:mi>M</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq96.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> we optimize over are constrained to satisfy marginal constraints ∏<bold>1</bold><sub><italic>p</italic>2</sub> &gt; 0 and <inline-formula id="ID97">
<alternatives>
<mml:math display="block" id="I97">
<mml:msup>
<mml:mi>Π</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq97.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula>. These marginal constraints simply impose that there is at least one nonzero entry in each row and column (i.e. each metabolite in both datasets has at least one corresponding match). Searching for the ∏ minimizing ϵ<italic><sub>X,Y</sub></italic> (∏) consists of putting the nonzero entries in ∏ such that the distance profiles of the matched features are similar, so that the minimizer of this criterion provides a good candidate estimate of ∏*. This is closely related to the Gromov–Hausdorff distance <xref ref-type="bibr" rid="c17">Gromov (2001)</xref>, an extension of optimal transport to the case where the sets to be coupled do not lie in the same metric space.</p>
<p>In practice, it is often desirable to optimize over a different set of matrices in order to make the optimization problem more tractable. Here we take intuition from optimal transport, and search over the set of coupling matrices with marginal constraints</p><disp-formula id="FD39">
<alternatives>
<mml:math display="block" id="M39">
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>U</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfenced open="{">
<mml:mrow>
<mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>×</mml:mo><mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
<mml:mo>:</mml:mo><mml:mi>Π</mml:mi><mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo><mml:mi>a</mml:mi></mml:mrow>
</mml:mfenced><mml:mtext>and</mml:mtext><mml:mfenced close="}">
<mml:mrow>
<mml:msup>
<mml:mi>Π</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo><mml:mi>b</mml:mi></mml:mrow>
</mml:mfenced><mml:mo>.</mml:mo>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn39.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(39)</label>
</disp-formula>
<p>where as before, <inline-formula id="ID98">
<alternatives>
<mml:math display="block" id="I98">
<mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq98.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> and <inline-formula id="ID99">
<alternatives>
<mml:math display="block" id="I99">
<mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq99.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> are desired marginals which are typically set to be uniform distributions <inline-formula id="ID100">
<alternatives>
<mml:math display="block" id="I100">
<mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mfrac>
<mml:mn>1</mml:mn>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:mfrac>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq100.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> and <inline-formula id="ID101">
<alternatives>
<mml:math display="block" id="I101">
<mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mfrac>
<mml:mn>1</mml:mn>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:mfrac>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq101.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula>. These marginal vectors can be interpreted as distributions of masses <italic>a<sub>i</sub></italic> and <italic>b<sub>j</sub></italic> on the feature vectors <italic>X<sub>i</sub></italic> and <italic>Y<sub>j</sub></italic> respectively for <italic>i</italic> ϵ [<italic>p</italic><sub>1</sub>]<italic>, j</italic> ϵ [<italic>p</italic><sub>2</sub>].</p>
<p>Coupling matrices in <bold>U</bold>( <italic>a, b</italic>) transport the distribution of masses <italic>a</italic> in the first dataset to the distribution of masses <italic>b</italic> in the second dataset. Now we can formulate the Gromov-Wasserstein (GW) distance, introduced by Memoli <xref ref-type="bibr" rid="c25">Mémoli (2011)</xref>, as</p><disp-formula id="FD40">
<alternatives>
<mml:math display="block" id="M40">
<mml:mtext>GW</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub>
<mml:mi>min</mml:mi>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>U</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
</mml:msub>
<mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo stretchy="false">)</mml:mo>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn40.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(40)</label>
</disp-formula>
<p>By optimizing this objective, each entry ∏<sub><italic>ij</italic></sub> now reflects the strength of the matched pair (<italic>X<sub>i</sub>,Y<sub>j</sub></italic>). Optimizing GW(<italic>a, b</italic>) then amounts to placing larger entries in ∏ whose paired features have similar distance profiles. Before we develop an algorithm to optimize this objective, we first modify it to allow for unbalanced matchings where marginal constraints are not enforced exactly (e.g. features in both datasets can remain unmatched).</p>
</sec>
<sec id="s18">
<title>Unbalanced Gromov–Wasserstein</title>
<p>In an untargeted context, all features measured in one study are not necessarily observed in another, either because these features are truly not shared or because of measurement error. However, the constraint ∏ ϵ <bold>U</bold>(<italic>a, b</italic>) in the original GW optimization criterion (40) ensures that all the mass is transported from one set to another, resulting in all features being matched across studies. In order to discard study-specific features during the GW computation, we use the unbalanced Gromov–Wasserstein (UGW) distance with an additional entropic regularization for computational purposes, described in <xref ref-type="bibr" rid="c37">Séjourné et al. Sejourne et al. (2021)</xref>. The optimization problem therefore reads</p><disp-formula id="FD41">
<alternatives>
<mml:math display="block" id="M41">
<mml:mtable columnalign="left" equalrows="true" equalcolumns="true">
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msub>
<mml:mi mathvariant="script">L</mml:mi>
<mml:mrow>
<mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>+</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>⊗</mml:mo><mml:mi>Π</mml:mi><mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>a</mml:mi></mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow/>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>+</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mi>ρ</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:msup>
<mml:mi>Π</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>⊗</mml:mo><mml:msup>
<mml:mi>Π</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow/>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>+</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mi>ε</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:mo>⊗</mml:mo><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:msup>
<mml:mrow>
<mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
<mml:mrow>
<mml:mo>⊗</mml:mo><mml:mn>2</mml:mn></mml:mrow>
</mml:msup>
</mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn41.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(41)</label>
</disp-formula>
<disp-formula id="FD42">
<alternatives>
<mml:math display="block" id="M42">
<mml:msub>
<mml:mtext>UGW</mml:mtext>
<mml:mrow>
<mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo><mml:msub>
<mml:mi>min</mml:mi>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>×</mml:mo><mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:mrow>
</mml:msub>
<mml:msub>
<mml:mi mathvariant="script">L</mml:mi>
<mml:mrow>
<mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo stretchy="false">)</mml:mo>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn42.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(42)</label>
</disp-formula>
<p>with <italic>ρ, ϵ &gt;</italic> 0. Here <italic>D</italic> <sub>KL</sub> is the Kullback–Leibler divergence defined in the previous sections and we define the tensor product (<italic>P</italic> ⊗<italic> P</italic>)<sub><italic>i,j,k,l</italic></sub> = <italic>P<sub>i,j</sub>P<sub>kl</sub></italic>. Here we set the desired marginal constraints to <inline-formula id="ID102">
<alternatives>
<mml:math display="block" id="I102">
<mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mfrac>
<mml:mn>1</mml:mn>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:mfrac>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq102.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> and <inline-formula id="ID103">
<alternatives>
<mml:math display="block" id="I103">
<mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mfrac>
<mml:mn>1</mml:mn>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:mfrac>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq103.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> as before.</p>
<p>As in the case of unbalanced optimal transport <xref ref-type="bibr" rid="c10">Chizat et al. (2018)</xref>, the regularization <italic>ρ</italic> times the Kullback–Leibler divergences allows for the relaxation of the marginal constraints <inline-formula id="ID104">
<alternatives>
<mml:math display="block" id="I104">
<mml:mi>Π</mml:mi><mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo><mml:mi>a</mml:mi>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq104.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> and <inline-formula id="ID105">
<alternatives>
<mml:math display="block" id="I105">
<mml:msup>
<mml:mi>Π</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo><mml:mi>b</mml:mi>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq105.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula>. The value of <italic>ρ &gt;</italic> 0 controls the extent to which we allow for mass destruction. Smaller values of <italic>ρ</italic> tend to lessen the constraint on the marginals of ∏, while balanced GW is recovered when <italic>ρ</italic> → + ∞. As proposed in the original paper Séjourne et al. (2021), our UGW cost modifies the UOT formulation by using the quadratic Kullback-Leibler divergence in <inline-formula id="ID106">
<alternatives>
<mml:math display="block" id="I106">
<mml:mi>Π</mml:mi><mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>⊗</mml:mo><mml:mi>Π</mml:mi><mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq106.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> and <inline-formula id="ID107">
<alternatives>
<mml:math display="block" id="I107">
<mml:msup>
<mml:mi>Π</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>⊗</mml:mo><mml:msup>
<mml:mi>Π</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq107.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> instead, hence preserving the quadratic form of the GW cost function ε (∏).</p>
<p>The term <inline-formula id="ID108">
<alternatives>
<mml:math display="block" id="I108">
<mml:mi>ϵ</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:mo>⊗</mml:mo><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:msup>
<mml:mrow>
<mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
<mml:mrow>
<mml:mo>⊗</mml:mo><mml:mn>2</mml:mn></mml:mrow>
</mml:msup>
</mml:mrow>
</mml:mfenced>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq108.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> serves as an entropic regularization, inspired again by optimal transport. Adding such a penalty is a standard way to compute an approximate solution to the optimal transport problem using the Sinkhorn algorithm as we shall show in the following section. Here again, we modify the entropic penalty in UGW to have a quadratic form in ∏ ⊗ ∏ to agree with the quadratic form of the GW cost ϵ (∏). The parameter <italic>e</italic> controls the smoothness (entropy) of the coupling matrix ∏ where larger values of <italic>ϵ</italic> encourage ∏ to put uniform weights on many of its entries, leading to less precision in the feature matches. However, increasing <italic>ϵ</italic> also leads to better numerical stability and a significant speedup of the alternating Sinkhorn algorithm used to optimize the objective function described below.</p>
</sec>
<sec id="s19">
<title>UGW optimization algorithm</title>
<p>Now we are ready to write out an algorithm to optimize the UGW objective in (42). First write our objective as</p><disp-formula id="FD43">
<alternatives>
<mml:math display="block" id="M43">
<mml:mtable columnalign="left" equalrows="true" equalcolumns="true">
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msub>
<mml:mi mathvariant="script">L</mml:mi>
<mml:mrow>
<mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow>
</mml:msub>
<mml:mfenced close="|" open="|">
<mml:mrow>
<mml:msubsup>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow>
<mml:mi>x</mml:mi>
</mml:msubsup>
<mml:mo>−</mml:mo><mml:msubsup>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mi>l</mml:mi></mml:mrow>
<mml:mi>y</mml:mi>
</mml:msubsup>
</mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>+</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mi>ρ</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:msub>
<mml:mn>1</mml:mn>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>⊗</mml:mo><mml:mi>Π</mml:mi><mml:msub>
<mml:mn>1</mml:mn>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>a</mml:mi></mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow/>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>+</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:msup>
<mml:mi>Π</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>⊗</mml:mo><mml:msup>
<mml:mi>Π</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow/>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>+</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mi>ε</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:mo>⊗</mml:mo><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:msup>
<mml:mrow>
<mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
<mml:mrow>
<mml:mo>⊗</mml:mo><mml:mn>2</mml:mn></mml:mrow>
</mml:msup>
</mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn43.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(43)</label>
</disp-formula>
<p>Using the quadratic nature of our cost function, we aim to perform an alternating minimization in the two copies of ∏. For the moment, let’s differentiate these two copies by ∏ and Γ and write the new cost</p><disp-formula id="FD44">
<alternatives>
<mml:math display="block" id="M44">
<mml:mtable columnalign="left" equalrows="true" equalcolumns="true">
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msub>
<mml:mi mathvariant="script">F</mml:mi>
<mml:mrow>
<mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:mi>Γ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>Γ</mml:mi>
<mml:mrow>
<mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow>
</mml:msub>
<mml:mfenced close="|" open="|">
<mml:mrow>
<mml:msubsup>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow>
<mml:mi>x</mml:mi>
</mml:msubsup>
<mml:mo>−</mml:mo><mml:msubsup>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mi>l</mml:mi></mml:mrow>
<mml:mi>y</mml:mi>
</mml:msubsup>
</mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>+</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mi>ρ</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:msub>
<mml:mn>1</mml:mn>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>⊗</mml:mo><mml:mi>Γ</mml:mi><mml:msub>
<mml:mn>1</mml:mn>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>a</mml:mi></mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow/>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>+</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mi>ρ</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:msup>
<mml:mi>Π</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>⊗</mml:mo><mml:msup>
<mml:mi>Γ</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow/>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>+</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mi>ε</mml:mi><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:mo>⊗</mml:mo><mml:mi>Γ</mml:mi><mml:mo>,</mml:mo><mml:msup>
<mml:mrow>
<mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
<mml:mrow>
<mml:mo>⊗</mml:mo><mml:mn>2</mml:mn></mml:mrow>
</mml:msup>
</mml:mrow>
</mml:mfenced><mml:mo>.</mml:mo></mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn44.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(44)</label>
</disp-formula>
<p>Before we expand this cost, we introduce the notation <italic>m</italic>(<italic>π</italic>) to denote the sum of the elements of <italic>π</italic> which can be a vector, matrix or tensor. In general, for four positive distributions 
<inline-formula id="ID109">
<alternatives>
<mml:math display="block" id="I109">
<mml:mi>π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mi>p</mml:mi>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq109.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> and <inline-formula id="ID110">
<alternatives>
<mml:math display="block" id="I110">
<mml:mi>γ</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mi>q</mml:mi>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq110.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> we have that the KL satisfies the tensorization property</p><disp-formula id="FD45">
<alternatives>
<mml:math display="block" id="M45">
<mml:mtable columnalign="left" equalrows="true" equalcolumns="true">
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>π</mml:mi><mml:mo>⊗</mml:mo><mml:mi>γ</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>=</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mi>p</mml:mi>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mi>q</mml:mi>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>π</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>γ</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mi>ln</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mi>π</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:msub>
<mml:mi>γ</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:mfenced><mml:mo>−</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mi>p</mml:mi>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mi>q</mml:mi>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>π</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>γ</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
<mml:mo>+</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mi>p</mml:mi>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mi>q</mml:mi>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow/>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>=</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>γ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mi>p</mml:mi>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>π</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle><mml:mi>ln</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mi>π</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:mfenced><mml:mo>+</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mi>q</mml:mi>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>γ</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle><mml:mi>ln</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mi>γ</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:mfenced><mml:mo>−</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>γ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow/>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>=</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>γ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>γ</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>γ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn45.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(45)</label>
</disp-formula>
<p>Specifically, if we remove those terms that do not depend on <italic>y</italic> we are left with</p><disp-formula id="FD46">
<alternatives>
<mml:math display="block" id="M46">
<mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>π</mml:mi><mml:mo>⊗</mml:mo><mml:mi>γ</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>γ</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>γ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mi>p</mml:mi>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>π</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle><mml:mi>ln</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mi>π</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:mfenced><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mo>.</mml:mo>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn46.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(46)</label>
</disp-formula>
<p>This allows us to write for the marginal constraints <inline-formula id="ID111">
<alternatives>
<mml:math display="block" id="I111">
<mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
<mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq111.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> and couplings <inline-formula id="ID112">
<alternatives>
<mml:math display="block" id="I112">
<mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:mi>Γ</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>×</mml:mo><mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq112.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> that</p><disp-formula id="UFD17">
<alternatives>
<mml:math display="block" id="UM17">
<mml:mtable columnalign="left" equalrows="true" equalcolumns="true">
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>⊗</mml:mo><mml:mi>Γ</mml:mi><mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>a</mml:mi></mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>=</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:mi>Γ</mml:mi><mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo><mml:mi>a</mml:mi></mml:mrow>
</mml:mfenced><mml:mo>+</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Γ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mfenced>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mfenced></mml:mrow>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle><mml:mi>ln</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mfenced>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mfenced></mml:mrow>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:mfenced><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mo>.</mml:mo></mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:msup>
<mml:mi>Π</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>⊗</mml:mo><mml:msup>
<mml:mi>Γ</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>=</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:msup>
<mml:mi>Γ</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow>
</mml:mfenced><mml:mo>+</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Γ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mfenced>
<mml:mrow>
<mml:msup>
<mml:mi>Π</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mfenced></mml:mrow>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle><mml:mi>ln</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mfenced>
<mml:mrow>
<mml:msup>
<mml:mi>Π</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mfenced></mml:mrow>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:mfenced><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mo>.</mml:mo></mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:mo>⊗</mml:mo><mml:mi>Γ</mml:mi><mml:mo>,</mml:mo><mml:msup>
<mml:mrow>
<mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
<mml:mrow>
<mml:mo>⊗</mml:mo><mml:mn>2</mml:mn></mml:mrow>
</mml:msup>
</mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>=</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>Γ</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Γ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:mi>ln</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:mfenced><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mo>.</mml:mo></mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:math>
<graphic xlink:href="2306.03218v3_ueqn17.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</disp-formula>
<p>where in the expansions above we have removed all terms that are independent of Γ. Finally, expanding out <italic>ℱ</italic><sub>ρ</sub><italic>,<sub>ϵ</sub></italic> (∏,Γ) and keeping only those terms that depend on Γ we get</p><disp-formula id="FD47">
<alternatives>
<mml:math display="block" id="M47">
<mml:msub>
<mml:mi mathvariant="script">F</mml:mi>
<mml:mrow>
<mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:mi>Γ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>Γ</mml:mi>
<mml:mrow>
<mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:msubsup>
<mml:mi>C</mml:mi>
<mml:mrow>
<mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow>
<mml:mi>Π</mml:mi>
</mml:msubsup>
<mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:mi>Γ</mml:mi><mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo><mml:mi>a</mml:mi></mml:mrow>
</mml:mfenced><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mfenced>
<mml:mrow>
<mml:msup>
<mml:mi>Γ</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow>
</mml:mfenced><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mtext>KL</mml:mtext></mml:mrow>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>Γ</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn47.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(47)</label>
</disp-formula>
<p>where the cost matrix <inline-formula id="ID113">
<alternatives>
<mml:math display="block" id="I113">
<mml:msup>
<mml:mi>C</mml:mi>
<mml:mi>Π</mml:mi>
</mml:msup>
<mml:mo>∈</mml:mo><mml:msup>
<mml:mi>ℝ</mml:mi>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>×</mml:mo><mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq113.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> is defined as</p>
<disp-formula id="FD48">
<alternatives>
<mml:math display="block" id="M48">
<mml:msubsup>
<mml:mi>C</mml:mi>
<mml:mrow>
<mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow>
<mml:mi>Π</mml:mi>
</mml:msubsup>
<mml:mo>=</mml:mo><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:mfenced close="|" open="|">
<mml:mrow>
<mml:msubsup>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow>
<mml:mi>x</mml:mi>
</mml:msubsup>
<mml:mo>−</mml:mo><mml:msubsup>
<mml:mi>D</mml:mi>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mi>l</mml:mi></mml:mrow>
<mml:mi>y</mml:mi>
</mml:msubsup>
</mml:mrow>
</mml:mfenced><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mfenced>
<mml:mrow>
<mml:mi>Π</mml:mi><mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mfenced></mml:mrow>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle><mml:mi>ln</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mfenced>
<mml:mrow>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mfenced></mml:mrow>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:mfenced><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mfenced>
<mml:mrow>
<mml:msup>
<mml:mi>Π</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mfenced></mml:mrow>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mstyle><mml:mi>ln</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mrow>
<mml:mfenced>
<mml:mrow>
<mml:msup>
<mml:mi>Π</mml:mi>
<mml:mi>T</mml:mi>
</mml:msup>
<mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mfenced></mml:mrow>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:mfenced><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:mi>ln</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mrow>
<mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>a</mml:mi>
<mml:mi>i</mml:mi>
</mml:msub>
<mml:msub>
<mml:mi>b</mml:mi>
<mml:mi>j</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfrac>
</mml:mrow>
</mml:mfenced><mml:mo>.</mml:mo>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn48.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(48)</label>
</disp-formula>
<p>where we have hidden the dependence of <italic>C</italic><sup>∏</sup> on the distance matrices <italic>D<sup>x</sup>,D<sup>y</sup></italic>, the marginals <italic>a, b</italic>, and the regularization parameters <italic>ρ, ϵ</italic> for ease of notation.</p>
<p>Remarkably, the cost above in Γ for fixed ∏ is in the form of an unbalanced optimal transport problem which can be solved through unbalanced Sinkhorn iterations (Algorithm 1). Note that in our derivation above, it did not matter whether we optimized Γ with ∏ fixed or vice versa because the cost <italic>ℱ<sub>ρ</sub>,<sub>ϵ</sub></italic>(∏,Γ) is symmetric in both of its arguments.</p>
<p>Our iterative algorithm for solving the unbalanced GW problem will proceed at each iteration by optimizing Γ to minimize the cost above using the unbalanced Sinkhorn method, setting ∏ equal to Γ and repeating. With each iteration, we expect this iterative procedure to make smaller and smaller updates to Γ until convergence. By definition, at the end of each iteration we assign ∏ = Γ so the minimizer of <italic>ℱ<sub>ρ</sub>,<sub>ϵ</sub></italic>(∏,Γ) we converge to should also be a minimizer of the original UGW cost ℒ<sub><italic>ρε</italic></sub>(∏) in the sense that the relaxation of <italic>ℒ<sub>ρ</sub>,<sub>ϵ</sub></italic>(∏) to <italic>ℱ<sub>ρ</sub>,<sub>ϵ</sub></italic>(∏,Γ) is tight. This is proven rigorously under strict mathematical assumptions in <xref ref-type="bibr" rid="c37">Sejourne et al. (2021</xref>). We state the full UGW optimization algorithm below.</p>
<fig id="alg2" position="float" fig-type="figure">
<label>Algorithm 2</label>
<caption><title>UnbalancedGromovWasserstein</title></caption>
<graphic xlink:href="2306.03218v3_alg2.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
<p>Following the implementation of the UGW algorithm in <xref ref-type="bibr" rid="c37">Sejourne et al. (2021)</xref>, we initialize both ∏ and Γ to be the product distribution of the marginals <inline-formula id="ID114">
<alternatives>
<mml:math display="block" id="I114">
<mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo>/</mml:mo><mml:msqrt>
<mml:mrow>
<mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
</mml:msqrt>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq114.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> before we begin the optimization. Also, we note that if (∏,Γ) is a minimizer of our UGW objective <italic>ℱ<sub>ρ</sub>,<sub>ϵ</sub></italic>(∏,Γ), then so is <inline-formula id="ID115">
<alternatives>
<mml:math display="block" id="I115">
<mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mn>1</mml:mn>
<mml:mi>s</mml:mi>
</mml:mfrac>
<mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mi>Γ</mml:mi></mml:mrow>
</mml:mfenced>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq115.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> for any scale factor <italic>s &gt;</italic> 0. Hence, we can set <inline-formula id="ID116">
<alternatives>
<mml:math display="block" id="I116">
<mml:mi>m</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfrac>
<mml:mn>1</mml:mn>
<mml:mi>s</mml:mi>
</mml:mfrac>
<mml:mi>Π</mml:mi></mml:mrow>
</mml:mfenced><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mi>Γ</mml:mi><mml:mo stretchy="false">)</mml:mo>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq116.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> by choosing <inline-formula id="ID117">
<alternatives>
<mml:math display="block" id="I117">
<mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:msqrt>
<mml:mrow>
<mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Γ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
</mml:msqrt>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq117.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula>. This motivates the final step in the while loop of the UGW algorithm where the rescaling of Γ by the factor <inline-formula id="ID118">
<alternatives>
<mml:math display="block" id="I118">
<mml:msqrt>
<mml:mrow>
<mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Γ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
</mml:msqrt>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq118.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> leads to mass equality <italic>m</italic>(∏) = <italic>m</italic>(Γ) and also stabilizes the convergence of the algorithm.</p>
<p>Returning to our metabolomics matching problem, we further guide our UGW optimization procedure by discouraging it from matching metabolic feature pairs whose mass-to-charge ratios are incompatible. Namely, we choose a value <italic>m</italic><sub>gap</sub> such that for all pairs (<italic>i,j</italic>) with <italic>i</italic> ϵ [<italic>p</italic><sub>1</sub>]<italic>, j</italic> ϵ <italic>[p</italic><sub>2</sub>] and mass-to-charge ratios <inline-formula id="ID119">
<alternatives>
<mml:math display="block" id="I119">
<mml:msubsup>
<mml:mi>m</mml:mi>
<mml:mi>i</mml:mi>
<mml:mi>x</mml:mi>
</mml:msubsup>
<mml:mo>,</mml:mo><mml:msubsup>
<mml:mi>m</mml:mi>
<mml:mi>j</mml:mi>
<mml:mi>y</mml:mi>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq119.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> we enforce that</p><disp-formula id="FD49">
<alternatives>
<mml:math display="block" id="M49">
<mml:mfenced close="|" open="|">
<mml:mrow>
<mml:msubsup>
<mml:mi>m</mml:mi>
<mml:mi>i</mml:mi>
<mml:mi>x</mml:mi>
</mml:msubsup>
<mml:mo>−</mml:mo><mml:msubsup>
<mml:mi>m</mml:mi>
<mml:mi>j</mml:mi>
<mml:mi>y</mml:mi>
</mml:msubsup>
</mml:mrow>
</mml:mfenced><mml:mo>&gt;</mml:mo><mml:msub>
<mml:mi>m</mml:mi>
<mml:mrow>
<mml:mtext>gap </mml:mtext></mml:mrow>
</mml:msub>
<mml:mo>⇒</mml:mo><mml:msub>
<mml:mi>Π</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo><mml:mn>0.</mml:mn>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn49.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(49)</label>
</disp-formula>
<p>In practice, this is done by taking the optimal transport cost <italic>C</italic><sup>∏</sup> in every iteration of the UGW algorithm and premultiplying it elementwise by a factor <inline-formula id="ID120">
<alternatives>
<mml:math display="block" id="I120">
<mml:mi>W</mml:mi><mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>×</mml:mo><mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq120.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> given by</p>
<disp-formula id="FD50">
<alternatives>
<mml:math display="block" id="M50">
<mml:msup>
<mml:mi>C</mml:mi>
<mml:mi>Π</mml:mi>
</mml:msup>
<mml:mo>→</mml:mo><mml:mi>W</mml:mi><mml:mo>⊙</mml:mo><mml:msup>
<mml:mi>C</mml:mi>
<mml:mi>Π</mml:mi>
</mml:msup>
<mml:mo>,</mml:mo><mml:msub>
<mml:mi>W</mml:mi>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo><mml:mn>99</mml:mn><mml:mo>⋅</mml:mo><mml:msub>
<mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle>
<mml:mrow>
<mml:mfenced close="}" open="{">
<mml:mrow>
<mml:mfenced close="|" open="|">
<mml:mrow>
<mml:msubsup>
<mml:mi>m</mml:mi>
<mml:mi>i</mml:mi>
<mml:mi>x</mml:mi>
</mml:msubsup>
<mml:mo>−</mml:mo><mml:msubsup>
<mml:mi>m</mml:mi>
<mml:mi>j</mml:mi>
<mml:mi>y</mml:mi>
</mml:msubsup>
</mml:mrow>
</mml:mfenced><mml:mo>&gt;</mml:mo><mml:msub>
<mml:mi>m</mml:mi>
<mml:mrow>
<mml:mtext>gap </mml:mtext><mml:mo>}</mml:mo></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mfenced></mml:mrow>
</mml:msub>
<mml:mo>+</mml:mo><mml:mn>1</mml:mn>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn50.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(50)</label>
</disp-formula>
<p>where <bold>1</bold><sub><italic>x</italic></sub> denotes the indicator function that is one when the condition χ is satisfied and zero otherwise. Such a prefactor changes the transport cost to be very large for feature matches with incompatible mass-to-charge ratio times, and hence, the entries of ∏ set small weights at these entries. Our weighted UGW algorithm is rewritten below.</p>
<fig id="alg3" position="float" fig-type="figure">
<label>Algorithm 3</label>
<caption><title>WeightedUnbalancedGromovWasserstein</title></caption>
<graphic xlink:href="2306.03218v3_alg3.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
<p>As mentioned before, the coupling matrix returned by our weighted UGW algorithm is a realvalued matrix rather than a binary matching matrix. In the next section, we describe how we incorporate metabolite retention time information to filter out unlikely pairs in our coupling matrix and transform it into a valid one-to-one matching of features across two datasets.</p>
</sec>
<sec id="s20">
<title>Retention time drift estimation and filtering</title>
<p>To filter out unlikely matches from the coupling matrix returned by Algorithm 3 above, we use the retention times (RTs) of the metabolites in both datasets. We remind the reader that RTs were not incorporated into the weighted UGW algorithm since they often exhibit a non-linear deviation between datasets, and hence are not directly comparable. However, using the metabolite coupling <inline-formula id="ID121">
<alternatives>
<mml:math display="block" id="I121">
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>˜</mml:mo>
</mml:mover>
<mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>×</mml:mo><mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq121.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> obtained from Algorithm 3, it is possible to estimate this RT drift. The estimated RT drift <inline-formula id="ID122">
<alternatives>
<mml:math display="block" id="I122">
<mml:mover accent="true">
<mml:mi>f</mml:mi>
<mml:mo>^</mml:mo>
</mml:mover>
<mml:mo>:</mml:mo><mml:msub>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
</mml:msub>
<mml:mo>→</mml:mo><mml:msub>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
</mml:msub>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq122.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> allows us to assess the plausibility of the pairs recovered by the restricted UGW coupling <inline-formula id="ID123">
<alternatives>
<mml:math display="block" id="I123">
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>˜</mml:mo>
</mml:mover>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq123.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula>
, and discard pairs incompatible with the estimated drift.</p>
<p>We propose to learn the drift <inline-formula id="ID124">
<alternatives>
<mml:math display="block" id="I124">
<mml:mover accent="true">
<mml:mi>f</mml:mi>
<mml:mo>^</mml:mo>
</mml:mover>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq124.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> through the weighted spline regression</p>
<disp-formula id="FD51">
<alternatives>
<mml:math display="block" id="M51">
<mml:msub>
<mml:mi>min</mml:mi>
<mml:mrow>
<mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:msub>
<mml:mi>B</mml:mi>
<mml:mrow>
<mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:msub>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:munderover>
<mml:mo>∑</mml:mo>
<mml:mrow>
<mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
</mml:mrow>
</mml:munderover>
<mml:mrow>
<mml:msub>
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>˜</mml:mo>
</mml:mover>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mstyle></mml:mrow>
</mml:mstyle><mml:mfenced close="|" open="|">
<mml:mrow>
<mml:mi>f</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mi>R</mml:mi><mml:msubsup>
<mml:mi>T</mml:mi>
<mml:mi>i</mml:mi>
<mml:mi>x</mml:mi>
</mml:msubsup>
</mml:mrow>
</mml:mfenced><mml:mo>−</mml:mo><mml:mi>R</mml:mi><mml:msubsup>
<mml:mi>T</mml:mi>
<mml:mi>j</mml:mi>
<mml:mi>y</mml:mi>
</mml:msubsup>
</mml:mrow>
</mml:mfenced>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn51.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(51)</label>
</disp-formula>
<p>where ℬ<sub><italic>n,k</italic></sub> is the set of <italic>n</italic>-order B-splines with <italic>k</italic> knots. All pairs <inline-formula id="ID125">
<alternatives>
<mml:math display="block" id="I125">
<mml:mfenced>
<mml:mrow>
<mml:mi>R</mml:mi><mml:msubsup>
<mml:mi>T</mml:mi>
<mml:mi>i</mml:mi>
<mml:mi>x</mml:mi>
</mml:msubsup>
<mml:mo>,</mml:mo><mml:mi>R</mml:mi><mml:msubsup>
<mml:mi>T</mml:mi>
<mml:mi>j</mml:mi>
<mml:mi>y</mml:mi>
</mml:msubsup>
</mml:mrow>
</mml:mfenced>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq125.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> in objective (51) are weighted by the coefficients of <inline-formula id="ID126">
<alternatives>
<mml:math display="block" id="I126">
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>˜</mml:mo>
</mml:mover>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq126.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> so that larger weights are given to pairs identified with high confidence in the first step of our procedure.</p>
<p>Pairs identified as incompatible with the estimated RT drift are then discarded from the coupling matrix. To do this, we first take the estimated RT drift <inline-formula id="ID127">
<alternatives>
<mml:math display="block" id="I127">
<mml:mover accent="true">
<mml:mi>f</mml:mi>
<mml:mo>^</mml:mo>
</mml:mover>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq127.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula>
, and the set of pairs <inline-formula id="ID128">
<alternatives>
<mml:math display="block" id="I128">
<mml:mi>S</mml:mi><mml:mo>=</mml:mo><mml:mfenced close="}" open="{">
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>:</mml:mo><mml:msub>
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>˜</mml:mo>
</mml:mover>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
<mml:mo>≠</mml:mo><mml:mn>0</mml:mn></mml:mrow>
</mml:mfenced>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq128.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> recovered in <inline-formula id="ID129">
<alternatives>
<mml:math display="block" id="I129">
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>^</mml:mo>
</mml:mover>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq129.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> with nonzero entries. We then define the residual associated with (<italic>i, j</italic>) ϵ <italic>𝒮</italic> as</p><disp-formula id="FD52">
<alternatives>
<mml:math display="block" id="M52">
<mml:msub>
<mml:mi>r</mml:mi>
<mml:mover accent="true">
<mml:mi>f</mml:mi>
<mml:mo>^</mml:mo>
</mml:mover>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfenced close="|" open="|">
<mml:mrow>
<mml:mover accent="true">
<mml:mi>f</mml:mi>
<mml:mo>^</mml:mo>
</mml:mover>
<mml:mfenced>
<mml:mrow>
<mml:mi>R</mml:mi><mml:msubsup>
<mml:mi>T</mml:mi>
<mml:mi>i</mml:mi>
<mml:mi>x</mml:mi>
</mml:msubsup>
</mml:mrow>
</mml:mfenced><mml:mo>−</mml:mo><mml:mi>R</mml:mi><mml:msubsup>
<mml:mi>T</mml:mi>
<mml:mi>j</mml:mi>
<mml:mi>y</mml:mi>
</mml:msubsup>
</mml:mrow>
</mml:mfenced><mml:mo>.</mml:mo>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn52.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(52)</label>
</disp-formula>
<p>The 95% prediction interval and the median absolute deviation (MAD) of these residuals are given by</p><disp-formula id="FD53">
<alternatives>
<mml:math display="block" id="M53">
<mml:mtable columnalign="left" equalrows="true" equalcolumns="true">
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mtext>PI</mml:mtext></mml:mrow>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>=</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mn>1.96</mml:mn><mml:mo>×</mml:mo><mml:mi mathvariant="normal">std</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfenced close="}" open="{">
<mml:mrow>
<mml:msub>
<mml:mi>r</mml:mi>
<mml:mover accent="true">
<mml:mi>f</mml:mi>
<mml:mo>^</mml:mo>
</mml:mover>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mtext>MAD</mml:mtext></mml:mrow>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>=</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mi mathvariant="normal">median</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfenced close="}" open="{">
<mml:mrow>
<mml:mfenced close="|" open="|">
<mml:mrow>
<mml:msub>
<mml:mi>r</mml:mi>
<mml:mover accent="true">
<mml:mi>f</mml:mi>
<mml:mo>^</mml:mo>
</mml:mover>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msub>
<mml:mi>μ</mml:mi>
<mml:mi>r</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfenced><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msub>
<mml:mi>μ</mml:mi>
<mml:mi>r</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mo>=</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mi mathvariant="normal">median</mml:mi><mml:mfenced>
<mml:mrow>
<mml:mfenced close="}" open="{">
<mml:mrow>
<mml:mfenced close="|" open="|">
<mml:mrow>
<mml:msub>
<mml:mi>r</mml:mi>
<mml:mover accent="true">
<mml:mi>f</mml:mi>
<mml:mo>^</mml:mo>
</mml:mover>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
</mml:mfenced><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mfenced></mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn53.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(53)</label>
</disp-formula>
<p>where <bold>|</bold>𝒮<bold>|</bold> is the size of 𝒮and the functions std, median denote the standard deviation and median respectively. Following Habra etal. (2021), we then create a new filtered coupling matrix <inline-formula id="ID130">
<alternatives>
<mml:math display="block" id="I130">
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>^</mml:mo>
</mml:mover>
<mml:mo>∈</mml:mo><mml:msubsup>
<mml:mi>ℝ</mml:mi>
<mml:mo>+</mml:mo>
<mml:mrow>
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>×</mml:mo><mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
</mml:mrow>
</mml:msubsup>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq130.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> given by</p><disp-formula id="FD54">
<alternatives>
<mml:math display="block" id="M54">
<mml:msub>
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>^</mml:mo>
</mml:mover>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo><mml:mfenced open="{">
<mml:mrow>
<mml:mtable columnalign="left" equalrows="true" equalcolumns="true">
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mrow>
<mml:msub>
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>˜</mml:mo>
</mml:mover>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mtext> if </mml:mtext><mml:msub>
<mml:mi>r</mml:mi>
<mml:mover accent="true">
<mml:mi>f</mml:mi>
<mml:mo>^</mml:mo>
</mml:mover>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&lt;</mml:mo><mml:msub>
<mml:mi>μ</mml:mi>
<mml:mi>r</mml:mi>
</mml:msub>
<mml:mo>+</mml:mo><mml:msub>
<mml:mi>r</mml:mi>
<mml:mrow>
<mml:mtext>thresh </mml:mtext></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:mtd>
</mml:mtr>
<mml:mtr columnalign="left">
<mml:mtd columnalign="left">
<mml:mn>0</mml:mn>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mrow>
<mml:mtext> otherwise </mml:mtext></mml:mrow>
</mml:mtd>
</mml:mtr>
</mml:mtable></mml:mrow>
</mml:mfenced>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn54.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(54)</label>
</disp-formula>
<p>where <italic>r</italic><sub>thresh</sub> is a given filtering threshold. The procedure of estimating the drift function <inline-formula id="ID131">
<alternatives>
<mml:math display="block" id="I131">
<mml:mover accent="true">
<mml:mi>f</mml:mi>
<mml:mo>^</mml:mo>
</mml:mover>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq131.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> in (51) and filtering the coupling can be repeated for multiple iterations, to improve the drift and coupling estimation. In our main algorithm, we use two preliminary iterations where we estimate the RT drift and discard outliers with <italic>r</italic><sub>thresh</sub> = PI, defined as points falling outside of the 95% prediction interval. We the re-estimate the drift and perform a final filtering step with the more stringent MAD by setting <italic>r</italic><sub>thresh</sub> = 2 × MAD.</p>
<p>At this stage, it is possible for <inline-formula id="ID132">
<alternatives>
<mml:math display="block" id="I132">
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>^</mml:mo>
</mml:mover>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq132.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> to still contain coefficients of very small magnitude. As an optional postprocessing step, we discard these coefficients by setting all entries smaller than <inline-formula id="ID133">
<alternatives>
<mml:math display="block" id="I133">
<mml:mi>τ</mml:mi><mml:mi>max</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>^</mml:mo>
</mml:mover>
<mml:mo stretchy="false">)</mml:mo>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq133.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> to zero for some scaling constant <italic>τ ϵ</italic> [0, 1]. Lastly, a feature from either study could have multiple possible matches, since <inline-formula id="ID134">
<alternatives>
<mml:math display="block" id="I134">
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>^</mml:mo>
</mml:mover>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq134.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> can have more than one non-zero coefficient per row or column. Although reporting multiple matches can be helpful in an exploratory context, for the sake of simplicity in our analysis, the final output of GromovMatcher returns a one-to-one matching. Consequently, we only keep those metabolite pairs (<italic>i, j</italic>) where the entry <inline-formula id="ID135">
<alternatives>
<mml:math display="block" id="I135">
<mml:msub>
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>^</mml:mo>
</mml:mover>
<mml:mrow>
<mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow>
</mml:msub>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq135.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> is largest in its corresponding row and column. All nonzero entries of <inline-formula id="ID136">
<alternatives>
<mml:math display="block" id="I136">
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>^</mml:mo>
</mml:mover>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq136.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> which do not satisfy this criterion are set to zero. Finally, we convert <inline-formula id="ID137">
<alternatives>
<mml:math display="block" id="I137">
<mml:mover accent="true">
<mml:mi>Π</mml:mi>
<mml:mo>^</mml:mo>
</mml:mover>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq137.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> into a binary matching matrix <inline-formula id="ID138">
<alternatives>
<mml:math display="block" id="I138">
<mml:mrow><mml:mi>M</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq138.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula> with ones in place of its nonzero entries and this final output is returned to the user.</p>
<p>As a naming convention, we use the abbreviation GM for our GromovMatcher method, and use the abbreviation GMT when running GromovMatcher with the optional <italic>τ</italic> -thresholding step.</p>
</sec>
<sec id="s21">
<title>GromovMatcher algorithm summary</title>
<p>In summary, our full GromovMatcher algorithm consists of (1) UGW optimization followed by (2) retention time drift estimation and filtering.</p>
<p>The tuning of <italic>ρ</italic> and <italic>ϵ</italic> was computationally driven and the two parameters were set as low as possible, with <italic>ρ</italic> = 0.05 and <italic>ϵ</italic> = 0.005. Based on literature <xref ref-type="bibr" rid="c24">Loftfield et al. (2021)</xref>; <xref ref-type="bibr" rid="c19">Hsu et al. (2019)</xref>; <xref ref-type="bibr" rid="c11">Climaco Pinto et al. (2022)</xref>; <xref ref-type="bibr" rid="c18">Habra et al. (2021)</xref>; <xref ref-type="bibr" rid="c9">Chen et al. (2021)</xref> and what is considered to be a plausible variation of a feature’s <italic>m</italic>/<italic>z</italic>, we set <italic>m</italic><sub>gap</sub> = 0.01ppm. For RT drift estimation, the order of the B-splines was set to <italic>n</italic> = 3 by default, while the number of knots <italic>k</italic> was selected by 10-fold cross-validation. If the optional thresholding step was applied in GMT, we set <italic>τ</italic> = 0.3. Otherwise, we let <italic>τ</italic> = 0 which gives the unthresholded GM algorithm.</p>
<fig id="alg4" position="float" fig-type="figure">
<label>Algorithm 4</label>
<caption><title>GromovMatcher</title></caption>
<graphic xlink:href="2306.03218v3_alg4.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
</sec>
</app>
<app id="app2">
<title>Appendix 2</title>
<p>Here we discuss existing metabolomic alignments methods and the hyperparameter experiments we perform on these methods. We consider two existing alignment methods for comparison, metabCombiner <xref ref-type="bibr" rid="c18">Habra et al. (2021)</xref> and M2S <xref ref-type="bibr" rid="c11">Climaco Pinto et al. (2022)</xref>. Both of them take the same kind of input as GromovMatcher, i.e. feature tables with features identified with their <italic>m</italic>/<italic>z</italic>, RT, and intensities across samples.</p>
<sec id="s22">
<title>MetabCombiner hyperparameter experiments</title>
<p>MetabCombiner <xref ref-type="bibr" rid="c18">Habra et al. (2021)</xref> is a three-step process that begins by grouping features based on their <italic>m</italic>/<italic>z</italic> within user-specified bins. This creates a search space for potential feature pairs. In the second step, MetabCombiner estimates the RT drift using the potential feature pairs identified in the first step, and eliminates outlying pairs over several iterations. This step can incorporate prior knowledge by identifying shared features and marking them as anchors, which are not discarded. In the final step, MetabCombiner scores the remaining feature pairs based on their <italic>m</italic>/<italic>z</italic>, RT, and relative intensity compatibility to discriminate between multiple matches for one feature. The scoring system relies on weights assigned to <italic>m</italic>/<italic>z</italic>, RT, and feature intensities, with the magnitude of those weights reflecting the reliability of the corresponding measurements across studies.</p>
<p>MetabCombiner <xref ref-type="bibr" rid="c18">Habra et al. (2021)</xref> includes adjustable parameters throughout the pipeline. We set most of them to default values unless otherwise stated. MetabCombiner first establishes candidate pairs by binning features in the <italic>m</italic>/<italic>z</italic> dimension with a width of binGap, and pairing the features sorted by relative intensities. The’binGap’parameter sets the <italic>m</italic>/<italic>z</italic> tolerance of metabCombiner, similar to <italic>m</italic><sub>gap</sub> in GromovMatcher. We used the same value of 0.01 as in GromovMatcher.</p>
<p>MetabCombiner then estimates the RT drift using basis splines, and removes pairs associated with a high residual (twice the mean model error) from the candidate set.</p>
<p>In our main experiment, the RT drift is estimated exclusively using candidate pairs selected by the pipeline. However, it is also possible to include known ground truth pairs as ‘anchors’ to estimate the RT drift. We choose not to rely on prior knowledge for drift estimation as Habra et al. <xref ref-type="bibr" rid="c18">Habra et al. (2021)</xref> show their drift estimation to be efficient and robust, even without prior knowledge. To confirm this claim, we conduct a sensitivity analysis comparing the results obtained in our main experiment with those obtained when supplying metabCombiner with known shared metabolites to anchor the RT drift estimation. We randomly select 100 anchors from the ground truth matching and compute the metabCombiner matchings with otherwise identical settings as in our main experiment. The results from this analysis (reported in <xref ref-type="fig" rid="figapp1">Appendix 2 - Figure 1</xref>) show that the unsupervised RT drift estimation (using anchors selected by the pipeline only) performs as well as the supervised RT drift estimation, showing the drift estimation to be very consistent, with or without shared entities.</p>
<p>After establishing candidate pairs and filtering out those that contradict the estimated RT drift, metabCombiner discriminates between multiple matches using a scoring system that considers <italic>m</italic>/<italic>z</italic>, RT, and rankings of the median feature intensities. Each dimension has a specific weight that can be left at default, manually adjusted, or automatically tuned using known matched pairs. Habra et al. <xref ref-type="bibr" rid="c18">Habra et al. (2021)</xref> provide qualitative guidelines for tuning the weights manually, mainly based on the experimental conditions and visual inspection of the RT drift plot. Since this approach is difficult to implement in the various settings we consider for our simulation study, we rely on the quantitative tuning function included in the metabCombiner pipeline. This function takes into account known shared features and tunes the weights to optimize the scores of those known matches. We randomly select 100 known true matches to define the objective function metabCombiner maximizes. We search over the recommended range of values, with the <italic>m</italic>/<italic>z</italic> weight <italic>A ϵ</italic> [50, 150], the RT weight <italic>B</italic> ϵ [5, 20] and the feature intensities weight <italic>C</italic> ϵ [0, 1]. <xref ref-type="fig" rid="figapp1">Appendix 2 - Figure 1</xref> presents the results obtained with the weights set at default values (<italic>A</italic> = 100<italic>, B</italic> = 15<italic>, C</italic> = 0.5), as a sensitivity analysis.</p>
<fig id="figapp1" position="float" fig-type="figure">
<label>Appendix 2—figure 1.</label>
<caption><title>Performance of metabCombiner with the different parameter settings.</title><p>The first setting, labelled ‘Scores’ correspond to the design of our main analysis, where 100 randomly selected true pairs are supplied to metabCombiner to set the scoring weights automatically, but are not otherwise used. In the second setting, labelled ‘Scores + RT’, metabCombiner is allowed to use the 100 true pairs not only to set the scoring weights, but also to estimate the RT drift. Finally, in the third ‘Default’ setting, we do not use any prior knowledge for the RT drift estimation and keep the scoring weights’ default values.</p>
</caption>
<graphic xlink:href="2306.03218v3_figapp1.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
</sec>
<sec id="s23">
<title>M2S hyperparameter experiments</title>
<p>Pinto et al. <xref ref-type="bibr" rid="c11">Climaco Pinto et al. (2022)</xref> introduce M2S as a more versatile alternative to metabCombiner, while still adhering to most of its core principles. Like metabCombiner, M2S follows a three-step process. First it searches for matches within user-defined thresholds for <italic>m/z</italic>, retention time, and mean feature intensity. Next, M2S estimates <italic>m/z</italic>, RT and feature intensity drifts between datasets and removes any outlier pairs. Finally, M2S selects the best match using a scoring system that weighs each measurement, similar to metabCombiner. M2S notably stands out by providing greater flexibility in the methods and measurements used at each step of the procedure, resulting however in a larger number of parameters that require manual fine-tuning. To address this, we adopt two different approaches for the simulation study and the EPIC study alignment. In the simulation study, we set the initial thresholds to oracle values and investigate technical parameters. For the EPIC study alignment, we use the combination of technical parameters with the best average F1-score in the simulation study and select the best threshold values based on the performance on the validation subset.</p>
<p>More precisely, M2S first matches all pairs of metabolic features whose absolute difference in <italic>m/z</italic>, RT, and median of <italic>log</italic> <sub>10</sub> FI are within the user-defined thresholds ‘MZ_intercept’, ‘RT_intercept’ and ‘log10FI_intercept’. On simulated data experiments, we set these thresholds to MZ_intercept = 0.01, RT_intercept = 3.5 and log10FI_intercept = 0.2 which are large enough to not exclude any true feature matches in any of the scenarios for our simulated data under low, medium, and high overlap/noise (see Methods). M2S also offers more detailed options to match features whose absolute difference stays within two lower and upper bound lines with a given slope where the intercepts of these lines are defined using the values above. In our analysis, we set the slopes of these linear boundaries to zero so as to not remove any true matches. Because the reference and target studies we are matching in the simulated analysis are on the same scale, we set the FI adjust method to ‘none’.</p>
<p>The second step of M2S involves calculating penalization scores for every pair of matches which are used to determine the best set of matches between metabolic features of both datasets. This step depends on a set of hyperparameters which we perform a grid search over to optimize the performance of M2S. For estimating the <italic>m/</italic><italic>z</italic>, RT, and FI drift, the hyperparameters are the percentage of neighbors ‘nrNeighbors’, the neighborhood shape ‘neighMethod’, and the LOESS span percentage ‘pctPointsLoess’ used to smooth the estimated drift functions. After the drifts are estimated, they are normalized using a method specified by ‘residPercentile’ that puts the <italic>m/</italic><italic>z</italic>, RT, and FI residuals on the same scale. We always fix residPercentile = NaN which defaults to the standard 2 × MAD normalization. Next, for every remaining metabolic feature match, the residuals/drifts of the <italic>m</italic>/<italic>z</italic>, RT, and FI are added together by taking the weighted square root sum of squares. For unnormalized data where feature intensity magnitudes are important, we weight all three drifts equally using <italic>W =</italic> (1, 1, 1) and for data with normalized feature intensities we set the FI drift weight to zero such that <italic>W</italic> = (1, 1, 0). Finally, using these weighted penalization scores, M2S selects the best matched pair within a multiple match cluster to obtain a one-to-one matching between datasets.</p>
<table-wrap id="apptbl1" orientation="portrait" position="float">
<label>Appendix 2—table 1.</label>
<caption><title>Performance of M2S in a setting where the RT drift between studies is linear.</title></caption>
<alternatives>
<graphic xlink:href="2306.03218v3_apptbl1.tif" mimetype="image" mime-subtype="tiff"/>
<table frame="hsides" rules="groups">
<thead>
<tr>
<th valign="bottom" align="left">Metric</th>
<th valign="bottom" align="center">Low overlap</th>
<th valign="bottom" align="center">Medium overlap</th>
<th valign="bottom" align="center">High overlap</th>
</tr>
</thead>
<tbody>
<tr>
<td valign="bottom" align="left"><bold>Precision</bold></td>
<td valign="bottom" align="center">0.831</td>
<td valign="bottom" align="center">0.917</td>
<td valign="bottom" align="center">0.947</td>
</tr>
<tr>
<td valign="bottom" align="left"><bold>Recall</bold></td>
<td valign="bottom" align="center">0.934</td>
<td valign="bottom" align="center">0.933</td>
<td valign="bottom" align="center">0.939</td>
</tr>
</tbody>
</table>
</alternatives>
</table-wrap>
<p>The third and final step of M2S involves removing those remaining matches which have large differences in <italic>m</italic>/<italic>z</italic>, RT, or FI. This can be performed using several methods indicated by the hyperparameter ‘methodType’. Each method excludes those matched pairs whose differences in <italic>m</italic>/<italic>z</italic>, RT, or FI exceed a certain number of median absolute deviations indicated by the parameter ‘nr-MAD’. The remaining one-to-one metabolic feature matches are returned as the final result of the M2S algorithm.</p>
<p>To optimally tune M2S on our simulated experiments, we determine the optimal M2S parameter combination for each individual simulation setting (low, medium, high overlap and noise) by performing a grid search over the product of parameter lists</p>
<list list-type="bullet">
<list-item>
<p>nrNeighbors = [0.01, 0.05, 0.1, 0.5, 1]</p>
</list-item>
<list-item>
<p>neighMethod = [‘cross’, ‘circle’]</p>
</list-item>
<list-item>
<p>pctPointsLoess = [0, 0.1, 0.5]</p>
</list-item>
<list-item>
<p>methodType = [‘none’, ‘scores’, ‘byBins’, ‘trend_mad’, ‘residuals_mad’]</p>
</list-item>
<list-item>
<p>nrMAD = [1, 3, 5]</p>
</list-item>
</list>
<p>Each parameter combination for M2S is tested across 20 randomly generated datasets at the same overlap and noise settings. For each setting, the combination of parameters above with the best average F1-score across these 20 trials is used as the optimal parameter choice.</p>
<p>M2S applies initial RT thresholds to search for candidate pairs, which may favor settings where the RT drift follows a linear trend. Therefore, as a sensitivity analysis, we apply M2S to simulated data with a linear drift. The simulation process is identical to that of our main simulation study, except for the deviation of the RT in dataset 2. Specifically, for a given overlap value, we divide the original real-world dataset into two smaller datasets and introduce random noise to the <italic>m</italic>/<italic>z</italic>, RT and intensities of the features, without introducing a systematic deviation to the RT in dataset 2. M2S parameters are kept identical to the ones used in our main analysis in comparable settings. The results obtained by M2S on three pairs of datasets generated for three overlap values (0.25, 0.5 and 0.75) and a medium noise level are reported in <xref ref-type="table" rid="apptbl1">Appendix 2 - Table 1.</xref> While the results obtained in a high overlap setting are close to those obtained in our main analysis M2S demonstrates better performance in a low overlap setting when the RT drift is linear than in our main analysis. This observation is consistent with the results obtained by M2S on EPIC data, considering the relatively low estimated overlap between the aligned EPIC studies in our main analysis.</p>
<p>For the EPIC data, we select the parameter combination that yields the highest F1-score across all simulated settings. However, due to the unavailability of oracle values for setting initial thresholds, we perform a search over several MZ intercept values (0.01, 0.05, and 0.1), RT intercept values (0.1, 0.5, 1, and 5), and logFI intercept values (1, 10, and 100).</p>
</sec>
</app>
<app id="app3">
<title>Appendix 3</title>
<p>In this section, we study the sensitivity of all three alignment methods GMT, M2S, and mC to the validation dataset split when creating two validation studies for matching. As described in the section “Validation on ground-truth data” and depicted in <xref ref-type="fig" rid="fig2">Fig. 2</xref> of the main text, we generate two datasets to be matched by splitting an initial LC-MS dataset with <italic>p</italic> features and <italic>n</italic> samples into two smaller overlapping datasets. The first dataset has <italic>p</italic><sub>1</sub> features and <italic>n</italic><sub>1</sub> samples while the second dataset has <italic>p</italic><sub>2</sub> features and <italic>n</italic><sub>2</sub> samples. The sets of samples in both datasets are disjoint such that <italic>n</italic><sub>1</sub> + <italic>n</italic><sub>2</sub> = <italic>n</italic>. However, the dataset split is constructed such that both datasets share ≈ <italic>λp</italic> of their features where <italic>λ</italic> ϵ [0,1] is an overlap fraction. Namely, this is done by defining the dataset feature sizes as</p><disp-formula id="FD55">
<alternatives>
<mml:math display="block" id="M55">
<mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>=</mml:mo><mml:mfenced close="⌋" open="⌊">
<mml:mrow>
<mml:mfenced>
<mml:mrow>
<mml:mi>λ</mml:mi><mml:mo>+</mml:mo><mml:msub>
<mml:mi>λ</mml:mi>
<mml:mi>f</mml:mi>
</mml:msub>
<mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>λ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
</mml:mfenced><mml:mi>p</mml:mi></mml:mrow>
</mml:mfenced><mml:mo>,</mml:mo><mml:msub>
<mml:mi>p</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
<mml:mo>=</mml:mo><mml:mfenced close="⌋" open="⌊">
<mml:mrow>
<mml:mfenced>
<mml:mrow>
<mml:mi>λ</mml:mi><mml:mo>+</mml:mo><mml:mfenced>
<mml:mrow>
<mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub>
<mml:mi>λ</mml:mi>
<mml:mi>f</mml:mi>
</mml:msub>
</mml:mrow>
</mml:mfenced><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>λ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow>
</mml:mfenced><mml:mi>p</mml:mi></mml:mrow>
</mml:mfenced>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn55.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(55)</label>
</disp-formula>
<p>and the dataset sample sizes as</p><disp-formula id="FD56">
<alternatives>
<mml:math display="block" id="M56">
<mml:msub>
<mml:mi>n</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>=</mml:mo><mml:mfenced close="⌋" open="⌊">
<mml:mrow>
<mml:msub>
<mml:mi>λ</mml:mi>
<mml:mi>s</mml:mi>
</mml:msub>
<mml:mi>n</mml:mi></mml:mrow>
</mml:mfenced><mml:mo>,</mml:mo><mml:msub>
<mml:mi>n</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
<mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mfenced close="⌋" open="⌊">
<mml:mrow>
<mml:msub>
<mml:mi>λ</mml:mi>
<mml:mi>s</mml:mi>
</mml:msub>
<mml:mi>n</mml:mi></mml:mrow>
</mml:mfenced><mml:mo>.</mml:mo>
</mml:math>
<graphic xlink:href="2306.03218v3_eqn56.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
<label>(56)</label>
</disp-formula>
<p>As before, ⌊⋅⌋and ⌈⋅⌉ denote integer floor and ceiling functions. Then taking the original LC-MS dataset and randomly permuting its samples and features, the first <italic>p</italic><sub>1</sub> features and first <italic>n</italic><sub>1</sub> samples are placed into dataset 1 while the last <italic>p</italic><sub>2</sub> features and last <italic>n</italic><sub>2</sub> samples are placed into dataset 2. It is indeed easy to check here that with such a splitting procedure, the feature overlap between both datasets is <italic>p</italic><sub>1</sub> + <italic>p</italic><sub>2</sub> –<italic> p</italic> ≈ <italic>λp</italic>.</p>
<p>Here <italic>λ<sub>f</sub></italic> ϵ [0.5, 1] controls the fraction of features in dataset 1 that is not shared with dataset 2 and <italic>λ<sub>s</sub> ϵ</italic> (0, 1) controls the fraction of samples in dataset 1 vs. dataset 2. In particular, if <italic>λ<sub>f</sub></italic> = 1 then the features in dataset 2 are entirely a subset of those in dataset 1. In the experiments described in the main text, we always set <italic>λ<sub>f</sub></italic> = <italic>λ<sub>s</sub></italic> = 0.5 as to balance the number of features and samples in both resulting datasets.</p>
<p>Now we study how the performance of all three alignment methods changes when <italic>λ<sub>f</sub>, λ<sub>s</sub></italic> and the feature overlap <italic>λ</italic> are varied. Here we vary the feature overlap <italic>λ</italic> ϵ {0.25, 0.5, 0.75}, the feature fraction <italic>λ<sub>s</sub></italic> ϵ {0.5,0.6, 0.7, 0.8,0.9}, and the sample fraction <italic>λ<sub>s</sub></italic> ϵ {0. 1, 0.2<italic>, … ,</italic>0.9}. In Figs. 1, 2, 3 we show how the precision and recall of GMT, M2S, and mC depend on these parameters. Here we use the same unnormalized validation data and experimental setup as decribed in the main text section “Validation on ground-truth data” and in the Methods and Materials section “Validation on simulated data”. For each triple (<italic>λ, λ<sub>f</sub>, λ<sub>s</sub></italic>) we randomly generate 20 dataset splits with these parameters and show the average precision and recall for each method over these trials. Our method GMT (thresholded GromovMatcher) is applied out-of-box with the default hyperparameter settings. The algorithm hyperparameters for mC and M2S are chosen optimally for each individual triple of dataset parameters (<italic>λ, λ<sub>f</sub>, λ<sub>s</sub></italic>) to maximize the average F1 score in each setting. The hyperparameters searched over when optimizing mC and M2S are described in detail in <xref ref-type="app" rid="app2">Appendix 2</xref>.</p>
<p>Consistent with prior validation experiments, we find that GromovMatcher outperforms both mC and M2S in all dataset regimes, for low overlap and high overlap <italic>λ</italic> as well as for varying balances of features <italic>λ<sub>f</sub></italic> and samples <italic>λ<sub>s</sub></italic>. Remarkably, all three methods exhibit the same sensitivity to variations of (<italic>λ, λ<sub>f</sub>, λ<sub>s</sub></italic>). All methods exhibit a monotonic decrease in their precision as <italic>λ<sub>f</sub></italic> drops from 0.9 to 0.5. In other words, the most challenging setting for matching both datasets is when dataset 1 and dataset 2 both have an equal number of unshared features (e.g. <italic>λ<sub>f</sub></italic> = 0.5). Likewise, the simplest setting for matching is when the features in dataset 2 are exactly a subset of the features in dataset 1 (e.g. <italic>λ<sub>f</sub></italic> = 1). Sensitivity to this parameter <italic>λ<sub>f</sub></italic> is most noticeable at low feature overlap <italic>λ</italic> = 0.25.</p>
<fig id="figapp2" position="float" fig-type="figure">
<label>Appendix 3—figure 1.</label>
<caption><title>Sensitivity of thresholded GromovMatcher (GMT) to feature overlap fraction <italic>λ</italic>, feature imbalance fraction <italic>λ<sub>f</sub></italic>, and sample imbalance fraction <italic>λ<sub>s</sub></italic> between two datasets being matched.</title></caption>
<graphic xlink:href="2306.03218v3_figapp2.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
<fig id="figapp3" position="float" fig-type="figure">
<label>Appendix 3—figure 2.</label>
<caption><title>Sensitivity of M2S to feature overlap fraction <italic>λ</italic>, feature imbalance fraction <italic>λ<sub>f</sub></italic>, and sample imbalance fraction <italic>λ<sub>s</sub></italic> between two datasets being matched.</title>
</caption>
<graphic xlink:href="2306.03218v3_figapp3.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
<fig id="figapp4" position="float" fig-type="figure">
<label>Appendix 3—figure 3.</label>
<caption><title>Sensitivity of metabCombiner (mC) to feature overlap fraction <italic>λ</italic>, feature imbalance fraction <italic>λ<sub>f</sub></italic>, and sample imbalance fraction <italic>λ<sub>s</sub></italic> between two datasets being matched.</title></caption>
<graphic xlink:href="2306.03218v3_figapp4.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
</app>
<app id="app4">
<title>Appendix 4</title>
<p>Here we describe additional preprocessing details and analyses of the EPIC data.</p>
<sec id="s24">
<title>Centered and scaled data - Negative mode</title>
<p>In this section, we present the results obtained on centered and scaled EPIC data in negative mode, shown in Figure 4 of our main paper. However, due to the smaller size of the validation subset (42 features examined in negative mode compared to 163 in positive mode), the evaluation of the performance of the three methods may be less reliable than in positive mode.</p>
<p>First, we align the CS and HCC studies in negative mode and detect a total of 449, 492, and 180 matches with GM, M2S, and metabCombiner, respectively. Similar to the positive mode analysis, we evaluate the precision and recall of the three methods on the 42 feature validation subset, of which 19 were manually matched. GM and M2S demonstrate identical F1-scores of 0.98, while metabCombiner performs poorly in comparison. GM is able to recover all 19 true matches and identified only 1 false positive, while M2S recovers no false positives but missed 1 true positive.</p>
<p>Next, we align the CS and PC studies in negative mode and detect a total of 485, 569, and 314 matches with GM, M2S, and metabCombiner, respectively. Again, we evaluate the precision and recall of the three methods on the 42 feature validation subset, of which 26 were manually matched. MetabCombiner performs better than in the other EPIC pairings with an F1-score of 0.857, but is still outperformed by the other two methods. GM is slightly outperformed by M2S in this setting, with an almost identical precision of 0.93, but a slightly higher recall for M2S due to detecting 1 additional true positive. However, this remains a good performance for GM since M2S was optimally tuned using the validation subset itself.</p>
</sec>
<sec id="s25">
<title>Non-centered and non-scaled data</title>
<p>As a sensitivity analysis, we apply the three methods to EPIC data that has not been centered or scaled. The detailed results can be found in <xref ref-type="table" rid="apptbl2">Appendix 4 - Table 1</xref>.</p>
<table-wrap id="apptbl2" orientation="portrait" position="float">
<label>Appendix 4—table 1.</label>
<caption><title>Precision and recall on the EPIC validation subset for unnormalized data in (a) positive mode, and (b) negative mode.</title><p>95% confidence intervals were computed using modified Wilson score intervals <xref ref-type="bibr" rid="c7">Brown et al. (2001)</xref>; <xref ref-type="bibr" rid="c1">Agresti and Coull (1998)</xref>.</p></caption>
<alternatives>
<graphic xlink:href="2306.03218v3_apptbl2.tif" mimetype="image" mime-subtype="tiff"/>
<table frame="hsides" rules="groups">
<thead>
<tr>
<th valign="bottom" align="center"/>
<th colspan="2" valign="bottom" align="center">CS ↔ HCC</th>
<th colspan="2" valign="bottom" align="center">CS ↔ PC</th>
</tr>
<tr>
<th valign="bottom" align="left">Method</th>
<th valign="bottom" align="center">Precision</th>
<th valign="bottom" align="center">Recall</th>
<th valign="bottom" align="center">Precision</th>
<th valign="bottom" align="center">Recall</th>
</tr>
</thead>
<tbody>
<tr>
<td valign="bottom" align="right"><bold>GromovMatcher</bold></td>
<td valign="bottom" align="center">0.988 (0.937, 0.999)</td>
<td valign="bottom" align="center">0.944 (0.876, 0.997)</td>
<td valign="bottom" align="center">0.873 (0.776, 0.932)</td>
<td valign="bottom" align="center">0.939 (0.854, 0.976)</td>
</tr>
<tr>
<td valign="bottom" align="left"><bold>M2S</bold></td>
<td valign="bottom" align="center">0.967 (0.908, 0.991)</td>
<td valign="bottom" align="center">0.978 (0.923, 0.996)</td>
<td valign="bottom" align="center">0.855 (0.759, 0.917)</td>
<td valign="bottom" align="center">0.985 (0.919, 0.999)</td>
</tr>
<tr>
<td valign="bottom" align="left"><bold>metabCombiner</bold></td>
<td valign="bottom" align="center">0.979 (0.889, 0.999)</td>
<td valign="bottom" align="center">0.511 (0.410, 0.612)</td>
<td valign="bottom" align="center">0.926 (0.766, 0.987)</td>
<td valign="bottom" align="center">0.379 (0.271, 0.499)</td>
</tr>
<tr>
<td valign="bottom" align="left"><bold>GromovMatcher</bold></td>
<td valign="bottom" align="center">0.950 (0.764, 0.997)</td>
<td valign="bottom" align="center">1.000 (0.832, 1.000)</td>
<td valign="bottom" align="center">0.964 (0.823, 0.998)</td>
<td valign="bottom" align="center">0.964 (0.823, 0.998)</td>
</tr>
<tr>
<td valign="bottom" align="left"><bold>M2S</bold></td>
<td valign="bottom" align="center">1.000 (0.824, 1.000)</td>
<td valign="bottom" align="center">0.947 (0.754, 0.997)</td>
<td valign="bottom" align="center">0.931 (0.780, 0.988)</td>
<td valign="bottom" align="center">0.964 (0.823, 0.998)</td>
</tr>
<tr>
<td valign="bottom" align="left"><bold>metabCombiner</bold></td>
<td valign="bottom" align="center">1.000 (0.566, 1.000)</td>
<td valign="bottom" align="center">0.263 (0.118, 0.488)</td>
<td valign="bottom" align="center">1.000 (0.785, 1.000)</td>
<td valign="bottom" align="center">0.500 (0.326, 0.674)</td>
</tr>
</tbody>
</table>
</alternatives>
<table-wrap-foot>
<fn id="apptbl2-fn1"><p><bold>(a)</bold> Positive mod</p></fn>
<fn id="apptbl2-fn2"><p><bold>(b)</bold> Negative mode</p></fn>
</table-wrap-foot>
</table-wrap>
<p>M2S was tuned manually on the validation subset to ignore feature intensities in both cases. As a result, it maintains its performance compared to our main experiment. On the other hand, the performance of GM and metabCombiner is affected by the lack of consistency in feature intensities. MetabCombiner’s recall drops slightly but its precision remains comparable to that of our main experiment, with the method clearly favoring the latter. Although GM’s recall decreases slightly in positive mode, it remains more precise than the optimally tuned M2S, and it balances precision and recall better than metabCombiner. Interestingly, GM’s results in negative mode are improved compared to our main experiment, and it outperforms both mC and M2S. However, since the validation subset in negative mode is relatively small, these differences may not be significant. Nonetheless, GM maintains a good performance, similar to that of the optimally tuned M2S.</p>
<p>Similar to the analysis we conducted on centered and scaled data, we find a high number of false positives when aligning the CS study and the PC study in positive mode. Therefore, we manually examine the matches recovered by GM. Our examination reveals 2 false positives, 4 unclear matches, and 3 additional good matches that GM also identifies in our main analysis. This demonstrates that the lack of centering and scaling results in two additional false positives for GM that are not present in our main results.</p>
</sec>
<sec id="s26">
<title>Illustration for alcohol biomarker discovery</title>
<p>Loftfield et al. <xref ref-type="bibr" rid="c24">Loftfield et al. (2021)</xref> identified 205 features associated with alcohol intake in the CS study, using a false discovery rate (FDR) correction to account for multiple testing. By applying an FDR correction in our pooled analysis, we identify 243 features associated with alcohol intake. Out of those 243 features, 185 are consistent with the features identified in the discovery step of Loftfield et al. <xref ref-type="bibr" rid="c24">Loftfield et al. (2021)</xref>, while 55 features are newly discovered (<xref ref-type="fig" rid="fig5">Fig. 5c</xref>). We examine the 20 features identified as significant in Loftfield et al.’s discovery analysis but that are not significant in our pooled analysis. Both manual and GM matching yield identical results for these features, indicating that the loss of significance is not due to incorrect matching. Upon further investigation, we find that these features do not demonstrate a meaningful association with alcohol intake in the HCC and PC studies. This observation is reinforced by the fact that none of these features are among the 10 features that persisted after the validation step in Loftfield et al.</p>
<p>Out of the 205 features initially discovered in Loftfield et al. <xref ref-type="bibr" rid="c24">Loftfield et al. (2021)</xref>, 10 are replicated in the EPIC HCC and PC studies using the more stringent Bonferroni correction. When using a Bonferroni correction in our pooled analysis, we find significant association between alcohol intake and 92 features, 36 of which are effectively shared by the three studies. Notably, these features include all 10 features that were retained in Loftfield et al. (<xref ref-type="fig" rid="fig5">Fig. 5c</xref>).</p>
<p>This analysis illustrates how GromovMatcher can be used in the context of biomarker discovery, and its potential to allow for increased statistical power.</p>
</sec>
</app>
<app id="app5">
<title>Appendix 5</title>
<p>Here we investigate how the choice of the reference dataset influences the discovery of metabolites shared across the CS, HCC and PC EPIC studies by GromovMatcher. All three methods considered in this paper, GromovMatcher, M2S, and metabCombiner, are limited to the comparison of two datasets. However, they can still be used to compare and pool multiple datasets using a multi-step procedure. Namely, this can be done by designating a ‘reference’ dataset and aligning all studies to it one by one. We take this exact approach in our analysis when aligning the CS, HCC, and PC studies of the EPIC data in positive mode. Namely, the HCC and PC studies are both aligned to the CS study (see main text <xref ref-type="fig" rid="fig5">Fig. 5b</xref>). However, this method raises two critical questions: <italic>(i)</italic> how does the use of a reference dataset affect matching results, and <italic>(ii)</italic> how is the matching affected by the choice of reference dataset.</p>
<p>To address these questions, we compare the features identified as common to the three studies using two different studies as references: the CS study used as reference in the main analysis, and the HCC study. For simplicity, let’s denote <italic>M</italic><sub>study1</sub>,<sub>study2</sub> the matching matrix obtained when aligning study 1 and study 2.</p>
<sec id="s27">
<title>Changes in matching results when reference dataset is used</title>
<p>Concerning question (i), we compare two matchings: HCC to CS to PC (the matrix product 
<inline-formula id="ID139">
<alternatives>
<mml:math display="block" id="I139">
<mml:mrow>
<mml:msubsup>
<mml:mi>M</mml:mi>
<mml:mrow>
<mml:mtext>CS</mml:mtext><mml:mo>,</mml:mo><mml:mtext>HCC</mml:mtext></mml:mrow>
<mml:mi>T</mml:mi>
</mml:msubsup>
<mml:msub>
<mml:mi>M</mml:mi>
<mml:mrow>
<mml:mtext>CS</mml:mtext><mml:mo>,</mml:mo><mml:mtext>PC</mml:mtext></mml:mrow>
</mml:msub>
</mml:mrow>
</mml:math>
<inline-graphic xlink:href="2306.03218v3_ieq139.tif" mimetype="image" mime-subtype="tiff"/>
</alternatives>
</inline-formula>) which we will refer to as the reference matching, and the direct matching of PC to HCC (<italic>M</italic><sub>HCC, PC</sub>). Note that these matchings are not fully comparable as the former considers only features found in CS, potentially missing unique HCC and PC matches. We can however compare the two matchings on the subset of 706 features common to all three studies, as determined by the reference matching. We find that the direct matching supports 683 out of them, indicating that the matching via a reference still yields good results compared to the direct matching (see <xref ref-type="app" rid="app5">Appendix 5</xref> <xref ref-type="fig" rid="fig1">Fig. 1</xref>).</p>
<fig id="figapp5" position="float" fig-type="figure">
<label>Appendix 5—figure 1</label>
<caption><title>Overlap between the 706 features common to the HCC and PC studies found via reference matching, and the 938 features common to HCC and PC found by direct matching</title></caption>
<graphic xlink:href="2306.03218v3_figapp5.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
</sec>
<sec id="s28">
<title>Effect of reference dataset choice on matching results</title>
<p>Concerning question <italic>(ii)</italic>, we compare the features identified as common to the three studies using two different studies as references: the CS study used in the paper, and the HCC study. We find that they identify 706 and 708 common features respectively, with an overlap of 640 features (see <xref ref-type="app" rid="app5">Appendix 5</xref> <xref ref-type="fig" rid="fig2">Fig. 2</xref>). This highlights that the choice of reference does matter to some extent. In the paper, choosing CS as a reference was informed by CS’s sample size, and study population.</p>
<fig id="figapp6" position="float" fig-type="figure">
<label>Appendix 5—figure 2.</label>
<caption><title>Overlap between the features identified as common to the three EPIC studies using either the CS study or the HCC study as a reference.</title></caption>
<graphic xlink:href="2306.03218v3_figapp6.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
<fig id="figS1" position="float" fig-type="figure">
<label>Figure 3—figure supplement 1.</label>
<caption><title>Average precision and recall obtained on simulated data, with fixed overlap λ = 0.5.</title><p>The noise level corresponds to different values of <italic>σ</italic><sub>RT</sub> and <italic>σ</italic><sub>FI</sub>. High, medium and low noise level correspond to (<italic>σ</italic><sub>RT</sub><italic>, σ</italic><sub>FI</sub>) = (0.2, 0. 1), (0<italic>.5,</italic> 0.5) and (1, 1) respectively. We run 20 simulations for each setting.</p></caption>
<graphic xlink:href="2306.03218v3_figS1.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
<fig id="figS2" position="float" fig-type="figure">
<label>Figure 3—figure supplement 2.</label>
<caption><title>Performance on centered and scaled data.</title><p>The feature intensities of both datasets are centered and scaled to have means of 0 and standard deviations of 1. The average precision and recall of the three methods are computed on 20 randomly generated pairs of datasets, for (a) three levels of overlap (low, medium and high corresponding to <italic>λ</italic> = 0<italic>.25,</italic> 0<italic>.5</italic> and 0.75, respectively) with a medium noise level ((<italic>σ</italic><sub>RT</sub><italic>, σ</italic><sub>FI</sub>) = (0.5, 0.5)), and (b) fixed medium overlap (<italic>λ</italic> = 0.5) and three different noise levels (low, medium and high corresponding to (<italic>σ</italic><sub>RT</sub><italic>, σ</italic><sub>FI</sub>) = (0.2, 0.1), (0.5, 0.5) and (1, 1), respectively).</p>
</caption>
<graphic xlink:href="2306.03218v3_figS2.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
<fig id="figS3" position="float" fig-type="figure">
<label>Figure 4—figure supplement 1.</label>
<caption><title>Consistency of the mean feature intensities (FI) in EPIC.</title><p>Each scatter plot represents the mean feature intensities of manually matched features from the validation subset. Each dot represents a pair of manually matched features. The axis represent the mean feature intensities recorded in the two different studies.</p></caption>
<graphic xlink:href="2306.03218v3_figS3.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
<fig id="figS4" position="float" fig-type="figure">
<label>Figure 4—figure supplement 2.</label>
<caption><title>Overlap between the matching results obtained by metabCombiner, M2S and GromovMatcher in EPIC. Venn diagrams are not up to scale.</title></caption>
<graphic xlink:href="2306.03218v3_figS4.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
<fig id="figS5" position="float" fig-type="figure">
<label>Figure 4—figure supplement 3.</label>
<caption><title>Estimated RT drift between the EPIC studies aligned in the main experiment.</title><p>Each dot correspond to a candidate matched pair after the first step of GM (<italic>m/z</italic> constrained GW matching), before the RT drift estimation and RT based filtering.</p></caption>
<graphic xlink:href="2306.03218v3_figS5.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
</sec>
</app>
</app-group>
</back>
<sub-article id="sa0" article-type="editor-report">
<front-stub>
<article-id pub-id-type="doi">10.7554/eLife.91597.2.sa2</article-id>
<title-group>
<article-title>eLife Assessment</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<name>
<surname>Fernandez</surname>
<given-names>Paula</given-names>
</name>
<role specific-use="editor">Reviewing Editor</role>
<aff>
<institution-wrap>
<institution>INTA</institution>
</institution-wrap>
<city>Buenos Aires</city>
<country>Argentina</country>
</aff>
</contrib>
</contrib-group>
<kwd-group kwd-group-type="evidence-strength">
<kwd>Convincing</kwd>
</kwd-group>
<kwd-group kwd-group-type="claim-importance">
<kwd>Important</kwd>
</kwd-group>
</front-stub>
<body>
<p>The authors describe an <bold>important</bold> tool, GromovMatcher, that can be used to compare proteomic data from various experimental approaches. The underlying method is innovative, the algorithm is clearly described, and the validation that is presented is <bold>convincing</bold>.</p>
</body>
</sub-article>
<sub-article id="sa1" article-type="referee-report">
<front-stub>
<article-id pub-id-type="doi">10.7554/eLife.91597.2.sa1</article-id>
<title-group>
<article-title>Reviewer #1 (Public Review):</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<anonymous/>
<role specific-use="referee">Reviewer</role>
</contrib>
</contrib-group>
</front-stub>
<body>
<p>Summary:</p>
<p>The authors have implemented Optimal Transport algorithm in GromovMatcher for comparing LC/MS features from different datasets. This paper gains significance in the proteomics field for performing meta-analysis of LC/MS data.</p>
<p>Strengths:</p>
<p>The main strength is that GromovMatcher acheives significant performance metrics compared to other existing methods. The authors have done extensive comparisons to claim that GromovMatcher performs well.</p>
<p>Weaknesses:</p>
<p>The authors might need to add the limitation of datasets and thus have tested/validated their tool using simulated data in the abstract as well.</p>
</body>
</sub-article>
<sub-article id="sa2" article-type="referee-report">
<front-stub>
<article-id pub-id-type="doi">10.7554/eLife.91597.2.sa0</article-id>
<title-group>
<article-title>Reviewer #2 (Public Review):</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<anonymous/>
<role specific-use="referee">Reviewer</role>
</contrib>
</contrib-group>
</front-stub>
<body>
<p>Summary</p>
<p>The goal of untargeted metabolomics is to identify differences between metabolomes of different biological samples.</p>
<p>Untargeted metabolomics identifies features with specific mass-to-charge-ratio (m/z) and retention time (RT). Matching those to specific metabolites based on the model compounds from databases is laborious and not always possible, which is why methods for comparing samples on the level of unmatched features are crucial.</p>
<p>
The main purpose of the GromovMatcher method presented here is to merge and compare untargeted metabolomes from different experiments. These larger datasets could then be used to advance biological analyses, for example, for identification of metabolic disease markers.</p>
<p>The main problem that complicates merging different experiments is that m/z and RT vary slightly for the same feature (metabolite).</p>
<p>The main idea behind the GromovMatcher is built on the assumption that if two features match between two datasets (that feature i from dataset 1 matches feature j from dataset 2, and feature k from dataset 1 matches feature l from dataset 2), then the correlations or distances between the two features within each of the datasets (i and k, and j and l) will be similar. The authors then use the Gromov-Wasserstein method to find the best matches matrix from these data.</p>
<p>The variation in m/z between the same features in different experiments is a user-defined value and it is initially set to 0.01 ppm. There is no clear limit for RT deviations, so the method estimates a non-linear deviation (drift) of RT between two studies. GromovMatcher estimates the drift between two studies, and then discards the matching pairs where the drift would deviate significantly from the estimate. It learns the drift from a weighted spline regression.</p>
<p>The authors validate the performance of their GromovMatcher method using a dataset of cord blood. They use 20 different splits and compare the GromovMatcher (both its GM and GMT iterations, whereby GMT version uses the deviation from estimated RT drift to filter the matching matrix) with two other matching methods: M2S and metabCombiner.</p>
<p>The second validation was done using a (scaled and centered) dataset of metabolics from cancer datasets from the EPIC cohort that were manually matched by an expert. This dataset was also used to show that using automated methods can identify more features that are associated with a particular group of samples than what was found by manual matching. Specifically, the authors identify additional features connected to alcohol consumption.</p>
<p>Strengths:</p>
<p>I see the main strength of this work in its combination of all levels of information (m/z, RT, and higher-order information on correlations between features) and using each of the types of information in a way that is appropriate for the measure. The most innovative aspect is using the Gromov-Wasserstein method to match the features based on distance matrices.</p>
<p>The authors of the paper identify two main shortcomings with previously established methods that attempt to match features from different experiments: a) all other methods require fine-tuning of user-defined parameters, and, more importantly, b) do not consider correlations between features. The main strength of the GromovMatcher is that it incorporates the information on distances between the features (in addition to also using m/z and RT).</p>
<p>Weaknesses:</p>
<p>The main weakness is that there seem not to be enough manually curated datasets that could be used for validation. It will, therefore, be important, for the authors, and the field in general to keep validating and improving their methods if more datasets become available.</p>
<p>The second weakness, as emphasized by the authors in the discussion is that the method as it is set up now can be directly used only to compare two datasets. I am confident that the authors will successfully implement novel algorithms to address this issue in the future.</p>
</body>
</sub-article>
<sub-article id="sa3" article-type="author-comment">
<front-stub>
<article-id pub-id-type="doi">10.7554/eLife.91597.2.sa3</article-id>
<title-group>
<article-title>Author Response</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<name>
<surname>Breeur</surname>
<given-names>Marie</given-names>
</name>
<role specific-use="author">Author</role>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Stepaniants</surname>
<given-names>George</given-names>
</name>
<role specific-use="author">Author</role>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Keski-Rahkonen</surname>
<given-names>Pekka</given-names>
</name>
<role specific-use="author">Author</role>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Rigollet</surname>
<given-names>Philippe</given-names>
</name>
<role specific-use="author">Author</role>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Viallon</surname>
<given-names>Vivian</given-names>
</name>
<role specific-use="author">Author</role>
</contrib>
</contrib-group>
</front-stub>
<body>
<p>The following is the authors’ response to the original reviews.</p>
<disp-quote content-type="editor-comment">
<p>eLife assessment</p>
<p>This paper represents important findings when identifying untargeted metabolomics and its differences between metabolomes of different biological samples. GromovMatcher is the fantasy name for the soft development. The main idea behind it is built on the assumption of featuring and matching complex datasets. Although the manuscript reflects a solid analysis, it remains incomplete for validation with putative non-curated datasets.</p>
</disp-quote>
<p>We are grateful to the eLife editor for taking the time and effort to assess our manuscript.</p>
<p>We are however unsure of what the editor means by “it remains incomplete for validation with putative non-curated datasets”. As noted by Reviewer 2, manually curated datasets that could be used for validation are scarce. Most publicly available datasets do not contain sufficient information to establish a ground truth matching on which GromovMatcher, M2S, or metabCombiner can be tested. Even in the case where such a ground truth matching can be established, it must be performed by-hand through a manual matching process which is extremely time-consuming and requires very specific expertise. This, in our opinion, only highlights the need for automatic alignment methods such as metabCombiner, M2S or GromovMatcher.</p>
<p>We do agree that the performance of GromovMatcher (and its competitors) needs to be validated further, and we plan to continue validating GromovMatcher as additional data becomes available in EPIC and other cohorts. With that in mind, the lack of publicly available validation data is the reason why we conducted such an extensive simulation study, arguably more comprehensive than previous validations, exploring challenging settings that we believe reflect real-life scenarios (main text “Validation on ground-truth data” and Appendix 3). We would like to stress that this allows us to highlight previously ignored limitations of the previously published methods, metabCombiner and M2S.</p>
<p>We wish to thank the editor and reviewers for their time and efforts in reviewing our manuscript which led to many significant additions to our paper. Namely we:</p>
<p>•   Performed an additional sensitivity analysis (Appendix 3) exploring how an imbalance in the number of features or samples between two studies being matched (e.g. the dataset split), affects the quality of matchings found by GromovMatcher, metabCombiner, and M2S.</p>
<p>•   Investigated how changing or removing the reference dataset (Appendix 5) in the EPIC study (main text “Application to EPIC data”), affects the results of GromovMatcher.</p>
<p>•   Improved alignment matrix visualizations in Fig. 3a for all four methods tested on the validation data, to highlight more clearly which feature matches were correctly identified or missed.</p>
<p>The revised paper is uploaded as the file “main_elife_revision.pdf” where all revisions are highlighted in blue as well as a copy “main_elife_revision_nohighlights.pdf” where revisions are not highlighted.</p>
<disp-quote content-type="editor-comment">
<p><bold>Public Reviews:</bold></p>
<p><bold>Reviewer #1 (Public Review):</bold></p>
</disp-quote>
<p>Summary:</p>
<disp-quote content-type="editor-comment">
<p>The authors have implemented the Optimal Transport algorithm in GromovMatcher for comparing LC/MS features from different datasets. This paper gains significance in the proteomics field for performing meta-analysis of LC/MS data.</p>
<p>Strengths:</p>
<p>The main strength is that GromovMatcher achieves significant performance metrics compared to other existing methods. The authors have done extensive comparisons to claim that GromovMatcher performs well.</p>
<p>Weaknesses:</p>
<p>There are two weaknesses.</p>
<p>(1) When the number of features is reduced the precision drops to ~0.8.</p>
</disp-quote>
<p>We would like to clarify that this drop in precision occurs in the challenging setting where only a small proportion of metabolites are shared between both datasets (e.g., the overlap – or proportion of shared features - was 25% in our simulation study). When two untargeted metabolic datasets share only 25% of their features, this is a challenging setting for any automated matching method as the vast majority 75% of the features in both datasets must remain unmatched.</p>
<p>In such settings, the reviewer correctly observes that the precision of GromovMatcher algorithms (GM and GMT) drops within the range of 0.80 - 0.85 (Figure 3b, top left panel). Such a precision of 0.8 or larger is still competitive compared with the alternative methods MetabCombiner (mC) and M2S whose precisions drop below 0.8 (see main text Fig. 3b, top left panel).</p>
<p>Precision is measured as the number of metabolite pairs correctly matched divided by all matches identified by a method. In other words, even in the challenging setting when the number of shared features (true matches) between both datasets is small (e.g. low 25% overlap), upwards of 80% of the feature matches found by GromovMatcher are correct which is a very encouraging result.</p>
<disp-quote content-type="editor-comment">
<p>(2) How applicable is the method for other non-human datasets?</p>
</disp-quote>
<p>We thank the reviewer for raising this question. The crux of the matter concerning the application to animal data revolves around the hypothesis that correlations between metabolites in two different studies are preserved. Theoretically, the metabolome operates under similar principles in humans, governed by an underlying network of biochemical reactions. Consequently, in comparable human populations, the GM hypothesis is likely to hold to some extent.</p>
<p>However, in practice, application to animal data is more complicated. Animal studies tend to have smaller sample sizes and often stem from intervention-driven scenarios, such as mice subjected to specific diets or chemicals. This results in deliberate alterations in metabolic structures which makes finding two comparable animal studies less likely. To investigate the reviewer’s question, we have searched through the two predominant LC-MS dataset repositories (MetaboLights and NIH Metabolomics Workbench) but did not find any pairs of comparable animal studies due to the reasons mentioned above. One potential strategy to navigate this issue could entail regressing the metabolic intensities against the variables that notably differ between the two animal populations and running GM using the residual intensities. This would be an interesting direction for future research and additional validation would be needed to test the robustness of GM in this setting.</p>
<disp-quote content-type="editor-comment">
<p><bold>Reviewer #2 (Public Review):</bold></p>
<p>Summary:</p>
<p>The goal of untargeted metabolomics is to identify differences between metabolomes of different biological samples. Untargeted metabolomics identifies features with specific mass-to-charge ratio (m/z) and retention time (RT). Matching those to specific metabolites based on the model compounds from databases is laborious and not always possible, which is why methods for comparing samples on the level of unmatched features are crucial.</p>
<p>The main purpose of the GromovMatcher method presented here is to merge and compare untargeted metabolomes from different experiments. These larger datasets could then be used to advance biological analyses, for example, for the identification of metabolic disease markers. The main problem that complicates merging different experiments is m/z and RT vary slightly for the same feature (metabolite).</p>
<p>The main idea behind the GromovMatcher is built on the assumption that if two features match between two datasets (that feature I from dataset 1 matches feature j from dataset 2, and feature k from dataset 1 matches feature l from dataset 2), then the correlations or distances between the two features within each of the datasets (i and k, and j and l) will be similar. The authors then use the Gromov-Wasserstein method to find the best matches matrix from these data.</p>
<p>The variation in m/z between the same features in different experiments is a user-defined value and it is initially set to 0.01 ppm. There is no clear limit for RT deviations, so the method estimates a non-linear deviation (drift) of RT between two studies. GromovMatcher estimates the drift between the two studies and then discards the matching pairs where the drift would deviate significantly from the estimate. It learns the drift from a weighted spline regression.</p>
<p>The authors validate the’performance of their GromovMatcher method by a validation experiment using a dataset of cord blood. They use 20 different splits and compare the GromovMatcher (both its GM and GMT iterations, whereby the GMT version uses the deviation from estimated RT drift to filter the matching matrix) with two other matching methods: M2S and metabCombiner.</p>
<p>The second validation was done using a (scaled and centered) dataset of metabolics from cancer datasets from the EPIC cohort that was manually matched by an expert. This dataset was also used to show that using automatic methods can identify more features that are associated with a particular group of samples than what was found by manual matching. Specifically, the authors identify additional features connected to alcohol consumption.</p>
<p>Strengths:</p>
<p>I see the main strength of this work in its combination of all levels of information (m/z, RT, and higher-order information on correlations between features) and using each of the types of information in a way that is appropriate for the measure. The most innovative aspect is using the Gromov-Wasserstein method to match the features based on distance matrices.</p>
</disp-quote>
<p>We thank the reviewer for acknowledging this strength of our proposed GromovMatcher method.</p>
<disp-quote content-type="editor-comment">
<p>The authors of the paper identify two main shortcomings with previously established methods that attempt to match features from different experiments: a) all other methods require fine-tuning of user-defined parameters, and, more importantly, b) do not consider correlations between features. The main strength of the GromovMatcher is that it incorporates the information on distances between the features (in addition to also using m/z and RT).</p>
<p>Weaknesses:</p>
<p>The first, minor, weakness I could identify is that there seem not to be plenty of manually curated datasets that could be used for validation.</p>
</disp-quote>
<p>We thank the reviewer for raising this issue concerning manually curated validation data.</p>
<p>Manually curated datasets available for validation purposes are indeed scarce. This stems from the laborious nature of matching features across diverse studies, hence the need for automatic matching methods. Our future strategy involves further validation of the GromovMatcher approach as more data becomes accessible in EPIC and other cohorts.</p>
<p>The scarcity of real-life publicly available datasets that can be used for validation purpose is the reason why we conducted an extensive simulation study (main text “Validation on ground-truth data” and Appendix 3). It is notably thorough, arguably more comprehensive than previous validations, utilizes real-life untargeted data, and imitates situations where data originates from distinct untargeted metabolomics studies, complete with realistic noise parameters encompassing RT, mz, and feature intensities. Our validation study comprehensively explores the performance of GromovMatcher, M2S, and metabCombiner, including in challenging realistic settings where there is a nonlinear drift in retention times, varying levels of feature overlaps between studies, normalizations of feature intensities, as well as imbalances in the number of features and samples present in the studies being matched.</p>
<disp-quote content-type="editor-comment">
<p>The second is also emphasized by the authors in the discussion. Namely, the method as it is set up now can be directly used only to compare two datasets.</p>
</disp-quote>
<p>This is indeed a limitation that is common to all three methods considered in this paper. However, all these methods, GromovMatcher, M2S, and metabCombiner, can still be used to compare and pool multiple datasets using a multi-step procedure. Namely, this can be done by designating a 'reference' dataset and aligning all studies to it one by one. We take this exact approach in our paper when aligning the CS, HCC, and PC studies of the EPIC data in positive mode (main text “Application to EPIC data”). Namely, the HCC and PC studies are both aligned to the CS study by running GromovMatcher twice, and after obtaining these matchings, our analysis is restricted to those features in HCC and PC that are present in the CS study.</p>
<p>After the reviewer’s comment, we have added an additional sensitivity analysis in Appendix 5, to compare the results produced by GromovMatcher depending on the choice of the reference study. Namely, setting the reference study to either the CS study or the HCC study, GromovMatcher identified 706 and 708 common features respectively, with an overlap of 640 features. This highlights that the choice of reference does matter to some extent. In our original analysis of the EPIC data, choosing CS as the reference was motivated by the fact that CS had the largest sample size (compared to HCC and PC) and a subset of features in HCC and PC were already matched by experts to the CS study which we could use for validation (see Loftfield et al. (2021). J Natl Cancer Inst.).</p>
<p>As mentioned in the discussion section of our manuscript, the recently proposed multimarginal Gromov-Wasserstein algorithm (Beier, F., Beinert, R., &amp; Steidl, G. (2023).  Information and Inference) could potentially allow multiple metabolomic studies to be matched using one optimization routine (e.g. without the designation of a ‘reference study’ for matching). We have not explored this possibility in depth yet as fast numerical methods for multimarginal GW are still in their infancy. Also, such multimarginal methods rely on the computation and storage of coupling or matching matrices that are tensors where the number of dimensions is equal to the number of datasets being matched.  Therefore, multimarginal methods have large memory costs, which currently precludes their application for the matching of multiple metabolomics datasets.</p>
<disp-quote content-type="editor-comment">
<p><bold>Reviewer #2 (Recommendations For The Authors):</bold></p>
<p>(1) I was struggling with the representation used in Figure 3a. The gray points overlayed over the green points on a straight line are difficult to visually quantify. I found that my eyes mainly focused on the pattern of the red dots.</p>
</disp-quote>
<p>Figure 3a has been modified to improve visual clarity. Namely we have consistently reordered the rows and columns of the coupling matrices such that the true positive matches (green points) are spatially separated from the false negative matches (red points). Now the fraction of true positive and false negative matches can be appreciated much more clearly by eye in Figure 3a.</p>
<disp-quote content-type="editor-comment">
<p>(2) I would also like to add the caveat that I cannot judge whether the authors used the other two methods that they compare with GromovMatcher (the M2S and metabCombiner) optimally. But I also do not see any evidence that they did not. Hopefully one of the other reviewers can address that.</p>
</disp-quote>
<p>We appreciate the reviewer for highlighting the comparison of our approach GromovMatcher to the other existing methods M2S and MetabCombiner (mC). Both M2S and mC depend on tens of hyperparameters each with a discrete or continuous set of values that must be properly optimized to infer accurate matchings between dataset features. We detail in Appendix 2 how the hyperparameters of the M2S and mC methods are optimally tuned to achieve the best possible performance on the validation ground-truth data. Namely, both in the simulation study and on EPIC data, we grid-search over all important hyperparameters in the M2S and mC methods and choose those parameter combinations that result in the highest F1 score, averaged over 20 random trials. We remark that no such hyperparameter optimization was performed for our GromovMatcher method. As shown in Figures 3 and 4 of the main text, we find that GromovMatcher outperforms M2S and mC even in these cases when the hyperparameters of M2S and mC are tuned to predict optimal feature matchings.</p>
<p>Given the large combinatorial space of hyperparameter choices, we believe we have thoroughly tested the important hyperparameter combinations that users of M2S and mC would be likely to explore in their own research.</p>
<disp-quote content-type="editor-comment">
<p>(3) Validation</p>
<p>(3a) The first validation is done on a split cord blood dataset. I could not clearly see from the paper how sensitive the result is to the dataset split.</p>
</disp-quote>
<p>We are grateful for the reviewer’s question and have included new experiments in Appendix 3 which show how the results of GromovMatcher, M2S, and MetabCombiner are affected by the dataset split. In our original manuscript, our validation ground-truth experiment began with an untargeted metabolomic dataset consisting of n = 499 samples and p = 4,712 metabolic features which is split equally into two datasets consisting of an equal number of samples n1 = n2 and an equal number of metabolic features p1 = p2. The features of these equal-sized datasets would then be matched by our method.</p>
<p>Now in Appendix 3 (Figs. 1-3) we show the sensitivity of all three alignment methods (GromovMatcher, M2S, and MetabCombiner) when we vary the fraction of samples in dataset 1 over dataset 2 given by n1/ n2, the overlap in shared features between both datasets, and the fraction of metabolic features in dataset 1 that are not present in dataset 2 which affects the feature sizes of both datasets  p1/ p2. We find that all alignment methods are able to maintain a consistent precision and recall score when these three dataset split parameters are varied. GromovMatcher achieves a higher precision and recall than M2S and MetabCombiner for all choices of dataset split, agreeing with the validation experiment results from the main text (see main text Fig. 3). All three methods tested decrease in precision (without dropping in recall) when dataset 1 and dataset 2 contain an equal number of unshared features (e.g. when p1 = p2). Therefore, these sensitivity experiments in Appendix 3 show that our results in the main text are performed in the most challenging setting for the dataset split.</p>
<disp-quote content-type="editor-comment">
<p>(3b) The second validation was done using a (scaled and centered) dataset of metabolics from cancer datasets from the EPIC cohort that was manually matched by an expert. Here the authors observe that metabCombiner has good precision, but lags in recall. And M2S has a very similar performance to GromovMatcher. The authors explain this by the fact that the drift in RT between the two experiments is mostly linear and thus does not affect the M2S performance. Can the authors find a different validation dataset where the drift in RT is not linear? If yes, it would be interesting to add it to the paper.</p>
</disp-quote>
<p>We thank the reviewer for raising this question. As mentioned above, curated validation datasets such as the EPIC study analyzed in our paper are very rare and we do not currently have a validation study with a nonlinear retention time drift.</p>
<p>Nevertheless, we performed an additional analysis of simulated data (reported in Appendix 2 – “M2S hyperparameter experiments” and Appendix 2 – Table 1) that demonstrates the decrease in M2S performance when the simulated drift is nonlinear. As presented in Appendix 2 – Table 1, in a low overlap setting with a linear drift which corresponds to the EPIC data, precision and recall were 0.831 and 0.934 respectively, instead of 0.769 and 0.905 in the main analysis where the drift was nonlinear.</p>
</body>
</sub-article>
</article>