<?xml version="1.0" ?><!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.3 20210610//EN"  "JATS-archivearticle1-mathml3.dtd"><article xmlns:ali="http://www.niso.org/schemas/ali/1.0/" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article" dtd-version="1.3" xml:lang="en">
<front>
<journal-meta>
<journal-id journal-id-type="nlm-ta">elife</journal-id>
<journal-id journal-id-type="publisher-id">eLife</journal-id>
<journal-title-group>
<journal-title>eLife</journal-title>
</journal-title-group>
<issn publication-format="electronic" pub-type="epub">2050-084X</issn>
<publisher>
<publisher-name>eLife Sciences Publications, Ltd</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">91597</article-id>
<article-id pub-id-type="doi">10.7554/eLife.91597</article-id>
<article-id pub-id-type="doi" specific-use="version">10.7554/eLife.91597.1</article-id>
<article-version-alternatives>
<article-version article-version-type="publication-state">reviewed preprint</article-version>
<article-version article-version-type="preprint-version">1.2</article-version>
</article-version-alternatives>
<article-categories>
<subj-group subj-group-type="heading">
<subject>Computational and Systems Biology</subject>
</subj-group>
<subj-group subj-group-type="heading">
<subject>Cancer Biology</subject>
</subj-group>
</article-categories>
<title-group>
<article-title>Optimal transport for automatic alignment of untargeted metabolomic data</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<name>
<surname>Breeur</surname>
<given-names>Marie</given-names>
</name>
<xref ref-type="aff" rid="a1">1</xref>
<xref ref-type="fn" rid="fn1">†</xref>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Stepaniants</surname>
<given-names>George</given-names>
</name>
<xref ref-type="aff" rid="a2">2</xref>
<xref ref-type="fn" rid="fn1">†</xref>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Keski-Rahkonen</surname>
<given-names>Pekka</given-names>
</name>
<xref ref-type="aff" rid="a1">1</xref>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Rigollet</surname>
<given-names>Philippe</given-names>
</name>
<xref ref-type="aff" rid="a2">2</xref>
</contrib>
<contrib contrib-type="author" corresp="yes">
<name>
<surname>Viallon</surname>
<given-names>Vivian</given-names>
</name>
<xref ref-type="aff" rid="a1">1</xref>
<xref ref-type="corresp" rid="cor1">*</xref>
<email xlink:href="mailto:viallonv@iarc.who.int">viallonv@iarc.who.int</email>
</contrib>
</contrib-group>
<contrib-group content-type="section">
<contrib contrib-type="editor">
<name>
<surname>Fernandez</surname>
<given-names>Paula</given-names>
</name>
<role>Reviewing Editor</role>
<aff>
<institution-wrap>
<institution>INTA</institution>
</institution-wrap>
<city>Buenos Aires</city>
<country>Argentina</country>
</aff>
</contrib>
<contrib contrib-type="senior_editor">
<name>
<surname>Choi</surname>
<given-names>Murim</given-names>
</name>
<role>Senior Editor</role>
<aff>
<institution-wrap>
<institution>Seoul National University</institution>
</institution-wrap>
<city>Seoul</city>
<country>Republic of Korea</country>
</aff>
</contrib>
</contrib-group>
<aff id="a1"><label>1</label><institution>Nutrition and Metabolism Branch, International Agency for Research on Cancer</institution>, <addr-line>Lyon</addr-line>, <country>France</country></aff>
<aff id="a2"><label>2</label><institution>Massachusetts Institute of Technology, Department of Mathematics</institution>, <addr-line>Cambridge MA</addr-line>, <country>United States</country></aff>
<author-notes>
<corresp id="cor1"><label>*</label><bold>For correspondence:</bold> <email xlink:href="mailto:viallonv@iarc.who.int">viallonv@iarc.who.int</email> (VV)</corresp>
<fn id="fn1"><label>†</label><p>These authors contributed equally to this work and are joint first authors</p></fn>
</author-notes>
<pub-date pub-type="epub">
<day>13</day>
<month>09</month>
<year>2023</year>
</pub-date>
<pub-date date-type="original-publication" iso-8601-date="2023-12-11">
<day>11</day>
<month>12</month>
<year>2023</year>
</pub-date>
<volume>12</volume>
<elocation-id>RP91597</elocation-id>
<history><date date-type="sent-for-review" iso-8601-date="2023-09-11">
<day>11</day>
<month>09</month>
<year>2023</year>
</date>
</history>
<pub-history>
<event>
<event-desc>Preprint posted</event-desc>
<date date-type="preprint" iso-8601-date="2023-09-13">
<day>13</day>
<month>09</month>
<year>2023</year>
</date>
<self-uri content-type="preprint" xlink:href="https://doi.org/10.48550/arXiv.2306.03218"/>
</event>
</pub-history>
<permissions>
<copyright-statement>© 2023, Breeur et al</copyright-statement>
<copyright-year>2023</copyright-year>
<copyright-holder>Breeur et al</copyright-holder>
<ali:free_to_read/>
<license xlink:href="https://creativecommons.org/licenses/by/4.0/">
<ali:license_ref>https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
<license-p>This article is distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution License</ext-link>, which permits unrestricted use and redistribution provided that the original author and source are credited.</license-p>
</license>
</permissions>
<self-uri content-type="pdf" xlink:href="elife-preprint-91597-v1.pdf"/>
<abstract>
<title>Abstract</title>
<p>Untargeted metabolomic profiling through liquid chromatography-mass spectrometry (LC-MS) measures a vast array of metabolites within biospecimens, advancing drug development, disease diagnosis, and risk prediction. However, the low throughput of LC-MS poses a major challenge for biomarker discovery, annotation, and experimental comparison, necessitating the merging of multiple datasets. Current data pooling methods encounter practical limitations due to their vulnerability to data variations and hyperparameter dependence. Here we introduce GromovMatcher, a flexible and user-friendly algorithm that automatically combines LC-MS datasets using optimal transport. By capitalizing on feature intensity correlation structures, GromovMatcher delivers superior alignment accuracy and robustness compared to existing approaches. This algorithm scales to thousands of features requiring minimal hyperparameter tuning. Applying our method to experimental patient studies of liver and pancreatic cancer, we discover shared metabolic features related to patient alcohol intake, demonstrating how GromovMatcher facilitates the search for biomarkers associated with lifestyle risk factors linked to several cancer types.</p>
</abstract>

</article-meta>
<notes>
<notes notes-type="conflict-of-interest-statement">
<title>Competing interests</title>
<p>The authors declare no competing interests.</p>
</notes>
</notes>
</front>
<body>
<sec id="s1" sec-type="intro">
<title>Introduction</title>
<p>Untargeted metabolomics is a powerful analytical technique used to identify and measure a large number of metabolites in a biological sample without preselecting targets <italic><bold><xref ref-type="bibr" rid="c28">Patti (2011)</xref></bold></italic>. This approach allows for a comprehensive overview of an individual’s metabolic profile, provides insights into the biochemical processes involved in cellular and organismal physiology <italic><bold><xref ref-type="bibr" rid="c48">Wishart (2019)</xref></bold></italic>; <bold><italic><xref ref-type="bibr" rid="c31">Pirhaji et al. (2016)</xref></italic></bold>, and allows for the exploration of how environmental factors impact metabolism <bold><italic><xref ref-type="bibr" rid="c32">Rappaport et al. (2014)</xref></italic></bold>; <italic><bold><xref ref-type="bibr" rid="c5">Bedia (2022)</xref></bold></italic>. It creates new opportunities to investigate health-related conditions, including diabetes <italic><bold><xref ref-type="bibr" rid="c47">Wang et al. (2011)</xref></bold></italic>, inflammatory bowel diseases <italic><bold><xref ref-type="bibr" rid="c14">Franzosa et al. (2019)</xref></bold></italic>, and various cancer types <italic><bold><xref ref-type="bibr" rid="c24">Loftfield et al. (2021)</xref></bold></italic>; <italic><bold><xref ref-type="bibr" rid="c22">Li et al. (2020)</xref></bold></italic>. However, a major challenge in biomarker discovery, metabolic signature identification and other untargeted metabolomic analyses lies in the low throughput of experimental data, necessitating the development of efficient pooling algorithms capable of merging datasets from multiple sources <italic><bold><xref ref-type="bibr" rid="c24">Loftfield et al. (2021)</xref></bold></italic>.</p>
<p>A common experimental technique in untargeted metabolomics is liquid chromatography-mass spectrometry (LC-MS) which assembles a list of thousands of unlabeled metabolic features characterized by their mass-to-charge ratio (<italic>m</italic>/<italic>z</italic>), retention time (RT) <italic><bold><xref ref-type="bibr" rid="c50">Zhou et al. (2012)</xref></bold></italic>, and intensity across all biological samples. Combining LC-MS datasets from multiple experimental studies remains challenging due to variation in the <italic>m</italic>/<italic>z</italic> and RT of a feature from one study to another <italic><bold><xref ref-type="bibr" rid="c50">Zhou et al. (2012)</xref></bold></italic>; <italic><bold><xref ref-type="bibr" rid="c20">Ivanisevic and Want (2019)</xref></bold></italic>. This problem is further compounded by differing instruments and analytical protocols across laboratories, resulting in seemingly incompatible metabolomic datasets.</p>
<p>Manual matching of metabolic features can be a laborious and error-prone task <bold><italic>Loftfield et al. (2021)</italic></bold>. To address this challenge, several automated methods have been developed for metabolic feature alignment. One such method is MetaXCMS, which matches LC-MS features based on user-defined <italic>m</italic>/<italic>z</italic> and RT thresholds <italic><bold><xref ref-type="bibr" rid="c44">Tautenhahn et al. (2011)</xref></bold></italic>. More advanced tools use information on feature intensities measured in samples. For instance, PAIRUP-MS uses known shared metabolic features to impute the intensities of all features from one dataset to another <italic><bold><xref ref-type="bibr" rid="c19">Hsu et al. (2019)</xref></bold></italic>. MetabCombiner <italic><bold><xref ref-type="bibr" rid="c18">Habra et al. (2021)</xref></bold></italic> and M2S <italic><bold><xref ref-type="bibr" rid="c11">Climaco Pinto et al. (2022)</xref></bold></italic> compare average feature intensities, along with their <italic>m</italic>/<italic>z</italic> and RT values, to align datasets without requiring extensive knowledge of shared features. These automated alignment methods have accelerated our ability to pool and annotate datasets as well as extract biologically meaningful biomarkers. However, they demand substantial fine-tuning of user-defined parameters and ignore correlations among metabolic features which provide a wealth of additional information on shared features.</p>
<p>Here we introduce GromovMatcher, a user-friendly flexible algorithm which automates the matching of metabolic features across experiments. The main technical innovation of Gromov-Matcher lies in its ability to incorporate the correlation information between metabolic feature intensities, building upon the powerful mathematical framework of computational optimal transport (OT) <italic><bold><xref ref-type="bibr" rid="c30">Peyré et al. (2019)</xref></bold></italic>; <italic><bold><xref ref-type="bibr" rid="c46">Villani (2021)</xref></bold></italic>. OT has proven effective in solving various matching problems and has found applications in multiomics analysis <italic><bold><xref ref-type="bibr" rid="c13">Demetci et al. (2022)</xref></bold></italic>, cell development <italic><bold><xref ref-type="bibr" rid="c35">Schiebinger et al. (2019)</xref></bold></italic>; <italic><bold><xref ref-type="bibr" rid="c49">Yang et al. (2020)</xref></bold></italic>, and chromatogram alignment <bold><italic>Skoraczynski et al. (2022)</italic></bold>. Here we leverage the Gromov-Wasserstein (GW) method <italic><bold><xref ref-type="bibr" rid="c25">Memoli (2011)</xref></bold></italic>; <bold><italic>Solomon et al. (2016)</italic></bold>, which matches datasets based on their distance structure and has been seminally applied to spatial reconstruction problems in genomics <italic><bold><xref ref-type="bibr" rid="c27">Nitzan et al. (2019)</xref></bold></italic>. GromovMatcher builds upon the GW algorithm to automatically uncover the shared correlation structure among metabolic feature intensities while also incorporating <italic>m</italic>/<italic>z</italic> and RT information in the final matching process.</p>
<p>To assess the performance of GromovMatcher, we systematically benchmark it on synthetic data with varying levels of noise, feature overlap, and data normalizations, outperforming prior state-of-the-art methods of metabCombiner <italic><bold><xref ref-type="bibr" rid="c18">Habra et al. (2021)</xref></bold></italic> and M2S <italic><bold><xref ref-type="bibr" rid="c11">Climaco Pinto et al. (2022)</xref></bold></italic>. Next we apply GromovMatcher to align experimental patient studies of liver and pancreatic cancer to a reference dataset and associate the shared metabolic features to each patient’s alcohol intake. Through these efforts, we demonstrate how GromovMatcher data pooling improves our ability to discover biomarkers of lifestyle risk factors associated with several types of cancer.</p>
</sec>
<sec id="s2" sec-type="results">
<title>Results</title>
<sec id="s2a">
<title>GromovMatcher algorithm</title>
<p>GromovMatcher uses the mathematical framework of OT to find all matching metabolic features between two untargeted metabolomic datasets (<xref ref-type="fig" rid="fig1">Fig. 1</xref>). It accepts two LC-MS datasets with possibly different numbers of metabolic features and samples. Each feature, fx<italic>،</italic> in Dataset 1 and fy<sub><italic>j</italic></sub> in Dataset 2, is identified by its <italic>m</italic>/<italic>z</italic>, RT, and vector of feature intensities across samples (<xref ref-type="fig" rid="fig1">Fig. 1a</xref>). The primary tenet of GromovMatcher is that shared metabolic features have similar correlation patterns in both datasets and can be matched based on the distance/correlations between their feature intensity vectors. Specifically, GromovMatcher computes the pairwise distances between the feature intensity vectors of each metabolic feature in a dataset and saves them into a distance matrix, one per dataset (<xref ref-type="fig" rid="fig1">Fig. 1b</xref>). In practice, we use either the Euclidean distance or the cosine distance (negative of correlation) to perform this step (Methods). The resulting distance matrices contain information about the feature intensity similarity within each study. Using optimal transport, we can deduce shared subsets of metabolic features in both datasets which have corresponding feature intensity distance structures.</p>
<fig id="fig1" position="float" fig-type="figure">
<label>Figure 1</label>
<caption><p>An optimal transport approach for combining untargeted metabolomics datasets (GromovMatcher). (<bold>A</bold>) Inputs are two LC-MS datasets of unlabeled metabolic features (rows) identified by their <italic>m</italic>/<italic>z</italic>, RT, and feature intensities across biospecimen samples. Both studies can have differing numbers of metabolic features and samples. (<bold>B</bold>) In both datasets, the intensities across samples of each metabolic feature are formed into a vector and Euclidean distances between these feature vectors are computed and stored in a distance matrix. (<bold>C</bold>) Based on the technique of optimal transport, the unbalanced GW algorithm learns a coupling matrix <inline-formula id="ID1">
<alternatives><mml:math display="inline" id="I1"><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">˜</mml:mo></mml:mover></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq1.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> that places large weights <inline-formula id="ID2">
<alternatives><mml:math display="inline" id="I2"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">˜</mml:mo></mml:mover><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq2.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> when fx<sub><italic>i</italic></sub> and fy<sub><italic>j</italic></sub> likely correspond to the same metabolic feature. It optimizes <inline-formula id="ID3">
<alternatives><mml:math display="inline" id="I3"><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">˜</mml:mo></mml:mover></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq3.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> to match features with similar pairwise distances (red outlined boxes) whose <italic>m</italic>/<italic>z</italic> ratios are close. (<bold>D</bold>) The final step of GromovMatcher plots the retention times of features from both datasets against each other and fits a spline interpolation <inline-formula id="ID4">
<alternatives><mml:math display="inline" id="I4"><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq4.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> weighted by the estimated coupling weights <inline-formula id="ID5">
<alternatives><mml:math display="inline" id="I5"><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq5.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>. This retention time drift function is then used to set all entries <inline-formula id="ID6">
<alternatives><mml:math display="inline" id="I6"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq6.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> to zero for those outlier pairs (fx<sub><italic>i</italic></sub>, fy<sub><italic>j</italic></sub>) which exceed twice the median absolute deviation (MAD) around <inline-formula id="ID7">
<alternatives><mml:math display="inline" id="I7"><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq7.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> (green highlighted region). Finally, the coupling matrix <inline-formula id="ID8">
<alternatives><mml:math display="inline" id="I8"><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">˜</mml:mo></mml:mover></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq8.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> is filtered and/or thresholded to obtain a refined coupling <inline-formula id="ID9">
<alternatives><mml:math display="inline" id="I9"><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq9.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> which is then binarized to obtain a one-to-one matching <italic>M</italic> between a subset of metabolite pairs in both datasets.</p></caption>
<graphic xlink:href="2306.03218v2_fig1.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
<p>OT was originally developed to optimize the transportation of soil for the construction of forts <bold><italic>Monge (1781)</italic></bold> and was later generalized through the language of probability theory and linear programming <italic><bold><xref ref-type="bibr" rid="c21">Kantorovich (2006)</xref></bold></italic>, leading to efficient numerical algorithms and direct applications to planning problems in economics. The ability of OT to efficiently match source to target locations found applications in data science for the alignment of distributions <italic><bold><xref ref-type="bibr" rid="c12">Courty et al. (2017)</xref></bold></italic>; <bold><italic><xref ref-type="bibr" rid="c4">Alvarez-Melis et al. (2019)</xref></italic></bold> and was generalized by the Gromov-Wasserstein (GW) method <italic><bold><xref ref-type="bibr" rid="c29">Peyré et al. (2016)</xref></bold></italic>; <italic><bold><xref ref-type="bibr" rid="c3">Alvarez-Melis and Jaakkola (2018)</xref></bold></italic> to align datasets with features of differing dimensions.</p>
<p>In practice, a sizeable fraction of the metabolic features measured in one study may not be present in the other. Hence, in most cases only a subset of features in both datasets can be matched. Recent GW formulations for unbalanced matching problems <italic><bold><xref ref-type="bibr" rid="c37">Sejourne et al. (2021)</xref></bold></italic> allow for matching only subsets of metabolic features with similar intensity structures (<xref ref-type="fig" rid="fig1">Fig. 1c</xref>). To incorporate additional feature information, we modify the optimization objective of unbalanced GW to penalize feature matches whose <italic>m</italic>/<italic>z</italic> differences exceed a fixed threshold (Methods, <xref ref-type="appendix" rid="app1">Appendix 1</xref>). The optimization ofthis objective computes a <italic>coupling matrix</italic> <inline-formula id="ID10">
<alternatives><mml:math display="inline" id="I10"><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">˜</mml:mo></mml:mover></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq10.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> where each entry <inline-formula id="ID11">
<alternatives><mml:math display="inline" id="I11"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq11.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> indicates the level of confidence in matching metabolic feature fx<sub><italic>i</italic></sub> in Dataset 1 to fy<sub><italic>j</italic></sub> in Dataset 2.</p>
<p>Differences in experimental conditions can induce variations in RT between datasets that can be nonlinear and large in magnitude <italic><bold><xref ref-type="bibr" rid="c50">Zhou et al. (2012)</xref></bold></italic>; <italic><bold><xref ref-type="bibr" rid="c11">Climaco Pinto et al. (2022)</xref></bold></italic>; <bold><italic>Habra et al. (2021)</italic></bold>. In the spirit of previous methods for LC-MS batch or dataset alignment <italic><bold><xref ref-type="bibr" rid="c40">Smith et al. (2006)</xref></bold></italic>; <italic><bold><xref ref-type="bibr" rid="c8">Brunius et al. (2016)</xref></bold></italic>; <italic><bold><xref ref-type="bibr" rid="c23">Liu et al. (2020)</xref></bold></italic>; <italic><bold><xref ref-type="bibr" rid="c45">Vaughan et al. (2012)</xref></bold></italic>; <italic><bold><xref ref-type="bibr" rid="c18">Habra et al. (2021)</xref></bold></italic>; <bold><italic>Climaco Pinto et al. (2022)</italic></bold>; <italic><bold><xref ref-type="bibr" rid="c38">Skoraczynski et al. (2022)</xref></bold></italic>, the learned coupling <inline-formula id="ID12">
<alternatives><mml:math display="inline" id="I12"><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">˜</mml:mo></mml:mover></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq12.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> is used to estimate a nonlinear map (drift function) between RTs of both datasets by weighted spline regression, which allows us to filter unlikely matches from the coupling matrix to obtain a refined coupling matrix <inline-formula id="ID13">
<alternatives><mml:math display="inline" id="I13"><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq13.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> (<xref ref-type="fig" rid="fig1">Fig. 1d</xref>, Methods). An optional thresholding step removes matches with small weights from the coupling matrix. The final output of GromovMatcher is a binary matching matrix <italic>M</italic> where <italic>M<sub>ij</sub></italic> is equal to 1 if features fx<sub><italic>i</italic></sub> and fy<sub><italic>j</italic></sub> are matched and 0 otherwise. Throughout the paper, we refer to the two variants of GromovMatcher, with and without the optional thresholding step as GMT and GM respectively.</p>
</sec>
<sec id="s2b">
<title>Validation on ground-truth data</title>
<p>We first evaluate the performance of GromovMatcher using a real-world untargeted metabolomics study of cord blood across 499 newborns containing 4,712 metabolic features characterized by their <italic>m</italic>/<italic>z</italic>, RT, and feature intensities <italic><bold><xref ref-type="bibr" rid="c2">Alfano et al. (2020)</xref></bold></italic>. To generate ground-truth data, we randomly divide the initial dataset into two smaller datasets sharing a subset of features (<xref ref-type="fig" rid="fig2">Fig. 2</xref>). We simulate diverse acquisition conditions by adding noise to the <italic>m</italic>/<italic>z</italic> and RT of dataset 2, and to the feature intensities in both datasets. Moreover, we introduce an RT drift in dataset 2 to replicate the retention time variations observed in real LC-MS experiments (Methods and Materials). For comparison, we also test M2S <italic><bold><xref ref-type="bibr" rid="c11">Climaco Pinto et al. (2022)</xref></bold></italic> and metabCombiner <bold><italic>Habra et al. (2021)</italic></bold>, both of which use <italic>m</italic> / <italic>z</italic>, RT, and median or mean feature intensities to match features (<xref ref-type="fig" rid="fig3">Fig. 3</xref>). MetabCombiner is supplied with 100 known shared metabolic features to automatically set its hyperparameters, while M2S parameters are manually fine-tuned to optimize the F1-score in each scenario (<xref ref-type="appendix" rid="app2">Appendix 2</xref>). We assess the performance of GM, GMT, metabCombiner, and M2S across 20 randomly generated dataset pairs in terms of their precision (fraction of true matches among the detected matches) and recall/sensitivity (fraction of true matches detected) averaged across 20 dataset pairs.</p>
<p>To investigate how the number of shared features affects dataset alignment, we generate pairs of LC-MS datasets with low, medium, and high feature overlap (25%, 50%, and 75%), while maintaining a medium noise level (Methods). Here we find that GM and GMT generally outperform existing alignment methods, with a recall above 0.95 while metabCombiner and M2S tend to be less sensitive (<xref ref-type="fig" rid="fig3">Fig. 3b</xref>). All methods drop in precision as the feature overlap is decreased, with GM and GMT still maintaining an average precision above 0.8.</p>
<fig id="fig2" position="float" fig-type="figure">
<label>Figure 2</label>
<caption><p>Simulated data for testing untargeted metabolomics alignment methods. (<bold>A</bold>) Initial LC-MS dataset taken from the EXPOsOMICS project with <italic>m</italic>/<italic>z</italic>, RT, and feature intensities of <italic>p</italic> = 4, 712 metabolites identified in cord blood across <italic>n</italic> = 499 newborns. (<bold>B</bold>) Newborns (rows) are split into two disjoint groups of sizes <italic>n</italic><sub>1</sub> = 249 and <italic>n</italic><sub>2</sub> = 250 respectively and metabolic features (columns) are split into two equal groups of size <italic>p</italic><sub>1</sub> = <italic>p</italic><sub>2</sub> with overlap <inline-formula id="ID14">
<alternatives><mml:math display="inline" id="I14"><mml:mrow><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:mi>λ</mml:mi><mml:mi>p</mml:mi></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq14.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> where λ = 0.25 ,0.5 ,0.75 (Methods). Datasets are perturbed by additive noise of magnitude (σ<sub>M</sub>, σ<sub>RT</sub>, σ<sub>FI</sub>) and a nonlinear drift <italic>f</italic> (<italic>X</italic>) is applied to the RTs of dataset 2. (<bold>C</bold>) The two resulting datasets share σ = 25%, 50%, or 75% of the original dataset’s metabolic features.</p></caption>
<graphic xlink:href="2306.03218v2_fig2.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
<p>Next we evaluate all four methods at low, moderate, and high noise levels for pairs of datasets with 50% over-lap in their features (Methods). Our results show that GMT, GM, and M2S maintain an average recall above 0.89, while metabCombiner’s recall drops below 0.6 for high noise. At large noise levels, RT drift estimation becomes more challenging, leading to a higher rate of false matches between metabolites (lower precision) for all four methods (<xref ref-type="fig" rid="fig7">Fig. 3 — figure supplement 1</xref>). Nevertheless, GMT obtains a high average precision and recall of 0.86 and 0.92 respectively.</p>
<p>A notable difference between GM, metabCombiner, and M2S lies in their use of feature intensities. MetabCombiner expects that the mean feature intensity rankings are identical across studies, while M2S assumes that shared features have similar median intensities. In contrast, GM uses both the mean feature intensities and their variances and covariances. In practice, differences in experimental assays or study populations can lead to greater variation in feature intensities, making matchings based on these statistics less reliable. Centering and scaling the feature intensities to unit variance avoids potential biases arising from inconsistent feature intensity magnitudes, but preserves correlations that GM leverages.</p>
<p>Exploring this further, we test how sensitive all four methods are to centering and scaling of feature intensities. MetabCombiner and M2S are tuned using the same methodology as for noncentered and non-scaled data. For M2S, we match features solely based on their <italic>m</italic>/<italic>z</italic> and RT. In this experiment (<xref ref-type="fig" rid="fig8">Figure 3 — figure supplement 2</xref>), the absence of intensity magnitude information significantly affects metabCombiner’s performance and, to a lesser extent, M2S. GM and GMT still obtain accurate matchings, due to their use of correlation structures which are preserved under centering and scaling.</p>
</sec>
<sec id="s2c">
<title>Application to EPIC data</title>
<p>Next, we apply GM, metabCombiner and M2S to align datasets from the European Prospective Investigation into Cancer and Nutrition (EPIC) cohort, a prospective study conducted across 23 European centers. EPIC comprises more than 500,000 participants who provided blood samples at recruitment <italic><bold><xref ref-type="bibr" rid="c34">Riboli et al. (2002)</xref></bold></italic>. Untargeted metabolomics data were successively acquired in several studies nested within the full cohort.</p>
<p>In the present work, we use LC-MS data from the EPIC cross-sectional (CS) study <italic><bold><xref ref-type="bibr" rid="c39">Slimani et al. (2003)</xref></bold></italic> and two matched case-control studies nested within EPIC, on hepatocellular carcinoma (HCC) <italic><bold><xref ref-type="bibr" rid="c42">Stepien et al. (2016</xref></bold></italic>, <xref ref-type="bibr" rid="c43">2021</xref>) and pancreatic cancer (PC) <italic><bold><xref ref-type="bibr" rid="c15">Gasull et al. (2019)</xref></bold></italic>. LC-MS untargeted metabolomic data were acquired at the International Agency for Research on Cancer, making use of the same platform and methodology (Methods). The number of samples and features in each study is displayed in <xref ref-type="fig" rid="fig4">Fig. 4a</xref>.</p>
<fig id="fig3" position="float" fig-type="figure">
<label>Figure 3.</label>
<caption><p>Comparison of MetabCombiner, M2S, and GromovMatcher on simulated data. (<bold>A</bold>) Ground-truth matchings, and matchings inferred by metabCombiner, M2S, GM, and GMT. Pairs of datasets are generated for three levels of overlap (low, medium and high), with a medium noise level (Methods). Matches correctly recovered (true positives) are represented in green. True matches that are not recovered (false negatives) are highlighted in grey. Incorrect matches (false positives) are plotted in red. (<bold>B</bold>) Average precision and recall on 20 randomly generated pairs of datasets, for three levels of overlap (low, medium and high) with a medium noise level.</p>
<p><bold><xref ref-type="fig" rid="fig7">Figure 3—figure supplement 1</xref>.</bold> Average precision and recall obtained on simulated data, with fixed overlap λ = 0.5. The noise level corresponds to different values of σ<sub>RT</sub> and σ<sub>FI</sub>. High, medium and low noise level correspond to (σ<sub>RT</sub>, σ<sub>FI</sub>) = (0.2, 0.1), (0.5, 0.5) and (1, 1) respectively. We run 20 simulations for each setting.</p>
<p><bold><xref ref-type="fig" rid="fig8">Figure 3—figure supplement 2</xref>.</bold> Performance on centered and scaled data. The feature intensities of both datasets are centered and scaled to have means of0 and standard deviations of 1. The average precision and recall of the three methods are computed on 20 randomly generated pairs of datasets, for (a) three levels of overlap (low, medium and high corresponding to λ = 0.25 ,0.5 and 0.75, respectively) with a medium noise level ((σ<sub>RT</sub>, σ<sub>FI</sub>) = (0.5, 0.5)), and (b) fixed medium overlap (λ = 0.5) and three different noise levels (low, medium and high corresponding to (σ<sub>RT</sub>, σ<sub>FI</sub>) = (0.2, 0.1), (0.5, 0.5) and (1, 1), respectively).</p></caption>
<graphic xlink:href="2306.03218v2_fig3.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
<p>Loftfield et al. <italic><bold><xref ref-type="bibr" rid="c24">Loftfield et al. (2021)</xref></bold></italic> previously matched features from the CS, HCC, and PC studies in EPIC for alcohol biomarker discovery. The authors first identified 205 features (163 in positive and 42 in negative mode) associated with alcohol intake in the CS study. These features were then manually matched by an expert to features in both the HCC and PC studies (Methods). In our analysis, we use these features as a validation set and compare each method’s matchings to the expert manual matchings on this subset. Due to the imbalance between the number of positive and negative mode features in the validation subset, our main analysis focuses on the alignment results of CS with HCC and CS with PC in positive mode. We delegate the matching results between the negative mode studies to <xref ref-type="appendix" rid="app3">Appendix 3</xref>.</p>
<p>In this section, we use the same settings for GM as in our simulation study, and do not apply an additional thresholding step. The parameters of metabCombiner and M2S are calibrated using the validation subset as prior knowledge (<xref ref-type="appendix" rid="app2">Appendix 2</xref>).</p>
<p>Preliminary analysis of the validation subset reveals inconsistencies in the mean feature intensities (<xref ref-type="fig" rid="fig9">Figure 4 — figure supplement 1</xref>), but <xref ref-type="fig" rid="fig4">Figure 4b</xref> shows that on centered and scaled data, the 90 expert matched features shared between the CS and HCC studies have similar correlation structures. Hence, to avoid potential errors we center and scale the feature intensities which improves the performance of all three methods tested below (<xref ref-type="appendix" rid="app3">Appendix 3</xref>, <xref ref-type="table" rid="tbl5">Appendix 3 — Table 1</xref>).</p>
<sec id="s2c1">
<title>Hepatocellular carcinoma</title>
<p>Here we analyze the quality of the matchings obtained by GM, M2S, and metabCombiner between the CS and HCC datasets in positive mode. Both GM and M2S identify approximately 1000 shared features while metabCombiner finds a smaller number of about 700 shared features. We refer the reader to <xref ref-type="fig" rid="fig10">Figure 4- figure supplement 2a</xref> for the precise matched feature sizes and details on the agreement between the feature matchings of all three methods.</p>
<p>We evaluate the performance of metabCombiner, M2S, and GM on the validation subset in positive mode (<xref ref-type="fig" rid="fig4">Fig. 4c</xref>), which consist of 90 features from the CS study manually matched to features from the HCC study and 73 features specific to the CS study. MetabCombiner demonstrates precise matching but lacks sensitivity. M2S’s precision and recall are comparable with GM, in contrast to its performance on simulated data. This can be attributed to the RT drift shape between the CS and HCC studies (<xref ref-type="appendix" rid="app2">Appendix 2</xref>), which is estimated to be close to linear (<xref ref-type="fig" rid="fig11">Figure 4 — figure supplement 3</xref>). Because the parameters of M2S are fine-tuned in the validation subset, it is able to learn this linear drift and apply tight RT thresholds to achieve accurate matchings. In contrast to metabCombiner and M2S, the GM algorithm is not given any prior knowledge of the validation subset, and nevertheless demonstrates the highest precision and recall rates of the three methods (<xref ref-type="fig" rid="fig4">Fig. 4c</xref>). <xref ref-type="fig" rid="fig4">Figure 4b</xref> shows how GM recovers the majority of the expert matched pairs by leveraging the shared correlations.</p>
</sec>
<sec id="s2c2">
<title>Pancreatic cancer</title>
<p>Matching features between the CS and PC studies in positive mode, GM and M2S identify approximately 1000 common features, while metabCombiner detects approximately 600 matches (<xref ref-type="fig" rid="fig10">Figure 4- figure supplement 2b</xref>). We examine the performance of all three methods on the validation subset consisting of 66 manually matched features between CS and PC along with 97 features specific to the CS study. As before, GM and M2S have high recall while the recall of metabCombiner is less than 0.5.</p>
<p>A decrease in precision is observed for both GM and M2S compared to the previous CS-HCC matchings. We therefore manually inspect the false positive matches; the set of CS features matched by the method to the PC study but explicitly examined and left unmatched in the expert manual matching. Assessing the GM results, we identify 7 false positive feature matches. Upon secondary inspection, 3 pairs are revealed as correct matches that were not initially identified in the expert matching. M2S finds 11 false positive matches which include the 7 false positives recovered by GM. Manual examination of the 4 remaining pairs reveals 2 clear mismatches. These results highlight the advantage of using automated methods for data alignment, as both GM and M2S detect correct matches that were not identified by experts, with GM being more precise than M2S.</p>
<fig id="fig4" position="float" fig-type="figure">
<label>Figure 4.</label>
<caption><p>Application of GromovMatcher and comparison to existing methods on EPIC dataset. (<bold>A</bold>) Dimensions of the three EPIC studies used. For each ionization mode, the cross-sectional (CS) study is aligned successively with the hepatocellular carcinoma (HCC) study and the pancreatic cancer (PC) study. (<bold>B</bold>) Demonstration of expert manual matching and GromovMatcher (GM) matching between the CS and HCC studies in positive mode. Experts manually match 90 features from <italic>Loftfield et al.</italic> (<italic>2021</italic>) and the correlation matrices of these features in both datasets have similar structure (bottom two matrices). GM discovers 996 shared features between the CS and HCC datasets which have similar correlation structure (top two matrices). We validate that 88 of the 90 features from the manually expert matched subset are contained in the set of features matched by GM. (<bold>C</bold>) Performance of metabCombiner (mC), M2S and GM in positive mode. Precisions and recalls are measured on a validation subset of 163 manually examined features, and 95% confidence intervals are computed using modified Wilson score intervals. (<bold>D</bold>) Performance of mC, M2S and GM in negative mode. Precision and recall are measured on a validation subset of42 manually examined features, and 95% confidence intervals are computed using modified Wilson score intervals. See <xref ref-type="table" rid="tbl2">Table 2</xref> and <xref ref-type="table" rid="tbl3">Table 3</xref> for exact precisions, recalls, and confidence intervals in positive and negative mode respectively.</p>
<p><bold><xref ref-type="fig" rid="fig9">Figure 4—figure supplement 1</xref>.</bold> Consistency of the mean feature intensities (FI) in EPIC. Each scatter plot represents the mean feature intensities of manually matched features from the validation subset. Each dot represents a pair of manually matched features. The axis represent the mean feature intensities recorded in the two different studies.</p>
<p><bold><xref ref-type="fig" rid="fig10">Figure 4—figure supplement 2</xref>.</bold> Overlap between the matching results obtained by metabCombiner, M2S and GromovMatcher in EPIC. Venn diagrams are not up to scale.</p>
<p><bold><xref ref-type="fig" rid="fig11">Figure 4—figure supplement 3</xref>.</bold> Estimated RT drift between the EPIC studies aligned in the main experiment. Each dot correspond to a candidate matched pair after the first step of GM (<italic>m</italic>/<italic>z</italic> constrained GW matching), before the RT drift estimation and RT based filtering.</p></caption>
<graphic xlink:href="2306.03218v2_fig4.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
</sec>
<sec id="s2c3">
<title>Illustration for alcohol biomarker discovery</title>
<p>Loftfield et al. <italic><bold><xref ref-type="bibr" rid="c24">Loftfield et al. (2021)</xref></bold></italic> identified biomarkers of habitual alcohol intake by first performing a discovery step, where they examined the relationship between alcohol intake and metabolic features in the CS study. They then manually matched the significant features in CS to features from the HCC and PC studies, and repeated the analysis with samples from the HCC and PC studies to determine whether the association with alcohol intake persisted. This led to the identification of 10 features possibly associated with alcohol intake (<xref ref-type="fig" rid="fig5">Fig. 5a</xref>).</p>
<p>To extend this analysis and illustrate the benefit of GM automatic matching for biomarker discovery, we use GM to pool features from the CS, HCC, and PC studies, and examine the relationship between metabolic features and alcohol intake in the pooled study (Methods and <xref ref-type="fig" rid="fig5">Fig. 5b</xref>).</p>
<p>Applying an FDR correction on the pooled study, we identify 243 features associated with alcohol intake, including 185 features consistent with the discovery step of Loftfield et al. <bold><italic>Loftfield et al. (2021)</italic></bold>, and 55 newly discovered features (<xref ref-type="fig" rid="fig5">Fig. 5c</xref>). Using the more stringent Bonferroni correction on the pooled data, we identify 36 features shared by all three studies that are significantly associated with alcohol intake. These features include all 10 features identified in Loftfield et al. (<xref ref-type="fig" rid="fig5">Fig. 5c</xref>). These findings highlight the potential benefits of using GM automatic matching for biomarker discovery in untargeted metabolomics data. Additional information regarding the methodology and findings of our GM and Loftfield et al. analyses can be found in Methods and <xref ref-type="appendix" rid="app3">Appendix 3</xref>.</p>
</sec>
</sec>
</sec>
<sec id="s3" sec-type="discussion">
<title>Discussion</title>
<p>LC-MS metabolomics has emerged as an increasingly powerful tool for biological and biomedical research, offering promising opportunities for epidemiological and clinical investigations. However, integrating data from different sources remains challenging. To address this issue, we introduce GromovMatcher, a method based on optimal transport that automatically aligns LC-MS data from pairs of studies. Our method exhibits superior performance on both simulated and real data when compared to existing approaches. Additionally, it presents a user-friendly interface with few hyperparameters.</p>
<p>While GromovMatcher is robust to noise and variations in data, it may face limitations when aligning LC-MS studies from populations with different characteristics, where the correlation structures between features may be inconsistent across studies. In this case, the base assumption of GromovMatcher can be relaxed by focusing on subsamples with similar characteristics, as exemplified in a recent study <italic><bold><xref ref-type="bibr" rid="c16">Gomari et al. (2022)</xref></bold></italic>.</p>
<p>A current limitation is that GromovMatcher does not account for more than two datasets simultaneously, although this can be overcome by aligning multiple studies to a chosen reference dataset, as demonstrated in our biomarker experiments. The extension of Gromov-Wasserstein to multiple distributions <italic><bold><xref ref-type="bibr" rid="c6">Beier et al. (2022)</xref></bold></italic> is another promising approach for generalizing Gro-movMatcher to multiple dataset alignment. Further improvements can be made by incorporating existing knowledge about the studies being matched, such as known shared features, samples in common, or MS/MS data.</p>
<p>The results obtained from GromovMatcher are highly promising, opening the door for various analyses of metabolomic datasets acquired in different experimental laboratories. Here we demonstrated the potential of GromovMatcher in expediting the combination and meta-analysis of data for biomarker and metabolic signature discovery. The matchings learned by GromovMatcher also allow for comparison between experimental protocols by assessing the drift in <italic>m</italic>/<italic>z</italic>, RT, and feature intensities across studies. Finally, inter-institutional annotation efforts can directly benefit from incorporating this method to transfer annotations between aligned datasets. Bridging the gap between otherwise incompatible LC-MS data, GromovMatcher enables seamless comparison of untargeted metabolomics experiments.</p>
<fig id="fig5" position="float" fig-type="figure">
<label>Figure 5.</label>
<caption><p>Comparison of GromovMatcher and Loftfield et al. <italic>Loftfield et al.</italic> (<italic>2021</italic>) analysis for alcohol biomarker discovery on EPIC data. (<bold>A</bold>) Loftfield study implemented a discovery step, examining the relationship between alcohol intake and metabolic features in the CS study. The significant features in CS were manually matched to features from the HCC and PC and the analysis was repeated using samples from the HCC and PC studies. After this step, 10 features associated with alcohol intake were identified. (<bold>B</bold>) GromovMatcher analysis begins by matching features from CS study to HCC and PC studies respectively (top blue, yellow, and red boxes). Samples corresponding to each CS feature are combined with the samples of its matched feature in the HCC study, PC study, or both. This generates a larger pooled data matrix with the same number of features as the CS study but with more samples pooled across the three original studies (center matrix). Because some features in the CS study may not have matches in HCC or PC, the corresponding entries in the pooled matrix are set to NaN/missing values (white regions in matrix). Each column/feature in this matrix is statistically tested for association with alcohol intake (ignoring missing values) and an FDR or a stricter Bonferroni correction is performed to retain only a subset of features from the pooled study that have a strong association. (<bold>C</bold>) Venn diagrams show intersection of feature sets (in positive and negative mode) found to be associated with alcohol intake by one of the four different analyses.</p></caption>
<graphic xlink:href="2306.03218v2_fig5.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
</sec>
<sec id="s4" sec-type="methods|materials">
<title>Methods and Materials</title>
<sec id="s4a">
<title>GromovMatcher method overview</title>
<p>GromovMatcher accepts as input two feature tables from separate LC-MS untargeted metabolomics studies. Each feature table for dataset 1 and dataset 2 consists of <italic>n</italic><sub>1</sub>, <italic>n</italic><sub>2</sub> biospecimen samples respectively and <italic>p</italic><sub>1</sub>, <italic>p</italic><sub>2</sub> metabolic features respectively detected in the study. Features in dataset 1 are given the label fx<sub><italic>i</italic></sub> for <italic>i</italic> = 1,… ,<italic>p</italic><sub>1</sub>. Every feature is characterized by a mass-to-charge ratio (<italic>m</italic>/<italic>z</italic>) denoted by <inline-formula id="ID15">
<alternatives><mml:math display="inline" id="I15"><mml:mrow><mml:msubsup><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>x</mml:mi></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq15.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>, a retention time (RT) denoted by <inline-formula id="ID16">
<alternatives><mml:math display="inline" id="I16"><mml:mrow><mml:mi>R</mml:mi><mml:msubsup><mml:mi>T</mml:mi><mml:mi>i</mml:mi><mml:mi>x</mml:mi></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq16.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>, and a vector of intensities across all samples written as <inline-formula id="ID17">
<alternatives><mml:math display="inline" id="I17"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq17.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>. Similarly, features in dataset 2 are labeled as fy<sub><italic>j</italic></sub> for <italic>j</italic> = 1,… ,<italic>p</italic><sub>2</sub> and are characterized by their <italic>m</italic>/<italic>z</italic> <inline-formula id="ID18">
<alternatives><mml:math display="inline" id="I18"><mml:mrow><mml:msubsup><mml:mi>m</mml:mi><mml:mi>j</mml:mi><mml:mi>y</mml:mi></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq18.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>, retention time <inline-formula id="ID19">
<alternatives><mml:math display="inline" id="I19"><mml:mrow><mml:mi>R</mml:mi><mml:msubsup><mml:mi>T</mml:mi><mml:mi>j</mml:mi><mml:mi>y</mml:mi></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq19.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>, and a vector of intensities across all samples <inline-formula id="ID20">
<alternatives><mml:math display="inline" id="I20"><mml:mrow><mml:msub><mml:mi>Y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq20.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>.</p>
<p>Our goal is to identify pairs of indexes (<italic>i, j</italic>) with <italic>i</italic> ∈ {1, … , <italic>p</italic><sub>1</sub>} and <italic>j</italic> ∈ {1, …, <italic>p</italic><sub>2</sub>}, such that fx<sub><italic>i</italic></sub> and fy<sub><italic>j</italic></sub> correspond to the same metabolic feature. More formally, we aim to identify a <italic>matching matrix</italic> <inline-formula id="ID21">
<alternatives><mml:math display="inline" id="I21"><mml:mrow><mml:mi>M</mml:mi><mml:mo>*</mml:mo><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq21.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> such that <italic>M<sub>ij</sub></italic> = 1 if fx<sub><italic>i</italic></sub> and fy<sub><italic>j</italic></sub> correspond to the same feature, hereafter referred to as <italic>matched</italic> features. Otherwise, we set <italic>M<sub>ij</sub></italic> = 0.</p>
<p>Because the <italic>m</italic>/<italic>z</italic> and RT values of metabolomic features are often noisy and subject to experimental bias, our matching algorithm leverages metabolite feature intensities <italic>X<sub>i</sub>,Y<sub>j</sub></italic> to produce accurate dataset alignments. The GromovMatcher method is based on the idea that signal intensities of the same metabolites measured in two different studies should exhibit similar correlation structures, in addition to having compatible <italic>m</italic>/<italic>z</italic> and RT values. Here we define the Pearson correlation for vectors <italic>u,v</italic> ∈ ℝ<sup><italic>n</italic></sup> as
<disp-formula id="FD1">
<alternatives>
<mml:math display="block" id="M1"><mml:mrow><mml:mtext>corr</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>u</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mi>v</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mo>〉</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mi>u</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:mi>v</mml:mi><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mi>v</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn1.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(1)</label>
</disp-formula>
</p>
<p>where we define
<disp-formula id="FD2">
<alternatives>
<mml:math display="block" id="M2"><mml:mrow><mml:mover accent="true"><mml:mi>u</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:mfrac><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mo>,</mml:mo><mml:mrow><mml:mo>‖</mml:mo><mml:mi>u</mml:mi><mml:mo>‖</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:msubsup><mml:mi>u</mml:mi><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mstyle></mml:mrow></mml:msqrt><mml:mo>,</mml:mo><mml:mrow><mml:mo>〈</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>〉</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn2.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(2)</label>
</disp-formula>
</p>
<p>as the mean value, Euclidean norm and inner product respectively. If measurements <italic>X<sub>i</sub>,Y<sub>j</sub></italic> correspond to the same underlying feature, and similarly, measurements <italic>X<sub>k</sub>,Y<sub>t</sub></italic> share the same an underlying feature, we expect that
<disp-formula id="FD3">
<alternatives>
<mml:math display="block" id="M3"><mml:mrow><mml:mtext>corr</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>≈</mml:mo><mml:mtext>corr</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>Y</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn3.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(3)</label>
</disp-formula>
</p>
<p>This idea that the feature intensities of shared metabolites have the same correlation structure in both datasets also holds more generally for distances, under a suitable choice of distance. For example, the correlation coefficient corr(<italic>u, V</italic>) can be turned into a dissimilarity metric by defining
<disp-formula id="FD4">
<alternatives>
<mml:math display="block" id="M4"><mml:mrow><mml:msup><mml:mi>d</mml:mi><mml:mrow><mml:mi>cos</mml:mi></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mtext>corr</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msqrt></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn4.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(4)</label>
</disp-formula>
</p>
<p>commonly referred to as the <italic>cosine distance</italic>. Preservation of feature intensity correlations then trivially amounts to the preservation of cosine distances.</p>
<p>Another classical notion of distance between vectors <italic>u, V</italic> ∈ ℝ<sup><italic>n</italic></sup> is the normalized Euclidean distance
<disp-formula id="FD5">
<alternatives>
<mml:math display="block" id="M5"><mml:mrow><mml:msup><mml:mi>d</mml:mi><mml:mrow><mml:mi>e</mml:mi><mml:mi>u</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mrow></mml:mfrac><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:mfrac></mml:mstyle><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mstyle></mml:mrow></mml:msqrt></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn5.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(5)</label>
</disp-formula>
</p>
<p>which is equal to the cosine distance (up to constants) when the vectors <italic>u, V</italic> are centered and scaled to have zero mean and a standard deviation of one. The Euclidean distance depends on the magnitude or mean intensity of metabolic features, and hence is a useful metric for matching metabolites as long as these mean feature intensities are reliably collected.</p>
<p>To summarize, the main tenant of GromovMatcher is that if measurements <italic>X<sub>i</sub>,Y<sub>j</sub></italic> correspond to the same feature and <italic>X<sub>k</sub>, Y<sub>l</sub></italic> correspond to the same feature, then for suitably chosen distances <inline-formula id="ID22">
<alternatives><mml:math display="inline" id="I22"><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo>:</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msup><mml:mo>×</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msup><mml:mo>→</mml:mo><mml:mi>ℝ</mml:mi><mml:mtext> and </mml:mtext><mml:msub><mml:mi>d</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mo>:</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup><mml:mo>×</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup><mml:mo>→</mml:mo><mml:mi>ℝ</mml:mi></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq22.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>, these distances are preserved
<disp-formula id="FD6">
<alternatives>
<mml:math display="block" id="M6"><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>≈</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>Y</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>l</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn6.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(6)</label>
</disp-formula>
</p>
<p>across both datasets. In this paper, the distances <italic>d<sub>x</sub>,d<sub>y</sub></italic> are taken to be the normalized Euclidean distances in (5). We take care to specify those experiments where the metabolic features <italic>X</italic> and <italic>Y</italic> are centered and scaled. In these cases, implicitly the Euclidean distance between normalized feature vectors becomes the cosine distance (4) between the original (unnormalized) feature vectors.</p>
<sec id="s4a1">
<title>Unbalanced Gromov-Wasserstein</title>
<p>The goal ofGromovMatcher is to learn a matching matrix <inline-formula id="ID23">
<alternatives><mml:math display="inline" id="I23"><mml:mrow><mml:mi>M</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq23.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> that gives an alignment between a subset of metabolites in both datasets. However, searching over the combinatorially large set of binary matrices would be an inefficient approach for dataset alignment. The mathematical framework of optimal transport <italic><bold><xref ref-type="bibr" rid="c30">Peyré et al. (2019)</xref></bold></italic> instead enlarges this space of binary matrices to the set of <italic>coupling matrices</italic> with real nonnegative entries <inline-formula id="ID24">
<alternatives><mml:math display="inline" id="I24"><mml:mrow><mml:mo>∏</mml:mo><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq24.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>. The entries ∏<sub><italic>ij</italic></sub> with large weights indicate that feature fx<sub><italic>i</italic></sub> in dataset 1 and feature fy<sub><italic>j</italic></sub> in dataset 2 are a likely match. Taking inspiration from (6), we minimize the following objective function
<disp-formula id="FD7">
<alternatives>
<mml:math display="block" id="M7"><mml:mrow><mml:mi>ε</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>Π</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>Π</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>Y</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>l</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn7.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(7)</label>
</disp-formula>
</p>
<p>to estimate the coupling matrix ∏.</p>
<p>A standard approach is to optimize this objective over all coupling matrices ∏ under exact marginal constraints <inline-formula id="ID25">
<alternatives><mml:math display="inline" id="I25"><mml:mrow><mml:mo>∏</mml:mo><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mfrac><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msup><mml:mo>∏</mml:mo><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mfrac><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq25.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>. Here we define <bold>1</bold><sub><italic>n</italic></sub> is the ones vector of length <italic>n</italic>, and <inline-formula id="ID26">
<alternatives><mml:math display="inline" id="I26"><mml:mrow><mml:msub><mml:mo>∏</mml:mo><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mo>∏</mml:mo><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mo>∏</mml:mo><mml:mn>2</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mo>∏</mml:mo><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq26.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> denote the column and row sums of the coupling matrix. Objective (7) under these exact marginal constraints defines a distance between the two sets of metabolic feature vectors <inline-formula id="ID27">
<alternatives><mml:math display="inline" id="I27"><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mi>Y</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq27.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> known as the Gromov-Wasserstein distance <italic><bold><xref ref-type="bibr" rid="c25">Mémoli (2011)</xref></bold></italic>, a generalization of optimal transport to metric spaces. Note that for pairs <italic>X<sub>i</sub>,Y<sub>j</sub></italic> and <italic>X<sub>k</sub>,Y<sub>l</sub></italic> for which <italic>d<sub>x</sub></italic>(<italic>X<sub>i</sub>, X<sub>k</sub></italic>) ≈ <italic>d<sub>y</sub></italic>(<italic>Y<sub>j</sub>,Y<sub>l</sub></italic>), the entries ∏<sub><italic>ij</italic></sub>, ∏<sub><italic>kl</italic></sub> are penalized less and hence matches between features fx<sub><italic>i</italic></sub> ,fy<sub><italic>j</italic></sub> and features fx<sub><italic>k</italic></sub> ,fy<sub><italic>l</italic></sub> are more favored. In our optimization, we avoid enforcing exact marginal constraints on the marginal distributions ∏1<sub><italic>p</italic>2</sub> and ∏<sup><italic>T</italic></sup><bold>1</bold><sub><italic>p</italic>1</sub> of our coupling matrix as this would enforce that all metabolites in both datasets are matched (<xref ref-type="appendix" rid="app1">Appendix 1</xref>). However, without any marginal constraints on the coupling ∏, the objective function (7) is trivially minimized by ∏ = 0, leaving all metabolites in both datasets unmatched.</p>
<p>To account for this, we follow the ideas of unbalanced Gromov-Wasserstein (UGW) <bold><italic><xref ref-type="bibr" rid="c37">Sejourne et al. (2021)</xref></italic></bold> and add three regularization terms to our objective
<disp-formula id="FD8">
<alternatives>
<mml:math display="block" id="M8"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>Π</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>ε</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>Π</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>⊗</mml:mo><mml:msub><mml:mi>Π</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>a</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtext>      </mml:mtext><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>⊗</mml:mo><mml:msub><mml:mi>Π</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtext>      </mml:mtext><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:mo>⊗</mml:mo><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>a</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>⊗</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math>
<graphic xlink:href="2306.03218v2_eqn8.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(8)</label>
</disp-formula>
</p>
<p>where <italic>ρ, ε</italic> &gt; 0 and we define <italic>a</italic> = <bold>1</bold><sub><italic>p</italic>1</sub>,<italic>b</italic> = <bold>1</bold><sub><italic>p</italic>2</sub>. Here ⊗ denotes the Kronecker product. We define <italic>D</italic><sub>KL</sub> as the Kullback-Leibler (KL) divergence between two discrete distributions <inline-formula id="ID28">
<alternatives><mml:math display="inline" id="I28"><mml:mrow><mml:mi>μ</mml:mi><mml:mo>,</mml:mo><mml:mi>ν</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mi>p</mml:mi></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq28.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> by
<disp-formula id="FD9">
<alternatives>
<mml:math display="block" id="M9"><mml:mrow><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>μ</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>p</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>μ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mtext>  In</mml:mtext></mml:mrow></mml:mstyle><mml:mtext> </mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>μ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>p</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>μ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mtext> </mml:mtext><mml:mo>+</mml:mo></mml:mrow></mml:mstyle><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>p</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn9.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(9)</label>
</disp-formula>
</p>
<p>which measures the closeness of probability distributions.</p>
<p>The first two regularization terms in (8) enforce that the row sums and column sums of the coupling matrix ∏ do not deviate too much from a uniform distribution, leading our optimization to match as many metabolic features as possible. The magnitude of the regularizer <italic>ρ</italic> roughly enforces the fraction of metabolites in both datasets that are matched where large <italic>ρ</italic> implies most metabolites are matched across datasets. The final regularization term <italic>ε</italic> in (8) controls the smoothness (entropy) of the coupling matrix ∏ where larger values of <italic>ε</italic> encourage ∏ to put uniform weights on many of its entries, leading to less precision in the metabolite matches. However, increasing <italic>ε</italic> also leads to better numerical stability and a significant speedup of the alternating minimization algorithm used to optimize the objective function (<xref ref-type="appendix" rid="app1">Appendix 1</xref>). In our implementation, we set <italic>ρ</italic> and <italic>ε</italic> to the lowest possible values under which our optimization converges, with <italic>ρ</italic> = 0.05 and <italic>ε</italic> = 0.005.</p>
<p>Our full optimization problem can now be written as
<disp-formula id="FD10">
<alternatives>
<mml:math display="block" id="M10"><mml:mrow><mml:msub><mml:mrow><mml:mtext>UGW</mml:mtext></mml:mrow><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mo>=</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:msubsup><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>Π</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn10.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(10)</label>
</disp-formula>
</p>
<p>The UGW objective function is optimized through alternating minimization based on the code of <bold><italic><xref ref-type="bibr" rid="c37">Sejourne et al. (2021)</xref></italic></bold> using the unbalanced Sinkhorn algorithm <italic><bold><xref ref-type="bibr" rid="c35">Séjourné et al. (2019)</xref></bold></italic> from optimal transport (<xref ref-type="appendix" rid="app1">Appendix 1</xref>).</p>
</sec>
<sec id="s4a2">
<title>Constraint on <italic>m</italic>/<italic>z</italic> ratios</title>
<p>Matched metabolic features must have compatible <italic>m</italic>/<italic>z</italic> so we enforce that ∏<sub><italic>ij</italic></sub> = 0 when <inline-formula id="ID29">
<alternatives><mml:math display="inline" id="I29"><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>x</mml:mi></mml:msubsup><mml:mo>−</mml:mo><mml:msubsup><mml:mi>m</mml:mi><mml:mi>j</mml:mi><mml:mi>y</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mo>&gt;</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mrow><mml:mi>g</mml:mi><mml:mi>a</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq29.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> <italic>m</italic><sub>gap</sub> where <italic>m</italic><sub>gap</sub> is a user-specified threshold. Based on prior literature <italic><bold><xref ref-type="bibr" rid="c24">Loftfield et al. (2021)</xref></bold></italic>; <bold><italic><xref ref-type="bibr" rid="c19">Hsu et al. (2019)</xref></italic></bold>; <italic><bold><xref ref-type="bibr" rid="c11">Climaco Pinto et al. (2022)</xref></bold></italic>; <italic><bold><xref ref-type="bibr" rid="c18">Habra et al. (2021)</xref></bold></italic>; <italic><bold><xref ref-type="bibr" rid="c9">Chen et al. (2021)</xref></bold></italic> we set <italic>m</italic><sub>gap</sub> = 0.01ppm. Note that <italic>m</italic><sub>gap</sub> is not explicitly used in (10) but is rather enforced in each iteration of our alternating minimization algorithm for the UGW objective (<xref ref-type="appendix" rid="app1">Appendix 1</xref>).</p>
<p>Unlike the <italic>m</italic>/<italic>z</italic> ratios discussed above, RTs often exhibit a non-linear deviation (drift) between studies so we cannot enforce compatibility of RTs directly in our optimization. Instead, in the following step of our pipeline we ensure matched metabolite pairs have compatible RTs by estimating the drift function and subsequently using it to filter out metabolite matches whose RT values are inconsistent with the estimated drift.</p>
</sec>
<sec id="s4a3">
<title>Estimation of the RT drift and filtering</title>
<p>Estimating the drift between RTs of two studies is a crucial step in assessing the validity of metabolite matches and discarding those pairs which are incompatible with the estimated drift.</p>
<p>Let <inline-formula id="ID30">
<alternatives><mml:math display="inline" id="I30"><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">˜</mml:mo></mml:mover><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq30.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> be the minimizer of (10) obtained after optimization. We seek to estimate the RT drift function <italic>f</italic> : ℝ<sub>+</sub> → ℝ<sub>+</sub> which relates the retention times of matched features between the two studies. Namely, if feature fx<sub><italic>i</italic></sub> and feature fy<sub><italic>j</italic></sub> correspond to the same metabolic feature, then we must have that <inline-formula id="ID31">
<alternatives><mml:math display="inline" id="I31"><mml:mrow><mml:mi>R</mml:mi><mml:msubsup><mml:mi>T</mml:mi><mml:mi>j</mml:mi><mml:mi>y</mml:mi></mml:msubsup><mml:mo>≈</mml:mo><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>R</mml:mi><mml:msubsup><mml:mi>T</mml:mi><mml:mi>i</mml:mi><mml:mi>x</mml:mi></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq31.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>.</p>
<p>We propose to learn the drift <italic>f</italic> through the weighted spline regression
<disp-formula id="FD11">
<alternatives>
<mml:math display="block" id="M11"><mml:mrow><mml:msubsup><mml:mrow/><mml:mrow><mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>B</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:msubsup><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>Π</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>R</mml:mi><mml:msubsup><mml:mi>T</mml:mi><mml:mi>i</mml:mi><mml:mi>x</mml:mi></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>R</mml:mi><mml:msubsup><mml:mi>T</mml:mi><mml:mi>j</mml:mi><mml:mi>y</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn11.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(11)</label>
</disp-formula>
</p>
<p>where <italic>B<sub>n,k</sub></italic> is the set of <italic>n</italic>-order B-splines with <italic>k</italic> knots. All pairs <inline-formula id="ID32">
<alternatives><mml:math display="inline" id="I32"><mml:mrow><mml:mi>R</mml:mi><mml:msubsup><mml:mi>T</mml:mi><mml:mi>i</mml:mi><mml:mi>x</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mi>R</mml:mi><mml:msubsup><mml:mi>T</mml:mi><mml:mi>j</mml:mi><mml:mi>y</mml:mi></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq32.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> in objective (11) are weighted by the coefficients of <inline-formula id="ID33">
<alternatives><mml:math display="inline" id="I33"><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">˜</mml:mo></mml:mover></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq33.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> so that larger weights are given to pairs identified with high confidence in the first step of our procedure. The order of the B-splines was set to <italic>n</italic> = 3 by default, while the number of knots <italic>k</italic> was selected by 10-fold cross-validation.</p>
<p>Pairs identified as incompatible with the estimated RT drift are then discarded from the coupling matrix. To do this, we first take the estimated RT drift <inline-formula id="ID34">
<alternatives><mml:math display="inline" id="I34"><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq34.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>, and the set of pairs <inline-formula id="ID35">
<alternatives><mml:math display="inline" id="I35"><mml:mrow><mml:mi>S</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>≠</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq35.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> recovered in <inline-formula id="ID36">
<alternatives><mml:math display="inline" id="I36"><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">˜</mml:mo></mml:mover></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq36.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>. We then define the residual associated with (<italic>i,j</italic>) ∈ S as
<disp-formula id="FD12">
<alternatives>
<mml:math display="block" id="M12"><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>R</mml:mi><mml:msubsup><mml:mi>T</mml:mi><mml:mi>i</mml:mi><mml:mi>x</mml:mi></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>R</mml:mi><mml:msubsup><mml:mi>T</mml:mi><mml:mi>j</mml:mi><mml:mi>y</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn12.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(12)</label>
</disp-formula>
</p>
<p>The 95% prediction interval and the median absolute deviation (MAD) of these residuals are given by
<disp-formula id="FD13">
<alternatives>
<mml:math display="block" id="M13"><mml:mtable><mml:mtr><mml:mtd><mml:mtext>PI</mml:mtext><mml:mo>=</mml:mo><mml:mn>1.96</mml:mn><mml:mo>×</mml:mo><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mi>d</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtext>MAD</mml:mtext><mml:mo>=</mml:mo><mml:mtext>median</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>μ</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mi>μ</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mi>i</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math>
<graphic xlink:href="2306.03218v2_eqn13.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(13)</label>
</disp-formula>
</p>
<p>where |S| is the size of S and the functions std and median denote the standard deviation and median respectively. Similar to the approach in <italic><bold><xref ref-type="bibr" rid="c11">Climaco Pinto et al. (2022)</xref></bold></italic>, we create a new filtered coupling matrix <inline-formula id="ID37">
<alternatives><mml:math display="inline" id="I37"><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">^</mml:mo></mml:mover><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq37.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> given by
<disp-formula id="FD14">
<alternatives>
<mml:math display="block" id="M14"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>Π</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>Π</mml:mi><mml:mo>~</mml:mo></mml:mover><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mi>i</mml:mi><mml:mi>f</mml:mi><mml:mtext> </mml:mtext><mml:msub><mml:mi>r</mml:mi><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>&lt;</mml:mo><mml:msub><mml:mi>μ</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mrow><mml:mi>o</mml:mi><mml:mi>t</mml:mi><mml:mi>h</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mi>w</mml:mi><mml:mi>i</mml:mi><mml:mi>s</mml:mi><mml:mi>e</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn14.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(14)</label>
</disp-formula>
</p>
<p>where <italic>r</italic><sub>thresh</sub> is a given filtering threshold. Following <italic><bold><xref ref-type="bibr" rid="c18">Habra et al. (2021)</xref></bold></italic>, the estimation and outlier detection step can be repeated for multiple iterations, to remove pairs that deviate significantly from the estimated drift and improve the robustness of the drift estimation. In our main algorithm, we use two preliminary iterations where estimate the RT drift and discard outliers outside of the 95% prediction interval by setting <italic>r</italic><sub>thresh</sub> = PI. We the re-estimate the drift and perform a final filtering step with the more stringent MAD by setting <italic>r</italic><sub>thresh</sub> = 2 × MAD.</p>
<p>At this stage, it is possible for <inline-formula id="ID38">
<alternatives><mml:math display="inline" id="I38"><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq38.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> to still contain coefficients of very small magnitude. As an optional postprocessing step, we discard these coefficients by setting all entries smaller than <inline-formula id="ID39">
<alternatives><mml:math display="inline" id="I39"><mml:mrow><mml:mi>τ</mml:mi><mml:mi>max</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq39.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> to zero, for some user-defined <italic>τ</italic> ∈ [0,1]. Lastly, a feature from either study could have multiple possible matches, since <inline-formula id="ID40">
<alternatives><mml:math display="inline" id="I40"><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq40.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> can have more than one non-zero coefficient per row or column. Although reporting multiple matches can be helpful in an exploratory context, for the sake of simplicity in our analysis, the final output of GromovMatcher returns a one-to-one matching, as we only keep those metabolite pairs (<italic>i, j</italic>) where the entry <inline-formula id="ID41">
<alternatives><mml:math display="inline" id="I41"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq41.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> is largest in its corresponding row and column. All nonzero entries of <inline-formula id="ID42">
<alternatives><mml:math display="inline" id="I42"><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq42.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> which do not satisfy this criterion are set to zero. Finally, we convert <inline-formula id="ID43">
<alternatives><mml:math display="inline" id="I43"><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq43.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> into a binary matching matrix <italic>M</italic> ∈ {0, 1}<sup><italic>p</italic>1 × <italic>p</italic>2</sup> with ones in place of its nonzero entries and this final output is returned to the user.</p>
<p>As a naming convention, we use the abbreviation GM for our GromovMatcher method, and use the abbreviation GMT when running GromovMatcher with the optional <italic>τ</italic>-thresholding step with <italic>τ</italic> = 0.3.</p>
</sec>
</sec>
<sec id="s4b">
<title>Metrics for dataset alignment</title>
<p>Every alignment method studied in this paper returns a binary <italic>partial matching</italic> matrix <italic>M</italic> ∈ {0, 1} <sup><italic>p</italic>1×<italic>p</italic>1</sup> which has at most one nonzero entry in each row and column. Specifically, <italic>M<sub>ij</sub></italic> = 1 if metabolic features <italic>i</italic> and <italic>j</italic> in both datasets correspond to each other and <italic>M<sub>ij</sub></italic> = 0 otherwise. In our simulated experiments, we compare the partial matching <italic>M</italic> to a known ground-truth partial matching matrix <italic>M</italic>* ∈ {0, 1}<sup><italic>p</italic>1×<italic>p</italic>2</sup>.</p>
<p>To do this, we first compute the number of true positives, false positives, true negatives, and false negatives as
<disp-formula id="FD15">
<alternatives>
<mml:math display="block" id="M15"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mtext>TP</mml:mtext><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msubsup><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtext>FP</mml:mtext><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msubsup><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtext>TN</mml:mtext><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msubsup><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtext>FN</mml:mtext><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msubsup><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math>
<graphic xlink:href="2306.03218v2_eqn15.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(15)</label>
</disp-formula>
</p>
<p>where <bold>1</bold> denotes the indicator function. Then we use these values to compute the precision and recall as
<disp-formula id="FD16">
<alternatives>
<mml:math display="block" id="M16"><mml:mtable><mml:mtr><mml:mtd><mml:mtext>Precision</mml:mtext><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mtext>TP</mml:mtext></mml:mrow><mml:mrow><mml:mtext>TP</mml:mtext><mml:mo>+</mml:mo><mml:mtext>FP</mml:mtext></mml:mrow></mml:mfrac></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtext>Recall</mml:mtext><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mtext>TP</mml:mtext></mml:mrow><mml:mrow><mml:mtext>TP</mml:mtext><mml:mo>+</mml:mo><mml:mtext>FN</mml:mtext></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math>
<graphic xlink:href="2306.03218v2_eqn16.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(16)</label>
</disp-formula>
</p>
<p>Precision measures the fraction of correctly found matches out of all discovered metabolite matches, while recall, also know as sensitivity, measures the fraction of correctly matched pairs out of all truly matched pairs. These two statistics can be summarized into one metric called the F1-score by taking their harmonic mean
<disp-formula id="FD17">
<alternatives>
<mml:math display="block" id="M17"><mml:mrow><mml:mtext>F</mml:mtext><mml:mn>1</mml:mn><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>⋅</mml:mo><mml:mfrac><mml:mrow><mml:mtext>Precision</mml:mtext><mml:mo>⋅</mml:mo><mml:mtext>Recall</mml:mtext></mml:mrow><mml:mrow><mml:mtext>Precision</mml:mtext><mml:mo>+</mml:mo><mml:mtext>Recall</mml:mtext></mml:mrow></mml:mfrac></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn17.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(17)</label>
</disp-formula>
</p>
<p>These three metrics, precision, recall, and the F1-score, are used throughout the paper to assess the performance of dataset alignment methods, both on simulated data where the ground-truth matching is known, and on the validation subset in EPIC, using results from the manual examination as the ground-truth benchmark.</p>
</sec>
<sec id="s4c">
<title>Validation on simulated data</title>
<p>To assess the performance of GromovMatcher and compare it to existing dataset alignment methods, we simulate realistic pairs of untargeted metabolomics feature with known ground-truth matchings. This allows us to analyze the dependence of alignment methods on the number of shared metabolites, dataset noise level, and feature intensity centering and scaling.</p>
<sec id="s4c1">
<title>Dataset generation</title>
<p>Our pairs of synthetic feature tables are generated from one real untargeted metabolomics study of 500 newborns within the EXPOsOMICS project, which uses reversed phase liquid chromatographyquadrupole time-of-flight mass spectrometry (UHPLC-QTOF-MS) system in positive ion mode <bold><italic><xref ref-type="bibr" rid="c2">Alfano et al. (2020)</xref></italic></bold>. The original dataset is first preprocessed following the procedure detailed in Alfano et al. <italic><bold><xref ref-type="bibr" rid="c2">Alfano et al. (2020)</xref></bold></italic>, resulting in <italic>p</italic> = 4,712 features measured in <italic>n</italic> = 499 samples available for subsequent analysis. Features and samples from the original study are then divided into two feature tables of respective size (<italic>n</italic><sub>1</sub>, <italic>p</italic><sub>1</sub>) and (<italic>n</italic><sub>2</sub>,<italic>p</italic><sub>2</sub>), with <italic>n</italic><sub>1</sub> + <italic>n</italic><sub>2</sub> = <italic>n</italic> and <italic>p</italic><sub>1</sub>, <italic>p</italic><sub>2</sub> ≤ <italic>p</italic>. In order to do this, <inline-formula id="ID44">
<alternatives><mml:math display="inline" id="I44"><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>⌈</mml:mo><mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mrow><mml:mo>⌉</mml:mo></mml:mrow></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq44.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> randomly chosen samples from the original study are placed into dataset 1 and the remaining <inline-formula id="ID45">
<alternatives><mml:math display="inline" id="I45"><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq45.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> samples from the original study are placed into dataset 2. Here <inline-formula id="ID46">
<alternatives><mml:math display="inline" id="I46"><mml:mrow><mml:mrow><mml:mo>⌊</mml:mo><mml:mo>⋅</mml:mo><mml:mo>⌋</mml:mo></mml:mrow></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq46.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> and <inline-formula id="ID47">
<alternatives><mml:math display="inline" id="I47"><mml:mrow><mml:mrow><mml:mo>⌈</mml:mo><mml:mo>⋅</mml:mo><mml:mo>⌉</mml:mo></mml:mrow></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq47.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> denote integer floor and ceiling functions. The features of the original study are randomly assigned to dataset 1, dataset 2, or both, allowing the resulting studies to have both common and studyspecific features (<xref ref-type="fig" rid="fig2">Fig. 2</xref>). Specifically, for a fixed overlap parameter <italic>λ</italic> ∈ [0,1], we assign a random subset <inline-formula id="ID48">
<alternatives><mml:math display="inline" id="I48"><mml:mrow><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:mi>λ</mml:mi><mml:mi>p</mml:mi></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq48.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> of the features into both dataset 1 and dataset 2 while the remaining <inline-formula id="ID49">
<alternatives><mml:math display="inline" id="I49"><mml:mrow><mml:mi>p</mml:mi><mml:mo>−</mml:mo><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:mi>λ</mml:mi><mml:mi>p</mml:mi></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq49.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> features are divided equally between the two studies such that <italic>p</italic><sub>1</sub> = <italic>p</italic><sub>2</sub>. We choose <italic>λ</italic> ∈ {0.25, 0.5,0.75} corresponding to low, medium and high overlap.</p>
<p>After generating a pair of studies, random noise is added to the <italic>m</italic>/<italic>z</italic>, RT and intensity levels of features in dataset 2 to mimic variations in data acquisition across two different experiments. The noise added to each <italic>m</italic> / <italic>z</italic> value in study 2 is sampled from a uniform distribution on the interval [-σ<sub>M</sub>, σ<sub>M</sub>] with σ<sub>M</sub> = 0.01 <italic><bold><xref ref-type="bibr" rid="c11">Climaco Pinto et al. (2022)</xref></bold></italic>. The RTs of dataset 2 are first deviated by the function <inline-formula id="ID50">
<alternatives><mml:math display="inline" id="I50"><mml:mrow><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>x</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mn>1.1</mml:mn><mml:mi>x</mml:mi><mml:mo>+</mml:mo><mml:mn>1.3</mml:mn><mml:mi>sin</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1.2</mml:mn><mml:msqrt><mml:mi>x</mml:mi></mml:msqrt></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq50.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>, corresponding to a systematic inter-dataset drift <bold><italic><xref ref-type="bibr" rid="c18">Habra et al. (2021)</xref></italic></bold>; <italic><bold><xref ref-type="bibr" rid="c11">Climaco Pinto et al. (2022)</xref></bold></italic>; <italic><bold><xref ref-type="bibr" rid="c8">Brunius et al. (2016)</xref></bold></italic>. A uniformly distributed noise on the interval [-σ<sub>RT</sub>, σ<sub>RT</sub>] is added to the deviated RTs of dataset 2, with σ<sub>RT</sub> ∈ {0.2, 0.5, 1} (in minutes) corresponding to low, moderate and high variations <italic><bold><xref ref-type="bibr" rid="c11">Climaco Pinto et al. (2022)</xref></bold></italic>; <italic><bold><xref ref-type="bibr" rid="c18">Habra et al. (2021)</xref></bold></italic>; <italic><bold><xref ref-type="bibr" rid="c45">Vaughan et al. (2012)</xref></bold></italic>. Finally, we add a Gaussian noise <inline-formula id="ID51">
<alternatives><mml:math display="inline" id="I51"><mml:mrow><mml:mi>N</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>FI</mml:mtext></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq51.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> to the feature intensities of both studies where σ<sub><italic>FI</italic></sub> is the scalarvariance ofthe noise. This noise perturbs the correlation matrices of dataset 1 and dataset 2, making matching based on feature intensity correlations more challenging. We vary <italic>σ<sub>FI</sub></italic> over the set of values {0.1, 0.5, 1}.</p>
<p>Given this data generation process, we test the performance of the four alignment methods (M2S, metabCombiner, GM, and GMT) under the parameter settings described below.</p>
</sec>
<sec id="s4c2">
<title>Dependence on overlap</title>
<p>We first assess how the performance of the four methods is affected by the number of metabolic features shared in both datasets. For each value of λ = 0.25 ,0.5 ,0.75 (low, medium and high overlap), we randomly generate 20 pairs of datasets with noise on the <italic>m</italic>/<italic>z</italic> , RT and feature intensities set to σ<sub>M</sub> = 0.01, σ<sub>RT</sub> = 0.5, σ<sub>FI</sub> = 0.5. The precision and recall of each method at low, medium, and high overlap is recorded for each of the repetitions.</p>
</sec>
<sec id="s4c3">
<title>Noise robustness</title>
<p>Next we test the robustness to noise of each method by fixing the metabolite overlap fraction at λ = 0.5 and generating 20 random pairs of datasets at low (σ<sub>RT</sub> = 0.2, σ<sub>FI</sub> = 0.1), medium (σ<sub>RT</sub> = 0.5, σ<sub>FI</sub> = 0.5), and high (σ<sub>RT</sub> = 1, σ<sub>FI</sub> = 1) noise levels. Similarly, the precision and recall of each method is saved for each noise level across the 20 repetitions.</p>
</sec>
<sec id="s4c4">
<title>Feature intensity centering and scaling</title>
<p>In order to test how all four methods are affected when the mean feature intensities and variance are not comparable across studies, we assess their performance when the feature intensities in both studies are mean centered and standardized to have unit standard deviation across all samples. We again generate 20 random pairs of datasets with medium overlap and medium noise, normalize the feature intensities in each pair of datasets, and compute the precision and recall of each method across the 20 repetitions.</p>
</sec>
</sec>
<sec id="s4d">
<title>EPIC data</title>
<p>We also evaluate our method on data collected within the European Prospective Investigation into Cancer and Nutrition (EPIC) cohort, an ongoing multicentric prospective study with over 500,000 participants recruited between 1992 and 2000 from 23 centers in 10 European countries, and who provided blood samples at the inclusion in the study <italic><bold><xref ref-type="bibr" rid="c34">Riboli et al. (2002)</xref></bold></italic>. In EPIC, untargeted metabolomics data were successively acquired in several studies nested within the full cohort.</p>
<p>In the present work, we use untargeted metabolomics data acquired in three studies nested in EPIC, namely the EPIC cross-sectional (CS) study <italic><bold><xref ref-type="bibr" rid="c39">Slimani et al. (2003)</xref></bold></italic> and two matched case-control studies nested within EPIC, on hepatocellular carcinoma (HCC) <italic><bold>Stepien et al. (2016</bold></italic>, <xref ref-type="bibr" rid="c43">2021</xref>) and pancreatic cancer (PC) <italic><bold><xref ref-type="bibr" rid="c15">Gasull et al. (2019)</xref></bold></italic>, respectively. All data were acquired at the International Agency for Research on Cancer, making use of the same plateform and methodology: UHPLC-QTOF-MS (1290 Binary Liquid chromatography system, 6550 quadrupole time-of-flight mass spectrometer, Agilent Technologies, Santa Clara, CA) using reversed phase chromatography and electrospray ionization in both positive and negative ionization mode.</p>
<p>In a previous analysis aiming at identifying biomarkers of habitual alcohol intake in EPIC, the 205 features associated with alcohol intake in the CS study were manually matched to features in both the HCC and PC studies <italic><bold><xref ref-type="bibr" rid="c24">Loftfield et al. (2021)</xref></bold></italic>. The results from this manual matching are presented in <xref ref-type="table" rid="tbl1">Table 1</xref>.This matching process was based on the proximity of <italic>m</italic>/<italic>z</italic> and RT, using a matching tolerance of ±15 ppm and ±0.2 min, and on the comparison of the chromatograms of features in a quality control samples from both studies.</p>
<sec id="s4d1">
<title>Preprocessing</title>
<p>In the HCC and PC studies, samples corresponding to participants selected as cases in either study (i.e., participants selected in the study because ofa diagnosis of incident HCC or PC) are excluded. Indeed, the metabolic profiles of participants selected as controls are expected to be more comparable across studies than those of cases, especially if certain features are associated with the risk of HCC or PC. Apart from this additional exclusion criterion, the untargeted metabolomics data of each study is pre-processed following the steps described in Loftfield et al. <italic><bold><xref ref-type="bibr" rid="c24">Loftfield et al. (2021)</xref></bold></italic>, to eliminate unreliable features and samples, impute missing values and minimize technical variations in the feature intensity levels.</p>
</sec>
<sec id="s4d2">
<title>Alcohol biomarker discovery</title>
<p>Loftfield et al. <italic><bold><xref ref-type="bibr" rid="c24">Loftfield et al. (2021)</xref></bold></italic> used the untargeted metabolomics data of the CS, HCC and PC studies in their alcohol biomarker discovery study in EPIC, without being able to automatically match their common features and pool the 3 datasets. Instead, the authors first implemented a discovery step, examining the relationship between alcohol intake and metabolic features measured in the CS study and accounting for multiple testing using a false discovery rate (FDR) correction. This led to the identification of 205 features significantly associated with alcohol intake in the CS study. In order to gauge the robustness of these associations, the authors of Loftfield et al. <bold><italic><xref ref-type="bibr" rid="c24">Loftfield et al. (2021</xref>)</italic></bold> then implemented a validation step using data from two independent test sets. The first test set was composed of data from the EPIC HCC and PC studies, while the second was derived from the Finnish Alpha-Tocopherol, Beta-Carotene Cancer Prevention (ATBC) study. The 205 features identified in the discovery step were manually investigated for matches in the EPIC test set, and 67 features were effectively matched to features in the HCC or PC study, or both. The authors then evaluated the association between alcohol intake and those 67 features, applying a more conservative Bonferroni correction to determine whether the association with alcohol intake persisted. This step led to the identification of 10 features associated with alcohol intake (Extended Data <xref ref-type="fig" rid="fig5">Fig. 5a</xref>). The second test set was then used to determine whether those 10 features were also significant in the ATBC population, which was indeed the case.</p>
<p>To conduct a more in-depth investigation of the matchings produced by the GromovMatcher algorithm, we build upon the analysis previously conducted by Loftfield et al. <italic><bold><xref ref-type="bibr" rid="c24">Loftfield et al. (2021)</xref></bold></italic> by exploring potential alcohol biomarkers using a pooled dataset created from the CS, HCC, and PC studies. Our goal is to assess whether pooling the data leads to increased statistical power and allows for the detection of more features associated with alcohol intake. Namely, we generate the pooled dataset by aligning a chosen reference dataset (CS study) with the HCC and PC studies successively using the GM matchings computed in both positive and negative mode (Methods and Extended Data <xref ref-type="fig" rid="fig5">Fig. 5b</xref>). Features that are not detected in either the HCC or PC studies are designated as ‘missing’ in the final pooled dataset for samples belonging to the respective studies where the feature is not found.</p>
<p>To evaluate the potential relationship between alcohol consumption and pooled metabolic features, we use a methodology akin to that of Loftfield et al. <italic><bold><xref ref-type="bibr" rid="c24">Loftfield et al. (2021)</xref></bold></italic>. The self-reported alcohol intake data is adjusted for various demographic and lifestyle factors (age, sex, country, body-mass-index, smoking status and intensity, coffee consumption, and study) via the residual method in linear regression models. Feature intensities are also adjusted for technical variables (plate number and position within the plate) via linear mixed effect models. The significance of the association is assessed using correlation coefficients computed from the residuals for both selfreported alcohol intake and feature intensities. P-values are corrected using either false discovery rate (FDR) or Bonferroni correction to account for multiple testing. Corrected p-values less than 5% are considered significant.</p>
<table-wrap id="tbl1" orientation="portrait" position="float">
<label>Table 1.</label>
<caption><title>Results from the manual matching conducted for Loftfield et al. <italic>Loftfield et al.</italic> (<italic>2021</italic>).</title>
<p>Features from the CS study (163 features in positive mode, 42 features in negative mode) were manually investigated for matches in the HCC and PC studies.</p></caption>
<alternatives>
<graphic xlink:href="2306.03218v2_tbl1.tif" mimetype="image" mime-subtype="tiff"/>
<table frame="hsides" rules="groups">
<thead>
<tr>
<th align="left" valign="top">Study</th>
<th align="center" valign="top">Manual matches found in positive mode</th>
<th align="center" valign="top">Manual matches found in negative mode</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><bold>Hepatocellular carcinoma (HCC)</bold></td>
<td align="center" valign="top">90</td>
<td align="center" valign="top">19</td>
</tr>
<tr>
<td align="left" valign="top"><bold>Pancreatic cancer (PC)</bold></td>
<td align="center" valign="top">66</td>
<td align="center" valign="top">28</td>
</tr>
</tbody>
</table>
</alternatives>
</table-wrap>
<table-wrap id="tbl2" orientation="portrait" position="float">
<label>Table 2.</label>
<caption><title>Precision and recall on the EPIC validation subset in positive mode.</title>
<p>95% confidence intervals were computed using modified Wilson score intervals <italic>Brown et al.</italic> (<italic>2001</italic>); <italic>Agresti and Coull</italic> (<italic>1998</italic>).</p></caption>
<alternatives>
<graphic xlink:href="2306.03218v2_tbl2.tif" mimetype="image" mime-subtype="tiff"/>
<table frame="below" rules="groups">
<thead>
<tr style="border-bottom: solid thin">
<th align="left" valign="top"/>
<th align="center" valign="top" colspan="2">CS ↔ HCC</th>
<th align="center" valign="top" colspan="2">CS ↔ PC</th>
</tr>
<tr>
<th align="left" valign="top">Method</th>
<th align="center" valign="top">Precision</th>
<th align="center" valign="top">Recall</th>
<th align="center" valign="top">Precision</th>
<th align="center" valign="top">Recall</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><bold>GromovMatcher</bold></td>
<td align="center" valign="top">0.989 (0.939, 0.999)</td>
<td align="center" valign="top">0.978 (0.923, 0.996)</td>
<td align="center" valign="top">0.903 (0.813, 0.952)</td>
<td align="center" valign="top">0.985 (0.919, 0.999)</td>
</tr>
<tr>
<td align="left" valign="top"><bold>M2S</bold></td>
<td align="center" valign="top">0.967 (0.908, 0.991)</td>
<td align="center" valign="top">0.978 (0.923, 0.996)</td>
<td align="center" valign="top">0.855 (0.759, 0.917)</td>
<td align="center" valign="top">0.985 (0.919, 0.999)</td>
</tr>
<tr>
<td align="left" valign="top"><bold>metabCombiner</bold></td>
<td align="center" valign="top">0.961 (0.868, 0.993)</td>
<td align="center" valign="top">0.544 (0.442, 0.643)</td>
<td align="center" valign="top">0.967 (0.833, 0.998)</td>
<td align="center" valign="top">0.439 (0.326, 0.559)</td>
</tr>
</tbody>
</table>
</alternatives>
</table-wrap>
<table-wrap id="tbl3" orientation="portrait" position="float">
<label>Table 3.</label>
<caption><title>Precision and recall on the EPIC validation subset in negative mode.</title>
<p>95% confidence intervals were computed using modified Wilson score intervals <italic>Brown et al.</italic> (<italic>2001</italic>); <italic>Agresti and Coull</italic> (<italic>1998</italic>).</p></caption>
<alternatives>
<graphic xlink:href="2306.03218v2_tbl3.tif" mimetype="image" mime-subtype="tiff"/>
<table frame="below" rules="groups">
<thead>
<tr style="border-bottom: solid thin">
<th align="left" valign="top"/>
<th align="center" valign="top" colspan="2">CS ↔ HCC</th>
<th align="center" valign="top" colspan="2">CS ↔ PC</th>
</tr>
<tr>
<th align="left" valign="top">Method</th>
<th align="center" valign="top">Precision</th>
<th align="center" valign="top">Recall</th>
<th align="center" valign="top">Precision</th>
<th align="center" valign="top">Recall</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><bold>GromovMatcher</bold></td>
<td align="center" valign="top">0.950 (0.764, 0.997)</td>
<td align="center" valign="top">1.000 (0.832, 1.000)</td>
<td align="center" valign="top">0.929 (0.774, 0.987)</td>
<td align="center" valign="top">0.929 (0.774, 0.987)</td>
</tr>
<tr>
<td align="left" valign="top"><bold>M2S</bold></td>
<td align="center" valign="top">1.000 (0.824, 1.000)</td>
<td align="center" valign="top">0.947 (0.754, 0.997)</td>
<td align="center" valign="top">0.931 (0.780, 0.988)</td>
<td align="center" valign="top">0.964 (0.823, 0.998)</td>
</tr>
<tr>
<td align="left" valign="top"><bold>metabCombiner</bold></td>
<td align="center" valign="top">0.875 (0.529, 0.993)</td>
<td align="center" valign="top">0.368 (0.191, 0.590)</td>
<td align="center" valign="top">1.000 (0.845, 1.000)</td>
<td align="center" valign="top">0.750 (0.566, 0.873)</td>
</tr>
</tbody>
</table>
</alternatives>
</table-wrap>
</sec>
</sec>
</sec>
</body>
<back>
<ack>
<title>Acknowledgments</title>
<p>We thank Jorn Dunkel for helpful advice on our manuscript. We acknowledge the MIT Super-Cloud and Lincoln Laboratory Supercomputing Center <italic><bold><xref ref-type="bibr" rid="c33">Reuther et al. (2018)</xref></bold></italic> for providing HPC resources that have contributed to the research results reported within this paper. G.S. acknowledges support through a National Science Foundation Graduate Research Fellowship under Grant No. 1745302. P.R. is supported by NSF grants IIS-1838071, DMS-2022448, and CCF-2106377. We are grateful to the Principal Investigators of each of the EPIC centers for sharing the data for our experimental application.</p>
</ack>
<sec id="S5" sec-type="data-availability">
<title>Data availability</title>
<p>The LC-MS data used to generate our simulated validation experiments is located at the bottom of the “Files” section in <ext-link ext-link-type="uri" xlink:href="https://www.ebi.ac.uk/metabolights/MTBLS1684/files">https://www.ebi.ac.uk/metabolights/MTBLS1684/files</ext-link> under filename ‘metabolomics_normalized_data.xlsx’. The EPIC data is not publicly available, but access requests can be submitted to the Steering Committee <ext-link ext-link-type="uri" xlink:href="https://epic.iarc.fr/access/index.php">https://epic.iarc.fr/access/index.php</ext-link>.</p>
<p>All code for the data preprocessing, figure generation, as well as the GromovMatcher algorithm and its comparison to other methods are available at: <ext-link ext-link-type="uri" xlink:href="https://github.com/sgstepaniants/GromovMatcher">https://github.com/sgstepaniants/GromovMatcher</ext-link>. Instructions and examples for how to run the GromovMatcher method are provided in the Github repository. The metabCombiner implementation written by the original authors was taken from their Github codebase: <ext-link ext-link-type="uri" xlink:href="https://github.com/hhabra/metabCombiner">https://github.com/hhabra/metabCombiner</ext-link>. The M2S implementation of the original authors was taken from their Github codebase: <ext-link ext-link-type="uri" xlink:href="https://github.com/rjdossan/M2S">https://github.com/rjdossan/M2S</ext-link>.</p>
</sec>
<fn-group>
<fn fn-type="con" id="FN1">
<p><bold>Author contributions</bold></p>
<p>M.B. and G.S. contributed equally and are joint first authors. P.R. and V.V. conceived the project. M.B. and G.S. developed the algorithms as well as performed the comparison to other alignment methods. P.K.R. analyzed and postprocessed the EPIC data and the analysis of our method on this data was performed by M.B. The manuscript was prepared by M.B., G.S., P.K.R, P.R., and V.V.</p>
</fn>
<fn fn-type="other" id="FN2">
<p><bold>Materials and Correspondence</bold></p>
<p>All correspondence and material requests should be addressed to V.V.</p>
</fn>
<fn fn-type="other" id="FN3">
<p><bold>IARC disclaimer</bold></p>
<p>Where authors are identified as personnel of the International Agency for Research on Cancer/World Health Organization, the authors alone are responsible for the views expressed in this article and they do not necessarily represent the decisions, policy, or views of the International Agency for Research on Cancer/World Health Organization.</p>
</fn>
</fn-group>
<ref-list>
<title>References</title>
<ref id="c1"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Agresti</surname> <given-names>A</given-names></string-name>, <string-name><surname>Coull</surname> <given-names>BA</given-names></string-name></person-group>. <article-title>Approximate is better than “exact” for interval estimation of binomial proportions</article-title>. <source><italic>Am Stat</italic></source>. <year>1998</year>; <volume>52</volume>(<issue>2</issue>)<fpage>19</fpage>–<lpage>126</lpage>. doi: <pub-id pub-id-type="doi">10.2307/2685469</pub-id>.</mixed-citation></ref>
<ref id="c2"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Alfano</surname> <given-names>R</given-names></string-name>, <string-name><surname>Chadeau-Hyam</surname> <given-names>M</given-names></string-name>, <string-name><surname>Ghantous</surname> <given-names>A</given-names></string-name>, <string-name><surname>Keski-Rahkonen</surname> <given-names>P</given-names></string-name>, <string-name><surname>Chatzi</surname> <given-names>L</given-names></string-name>, <string-name><surname>Perez</surname> <given-names>AE</given-names></string-name>, <string-name><surname>Herceg</surname> <given-names>Z</given-names></string-name>, <string-name><surname>Kogevinas</surname> <given-names>M</given-names></string-name>, <string-name><surname>de Kok</surname> <given-names>TM</given-names></string-name>, <string-name><surname>Nawrot</surname> <given-names>TS</given-names></string-name>, <string-name><surname>Novoloaca</surname> <given-names>A</given-names></string-name>, <string-name><surname>Patel</surname> <given-names>CJ</given-names></string-name>, <string-name><surname>Pizzi</surname> <given-names>C</given-names></string-name>, <string-name><surname>Robinot</surname> <given-names>N</given-names></string-name>, <string-name><surname>Rusconi</surname> <given-names>F</given-names></string-name>, <string-name><surname>Scalbert</surname> <given-names>A</given-names></string-name>, <string-name><surname>Sunyer</surname> <given-names>J</given-names></string-name>, <string-name><surname>Vermeulen</surname> <given-names>R</given-names></string-name>, <string-name><surname>Vrijheid</surname> <given-names>M</given-names></string-name>, <string-name><surname>Vineis</surname> <given-names>P</given-names></string-name></person-group>, <etal>et al.</etal> <article-title>A multi-omic analysis of birthweight in newborn cord blood reveals new underlying mechanisms related to cholesterol metabolism</article-title>. <source><italic>Metabolism</italic></source>. <year>2020</year>; <volume>110</volume>:<fpage>154292</fpage>. doi: <pub-id pub-id-type="doi">10.1016/j.metabol.2020.154292</pub-id>.</mixed-citation></ref>
<ref id="c3"><mixed-citation publication-type="web"><person-group person-group-type="author"><string-name><surname>Alvarez-Melis</surname> <given-names>D</given-names></string-name>, <string-name><surname>Jaakkola</surname> <given-names>T</given-names></string-name></person-group>. <article-title>Gromov-Wasserstein Alignment of Word Embedding Spaces</article-title>. In: <source><italic>EMNLP Brussels, Belgium: Association for Computational Linguistics</italic></source>; <year>2018</year>. p. <fpage>1881</fpage>–<lpage>1890</lpage>. <ext-link ext-link-type="uri" xlink:href="https://aclanthology.org/D18-1214,doi:10.18653/v1/D18-1214">https://aclanthology.org/D18-1214,doi:10.18653/v1/D18-1214</ext-link>.</mixed-citation></ref>
<ref id="c4"><mixed-citation publication-type="web"><person-group person-group-type="author"><string-name><surname>Alvarez-Melis</surname> <given-names>D</given-names></string-name>, <string-name><surname>Jegelka</surname> <given-names>S</given-names></string-name>, <string-name><surname>Jaakkola</surname> <given-names>TS</given-names></string-name></person-group>. <article-title>Towards optimal transport with global invariances</article-title>. In: <source><italic>AISTATS PMLR</italic></source>; <year>2019</year>. p. <fpage>1870</fpage>–<lpage>1879</lpage>. <ext-link ext-link-type="uri" xlink:href="https://proceedings.mlr.press/v89/alvarez-melis19a.html">https://proceedings.mlr.press/v89/alvarez-melis19a.html</ext-link>.</mixed-citation></ref>
<ref id="c5"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bedia</surname> <given-names>C</given-names></string-name></person-group>. <article-title>Metabolomics in environmental toxicology: Applications and challenges</article-title>. <source><italic>Trends Environ Anal Chem</italic></source>. <year>2022</year>; <volume>34</volume>:<elocation-id>e00161</elocation-id>. doi: <pub-id pub-id-type="doi">10.1016/j.teac.2022.e00161</pub-id>.</mixed-citation></ref>
<ref id="c6"><mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Beier</surname> <given-names>F</given-names></string-name>, <string-name><surname>Beinert</surname> <given-names>R</given-names></string-name>, <string-name><surname>Steidl</surname> <given-names>G</given-names></string-name></person-group>. <article-title>Multi-marginal Gromov-Wasserstein transport and barycenters</article-title>. <source>arXiv preprint arXiv:220506725</source>. <year>2022</year>; doi: <pub-id pub-id-type="doi">10.48550/arXiv.2205.06725</pub-id>.</mixed-citation></ref>
<ref id="c7"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Brown</surname> <given-names>LD</given-names></string-name>, <string-name><surname>Cai</surname> <given-names>TT</given-names></string-name>, <string-name><surname>DasGupta</surname> <given-names>A</given-names></string-name></person-group>. <article-title>Interval Estimation for a Binomial Proportion</article-title>. <source><italic>Stat Sci</italic></source>. <year>2001</year>; <volume>16</volume>(<issue>2</issue>):<fpage>101</fpage>–<lpage>133</lpage>. doi: <pub-id pub-id-type="doi">10.1214/ss/1009213286</pub-id>.</mixed-citation></ref>
<ref id="c8"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Brunius</surname> <given-names>C</given-names></string-name>, <string-name><surname>Shi</surname> <given-names>L</given-names></string-name>, <string-name><surname>Landberg</surname> <given-names>R</given-names></string-name></person-group>. <article-title>Large-scale untargeted LC-MS metabolomics data correction using between-batch feature alignment and cluster-based within-batch signal intensity drift correction</article-title>. <source><italic>Metabolomics</italic></source>. <year>2016</year> <month>Sep</month>; <volume>12</volume>(<issue>11</issue>):<fpage>173</fpage>. doi: <pub-id pub-id-type="doi">10.1007/s11306-016-1124-4</pub-id>.</mixed-citation></ref>
<ref id="c9"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Chen</surname> <given-names>L</given-names></string-name>, <string-name><surname>Lu</surname> <given-names>W</given-names></string-name>, <string-name><surname>Wang</surname> <given-names>L</given-names></string-name>, <string-name><surname>Xing</surname> <given-names>X</given-names></string-name>, <string-name><surname>Chen</surname> <given-names>Z</given-names></string-name>, <string-name><surname>Teng</surname> <given-names>X</given-names></string-name>, <string-name><surname>Zeng</surname> <given-names>X</given-names></string-name>, <string-name><surname>Muscarella</surname> <given-names>AD</given-names></string-name>, <string-name><surname>Shen</surname> <given-names>Y</given-names></string-name>, <string-name><surname>Cowan</surname> <given-names>A</given-names></string-name>, <string-name><surname>McReynolds</surname> <given-names>MR</given-names></string-name>, <string-name><surname>Kennedy</surname> <given-names>BJ</given-names></string-name>, <string-name><surname>Lato</surname> <given-names>AM</given-names></string-name>, <string-name><surname>Campagna</surname> <given-names>SR</given-names></string-name>, <string-name><surname>Singh</surname> <given-names>M</given-names></string-name>, <string-name><surname>Rabinowitz</surname> <given-names>JD</given-names></string-name></person-group>. <article-title>Metabolite discovery through global annotation of untargeted metabolomics data</article-title>. <source><italic>Nat Methods</italic></source>. <year>2021</year> <month>Nov</month>; <volume>18</volume>(<issue>11</issue>):<fpage>1377</fpage>–<lpage>1385</lpage>. doi: <pub-id pub-id-type="doi">10.1038/s41592-021-01303-3</pub-id>.</mixed-citation></ref>
<ref id="c10"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Chizat</surname> <given-names>L</given-names></string-name>, <string-name><surname>Peyré</surname> <given-names>G</given-names></string-name>, <string-name><surname>Schmitzer</surname> <given-names>B</given-names></string-name>, <string-name><surname>Vialard</surname> <given-names>FX</given-names></string-name></person-group>. <article-title>Unbalanced optimal transport: Dynamic and Kantorovich formulations</article-title>. <source><italic>J Funct Anal</italic></source>. <year>2018</year>; <volume>274</volume>(<issue>11</issue>):<fpage>3090</fpage>–<lpage>3123</lpage>. doi: <pub-id pub-id-type="doi">10.1016/j.jfa.2018.03.008</pub-id>.</mixed-citation></ref>
<ref id="c11"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Climaco</surname> <given-names>Pinto R</given-names></string-name>, <string-name><surname>Karaman</surname> <given-names>I</given-names></string-name>, <string-name><surname>Lewis</surname> <given-names>MR</given-names></string-name>, <string-name><surname>Hallqvist</surname> <given-names>J</given-names></string-name>, <string-name><surname>Kaluarachchi</surname> <given-names>M</given-names></string-name>, <string-name><surname>Gra؟a</surname> <given-names>G</given-names></string-name>, <string-name><surname>Chekmeneva</surname> <given-names>E</given-names></string-name>, <string-name><surname>Durainayagam</surname> <given-names>B</given-names></string-name>, <string-name><surname>Ghanbari</surname> <given-names>M</given-names></string-name>, <string-name><surname>Ikram</surname> <given-names>MA</given-names></string-name>, <string-name><surname>Zetterberg</surname> <given-names>H</given-names></string-name>, <string-name><surname>Griffin</surname> <given-names>J</given-names></string-name>, <string-name><surname>Elliott</surname> <given-names>P</given-names></string-name>, <string-name><surname>Tzoulaki</surname> <given-names>I</given-names></string-name>, <string-name><surname>Dehghan</surname> <given-names>A</given-names></string-name>, <string-name><surname>Herrington</surname> <given-names>D</given-names></string-name>, <string-name><surname>Ebbels</surname> <given-names>T</given-names></string-name></person-group>. <article-title>Finding Correspondence between Metabolomic Features in Untargeted Liquid Chromatography-Mass Spectrometry Metabolomics Datasets</article-title>. <source><italic>Anal Chem</italic></source>. <year>2022</year>; <volume>94</volume>(<issue>14</issue>):<fpage>5493</fpage>–<lpage>5503</lpage>. doi: <pub-id pub-id-type="doi">10.1021/acs.analchem.1c03592</pub-id>.</mixed-citation></ref>
<ref id="c12"><mixed-citation publication-type="web"><person-group person-group-type="author"><string-name><surname>Courty</surname> <given-names>N</given-names></string-name>, <string-name><surname>Flamary</surname> <given-names>R</given-names></string-name>, <string-name><surname>Habrard</surname> <given-names>A</given-names></string-name>, <string-name><surname>Rakotomamonjy</surname> <given-names>A</given-names></string-name></person-group>. <article-title>Joint distribution optimal transportation for domain adaptation</article-title>. <source><italic>NeurIPS</italic></source>. <year>2017</year>; <fpage>30</fpage>. <ext-link ext-link-type="uri" xlink:href="https://dl.acm.org/doi/10.5555/3294996.3295130">https://dl.acm.org/doi/10.5555/3294996.3295130</ext-link>.</mixed-citation></ref>
<ref id="c13"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Demetci</surname> <given-names>P</given-names></string-name>, <string-name><surname>Santorella</surname> <given-names>R</given-names></string-name>, <string-name><surname>Sandstede</surname> <given-names>B</given-names></string-name>, <string-name><surname>Noble</surname> <given-names>WS</given-names></string-name>, <string-name><surname>Singh</surname> <given-names>R</given-names></string-name></person-group>. <article-title>SCOT: Single-Cell Multi-Omics Alignment with Optimal Transport</article-title>. <source><italic>J Comput Biol</italic></source>. <year>2022</year>; <volume>29</volume>(<issue>1</issue>):<fpage>3</fpage>–<lpage>18</lpage>. doi: <pub-id pub-id-type="doi">10.1089/cmb.2021.0446</pub-id>.</mixed-citation></ref>
<ref id="c14"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Franzosa</surname> <given-names>EA</given-names></string-name>, <string-name><surname>Sirota-Madi</surname> <given-names>A</given-names></string-name>, <string-name><surname>Avila-Pacheco</surname> <given-names>J</given-names></string-name>, <string-name><surname>Fornelos</surname> <given-names>N</given-names></string-name>, <string-name><surname>Haiser</surname> <given-names>HJ</given-names></string-name>, <string-name><surname>Reinker</surname> <given-names>S</given-names></string-name>, <string-name><surname>Vatanen</surname> <given-names>T</given-names></string-name>, <string-name><surname>Hall</surname> <given-names>AB</given-names></string-name>, <string-name><surname>Mallick</surname> <given-names>H</given-names></string-name>, <string-name><surname>McIver</surname> <given-names>LJ</given-names></string-name>, <string-name><surname>Sauk</surname> <given-names>JS</given-names></string-name>, <string-name><surname>Wilson</surname> <given-names>RG</given-names></string-name>, <string-name><surname>Stevens</surname> <given-names>BW</given-names></string-name>, <string-name><surname>Scott</surname> <given-names>JM</given-names></string-name>, <string-name><surname>Pierce</surname> <given-names>K</given-names></string-name>, <string-name><surname>Deik</surname> <given-names>AA</given-names></string-name>, <string-name><surname>Bullock</surname> <given-names>K</given-names></string-name>, <string-name><surname>Imhann</surname> <given-names>F</given-names></string-name>, <string-name><surname>Porter</surname> <given-names>JA</given-names></string-name>, <string-name><surname>Zhernakova</surname> <given-names>A</given-names></string-name></person-group>, <etal>et al.</etal> <article-title>Gut microbiome structure and metabolic activity in inflammatory bowel disease</article-title>. <source><italic>Nat Microbiol</italic></source>. <year>2019</year>; <volume>4</volume>(<issue>2</issue>):<fpage>293</fpage>–<lpage>305</lpage>. doi: <pub-id pub-id-type="doi">10.1038/s41564-018-0306-4</pub-id>.</mixed-citation></ref>
<ref id="c15"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gasull</surname> <given-names>M</given-names></string-name>, <string-name><surname>Pumarega</surname> <given-names>J</given-names></string-name>, <string-name><surname>Kiviranta</surname> <given-names>H</given-names></string-name>, <string-name><surname>Rantakokko</surname> <given-names>P</given-names></string-name>, <string-name><surname>Raaschou-Nielsen</surname> <given-names>O</given-names></string-name>, <string-name><surname>Bergdahl</surname> <given-names>IA</given-names></string-name>, <string-name><surname>Sandanger</surname> <given-names>TM</given-names></string-name>, <string-name><surname>Goni</surname> <given-names>F</given-names></string-name>, <string-name><surname>Cirera</surname> <given-names>L</given-names></string-name>, <string-name><surname>Donat-Vargas</surname> <given-names>C</given-names></string-name>, <string-name><surname>Alguacil</surname> <given-names>J</given-names></string-name>, <string-name><surname>Iglesias</surname> <given-names>M</given-names></string-name>, <string-name><surname>Tjønneland</surname> <given-names>A</given-names></string-name>, <string-name><surname>Overvad</surname> <given-names>K</given-names></string-name>, <string-name><surname>Mancini</surname> <given-names>FR</given-names></string-name>, <string-name><surname>Boutron-Ruault</surname> <given-names>MC</given-names></string-name>, <string-name><surname>Severi</surname> <given-names>G</given-names></string-name>, <string-name><surname>Johnson</surname> <given-names>T</given-names></string-name>, <string-name><surname>Kuhn</surname> <given-names>T</given-names></string-name>, <string-name><surname>Trichopoulou</surname> <given-names>A</given-names></string-name></person-group>, <etal>et al.</etal> <article-title>Methodological issues in a prospective study on plasma concentrations of persistent organic pollutants and pancreatic cancer risk within the EPIC cohort</article-title>. <source><italic>Environmental Research</italic></source>. <year>2019</year>; <volume>169</volume>:<fpage>417</fpage>–<lpage>433</lpage>. doi: <pub-id pub-id-type="doi">10.1016/j.envres.2018.11.027</pub-id>.</mixed-citation></ref>
<ref id="c16"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gomari</surname> <given-names>DP</given-names></string-name>, <string-name><surname>Schweickart</surname> <given-names>A</given-names></string-name>, <string-name><surname>Cerchietti</surname> <given-names>L</given-names></string-name>, <string-name><surname>Paietta</surname> <given-names>E</given-names></string-name>, <string-name><surname>Fernandez</surname> <given-names>H</given-names></string-name>, <string-name><surname>Al-Amin</surname> <given-names>H</given-names></string-name>, <string-name><surname>Suhre</surname> <given-names>K</given-names></string-name>, <string-name><surname>Krumsiek</surname> <given-names>J</given-names></string-name></person-group>. <article-title>Variational autoencoders learn transferrable representations of metabolomics data</article-title>. <source><italic>Commun Biol</italic></source>. <year>2022</year> <month>Jun</month>; <volume>5</volume>(<issue>1</issue>):<fpage>645</fpage>. doi: <pub-id pub-id-type="doi">10.1038/s42003-022-03579-3</pub-id>.</mixed-citation></ref>
<ref id="c17"><mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Gromov</surname> <given-names>M</given-names></string-name></person-group>. <chapter-title>Metric Structures for Riemannian and Non-Riemannian Spaces</chapter-title>. <publisher-name>Birkhäuser Boston, Inc.</publisher-name>, <publisher-loc>Boston, MA</publisher-loc>; <year>2001</year>. doi: <pub-id pub-id-type="doi">10.1007/978-0-8176-4583-0</pub-id>.</mixed-citation></ref>
<ref id="c18"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Habra</surname> <given-names>H</given-names></string-name>, <string-name><surname>Kachman</surname> <given-names>M</given-names></string-name>, <string-name><surname>Bullock</surname> <given-names>K</given-names></string-name>, <string-name><surname>Clish</surname> <given-names>C</given-names></string-name>, <string-name><surname>Evans</surname> <given-names>CR</given-names></string-name>, <string-name><surname>Karnovsky</surname> <given-names>A</given-names></string-name></person-group>. <article-title>metabCombiner: Paired Untargeted LC-HRMS Metabolomics Feature Matching and Concatenation of Disparately Acquired Data Sets</article-title>. <source><italic>Anal Chem</italic></source>. <year>2021</year>; <volume>93</volume>(<issue>12</issue>):<fpage>5028</fpage>–<lpage>5036</lpage>. doi: <pub-id pub-id-type="doi">10.1021/acs.analchem.0c03693</pub-id>.</mixed-citation></ref>
<ref id="c19"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Hsu</surname> <given-names>YHH</given-names></string-name>, <string-name><surname>Churchhouse</surname> <given-names>C</given-names></string-name>, <string-name><surname>Pers</surname> <given-names>TH</given-names></string-name>, <string-name><surname>Mercader</surname> <given-names>JM</given-names></string-name>, <string-name><surname>Metspalu</surname> <given-names>A</given-names></string-name>, <string-name><surname>Fischer</surname> <given-names>K</given-names></string-name>, <string-name><surname>Fortney</surname> <given-names>K</given-names></string-name>, <string-name><surname>Morgen</surname> <given-names>EK</given-names></string-name>, <string-name><surname>Gonzalez</surname> <given-names>C</given-names></string-name>, <string-name><surname>Gonzalez</surname> <given-names>ME</given-names></string-name>, <string-name><surname>Esko</surname> <given-names>T</given-names></string-name>, <string-name><surname>Hirschhorn</surname> <given-names>JN</given-names></string-name></person-group>. <article-title>PAIRUP-MS: Pathway analysis and imputation to relate unknowns in profiles from mass spectrometry-based metabolite data</article-title>. <source><italic>PLoS Comput Biol</italic></source>. <year>2019</year> <day>01</day>; <volume>15</volume>(<issue>1</issue>):<fpage>1</fpage>–<lpage>26</lpage>. doi: <pub-id pub-id-type="doi">10.1371/journal.pcbi.1006734</pub-id>.</mixed-citation></ref>
<ref id="c20"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ivanisevic</surname> <given-names>J</given-names></string-name>, <string-name><surname>Want</surname> <given-names>EJ</given-names></string-name></person-group>. <article-title>From Samples to Insights into Metabolism: Uncovering Biologically Relevant Information in LC-HRMS Metabolomics Data</article-title>. <source><italic>Metabolites</italic></source>. <year>2019</year>; <volume>9</volume>(<issue>12</issue>). doi: <pub-id pub-id-type="doi">10.3390/metabo9120308</pub-id>.</mixed-citation></ref>
<ref id="c21"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kantorovich</surname> <given-names>LV</given-names></string-name></person-group>. <article-title>On the translocation of masses</article-title>. <source><italic>J Math Sci</italic></source>. <year>2006</year>; <volume>133</volume>(<issue>4</issue>):<fpage>1381</fpage>–<lpage>1382</lpage>. doi: <pub-id pub-id-type="doi">10.1007/s10958-006-0049-2</pub-id>.</mixed-citation></ref>
<ref id="c22"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname> <given-names>L</given-names></string-name>, <string-name><surname>Zheng</surname> <given-names>X</given-names></string-name>, <string-name><surname>Zhou</surname> <given-names>Q</given-names></string-name>, <string-name><surname>Villanueva</surname> <given-names>N</given-names></string-name>, <string-name><surname>Nian</surname> <given-names>W</given-names></string-name>, <string-name><surname>Liu</surname> <given-names>X</given-names></string-name>, <string-name><surname>Huan</surname> <given-names>T</given-names></string-name></person-group>. <article-title>Metabolomics-Based Discovery of Molecular Signatures for Triple Negative Breast Cancer in Asian Female Population</article-title>. <source><italic>Sci Rep</italic></source>. <year>2020</year> <month>Jan</month>; <volume>10</volume>(<issue>1</issue>):<fpage>370</fpage>. doi: <pub-id pub-id-type="doi">10.1038/s41598-019-57068-5</pub-id>.</mixed-citation></ref>
<ref id="c23"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Liu</surname> <given-names>Q</given-names></string-name>, <string-name><surname>Walker</surname> <given-names>D</given-names></string-name>, <string-name><surname>Uppal</surname> <given-names>K</given-names></string-name>, <string-name><surname>Liu</surname> <given-names>Z</given-names></string-name>, <string-name><surname>Ma</surname> <given-names>C</given-names></string-name>, <string-name><surname>Tran</surname> <given-names>V</given-names></string-name>, <string-name><surname>Li</surname> <given-names>S</given-names></string-name>, <string-name><surname>Jones</surname> <given-names>DP</given-names></string-name>, <string-name><surname>Yu</surname> <given-names>T</given-names></string-name></person-group>. <article-title>Addressing the batch effect issue for LC/MS metabolomics data in data preprocessing</article-title>. <source><italic>Sci Rep</italic></source>. <year>2020</year> <month>Aug</month>; <volume>10</volume>(<issue>1</issue>):<fpage>13856</fpage>. doi: <pub-id pub-id-type="doi">10.1038/s41598-020-70850-0</pub-id>.</mixed-citation></ref>
<ref id="c24"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Loftfield</surname> <given-names>E</given-names></string-name>, <string-name><surname>Stepien</surname> <given-names>M</given-names></string-name>, <string-name><surname>Viallon</surname> <given-names>V</given-names></string-name>, <string-name><surname>Trijsburg</surname> <given-names>L</given-names></string-name>, <string-name><surname>Rothwell</surname> <given-names>JA</given-names></string-name>, <string-name><surname>Robinot</surname> <given-names>N</given-names></string-name>, <string-name><surname>Biessy</surname> <given-names>C</given-names></string-name>, <string-name><surname>Bergdahl</surname> <given-names>IA</given-names></string-name>, <string-name><surname>Boden</surname> <given-names>S</given-names></string-name>, <string-name><surname>Schulze</surname> <given-names>MB</given-names></string-name></person-group>, <etal>et al.</etal> <article-title>Novel biomarkers of habitual alcohol intake and associations with risk of pancreatic and liver cancers and liver disease mortality</article-title>. <source><italic>J Natl Cancer Inst</italic></source>. <year>2021</year>; <volume>113</volume>(<issue>11</issue>):<fpage>1542</fpage>–<lpage>1550</lpage>. doi: <pub-id pub-id-type="doi">10.1093/jnci/djab078</pub-id>.</mixed-citation></ref>
<ref id="c25"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Memoli</surname> <given-names>F</given-names></string-name></person-group>. <article-title>Gromov-Wasserstein Distances and the Metric Approach to Object Matching</article-title>. <source><italic>Found Comput Math</italic></source>. <year>2011</year> <month>Aug</month>; <volume>11</volume>(<issue>4</issue>):<fpage>417</fpage>–<lpage>487</lpage>. doi: <pub-id pub-id-type="doi">10.1007/s10208-011-9093-5</pub-id>.</mixed-citation></ref>
<ref id="c26"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Monge</surname> <given-names>G</given-names></string-name></person-group>. <article-title>Memoire sur la théorie des déblais et des remblais</article-title>. <source><italic>Mem Math Phys Acad Royale Sci</italic></source>. <year>1781</year>; p. <fpage>666</fpage>–<lpage>704</lpage>.</mixed-citation></ref>
<ref id="c27"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Nitzan</surname> <given-names>M</given-names></string-name>, <string-name><surname>Karaiskos</surname> <given-names>N</given-names></string-name>, <string-name><surname>Friedman</surname> <given-names>N</given-names></string-name>, <string-name><surname>Rajewsky</surname> <given-names>N</given-names></string-name></person-group>. <article-title>Gene expression cartography</article-title>. <source><italic>Nature</italic></source>. <year>2019</year> <month>Dec</month>; <volume>576</volume>(<issue>7785</issue>):<fpage>132</fpage>–<lpage>137</lpage>. doi: <pub-id pub-id-type="doi">1O.1O38/s41586-O19-1773-3</pub-id>.</mixed-citation></ref>
<ref id="c28"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Patti</surname> <given-names>GJ</given-names></string-name></person-group>. <article-title>Separation strategies for untargeted metabolomics</article-title>. <source><italic>J Sep Sci</italic></source>. <year>2011</year>; <volume>34</volume>(<issue>24</issue>):<fpage>3460</fpage>–<lpage>3469</lpage>. doi: <pub-id pub-id-type="doi">10.1002/jssc.201100532</pub-id>.</mixed-citation></ref>
<ref id="c29"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Peyré</surname> <given-names>G</given-names></string-name>, <string-name><surname>Cuturi</surname> <given-names>M</given-names></string-name>, <string-name><surname>Solomon</surname> <given-names>J</given-names></string-name></person-group>. <article-title>Gromov-wasserstein averaging of kernel and distance matrices</article-title>. In: <source><italic>ICML PMLR</italic></source>; <year>2016</year>. p. <fpage>2664</fpage>–<lpage>2672</lpage>. doi: <pub-id pub-id-type="doi">10.5555/3045390.3045671</pub-id>.</mixed-citation></ref>
<ref id="c30"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Peyré</surname> <given-names>G</given-names></string-name>, <string-name><surname>Cuturi</surname> <given-names>M</given-names></string-name></person-group>, <etal>et al.</etal> <article-title>Computational optimal transport: With applications to data science</article-title>. <source><italic>Found Trends Mach Learn</italic></source>. <year>2019</year>; <volume>11</volume>(<issue>5-6</issue>):<fpage>355</fpage>–<lpage>607</lpage>. doi: <pub-id pub-id-type="doi">10.1561/22OOOOOO73</pub-id>.</mixed-citation></ref>
<ref id="c31"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Pirhaji</surname> <given-names>L</given-names></string-name>, <string-name><surname>Milani</surname> <given-names>P</given-names></string-name>, <string-name><surname>Leidl</surname> <given-names>M</given-names></string-name>, <string-name><surname>Curran</surname> <given-names>T</given-names></string-name>, <string-name><surname>Avila-Pacheco</surname> <given-names>J</given-names></string-name>, <string-name><surname>Clish</surname> <given-names>CB</given-names></string-name>, <string-name><surname>White</surname> <given-names>FM</given-names></string-name>, <string-name><surname>Saghatelian</surname> <given-names>A</given-names></string-name>, <string-name><surname>Fraenkel</surname> <given-names>E</given-names></string-name></person-group>. <article-title>Revealing disease-associated pathways by network integration of untargeted metabolomics</article-title>. <source><italic>Nat Methods</italic></source>. <year>2016</year>; <volume>13</volume>(<issue>9</issue>):<fpage>770</fpage>–<lpage>776</lpage>. doi: <pub-id pub-id-type="doi">10.1038/nmeth.3940</pub-id>.</mixed-citation></ref>
<ref id="c32"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rappaport</surname> <given-names>SM</given-names></string-name>, <string-name><surname>Barupal</surname> <given-names>DK</given-names></string-name>, <string-name><surname>Wishart</surname> <given-names>D</given-names></string-name>, <string-name><surname>Vineis</surname> <given-names>P</given-names></string-name>, <string-name><surname>Scalbert</surname> <given-names>A</given-names></string-name></person-group>. <article-title>The Blood Exposome and Its Role in Discovering Causes of Disease</article-title>. <source><italic>Environ Health Perspect</italic></source>. <year>2014</year>; <volume>122</volume>(<issue>8</issue>):<fpage>769</fpage>–<lpage>774</lpage>. doi: <pub-id pub-id-type="doi">10.1289/ehp.1308015</pub-id>.</mixed-citation></ref>
<ref id="c33"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Reuther</surname> <given-names>A</given-names></string-name>, <string-name><surname>Kepner</surname> <given-names>J</given-names></string-name>, <string-name><surname>Byun</surname> <given-names>C</given-names></string-name>, <string-name><surname>Samsi</surname> <given-names>S</given-names></string-name>, <string-name><surname>Arcand</surname> <given-names>W</given-names></string-name>, <string-name><surname>Bestor</surname> <given-names>D</given-names></string-name>, <string-name><surname>Bergeron</surname> <given-names>B</given-names></string-name>, <string-name><surname>Gadepally</surname> <given-names>V</given-names></string-name>, <string-name><surname>Houle</surname> <given-names>M</given-names></string-name>, <string-name><surname>Hubbell</surname> <given-names>M</given-names></string-name>, <string-name><surname>Jones</surname> <given-names>M</given-names></string-name>, <string-name><surname>Klein</surname> <given-names>A</given-names></string-name>, <string-name><surname>Milechin</surname> <given-names>L</given-names></string-name>, <string-name><surname>Mullen</surname> <given-names>J</given-names></string-name>, <string-name><surname>Prout</surname> <given-names>A</given-names></string-name>, <string-name><surname>Rosa</surname> <given-names>A</given-names></string-name>, <string-name><surname>Yee</surname> <given-names>C</given-names></string-name>, <string-name><surname>Michaleas</surname> <given-names>P</given-names></string-name></person-group>. <article-title>Interactive supercomputing on 40,000 cores for machine learning and data analysis</article-title>. In: <source><italic>HPEC IEEE</italic></source>; <year>2018</year>. p. <fpage>1</fpage>–<lpage>6</lpage>. doi: <pub-id pub-id-type="doi">10.1109/HPEC.2018.8547629</pub-id>.</mixed-citation></ref>
<ref id="c34"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Riboli</surname> <given-names>E</given-names></string-name>, <string-name><surname>Hunt</surname> <given-names>K</given-names></string-name>, <string-name><surname>Slimani</surname> <given-names>N</given-names></string-name>, <string-name><surname>Ferrari</surname> <given-names>P</given-names></string-name>, <string-name><surname>Norat</surname> <given-names>T</given-names></string-name>, <string-name><surname>Fahey</surname> <given-names>M</given-names></string-name>, <string-name><surname>Charrondiere</surname> <given-names>U</given-names></string-name>, <string-name><surname>Hemon</surname> <given-names>B</given-names></string-name>, <string-name><surname>Casagrande</surname> <given-names>C</given-names></string-name>, <string-name><surname>Vignat</surname> <given-names>J</given-names></string-name></person-group>, <etal>et al.</etal> <article-title>European Prospective Investigation into Cancer and Nutrition (EPIC): study populations and data collection</article-title>. <source><italic>Public Health Nutr</italic></source>. <year>2002</year>; <volume>5</volume>(<issue>6b</issue>):<fpage>1113</fpage>–<lpage>1124</lpage>. doi: <pub-id pub-id-type="doi">10.1079/PHN2002394</pub-id>.</mixed-citation></ref>
<ref id="c35"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Schiebinger</surname> <given-names>G</given-names></string-name>, <string-name><surname>Shu</surname> <given-names>J</given-names></string-name>, <string-name><surname>Tabaka</surname> <given-names>M</given-names></string-name>, <string-name><surname>Cleary</surname> <given-names>B</given-names></string-name>, <string-name><surname>Subramanian</surname> <given-names>V</given-names></string-name>, <string-name><surname>Solomon</surname> <given-names>A</given-names></string-name>, <string-name><surname>Gould</surname> <given-names>J</given-names></string-name>, <string-name><surname>Liu</surname> <given-names>S</given-names></string-name>, <string-name><surname>Lin</surname> <given-names>S</given-names></string-name>, <string-name><surname>Berube</surname> <given-names>P</given-names></string-name></person-group>, <etal>et al.</etal> <article-title>Optimal-transport analysis of single-cell gene expression identifies developmental trajectories in reprogramming</article-title>. <source><italic>Cell</italic></source>. <year>2019</year>; <volume>176</volume>(<issue>4</issue>):<fpage>928</fpage>–<lpage>943</lpage>. doi: <pub-id pub-id-type="doi">10.1016/j.cell.2019.01.006</pub-id>.</mixed-citation></ref>
<ref id="c36"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sejourne</surname> <given-names>T</given-names></string-name>, <string-name><surname>Feydy</surname> <given-names>J</given-names></string-name>, <string-name><surname>Vialard</surname> <given-names>FX</given-names></string-name>, <string-name><surname>Trouve</surname> <given-names>A</given-names></string-name>, <string-name><surname>Peyré</surname> <given-names>G</given-names></string-name></person-group>. <article-title>Sinkhorn divergences for unbalanced optimal transport</article-title>. <source>arXiv preprint arXiv:191012958</source>. <year>2019</year>; doi: <pub-id pub-id-type="doi">10.48550/arXiv.1910.12958</pub-id>.</mixed-citation></ref>
<ref id="c37"><mixed-citation publication-type="web"><person-group person-group-type="author"><string-name><surname>Sejourne</surname> <given-names>T</given-names></string-name>, <string-name><surname>Vialard</surname> <given-names>FX</given-names></string-name>, <string-name><surname>Peyré</surname> <given-names>G</given-names></string-name></person-group>. <article-title>The Unbalanced Gromov Wasserstein Distance: Conic Formulation and Relaxation</article-title>. In: <source><italic>NeuS vol. 34 Curran Associates, Inc.</italic></source>; <year>2021</year>. p. <fpage>8766</fpage>–<lpage>8779</lpage>. <ext-link ext-link-type="uri" xlink:href="https://proceedings.neurips.cc/paper/2021/hash/4990974d150d0de5e6e15a1454fe6b0f-Abstract.html">https://proceedings.neurips.cc/paper/2021/hash/4990974d150d0de5e6e15a1454fe6b0f-Abstract.html</ext-link>.</mixed-citation></ref>
<ref id="c38"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Skoraczyki</surname> <given-names>G</given-names></string-name>, <string-name><surname>Gambin</surname> <given-names>A</given-names></string-name>, <string-name><surname>Miasojedow</surname> <given-names>B</given-names></string-name></person-group>. <article-title>Alignstein: Optimal transport for improved LC-MS retention time alignment</article-title>. <source><italic>GigaScience</italic></source>. <year>2022</year> <volume>11</volume>; <fpage>11</fpage>. doi: <pub-id pub-id-type="doi">https://doi.org/10.1093/gigascience/giac101</pub-id>.</mixed-citation></ref>
<ref id="c39"><mixed-citation publication-type="web"><person-group person-group-type="author"><string-name><surname>Slimani</surname> <given-names>N</given-names></string-name>, <string-name><surname>Bingham</surname> <given-names>S</given-names></string-name>, <string-name><surname>Runswick</surname> <given-names>S</given-names></string-name>, <string-name><surname>Ferrari</surname> <given-names>P</given-names></string-name>, <string-name><surname>Day</surname> <given-names>NE</given-names></string-name>, <string-name><surname>Welch</surname> <given-names>AA</given-names></string-name>, <string-name><surname>Key</surname> <given-names>TJ</given-names></string-name>, <string-name><surname>Miller</surname> <given-names>AB</given-names></string-name>, <string-name><surname>Boeing</surname> <given-names>H</given-names></string-name>, <string-name><surname>Sieri</surname> <given-names>S</given-names></string-name>, <string-name><surname>Veglia</surname> <given-names>F</given-names></string-name>, <string-name><surname>Palli</surname> <given-names>D</given-names></string-name>, <string-name><surname>Panico</surname> <given-names>S</given-names></string-name>, <string-name><surname>Tumino</surname> <given-names>R</given-names></string-name>, <string-name><surname>Bueno-De-Mesquita</surname> <given-names>B</given-names></string-name>, <string-name><surname>Ocke</surname> <given-names>MC</given-names></string-name>, <string-name><surname>Clavel-Chapelon</surname> <given-names>F</given-names></string-name>, <string-name><surname>Trichopoulou</surname> <given-names>A</given-names></string-name>, <string-name><surname>Van Staveren</surname> <given-names>WA</given-names></string-name>, <string-name><surname>Riboli</surname> <given-names>E</given-names></string-name></person-group>. <article-title>Group level validation of protein intakes estimated by 24-hour diet recall and dietary questionnaires against 24-hour urinary nitrogen in the European Prospective Investigation into Cancer and Nutrition (EPIC) calibration study</article-title>. <source><italic>Cancer Epidemiol Biomarkers Prev</italic></source>. <year>2003</year> <month>Aug</month>; <volume>12</volume>(<issue>8</issue>):<fpage>784</fpage>–<lpage>795</lpage>. <ext-link ext-link-type="uri" xlink:href="https://pubmed.ncbi.nlm.nih.gov/12917211/">https://pubmed.ncbi.nlm.nih.gov/12917211/</ext-link>.</mixed-citation></ref>
<ref id="c40"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Smith</surname> <given-names>CA</given-names></string-name>, <string-name><surname>Want</surname> <given-names>EJ</given-names></string-name>, <string-name><surname>O’Maille</surname> <given-names>G</given-names></string-name>, <string-name><surname>Abagyan</surname> <given-names>R</given-names></string-name>, <string-name><surname>Siuzdak</surname> <given-names>G</given-names></string-name></person-group>. <article-title>XCMS: Processing Mass Spectrometry Data for Metabolite Profiling Using Nonlinear PeakAlignment, Matching, and Identification</article-title>. <source><italic>Anal Chem</italic></source>. <year>2006</year>; <volume>78</volume>(<issue>3</issue>):<fpage>779</fpage>–<lpage>787</lpage>. doi: <pub-id pub-id-type="doi">10.1021/ac051437y</pub-id>.</mixed-citation></ref>
<ref id="c41"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Solomon</surname> <given-names>J</given-names></string-name>, <string-name><surname>Peyré</surname> <given-names>G</given-names></string-name>, <string-name><surname>Kim</surname> <given-names>VG</given-names></string-name>, <string-name><surname>Sra</surname> <given-names>S</given-names></string-name></person-group>. <article-title>Entropic Metric Alignment for Correspondence Problems</article-title>. <source><italic>ACM Trans Graph</italic></source>. <year>2016</year> <month>jul</month>; <volume>35</volume>(<issue>4</issue>). doi: <pub-id pub-id-type="doi">10.1145/2897824.2925903</pub-id>.</mixed-citation></ref>
<ref id="c42"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Stepien</surname> <given-names>M</given-names></string-name>, <string-name><surname>Duarte-Salles</surname> <given-names>T</given-names></string-name>, <string-name><surname>Fedirko</surname> <given-names>V</given-names></string-name>, <string-name><surname>Floegel</surname> <given-names>A</given-names></string-name>, <string-name><surname>Barupal</surname> <given-names>DK</given-names></string-name>, <string-name><surname>Rinaldi</surname> <given-names>S</given-names></string-name>, <string-name><surname>Achaintre</surname> <given-names>D</given-names></string-name>, <string-name><surname>Assi</surname> <given-names>N</given-names></string-name>, <string-name><surname>Tjønneland</surname> <given-names>A</given-names></string-name>, <string-name><surname>Overvad</surname> <given-names>K</given-names></string-name>, <string-name><surname>Bastide</surname> <given-names>N</given-names></string-name>, <string-name><surname>Boutron-Ruault</surname> <given-names>MC</given-names></string-name>, <string-name><surname>Severi</surname> <given-names>G</given-names></string-name>, <string-name><surname>Kuhn</surname> <given-names>T</given-names></string-name>, <string-name><surname>Kaaks</surname> <given-names>R</given-names></string-name>, <string-name><surname>Aleksandrova</surname> <given-names>K</given-names></string-name>, <string-name><surname>Boeing</surname> <given-names>H</given-names></string-name> <string-name><surname>Trichopoulou</surname> <given-names>A</given-names></string-name>, <string-name><surname>Bamia</surname> <given-names>C</given-names></string-name>, <string-name><surname>Lagiou</surname> <given-names>P</given-names></string-name></person-group>, <etal>et al.</etal> <article-title>Alteration of amino acid and biogenic amine metabolism in hepatobiliary cancers: Findings from a prospective cohort study</article-title>. <source><italic>Int J Cancer</italic></source>. <year>2016</year>; <volume>138</volume>(<issue>2</issue>):<fpage>348</fpage>–<lpage>360</lpage>. doi: <pub-id pub-id-type="doi">10.1002/ijc.29718</pub-id>.</mixed-citation></ref>
<ref id="c43"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Stepien</surname> <given-names>M</given-names></string-name>, <string-name><surname>Keski-Rahkonen</surname> <given-names>P</given-names></string-name>, <string-name><surname>Kiss</surname> <given-names>A</given-names></string-name>, <string-name><surname>Robinot</surname> <given-names>N</given-names></string-name>, <string-name><surname>Duarte-Salles</surname> <given-names>T</given-names></string-name>, <string-name><surname>Murphy</surname> <given-names>N</given-names></string-name>, <string-name><surname>Perlemuter</surname> <given-names>G</given-names></string-name>, <string-name><surname>Viallon</surname> <given-names>V</given-names></string-name>, <string-name><surname>Tjønneland</surname> <given-names>A</given-names></string-name>, <string-name><surname>Rostgaard-Hansen</surname> <given-names>AL</given-names></string-name>, <string-name><surname>Dahm</surname> <given-names>CC</given-names></string-name>, <string-name><surname>Overvad</surname> <given-names>K</given-names></string-name>, <string-name><surname>Boutron-Ruault</surname> <given-names>MC</given-names></string-name>, <string-name><surname>Mancini</surname> <given-names>FR</given-names></string-name>, <string-name><surname>Mahamat-Saleh</surname> <given-names>Y</given-names></string-name>, <string-name><surname>Aleksandrova</surname> <given-names>K</given-names></string-name>, <string-name><surname>Kaaks</surname> <given-names>R</given-names></string-name>, <string-name><surname>Kuhn</surname> <given-names>T</given-names></string-name>, <string-name><surname>Trichopoulou</surname> <given-names>A</given-names></string-name>, <string-name><surname>Karakatsani</surname> <given-names>A</given-names></string-name></person-group>, <etal>et al.</etal> <article-title>Metabolic perturbations prior to hepatocellular carcinoma diagnosis: Findings from a prospective observational cohort study</article-title>. <source><italic>Int J Cancer</italic></source>. <year>2021</year>; <volume>148</volume>(<issue>3</issue>):<fpage>609</fpage>–<lpage>625</lpage>. doi: <pub-id pub-id-type="doi">https://doi.org/10.1002/ijc.33236</pub-id>.</mixed-citation></ref>
<ref id="c44"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tautenhahn</surname> <given-names>R</given-names></string-name>, <string-name><surname>Patti</surname> <given-names>GJ</given-names></string-name>, <string-name><surname>Kalisiak</surname> <given-names>E</given-names></string-name>, <string-name><surname>Miyamoto</surname> <given-names>T</given-names></string-name>, <string-name><surname>Schmidt</surname> <given-names>M</given-names></string-name>, <string-name><surname>Lo</surname> <given-names>FY</given-names></string-name>, <string-name><surname>McBee</surname> <given-names>J</given-names></string-name>, <string-name><surname>Baliga</surname> <given-names>NS</given-names></string-name>, <string-name><surname>Siuzdak</surname> <given-names>G</given-names></string-name></person-group>. <article-title>metaX-CMS: second-order analysis of untargeted metabolomics data</article-title>. <source><italic>Anal Chem</italic></source>. <year>2011</year>; <volume>83</volume>(<issue>3</issue>):<fpage>696</fpage>–<lpage>700</lpage>. doi: <pub-id pub-id-type="doi">10.1021/ac102980g</pub-id>.</mixed-citation></ref>
<ref id="c45"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Vaughan</surname> <given-names>AA</given-names></string-name>, <string-name><surname>Dunn</surname> <given-names>WB</given-names></string-name>, <string-name><surname>Allwood</surname> <given-names>JW</given-names></string-name>, <string-name><surname>Wedge</surname> <given-names>DC</given-names></string-name>, <string-name><surname>Blackhall</surname> <given-names>FH</given-names></string-name>, <string-name><surname>Whetton</surname> <given-names>AD</given-names></string-name>, <string-name><surname>Dive</surname> <given-names>C</given-names></string-name>, <string-name><surname>Goodacre</surname> <given-names>R</given-names></string-name></person-group>. <article-title>Liquid Chromatography-Mass Spectrometry Calibration Transfer and Metabolomics Data Fusion</article-title>. <source><italic>Anal Chem</italic></source>. <year>2012</year>; <volume>84</volume>(<issue>22</issue>):<fpage>9848</fpage>–<lpage>9857</lpage>. doi: <pub-id pub-id-type="doi">10.1021/ac302227c</pub-id>.</mixed-citation></ref>
<ref id="c46"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Villani</surname> <given-names>C</given-names></string-name></person-group>. <article-title>Topics in optimal transportation, vol. 58</article-title>. <source><italic>American Mathematical Soc</italic></source>.; <year>2021</year>.</mixed-citation></ref>
<ref id="c47"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wang</surname> <given-names>TJ</given-names></string-name>, <string-name><surname>Larson</surname> <given-names>MG</given-names></string-name>, <string-name><surname>Vasan</surname> <given-names>RS</given-names></string-name>, <string-name><surname>Cheng</surname> <given-names>S</given-names></string-name>, <string-name><surname>Rhee</surname> <given-names>EP</given-names></string-name>, <string-name><surname>McCabe</surname> <given-names>E</given-names></string-name>, <string-name><surname>Lewis</surname> <given-names>GD</given-names></string-name>, <string-name><surname>Fox</surname> <given-names>CS</given-names></string-name>, <string-name><surname>Jacques</surname> <given-names>PF</given-names></string-name>, <string-name><surname>Fernandez</surname> <given-names>C</given-names></string-name>, <string-name><surname>O’Donnell</surname> <given-names>CJ</given-names></string-name>, <string-name><surname>Carr</surname> <given-names>SA</given-names></string-name>, <string-name><surname>Mootha</surname> <given-names>VK</given-names></string-name>, <string-name><surname>Florez</surname> <given-names>JC</given-names></string-name>, <string-name><surname>Souza</surname> <given-names>A</given-names></string-name>, <string-name><surname>Melander</surname> <given-names>O</given-names></string-name>, <string-name><surname>Clish</surname> <given-names>CB</given-names></string-name>, <string-name><surname>Gerszten</surname> <given-names>RE</given-names></string-name></person-group>. <article-title>Metabolite profiles and the risk of developing diabetes</article-title>. <source><italic>Nat Med</italic></source>. <year>2011</year>; <volume>17</volume>(<issue>4</issue>):<fpage>448</fpage>–<lpage>453</lpage>. doi: <pub-id pub-id-type="doi">10.1038/nm.2307</pub-id>.</mixed-citation></ref>
<ref id="c48"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wishart</surname> <given-names>DS</given-names></string-name></person-group>. <article-title>Metabolomics for Investigating Physiological and Pathophysiological Processes</article-title>. <source><italic>Physiol Rev</italic></source>. <year>2019</year>; <volume>99</volume>(<issue>4</issue>):<fpage>1819</fpage>–<lpage>1875</lpage>. doi: <pub-id pub-id-type="doi">10.1152/physrev.00035.2018</pub-id>.</mixed-citation></ref>
<ref id="c49"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Yang</surname> <given-names>KD</given-names></string-name>, <string-name><surname>Damodaran</surname> <given-names>K</given-names></string-name>, <string-name><surname>Venkatachalapathy</surname> <given-names>S</given-names></string-name>, <string-name><surname>Soylemezoglu</surname> <given-names>AC</given-names></string-name>, <string-name><surname>Shivashankar</surname> <given-names>G</given-names></string-name>, <string-name><surname>Uhler</surname> <given-names>C</given-names></string-name></person-group>. <article-title>Predicting cell lineages using autoencoders and optimal transport</article-title>. <source><italic>PLoS Comput Biol</italic></source>. <year>2020</year>; <volume>16</volume>(<issue>4</issue>):<fpage>1</fpage>–<lpage>20</lpage>. doi: <pub-id pub-id-type="doi">10.1371/journal.pcbi.1007828</pub-id>.</mixed-citation></ref>
<ref id="c50"><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zhou</surname> <given-names>B</given-names></string-name>, <string-name><surname>Xiao</surname> <given-names>JF</given-names></string-name>, <string-name><surname>Tuli</surname> <given-names>L</given-names></string-name>, <string-name><surname>Ressom</surname> <given-names>HW</given-names></string-name></person-group>. <article-title>LC-MS-based metabolomics</article-title>. <source><italic>Mol BioSyst</italic></source>. <year>2012</year>; <volume>8</volume>:<fpage>470</fpage>–<lpage>481</lpage>. doi: <pub-id pub-id-type="doi">10.1039/C1MB05350G</pub-id>.</mixed-citation></ref>
</ref-list>
<app-group>
<app id="app1">
<title>Appendix 1</title>
<p>In this paper, we study howto match metabolic features across two datasets where Dataset 1 has <italic>p</italic><sub>1</sub> metabolic features measured across <italic>n</italic><sub>1</sub> patients and Dataset 2 has <italic>p</italic><sub>2</sub> metabolic features measured across <italic>n</italic><sub>2</sub> patients. Our goal is to identify pairs of indexes (<italic>i,j</italic>) with <italic>i</italic> ∈ {1,… ,<italic>p</italic><sub>1</sub>} and <italic>j</italic> ∈ {1,… ,<italic>p</italic><sub>2</sub>}, such that feature <italic>i</italic> in Dataset 1 and feature <italic>j</italic> in Dataset 2 correspond to the same metabolic feature. More formally, we aim to identify a <italic>matching matrix</italic> <inline-formula id="ID52">
<alternatives><mml:math display="inline" id="I52"><mml:mrow><mml:mi>M</mml:mi><mml:mo>*</mml:mo><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq52.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> such that <inline-formula id="ID53">
<alternatives><mml:math display="inline" id="I53"><mml:mrow><mml:msubsup><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq53.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> if features <italic>i</italic> in Dataset 1 and feature <italic>j</italic> in Dataset 2 correspond to the same feature, hereafter referred to as <italic>matched</italic> features. Otherwise we set <inline-formula id="ID54">
<alternatives><mml:math display="inline" id="I54"><mml:mrow><mml:msubsup><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq54.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> otherwise. We emphasize that a matching matrix <italic>M</italic>* can have at most one nonzero entry in each row and column.</p>
<p>Both of the datasets we aim to match are obtained from liquid chromatography-mass spectrometry (LC-MS) experiments. Hence, for Dataset 1 each metabolite <italic>i</italic> ∈ [<italic>p</italic><sub>1</sub>] is labeled with a mass-to-charge (<italic>m</italic>/<italic>z</italic>) ratio <inline-formula id="ID55">
<alternatives><mml:math display="inline" id="I55"><mml:mrow><mml:msubsup><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq55.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> as well as a retention time (RT) given by <inline-formula id="ID56">
<alternatives><mml:math display="inline" id="I56"><mml:mrow><mml:mi>R</mml:mi><mml:msubsup><mml:mi>T</mml:mi><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq56.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>. Additionally, each metabolite has a vector of intensities across patients denoted by <inline-formula id="ID57">
<alternatives><mml:math display="inline" id="I57"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq57.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>. Similarly, each metabolite <italic>j</italic> ∈ [<italic>p</italic><sub>2</sub>] in Dataset 2 is labeled by its <italic>m</italic>/<italic>z</italic> ratio <inline-formula id="ID58">
<alternatives><mml:math display="inline" id="I58"><mml:mrow><mml:msubsup><mml:mi>m</mml:mi><mml:mi>j</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq58.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>, its retention time <inline-formula id="ID59">
<alternatives><mml:math display="inline" id="I59"><mml:mrow><mml:mi>R</mml:mi><mml:msubsup><mml:mi>T</mml:mi><mml:mi>j</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq59.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> and its vector of intensities across samples <inline-formula id="ID60">
<alternatives><mml:math display="inline" id="I60"><mml:mrow><mml:msub><mml:mi>Y</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq60.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>.</p>
<sec id="s5a">
<title>Correlations and distances between metabolomic features</title>
<p>Features cannot be aligned based on their <italic>m</italic>/<italic>z</italic> and RT alone as they are often too inconsistent across studies. Our method is based on the idea that, in addition to their <italic>m</italic>/<italic>z</italic> and RT being compatible, the signal intensities of metabolites measured in two different studies should exhibit similar correlation structures, or more generally exhibit similar distances between their intensity vectors. In other words, if feature intensity vectors <inline-formula id="ID61">
<alternatives><mml:math display="inline" id="I61"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq61.tif" mimetype="image" mime-subtype="tiff"/></alternatives></inline-formula>, <inline-formula id="ID157">
<alternatives><mml:math display="inline" id="I157"><mml:mrow><mml:msub><mml:mi>Y</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq157.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> correspond to the same underlying feature (<inline-formula id="ID62">
<alternatives><mml:math display="inline" id="I62"><mml:mrow><mml:msubsup><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq62.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>) and similarly if <inline-formula id="ID63">
<alternatives><mml:math display="inline" id="I63"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq63.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>, <inline-formula id="ID158">
<alternatives><mml:math display="inline" id="I158"><mml:mrow><mml:msub><mml:mi>Y</mml:mi><mml:mi>l</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq158.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> correspond to the same feature (<inline-formula id="ID64">
<alternatives><mml:math display="inline" id="I64"><mml:mrow><mml:msubsup><mml:mi>M</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq64.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>), then we expect that
<disp-formula id="FD18">
<alternatives>
<mml:math display="block" id="M18"><mml:mrow><mml:mtext>corr</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>≈</mml:mo><mml:mtext>corr</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>Y</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>l</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mtext> if </mml:mtext><mml:msubsup><mml:mi>Π</mml:mi><mml:mrow><mml:mtext>ij</mml:mtext></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:msubsup><mml:mi>Π</mml:mi><mml:mrow><mml:mtext>kl</mml:mtext></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mn>1.</mml:mn></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn18.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(18)</label>
</disp-formula>
</p>
<p>Here we define corr(<italic>u,v</italic>) to be the Pearson correlation coefficient between two feature intensity vectors <italic>u,v</italic> ∈ ℝ<sup><italic>n</italic></sup> by
<disp-formula id="FD19">
<alternatives>
<mml:math display="block" id="M19"><mml:mrow><mml:mtext>corr</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mi>u</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mi>v</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mo>〉</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mi>u</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:mi>v</mml:mi><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mi>v</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn19.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(19)</label>
</disp-formula>
</p>
<p>where we define
<disp-formula id="FD20">
<alternatives>
<mml:math display="block" id="M20"><mml:mrow><mml:mover accent="true"><mml:mi>u</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:mfrac></mml:mstyle><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:mrow><mml:mo>‖</mml:mo><mml:mi>u</mml:mi><mml:mo>‖</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:msubsup><mml:mi>u</mml:mi><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mstyle></mml:mrow></mml:msqrt><mml:mtext> </mml:mtext><mml:mrow><mml:mo>〈</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>〉</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn20.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(20)</label>
</disp-formula>
</p>
<p>as the mean value, Euclidean norm and inner product respectively. More generally, with <italic>d<sub>x</sub></italic> and <italic>d<sub>y</sub></italic> denoting two given distances on <inline-formula id="ID65">
<alternatives><mml:math display="inline" id="I65"><mml:mrow><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq65.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> and <inline-formula id="ID66">
<alternatives><mml:math display="inline" id="I66"><mml:mrow><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq66.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> respectively, we expect that
<disp-formula id="FD21">
<alternatives>
<mml:math display="block" id="M21"><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>≈</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>Y</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>l</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mtext> if </mml:mtext><mml:msubsup><mml:mi>Π</mml:mi><mml:mrow><mml:mtext>ij</mml:mtext></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:msubsup><mml:mi>Π</mml:mi><mml:mrow><mml:mtext>kl</mml:mtext></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mn>1.</mml:mn></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn21.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(21)</label>
</disp-formula>
</p>
<p>Throughout this paper, we use the normalized Euclidean distance defined for any <italic>u,v</italic> ∈ ℝ<sup><italic>n</italic></sup> as
<disp-formula id="FD22">
<alternatives>
<mml:math display="block" id="M22"><mml:mrow><mml:msup><mml:mi>d</mml:mi><mml:mrow><mml:mi>e</mml:mi><mml:mi>u</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mrow></mml:mfrac><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn22.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(22)</label>
</disp-formula>
</p>
<p>where for <italic>d<sub>x</sub></italic> and <italic>d<sub>y</sub></italic> we take <italic>n</italic> = <italic>n</italic><sub>1</sub>, <italic>n</italic><sub>2</sub> respectively. If the signal intensity vectors <italic>u,v</italic> are mean centered and normalized by their standard deviation as
<disp-formula id="FD23">
<alternatives>
<mml:math display="block" id="M23"><mml:mrow><mml:mi>u</mml:mi><mml:mo>↦</mml:mo><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt><mml:mo>⋅</mml:mo><mml:mfrac><mml:mrow><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:mfrac></mml:mstyle><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle></mml:mrow><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:mfrac></mml:mstyle><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn23.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(23)</label>
</disp-formula>
</p>
<p>and likewise for <italic>v</italic>, then it follows that
<disp-formula id="FD24">
<alternatives>
<mml:math display="block" id="M24"><mml:mrow><mml:msup><mml:mi>d</mml:mi><mml:mrow><mml:mtext>euc</mml:mtext></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:mn>2</mml:mn><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mtext>corr</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msqrt><mml:mo>=</mml:mo><mml:msqrt><mml:mn>2</mml:mn></mml:msqrt><mml:msup><mml:mi>d</mml:mi><mml:mrow><mml:mi>cos</mml:mi></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn24.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(24)</label>
</disp-formula>
</p>
<p>where we denote <inline-formula id="ID67">
<alternatives><mml:math display="inline" id="I67"><mml:mrow><mml:msup><mml:mi>d</mml:mi><mml:mrow><mml:mi>cos</mml:mi></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mtext>corr</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msqrt></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq67.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> as the cosine distance. For the purposes of this paper, we will always assume that <italic>d<sub>x</sub></italic> and <italic>d<sub>y</sub></italic> denote the normalized Euclidean distance from (22). As shown above, this will be implicitly equal to the cosine distance from (24) on centered and scaled data.</p>
<p>The goal of metabolomic feature matching is to learn the binary matching matrix <italic>M</italic>* that aligns the distances between pairs of features in the most consistent way possible as shown in (21). To formalize this notion into a practical algorithm, we use the mathematical theory of optimal transport <italic><bold>Peyré et al. (2019)</bold></italic> which we discuss next.</p>
</sec>
<sec id="s5b">
<title>Optimal transport</title>
<p>Optimal transport(OT) applies in the settingwhen the points <inline-formula id="ID68">
<alternatives><mml:math display="inline" id="I68"><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq68.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> and <inline-formula id="ID69">
<alternatives><mml:math display="inline" id="I69"><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mi>Y</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq69.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> being matched live in the same dimensional space <italic>n</italic><sub>1</sub> = <italic>n</italic><sub>2</sub> = <italic>n</italic>. It aims to find a matching between each point <italic>X<sub>i</sub></italic> and its corresponding point <italic>Y<sub>j</sub></italic> such that the sum of distances between matches is minimized. Matches between each pair of points can be stored in a matching matrix <inline-formula id="ID70">
<alternatives><mml:math display="inline" id="I70"><mml:mrow><mml:mi>M</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq70.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> such that <italic>M<sub>ij</sub></italic> = 1 if <italic>X<sub>i</sub></italic> and <italic>Y<sub>j</sub></italic> are matched, and <italic>M<sub>ij</sub></italic> = 0 otherwise. Again we note that <italic>M</italic> must have at most one nonzero entry in each row and column to be a valid matching matrix.</p>
<p>Instead of searching over this space of binary matching matrices, optimal transport places masses <italic>a<sub>i</sub></italic> ≥ 0 at all points <italic>X<sub>i</sub></italic> for <italic>i</italic> = 1,… ,<italic>p</italic><sub>1</sub> and masses <italic>b<sub>j</sub></italic> ≥ 0 at all points <italic>Y<sub>j</sub></italic> for <italic>j</italic> = 1,… ,<italic>p</italic><sub>2</sub> and optimizes over the space of probabilistic <italic>couplings</italic> <inline-formula id="ID71">
<alternatives><mml:math display="inline" id="I71"><mml:mrow><mml:mo>∏</mml:mo><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq71.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> which move a ∏<sub><italic>ij</italic></sub> amount of mass from <italic>X<sub>i</sub></italic> to <italic>Y<sub>j</sub></italic>. We assume here for simplicity that the sum of masses in both datasets are equal to one <inline-formula id="ID72">
<alternatives><mml:math display="inline" id="I72"><mml:mrow><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq72.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> and that the coupling n transports all mass from <italic>a</italic> into <italic>b</italic>. More formally, optimal transport optimizes over the constrained set of couplings
<disp-formula id="FD25">
<alternatives>
<mml:math display="block" id="M25"><mml:mrow><mml:mtext>U</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>:</mml:mo><mml:mi>Π</mml:mi><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>a</mml:mi><mml:mtext> and </mml:mtext><mml:msup><mml:mi>Π</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn25.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(25)</label>
</disp-formula>
</p>
<p>where <bold>1</bold><sub><italic>p</italic></sub> denotes the all ones vector of length <italic>p</italic>. In practice, the points <italic>X<sub>i</sub></italic> and <italic>Y<sub>j</sub></italic> in each dataset are all treated the same and the masses placed on the data are chosen to be uniform <inline-formula id="ID73">
<alternatives><mml:math display="inline" id="I73"><mml:mrow><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mfrac><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq73.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>, and <inline-formula id="ID74">
<alternatives><mml:math display="inline" id="I74"><mml:mrow><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mfrac><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq74.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>.</p>
<p>The cost function which optimal transport minimizes is the sum of squared distances of its transported mass
<disp-formula id="FD26">
<alternatives>
<mml:math display="block" id="M26"><mml:mrow><mml:mi>ε</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>Π</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn26.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(26)</label>
</disp-formula>
</p>
<p>where <inline-formula id="ID75">
<alternatives><mml:math display="inline" id="I75"><mml:mrow><mml:mi>d</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msup><mml:mi>d</mml:mi><mml:mrow><mml:mtext>euc</mml:mtext></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mrow></mml:mfrac><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq75.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> is the Euclidean distance. The distance matrix <italic>d</italic>(<italic>X<sub>i</sub>,Y<sub>j</sub></italic>) in the OT objective can be replaced more generally with a cost matrix <inline-formula id="ID76">
<alternatives><mml:math display="inline" id="I76"><mml:mrow><mml:mi>C</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq76.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> that is not necessarily a distance matrix. In this case the cost function becomes
<disp-formula id="FD27">
<alternatives>
<mml:math display="block" id="M27"><mml:mrow><mml:mi>ε</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>Π</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn27.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(27)</label>
</disp-formula>
</p>
<p>When the transport cost <italic>c<sub>ij</sub></italic> is a distance, the OT optimization defines a valid distance metric known as the <italic>optimal transport distance</italic> between discrete distributions <inline-formula id="ID77">
<alternatives><mml:math display="inline" id="I77"><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq77.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> and <inline-formula id="ID78">
<alternatives><mml:math display="inline" id="I78"><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq78.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> in ℝ<sup><italic>n</italic></sup> given by
<disp-formula id="FD28">
<alternatives>
<mml:math display="block" id="M28"><mml:mrow><mml:mi>O</mml:mi><mml:mi>T</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msubsup><mml:mo>=</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:mtext>U</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:msubsup><mml:mi>ε</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>Π</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn28.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(28)</label>
</disp-formula>
</p>
<p>When <italic>d</italic>(<italic>u, v</italic>) is Euclidean, this OT distance is also referred to as the <italic>L</italic><sup>1</sup> optimal transport distance, the Wasserstein 1-distance, or the Earth mover’s distance. As formulated, the computation of the optimal transport objective involves an optimization over coupling matrices n which can be solved by linear programming <italic><bold>Peyré et al. (2019)</bold></italic>. The OT optimization problem becomes time consuming for problems with many points <italic>p</italic><sub>1</sub> ,<italic>p</italic><sub>2</sub> ≫ 1. We show in the next section how augmenting this distance with a regularization term leads to a more efficient algorithm for learning the optimal coupling ∏.</p>
</sec>
<sec id="s5c">
<title>Entropic regularization</title>
<p>Define the Kullback-Leibler (KL) divergence between two positive vectors μ, <inline-formula id="ID79">
<alternatives><mml:math display="inline" id="I79"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mi>p</mml:mi></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq79.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> as
<disp-formula id="FD29">
<alternatives>
<mml:math display="block" id="M29"><mml:mrow><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>μ</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>p</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>μ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mtext> In</mml:mtext></mml:mrow></mml:mstyle><mml:mtext> </mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>μ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>p</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>μ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo></mml:mrow></mml:mstyle><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>p</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn29.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(29)</label>
</disp-formula>
</p>
<p>Given fixed marginals <inline-formula id="ID80">
<alternatives><mml:math display="inline" id="I80"><mml:mrow><mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq80.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> and <inline-formula id="ID81">
<alternatives><mml:math display="inline" id="I81"><mml:mrow><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq81.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> from the previous section, we can define the entropy of a coupling matrix <inline-formula id="ID82">
<alternatives><mml:math display="inline" id="I82"><mml:mrow><mml:mo>∏</mml:mo><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq82.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> with respect to these fixed marginals as
<disp-formula id="FD30">
<alternatives>
<mml:math display="block" id="M30"><mml:mrow><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mtext> In </mml:mtext></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle><mml:mtext> </mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mtext> +</mml:mtext><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle><mml:mtext> </mml:mtext></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle><mml:mo>.</mml:mo></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn30.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(30)</label>
</disp-formula>
</p>
<p>where (<italic>a</italic> ⊗ <italic>b</italic>)<sub><italic>ij</italic></sub> = <italic>a<sub>i</sub>b<sub>j</sub></italic> denotes the outer product. This can be further simplified as
<disp-formula id="FD31">
<alternatives>
<mml:math display="block" id="M31"><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mtext> In </mml:mtext></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle><mml:mtext> </mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mtext> +</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mtext> </mml:mtext></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mtext> In </mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mtext> </mml:mtext></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:mi>H</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>Π</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mtext>In</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mtext>In</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math>
<graphic xlink:href="2306.03218v2_eqn31.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(31)</label>
</disp-formula>
</p>
<p>where we define <italic>H</italic>(∏) by
<disp-formula id="FD32">
<alternatives>
<mml:math display="block" id="M32"><mml:mrow><mml:mi>H</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>Π</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mtext> In </mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mtext> </mml:mtext><mml:mo>.</mml:mo></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn32.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(32)</label>
</disp-formula>
</p>
<p>In the second line of the derivation above, we used the fact that the entries of <italic>a, b</italic>, and n summed to one, and in the third line we used the fact that the marginals <italic>a</italic> and <italic>b</italic> were uniform. Under these assumptions, we see that the KL divergence D<sub>KL</sub>(∏, <italic>a</italic> ⊗ <italic>b</italic>) is independent of the values of the marginals <italic>a, b</italic> and is equal to <italic>H</italic>(∏) up to constants.</p>
<p>Although here the general definition of entropy through the KL divergence reduces to the simpler formula of <italic>H</italic>(∏), in the following sections we will need to extend our analysis to cases when <italic>a, b</italic>, and ∏ have positive values that do not sum to one (i.e. not distributions). In this context, we will no longer have that D<sub>KL</sub>(∏, <italic>a</italic> ⊗ <italic>b</italic>) = <italic>H</italic> (∏) + <italic>const</italic> but we will still be able to use D<sub>KL</sub>(∏, <italic>a</italic> ⊗ <italic>b</italic>) as a general notion of entropy for ∏.</p>
<p>The entropy ofa coupling D<sub>KL</sub>(∏, <italic>a</italic> ⊗ <italic>b</italic>) is an important notion because it quantifies how uniform or smooth ∏ is with respect to the product distribution <italic>a</italic> ⊗ <italic>b</italic>. In particular, if <italic>a</italic> and <italic>b</italic> are set to uniform distributions as commonly done in practice, then D<sub>KL</sub>(∏, <italic>a</italic> ⊗ <italic>b</italic>) is small when n has close to uniform entries and is large otherwise. This notion of smoothness allows us to use D<sub>KL</sub>(∏, <italic>a</italic> ⊗ <italic>b</italic>) as a regularizer in our optimal transport distance as
<disp-formula id="FD33">
<alternatives>
<mml:math display="block" id="M33"><mml:mrow><mml:msub><mml:mi>L</mml:mi><mml:mi>ε</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>Π</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn33.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(33)</label>
</disp-formula>
</p>
<p>where <italic>ε</italic> is a small regularization parameter. Note that here we have denoted the transport cost matrix by <inline-formula id="ID83">
<alternatives><mml:math display="inline" id="I83"><mml:mrow><mml:mi>C</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq83.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> which is not necessarily a distance matrix. The introduction of the regularizer <italic>ε</italic>D<sub>KL</sub>(∏, <italic>a</italic> ⊗ <italic>b</italic>) gives us an efficient iterative algorithm known as the <italic>Sinkhorn algorithm</italic> for optimizing ∏ which we describe in the following sections.</p>
</sec>
<sec id="s5d">
<title>Unbalanced optimal transport</title>
<p>Before we introduce the Sinkhorn algorithm, we introduce a final modification to our optimal transport distance that allows us to learn couplings between distributions <italic>a</italic>, <inline-formula id="ID84">
<alternatives><mml:math display="inline" id="I84"><mml:mrow><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mi>p</mml:mi></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq84.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> that do not preserve mass. In other words, the coupling ∏ is not required to perfectly satisfy the marginal constraints <inline-formula id="ID85">
<alternatives><mml:math display="inline" id="I85"><mml:mrow><mml:mo>∏</mml:mo><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>a</mml:mi></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq85.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> and <inline-formula id="ID86">
<alternatives><mml:math display="inline" id="I86"><mml:mrow><mml:msup><mml:mo>∏</mml:mo><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq86.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>. In our metabolite matching problem, this is particularly useful as not all metabolites in one dataset necessarily appear in the other dataset and hence should be left unmatched. This modification of optimal transport, known as unbalanced optimal transport (UOT) <italic><bold>Chizat et al. (2018)</bold></italic>, optimizes the following cost function
<disp-formula id="FD34">
<alternatives>
<mml:math display="block" id="M34"><mml:mrow><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>Π</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>a</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>Π</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn34.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(34)</label>
</disp-formula>
</p>
<p>where we have added two KL terms with regularization parameter <italic>ρ</italic> to enforce that the marginals of the coupling <inline-formula id="ID87">
<alternatives><mml:math display="inline" id="I87"><mml:mrow><mml:mo>∏</mml:mo><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq87.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>, <inline-formula id="ID159">
<alternatives><mml:math display="inline" id="I159"><mml:mrow><mml:msup><mml:mo>∏</mml:mo><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq159.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> are approximately close to the prescribed marginals <italic>a,b</italic> respectively. We have also kept the smoothness/entropy regularizer <italic>ε</italic>D<sub>KL</sub>(∏, <italic>a</italic> ⊗ <italic>b</italic>) from the previous section.</p>
</sec>
<sec id="s5e">
<title>Unbalanced Sinkhorn algorithm</title>
<p>Now we are ready to present the unbalanced Sinkhorn algorithm <italic><bold>Peyré et al. (2019)</bold></italic> for optimizing the unbalanced optimal transport cost defined above. First we rewrite our optimization as
<disp-formula id="FD35">
<alternatives>
<mml:math display="block" id="M35"><mml:mtable><mml:mtr><mml:mtd><mml:msubsup><mml:mrow/><mml:mrow><mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>R</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:msubsup><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>Π</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:msubsup><mml:mo>=</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>R</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:msubsup><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>a</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>Π</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msubsup><mml:mo>=</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow/><mml:mrow><mml:msubsup><mml:mrow/><mml:mrow><mml:mi>Π</mml:mi><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:msup><mml:mi>Π</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:msubsup><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>a</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>Π</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math>
<graphic xlink:href="2306.03218v2_eqn35.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</disp-formula>
</p>
<p>The inner minimization can be solved exactly by introducing dual variables <inline-formula id="ID88">
<alternatives><mml:math display="inline" id="I88"><mml:mrow><mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq88.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>, <inline-formula id="ID160">
<alternatives><mml:math display="inline" id="I160"><mml:mrow><mml:mi>g</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq160.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> and writing out the Lagrange dual problem
<disp-formula id="FD36">
<alternatives>
<mml:math display="block" id="M36"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:msubsup><mml:mrow/><mml:mrow><mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>R</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:msubsup><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msup><mml:mi>f</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>u</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msup><mml:mi>g</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>Π</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msubsup><mml:msubsup><mml:mrow/><mml:mrow><mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mi>max</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:msub><mml:mrow/><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:msubsup><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msup><mml:mi>f</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>u</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msup><mml:mi>g</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>Π</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math>
<graphic xlink:href="2306.03218v2_eqn36.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</disp-formula>
</p>
<p>where we have removed the terms <italic>ρ</italic>D<sub>KL</sub>(<italic>u, a</italic>) and <italic>ρ</italic>D<sub>KL</sub>(<italic>v, b</italic>) since they do not depend on ∏. Taking the gradient in n in the inner minimization and setting it to zero we get
<disp-formula id="FD37">
<alternatives>
<mml:math display="block" id="M37"><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:mi>log</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn37.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</disp-formula>
</p>
<p>which implies that
<disp-formula id="FD38">
<alternatives>
<mml:math display="block" id="M38"><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mi>exp</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>ε</mml:mi></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn38.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</disp-formula>
</p>
<p>Now we can substitute this expression for n back into our Lagrange dual problem. First we compute
<disp-formula id="FD39">
<alternatives>
<mml:math display="block" id="M39"><mml:mrow><mml:mi>ε</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn39.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</disp-formula>
</p>
<p>which implies that
<disp-formula id="FD40">
<alternatives>
<mml:math display="block" id="M40"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo></mml:mrow></mml:mstyle><mml:msup><mml:mi>f</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>u</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msup><mml:mi>g</mml:mi><mml:mi>T</mml:mi></mml:msup></mml:mrow></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:msup><mml:mi>u</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>f</mml:mi><mml:mo>+</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>g</mml:mi><mml:mo>−</mml:mo><mml:mi>ε</mml:mi><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mi>exp</mml:mi></mml:mrow></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>ε</mml:mi></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math>
<graphic xlink:href="2306.03218v2_eqn40.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</disp-formula>
</p>
<p>Hence, the outer maximization in our Lagrange dual problem for <italic>f</italic> and <italic>g</italic> can now be written as
<disp-formula id="FD41">
<alternatives>
<mml:math display="block" id="M41"><mml:mrow><mml:msubsup><mml:mrow/><mml:mrow><mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mtext>       </mml:mtext><mml:mi>max</mml:mi></mml:mrow></mml:msubsup><mml:msup><mml:mi>u</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>f</mml:mi><mml:mo>+</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>g</mml:mi><mml:mo>−</mml:mo><mml:mi>ε</mml:mi><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mi>exp</mml:mi></mml:mrow></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>ε</mml:mi></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn41.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</disp-formula>
</p>
<p>where we have removed the last constantsum in <italic>a<sub>i</sub>b<sub>j</sub></italic>. Finallywe can rewrite our entire minimization from the start of this section as
<disp-formula id="FD42">
<alternatives>
<mml:math display="block" id="M42">
<mml:mtable><mml:mtr><mml:mtd><mml:msubsup><mml:mrow/><mml:mrow><mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>R</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:msubsup><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>Π</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:msubsup><mml:mo>=</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>R</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow/><mml:mrow><mml:msubsup><mml:mrow/><mml:mrow><mml:mi>Π</mml:mi><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:msup><mml:mi>Π</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mtext>    </mml:mtext><mml:mi>min</mml:mi></mml:mrow></mml:msubsup><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msubsup><mml:mo>=</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mtext>  </mml:mtext><mml:mi>min</mml:mi></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow/><mml:mrow><mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mtext>  </mml:mtext><mml:mi>max</mml:mi></mml:mrow></mml:msubsup><mml:msup><mml:mi>u</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>f</mml:mi><mml:mo>+</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>g</mml:mi><mml:mo>−</mml:mo><mml:mi>ε</mml:mi><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mi>exp</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>ε</mml:mi></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math>
<graphic xlink:href="2306.03218v2_eqn42.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</disp-formula>
</p>
<p>By strong duality, we can interchange the minimum and maximum above to write
<disp-formula id="FD43">
<alternatives>
<mml:math display="block" id="M43"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:msubsup><mml:mrow/><mml:mrow><mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>R</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:msubsup><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>Π</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:msubsup><mml:mo>=</mml:mo><mml:mrow><mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>R</mml:mi><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:msub><mml:mrow/><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mtext>  </mml:mtext><mml:mi>max</mml:mi></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow/><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mtext>  </mml:mtext><mml:mi>min</mml:mi></mml:mrow></mml:msubsup><mml:msup><mml:mi>u</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>f</mml:mi><mml:mo>+</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>g</mml:mi><mml:mo>−</mml:mo><mml:mi>ε</mml:mi><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mi>exp</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>ε</mml:mi></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo></mml:mrow></mml:mstyle><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:msup><mml:mi>U</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi>f</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:msup><mml:mi>V</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi>g</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>ε</mml:mi><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mi>exp</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>ε</mml:mi></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math>
<graphic xlink:href="2306.03218v2_eqn43.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</disp-formula>
</p>
<p>where we define the functions
<disp-formula id="FD44">
<alternatives>
<mml:math display="block" id="M44"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:msup><mml:mi>U</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi>f</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:msubsup><mml:mo>=</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mtext>  </mml:mtext><mml:mi>min</mml:mi></mml:mrow></mml:msubsup><mml:msup><mml:mi>u</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>f</mml:mi><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msup><mml:mi>V</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi>g</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:msubsup><mml:mo>=</mml:mo><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mtext>  </mml:mtext><mml:mi>min</mml:mi></mml:mrow></mml:msubsup><mml:msup><mml:mi>v</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>g</mml:mi><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math>
<graphic xlink:href="2306.03218v2_eqn44.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(35)</label>
</disp-formula>
</p>
<p>In fact, we can solve the minimizations in <italic>u</italic>* and <italic>V</italic>* in closed form to get the minimizes <italic>u</italic>* = <italic>a</italic> ⊙ exp(-<italic>f</italic>/<italic>p</italic>) and <italic>v</italic> * = <italic>b</italic> ⊙ exp(-<italic>g</italic>/<italic>p</italic>) which we can substitute back in to get
<disp-formula id="FD45">
<alternatives>
<mml:math display="block" id="M45">
<mml:mtable><mml:mtr><mml:mtd><mml:msup><mml:mi>U</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi>f</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msubsup><mml:mi>u</mml:mi><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msubsup><mml:mi>u</mml:mi><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mtext> In </mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msubsup><mml:mi>u</mml:mi><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup></mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo></mml:mrow></mml:mstyle><mml:mi>ρ</mml:mi><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msubsup><mml:mi>u</mml:mi><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mtext>+ </mml:mtext></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle><mml:mi>ρ</mml:mi><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mtext> </mml:mtext></mml:mrow></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msubsup><mml:mi>u</mml:mi><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msubsup><mml:mi>u</mml:mi><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mo>−</mml:mo><mml:mi>ρ</mml:mi><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mtext>exp</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>/</mml:mo><mml:mi>ρ</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mtext> </mml:mtext></mml:mrow></mml:mstyle><mml:mtext> </mml:mtext></mml:mrow></mml:mstyle><mml:mtext> </mml:mtext></mml:mrow></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mi>ρ</mml:mi><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mi>exp</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>/</mml:mo><mml:mi>ρ</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mtext> </mml:mtext></mml:mrow></mml:mstyle><mml:mtext> </mml:mtext></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math>
<graphic xlink:href="2306.03218v2_eqn45.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</disp-formula>
</p>
<p>Likewise we can see that
<disp-formula id="FD46">
<alternatives>
<mml:math display="block" id="M46"><mml:mrow><mml:msup><mml:mi>V</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi>f</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mi>ρ</mml:mi><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mtext>exp</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>/</mml:mo><mml:mi>ρ</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mtext> </mml:mtext><mml:mo>.</mml:mo></mml:mrow></mml:mstyle><mml:mtext> </mml:mtext></mml:mrow></mml:mstyle></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn46.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</disp-formula>
</p>
<p>Thus, we can rewrite our full optimization as
<disp-formula id="FD47">
<alternatives>
<mml:math display="block" id="M47">
<mml:mtable><mml:mtr><mml:mtd><mml:msubsup><mml:mrow/><mml:mrow><mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>R</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:msubsup><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>Π</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:msubsup><mml:mo>=</mml:mo><mml:mrow><mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>R</mml:mi><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:msub><mml:mrow/><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mtext>  </mml:mtext><mml:mi>max</mml:mi></mml:mrow></mml:msubsup><mml:mo>−</mml:mo><mml:mi>ρ</mml:mi><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mi>exp</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>/</mml:mo><mml:mi>ρ</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>ρ</mml:mi></mml:mrow></mml:mstyle><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mi>exp</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>/</mml:mo><mml:mi>ρ</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:mstyle><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mi>exp</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>ε</mml:mi></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msubsup><mml:mo>=</mml:mo><mml:mrow><mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>R</mml:mi><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:msub><mml:mrow/><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mtext>      </mml:mtext><mml:mi>max</mml:mi></mml:mrow></mml:msubsup><mml:mi>ρ</mml:mi><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mi>exp</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>/</mml:mo><mml:mi>ρ</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi></mml:mrow></mml:mstyle><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mi>exp</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>/</mml:mo><mml:mi>ρ</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:mstyle><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mi>exp</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>ε</mml:mi></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math>
<graphic xlink:href="2306.03218v2_eqn47.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</disp-formula>
</p>
<p>where we have removed the terms independent of <italic>f</italic> and <italic>g</italic>.</p>
<p>Note that now we can optimize the cost function above by performing an alternating minimization on the dual variables <italic>f</italic> and <italic>g</italic>. Taking the gradient in <italic>f</italic> and setting it to zero we see that
<disp-formula id="FD48">
<alternatives>
<mml:math display="block" id="M48"><mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mi>exp</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>/</mml:mo><mml:mi>ρ</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mi>exp</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>ε</mml:mi></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn48.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</disp-formula>
</p>
<p>which implies that
<disp-formula id="FD49">
<alternatives>
<mml:math display="block" id="M49"><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mi>ε</mml:mi><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mi>ε</mml:mi><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi></mml:mrow></mml:mfrac><mml:mtext> In </mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mi>exp</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>g</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>ε</mml:mi></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn49.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</disp-formula>
</p>
<p>Similarly, we can write out
<disp-formula id="FD50">
<alternatives>
<mml:math display="block" id="M50"><mml:mrow><mml:msub><mml:mi>g</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mi>ε</mml:mi><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mi>ε</mml:mi><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi></mml:mrow></mml:mfrac><mml:mtext> In </mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mi>exp</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>ε</mml:mi></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn50.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</disp-formula>
</p>
<p>We are now ready to write out the full unbalanced Sinkhorn algorithm which performs an alternating minimization on the dual potentials <italic>f, g</italic> as outlined above. We remind the reader that the coupling matrix can be recovered from the dual potentials by the formula
<disp-formula id="FD51">
<alternatives>
<mml:math display="block" id="M51"><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mtext> </mml:mtext><mml:mi>exp</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>ε</mml:mi></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn51.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</disp-formula>
</p>
<p>The unbalanced Sinkhorn algorithm proceeds as follows.</p>
<table-wrap id="tbl6" orientation="portrait" position="float">
<label>Algorithm 1:</label>
<caption><title>UnbalancedSinkhorn</title></caption>
<alternatives>
<graphic xlink:href="2306.03218v2_tbl6.tif" mimetype="image" mime-subtype="tiff"/>
<table frame="hsides" rules="groups">
<tbody>
<tr>
<td align="left" valign="top"><bold>input :</bold>Transport cost <italic>C</italic>, marginals <italic>a, b</italic>, marginal relaxation <italic>ρ</italic>, entropic regularization <italic>ε</italic></td>
</tr>
<tr>
<td align="left" valign="top"><bold>output:</bold>Return the coupling matrix ∏</td>
</tr>
<tr>
<td align="left" valign="top">Initialize <italic>g</italic> = 0
<break/><bold>while</bold> <underline>(<italic>f, g</italic>) has not converged</underline> <bold>do</bold>
<break/>  Set <inline-formula id="ID89">
<alternatives><mml:math display="inline" id="I89"><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>←</mml:mo><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mi>ε</mml:mi><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mi>ε</mml:mi><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi></mml:mrow></mml:mfrac><mml:mi>ln</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mi>exp</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>g</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>ε</mml:mi></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq89.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> for <italic>i</italic> ∈ [<italic>p</italic><sub>1</sub>]
<break/>  Set <inline-formula id="ID90">
<alternatives><mml:math display="inline" id="I90"><mml:mrow><mml:msub><mml:mi>g</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>←</mml:mo><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mi>ε</mml:mi><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mi>ε</mml:mi><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi></mml:mrow></mml:mfrac><mml:mi>ln</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mi>exp</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>ε</mml:mi></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq90.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> for <italic>j</italic> ∈ [<italic>p</italic><sub>2</sub>]</td>
</tr>
<tr>
<td align="left" valign="top">Return the coupling matrix <inline-formula id="ID91">
<alternatives><mml:math display="inline" id="I91"><mml:mrow><mml:msub><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mi>exp</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>ε</mml:mi></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq91.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> for <italic>i</italic> ∈ [<italic>p</italic><sub>1</sub>] and <italic>j</italic> ∈ [<italic>p</italic><sub>2</sub>]</td>
</tr>
</tbody>
</table>
</alternatives>
</table-wrap>
<p>The final output of the Sinkhorn algorithm optimization is a real-valued coupling matrix ∏ ∈ <inline-formula id="ID92">
<alternatives><mml:math display="inline" id="I92"><mml:mrow><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq92.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>. In some cases, it is desirable to transform the coupling matrix into a binary-valued matching matrix <inline-formula id="ID93">
<alternatives><mml:math display="inline" id="I93"><mml:mrow><mml:mi>M</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq93.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> with possibly an added restriction that there is at most one nonzero element in each row and column (to obtain a valid partial matching). This can be done by either thresholding the real matrix ∏ or by assigning all maximal entries in each row (or column) to one and setting the remaining entries to zero. For our metabolomics matching problem, we describe our procedure for transforming our real-valued coupling into a binary matching matrix in the section on the GromovMatcher algorithm below.</p>
</sec>
<sec id="s5f">
<title>Gromov-Wasserstein</title>
<p>Now that we have introduced the general formulation of unbalanced optimal transport and its corresponding Sinkhorn algorithm, we can extend this formulation to matching problems between distributions of points that live in different dimensional spaces. In our metabolomics setting, we aim to match two datasets of <italic>p</italic><sub>1</sub> and <italic>p</italic><sub>2</sub> metabolic features respectively where each feature in a dataset is associated with a feature intensity vector <inline-formula id="ID94">
<alternatives><mml:math display="inline" id="I94"><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>⊂</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq94.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> and <inline-formula id="ID161">
<alternatives><mml:math display="inline" id="I161"><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mi>Y</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>⊂</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq161.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> respectively across samples. We assume that there exists a true matching matrix <inline-formula id="ID95">
<alternatives><mml:math display="inline" id="I95"><mml:mrow><mml:mi>M</mml:mi><mml:mo>*</mml:mo><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq95.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> with at most one nonzero entry in each row and column such that two metabolites (<italic>i,j</italic>) are matched if <inline-formula id="ID96">
<alternatives><mml:math display="inline" id="I96"><mml:mrow><mml:msubsup><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq96.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>.</p>
<p>We make the further assumption that if feature vectors <italic>X<sub>i</sub>,Y<sub>j</sub></italic> are matched and feature vectors <italic>X<sub>k</sub>, Y<sub>j</sub></italic> are matched under <italic>M</italic>*, then we expect that
<disp-formula id="FD52">
<alternatives>
<mml:math display="block" id="M52"><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>≈</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>Y</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>l</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mtext> if </mml:mtext><mml:msubsup><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:msubsup><mml:mi>M</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mn>1.</mml:mn></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn52.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(36)</label>
</disp-formula>
</p>
<p>where <italic>d<sub>x</sub></italic> is a distance metric on <inline-formula id="ID97">
<alternatives><mml:math display="inline" id="I97"><mml:mrow><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq97.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> and <italic>d<sub>y</sub></italic> is a distance metric n <inline-formula id="ID98">
<alternatives><mml:math display="inline" id="I98"><mml:mrow><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq98.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>. In practice, we always choose these distance metrics to be the normalized Euclidean distance defined for any <italic>u,v</italic> ∈ ℝ<sup><italic>n</italic></sup> as
<disp-formula id="FD53">
<alternatives>
<mml:math display="block" id="M53"><mml:mrow><mml:msup><mml:mi>d</mml:mi><mml:mrow><mml:mi>e</mml:mi><mml:mi>u</mml:mi><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mrow></mml:mfrac><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn53.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(37)</label>
</disp-formula>
</p>
<p>which is equal to the cosine distance <italic>d</italic><sup>cos</sup> (i.e. one minus the correlation) for centered and scaled data. Given these two distance matrices <inline-formula id="ID99">
<alternatives><mml:math display="inline" id="I99"><mml:mrow><mml:msup><mml:mi>D</mml:mi><mml:mi>x</mml:mi></mml:msup><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq99.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> and <inline-formula id="ID100">
<alternatives><mml:math display="inline" id="I100"><mml:mrow><mml:msup><mml:mi>D</mml:mi><mml:mi>y</mml:mi></mml:msup><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>Y</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>l</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>∈</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq100.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> <inline-formula id="ID162">
<alternatives><mml:math display="inline" id="I162"><mml:mrow><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq162.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> we would like to infer the true matching matrix <italic>M</italic>* by solving an optimization problem.</p>
<p>Consider the following objective function
<disp-formula id="FD54">
<alternatives>
<mml:math display="block" id="M54"><mml:mrow><mml:mi>ε</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>M</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mi>D</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msubsup><mml:mo>−</mml:mo><mml:msubsup><mml:mi>D</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mi>l</mml:mi></mml:mrow><mml:mi>y</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:mstyle><mml:mo>.</mml:mo></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn54.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(38)</label>
</disp-formula>
</p>
<p>where the matching matrices <inline-formula id="ID101">
<alternatives><mml:math display="inline" id="I101"><mml:mrow><mml:mi>M</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq101.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> we optimize over are constrained to satisfy marginal constraints <inline-formula id="ID102">
<alternatives><mml:math display="inline" id="I102"><mml:mrow><mml:mo>∏</mml:mo><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq102.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> and <inline-formula id="ID103">
<alternatives><mml:math display="inline" id="I103"><mml:mrow><mml:msup><mml:mo>∏</mml:mo><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq103.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>. These marginal constraints simply impose that there is at least one nonzero entry in each row and column (i.e. each metabolite in both datasets has at least one corresponding match). Searching for the n minimizing <italic>ε<sub>X, Y</sub></italic> (∏) consists of putting the nonzero entries in ∏ such that the distance profiles of the matched features are similar, so that the minimizer of this criterion provides a good candidate estimate of ∏*. This is closely related to the Gromov-Hausdorff distance <italic><bold>Gromov (2001)</bold></italic>, an extension of optimal transport to the case where the sets to be coupled do not lie in the same metric space.</p>
<p>In practice, it is often desirable to optimize over a different set of matrices in order to make the optimization problem more tractable. Here we take intuition from optimal transport, and search over the set of coupling matrices with marginal constraints
<disp-formula id="FD55">
<alternatives>
<mml:math display="block" id="M55"><mml:mrow><mml:mi>U</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>:</mml:mo><mml:mi>Π</mml:mi><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>a</mml:mi><mml:mtext> and </mml:mtext><mml:msup><mml:mi>Π</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>}</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn55.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(39)</label>
</disp-formula>
</p>
<p>where as before, <inline-formula id="ID104">
<alternatives><mml:math display="inline" id="I104"><mml:mrow><mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq104.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> and <inline-formula id="ID105">
<alternatives><mml:math display="inline" id="I105"><mml:mrow><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq105.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> are desired marginals which are typically set to be uniform distributions <inline-formula id="ID106">
<alternatives><mml:math display="inline" id="I106"><mml:mrow><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mfrac><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq106.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> and <inline-formula id="ID107">
<alternatives><mml:math display="inline" id="I107"><mml:mrow><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mfrac><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq107.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>. These marginal vectors can be interpreted as distributions of masses <italic>a<sub>i</sub></italic> and <italic>b<sub>j</sub></italic> on the feature vectors <italic>X<sub>i</sub></italic> and <italic>Y<sub>j</sub></italic> respectively for <italic>i</italic> ∈ [<italic>p</italic><sub>1</sub>], <italic>j</italic> ∈ [<italic>p</italic><sub>2</sub>].</p>
<p>Coupling matrices in <bold>U</bold>(<italic>a,b</italic>) transport the distribution of masses <italic>a</italic> in the first dataset to the distribution of masses <italic>b</italic> in the second dataset. Now we can formulate the Gromov-Wasserstein (GW) distance, introduced by Memoli <italic><bold>Memoli (2011)</bold></italic>, as
<disp-formula id="FD56">
<alternatives>
<mml:math display="block" id="M56"><mml:mrow><mml:mtext>GW</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msubsup><mml:mo>=</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:mi>U</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mtext>     </mml:mtext><mml:mi>min</mml:mi></mml:mrow></mml:msubsup><mml:mi>ε</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>Π</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn56.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(40)</label>
</disp-formula>
</p>
<p>By optimizing this objective, each entry ∏<sub><italic>ij</italic></sub> now reflects the strength of the matched pair (<italic>X<sub>i</sub>, Y<sub>j</sub></italic>). Optimizing GW(<italic>a, b</italic>) then amounts to placing larger entries in n whose paired features have similar distance profiles. Before we develop an algorithm to optimize this objective, we first modify it to allow for unbalanced matchings where marginal constraints are not enforced exactly (e.g. features in both datasets can remain unmatched).</p>
</sec>
<sec id="s5g">
<title>Unbalanced Gromov-Wasserstein</title>
<p>In an untargeted context, all features measured in one study are not necessarily observed in another, either because these features are truly not shared or because of measurement error. However, the constraint ∏ ∈ <bold>U</bold>(<italic>a, b</italic>) in the original GW optimization criterion (40) ensures that all the mass is transported from one set to another, resulting in all features being matched across studies. In order to discard study-specific features during the GW computation, we use the unbalanced Gromov-Wasserstein (UGW) distance with an additional entropic regularization for computational purposes, described in Séjourné et al. <italic><bold>Sejourne et al. (2021)</bold></italic>. The optimization problem therefore reads
<disp-formula id="FD57">
<alternatives>
<mml:math display="block" id="M57">
<mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>Π</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>ε</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>Π</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>⊗</mml:mo><mml:mi>Π</mml:mi><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>a</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>Π</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>⊗</mml:mo><mml:msup><mml:mi>Π</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:mo>⊗</mml:mo><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>⊗</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math>
<graphic xlink:href="2306.03218v2_eqn57.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(41)</label>
</disp-formula>
<disp-formula id="FD58">
<alternatives>
<mml:math display="block" id="M58"><mml:mrow><mml:msub><mml:mrow><mml:mtext>UGW</mml:mtext></mml:mrow><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mo>=</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:msubsup><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>Π</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn58.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(42)</label>
</disp-formula>
</p>
<p>with <italic>ρ, ε</italic> &gt; 0. Here <italic>D</italic><sub>KL</sub> is the Kullback-Leibler divergence defined in the previous sections and we define the tensor product (<italic>p</italic> ⊗ <italic>p</italic>)<sub><italic>i,j,k,l</italic></sub> = <italic>P<sub>i,j</sub>P<sub>k,i</sub></italic>. Here we set the desired marginal constraints to <inline-formula id="ID108">
<alternatives><mml:math display="inline" id="I108"><mml:mrow><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mfrac><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq108.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> and <inline-formula id="ID109">
<alternatives><mml:math display="inline" id="I109"><mml:mrow><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mfrac><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq109.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> as before.</p>
<p>As in the case of unbalanced optimal transport <italic><bold>Chizat et al. (2018)</bold></italic>, the regularization <italic>ρ</italic> times the Kullback-Leibler divergences allows for the relaxation of the marginal constraints <inline-formula id="ID110">
<alternatives><mml:math display="inline" id="I110"><mml:mrow><mml:mo>∏</mml:mo><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>a</mml:mi></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq110.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> and <inline-formula id="ID111">
<alternatives><mml:math display="inline" id="I111"><mml:mrow><mml:msup><mml:mo>∏</mml:mo><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq111.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>. The value of <italic>ρ</italic> &gt; 0 controls the extent to which we allow for mass destruction. Smaller values of <italic>ρ</italic> tend to lessen the constraint on the marginals of ∏, while balanced GW is recovered when <italic>ρ</italic> → +∞. As proposed in the original paper <italic><bold>Sejourne et al. (2021)</bold></italic>, our UGW cost modifies the UOT formulation by using the quadratic Kullback-Leibler divergence in <inline-formula id="ID112">
<alternatives><mml:math display="inline" id="I112"><mml:mrow><mml:mo>∏</mml:mo><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>⊗</mml:mo><mml:mo>∏</mml:mo><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq112.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> and <inline-formula id="ID113">
<alternatives><mml:math display="inline" id="I113"><mml:mrow><mml:msup><mml:mo>∏</mml:mo><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>⊗</mml:mo><mml:msup><mml:mo>∏</mml:mo><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq113.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> instead, hence preserving the quadratic form of the GW cost function <italic>ε</italic>(∏).</p>
<p>The term <italic>εD<sub>KL</sub></italic> (∏ ⊗ ∏, (<italic>a</italic> ⊗ <italic>b</italic>)<sup>⊗2</sup>) serves as an entropic regularization, inspired again by optimal transport. Adding such a penalty is a standard way to compute an approximate solution to the optimal transport problem using the Sinkhorn algorithm as we shall show in the following section. Here again, we modify the entropic penalty in UGW to have a quadratic form in ∏ ⊗ ∏ to agree with the quadratic form of the GW cost <italic>ε</italic>(∏). The parameter <italic>ε</italic> controls the smoothness (entropy) of the coupling matrix ∏ where larger values of <italic>ε</italic> encourage n to put uniform weights on many of its entries, leading to less precision in the feature matches. However, increasing <italic>ε</italic> also leads to better numerical stability and a significant speedup of the alternating Sinkhorn algorithm used to optimize the objective function described below.</p>
</sec>
<sec id="s5h">
<title>UGW optimization algorithm</title>
<p>Now we are ready to write out an algorithm to optimize the UGW objective in (42). First write our objective as
<disp-formula id="FD59">
<alternatives>
<mml:math display="block" id="M59">
<mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>Π</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>I</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>Π</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mi>D</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msubsup><mml:mo>−</mml:mo><mml:msubsup><mml:mi>D</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mi>I</mml:mi></mml:mrow><mml:mi>y</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:mstyle><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>⊗</mml:mo><mml:mi>Π</mml:mi><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>a</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>Π</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>⊗</mml:mo><mml:msup><mml:mi>Π</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:mo>⊗</mml:mo><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>a</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>⊗</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math>
<graphic xlink:href="2306.03218v2_eqn59.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(43)</label>
</disp-formula>
</p>
<p>Using the quadratic nature of our cost function, we aim to perform an alternating minimization in the two copies of ∏. For the moment, let’s differentiate these two copies by n and r and write the new cost
<disp-formula id="FD60">
<alternatives>
<mml:math display="block" id="M60">
<mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mi>F</mml:mi><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:mi>Γ</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>I</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>Π</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mi>D</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msubsup><mml:mo>−</mml:mo><mml:msubsup><mml:mi>D</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mi>I</mml:mi></mml:mrow><mml:mi>y</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:mstyle><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>⊗</mml:mo><mml:mi>Γ</mml:mi><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>a</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>Π</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>⊗</mml:mo><mml:msup><mml:mi>Γ</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:mo>⊗</mml:mo><mml:mi>Γ</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>⊗</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math>
<graphic xlink:href="2306.03218v2_eqn60.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(44)</label>
</disp-formula>
</p>
<p>Before we expand this cost, we introduce the notation <italic>m</italic>(<italic>π</italic>) to denote the sum of the elements of <italic>π</italic> which can be a vector, matrix or tensor. In general, for four positive distributions <italic>π</italic>, <inline-formula id="ID114">
<alternatives><mml:math display="inline" id="I114"><mml:mrow><mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mi>p</mml:mi></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq114.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> and <italic>γ</italic>, <inline-formula id="ID115">
<alternatives><mml:math display="inline" id="I115"><mml:mrow><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mi>q</mml:mi></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq115.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> we have that the KL satisfies the tensorization property
<disp-formula id="FD61">
<alternatives>
<mml:math display="block" id="M61"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>π</mml:mi><mml:mo>⊗</mml:mo><mml:mi>γ</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>p</mml:mi></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>q</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>π</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>γ</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mtext> </mml:mtext><mml:mi>I</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle><mml:mtext> </mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>π</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>γ</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>p</mml:mi></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>q</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>π</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>γ</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mtext> </mml:mtext><mml:mo>+</mml:mo></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>p</mml:mi></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>q</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>γ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>p</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>π</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mtext> In </mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>π</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>π</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>q</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>γ</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mtext> In </mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>γ</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>π</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>γ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>a</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>b</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>γ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>π</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>γ</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>π</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>a</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>γ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>b</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math>
<graphic xlink:href="2306.03218v2_eqn61.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(45)</label>
</disp-formula>
</p>
<p>Specifically, if we remove those terms that do not depend on <italic>γ</italic> we are left with
<disp-formula id="FD62">
<alternatives>
<mml:math display="block" id="M62"><mml:mrow><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>π</mml:mi><mml:mo>⊗</mml:mo><mml:mi>γ</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>π</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>γ</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>γ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>p</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>π</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mtext> In </mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>π</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mo>.</mml:mo></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn62.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(46)</label>
</disp-formula>
</p>
<p>This allows us to write for the marginal constraints <inline-formula id="ID116">
<alternatives><mml:math display="inline" id="I116"><mml:mrow><mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq116.tif" mimetype="image" mime-subtype="tiff"/></alternatives></inline-formula>, <inline-formula id="ID163">
<alternatives><mml:math display="inline" id="I163"><mml:mrow><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq163.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> and couplings ∏, <inline-formula id="ID117">
<alternatives><mml:math display="inline" id="I117"><mml:mrow><mml:mi>Γ</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq117.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> that
<disp-formula id="FD63">
<alternatives>
<mml:math display="block" id="M63"><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>⊗</mml:mo><mml:mi>Γ</mml:mi><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>a</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>Π</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Γ</mml:mi><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>a</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>Γ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mi>ln</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2306.03218v2_eqn63.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</disp-formula>
<disp-formula id="FD64">
<alternatives>
<mml:math display="block" id="M64"><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>Π</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>⊗</mml:mo><mml:msup><mml:mi>Γ</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>Π</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>Γ</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>Γ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>Π</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mi>ln</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>Π</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2306.03218v2_eqn64.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</disp-formula>
<disp-formula id="FD65">
<alternatives>
<mml:math display="block" id="M65"><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:mo>⊗</mml:mo><mml:mi>Γ</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>⊗</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>Π</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Γ</mml:mi><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>a</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>Γ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mi>ln</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2306.03218v2_eqn65.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</disp-formula>
</p>
<p>where in the expansions above we have removed all terms that are independent of Γ. Finally, expanding out <italic>F<sub>ρ,α</sub></italic>(∏, Γ) and keeping only those terms that depend on Γ we get
<disp-formula id="FD66">
<alternatives>
<mml:math display="block" id="M66"><mml:msub><mml:mi>F</mml:mi><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:mo>,</mml:mo><mml:mi>Γ</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>Γ</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mi>C</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow><mml:mi>Π</mml:mi></mml:msubsup><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>Π</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Γ</mml:mi><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>a</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle><mml:mi>ρ</mml:mi><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>Π</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>Γ</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>Π</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Γ</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn66.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(47)</label>
</disp-formula>
</p>
<p>where the cost matrix <inline-formula id="ID118">
<alternatives><mml:math display="inline" id="I118"><mml:mrow><mml:msup><mml:mi>C</mml:mi><mml:mo>∏</mml:mo></mml:msup><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq118.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> is defined as
<disp-formula id="FD67">
<alternatives>
<mml:math display="block" id="M67"><mml:msubsup><mml:mi>C</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow><mml:mi>Π</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mi>D</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msubsup><mml:mo>−</mml:mo><mml:msubsup><mml:mi>D</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mi>l</mml:mi></mml:mrow><mml:mi>y</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mi>ln</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Π</mml:mi><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>Π</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mi>ln</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>Π</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mi>ln</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2306.03218v2_eqn67.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(48)</label>
</disp-formula>
</p>
<p>where we have hidden the dependence of <italic>c</italic><sup>∏</sup> on the distance matrices <italic>D<sup>x</sup>,D<sup>y</sup></italic>, the marginals <italic>a, b</italic>, and the regularization parameters <italic>ρ, ε</italic> for ease of notation.</p>
<p>Remarkably, the cost above in Γ for fixed ∏ is in the form of an unbalanced optimal transport problem which can be solved through unbalanced Sinkhorn iterations (<xref ref-type="table" rid="tbl6">Algorithm 1</xref>). Note that in our derivation above, it did not matter whether we optimized Γ with ∏ fixed or vice versa because the cost <italic>F<sub>ρ,ε</sub></italic>(∏, Γ) is symmetric in both of its arguments.</p>
<p>Our iterative algorithm for solving the unbalanced GW problem will proceed at each iteration by optimizing Γ to minimizethecostaboveusingthe unbalanced Sinkhorn method, setting ∏ equal to Γ and repeating. With each iteration, we expect this iterative procedure to make smaller and smaller updates to Γ until convergence. By definition, at the end of each iteration we assign ∏ = Γ so the minimizer of <italic>F<sub>ρ,ε</sub></italic>(∏, Γ) we converge to should also be a minimizer of the original UGW cost <italic>L<sub>ρ,ε</sub></italic>(∏) in the sense that the relaxation of <italic>L<sub>ρ,ε</sub></italic>(∏) to <italic>F<sub>ρ,ε</sub></italic>(∏, Γ) is tight. This is proven rigorously under strict mathematical assumptions in <italic><bold>Sejourne et al. (2021)</bold></italic>. We state the full UGW optimization algorithm below.</p>
<table-wrap id="tbl7" orientation="portrait" position="float">
<label>Algorithm 2:</label>
<caption><title>UnbalancedGromovWasserstein</title></caption>
<alternatives>
<graphic xlink:href="2306.03218v2_tbl7.tif" mimetype="image" mime-subtype="tiff"/>
<table frame="hsides" rules="groups">
<tbody>
<tr>
<td align="left" valign="top"><bold>input :</bold> Distance matrices <italic>D<sup>x</sup>, D<sup>y</sup></italic>, marginals <italic>a, b</italic>, marginal relaxation <italic>ρ</italic>, entropic regularization <italic>ε</italic></td>
</tr>
<tr>
<td align="left" valign="top"><bold>output:</bold>Return the coupling matrix ∏</td>
</tr>
<tr>
<td align="left" valign="top">Initialize <inline-formula id="ID119">
<alternatives><mml:math display="inline" id="I119"><mml:mrow><mml:mo>∏</mml:mo><mml:mo>=</mml:mo><mml:mi>Γ</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mrow><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>/</mml:mo><mml:mrow><mml:msqrt><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>a</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>b</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msqrt></mml:mrow></mml:mrow></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq119.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>
<break/><bold>while</bold> <underline>(∏, Γ) has not converged</underline> <bold>do</bold>
<break/>  Update ∏ ← Γ
<break/>  Update Γ = UnbalancedSinkhorn(<italic>c</italic><sup>∏</sup>, <italic>a, b, ρm</italic>(∏), <italic>εm</italic>(∏))
<break/>  Rescale <inline-formula id="ID120">
<alternatives><mml:math display="inline" id="I120"><mml:mrow><mml:mi>Γ</mml:mi><mml:mo>←</mml:mo><mml:msqrt><mml:mrow><mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mo>∏</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>/</mml:mo><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>Γ</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:msqrt><mml:mi>Γ</mml:mi></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq120.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>
<break/>Update ∏ ← Γ
<break/>Return ∏.</td>
</tr>
</tbody>
</table>
</alternatives>
</table-wrap>
<p>Following the implementation of the UGW algorithm in <italic><bold>Sejourne et al. (2021)</bold></italic>, we initialize both ∏ and Γ to be the product distribution of the marginals <inline-formula id="ID121">
<alternatives><mml:math display="inline" id="I121"><mml:mrow><mml:mrow><mml:mrow><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>/</mml:mo><mml:mrow><mml:msqrt><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>a</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>b</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msqrt></mml:mrow></mml:mrow></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq121.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> before we begin the optimization. Also, we note that if (∏, Γ) is a minimizer of our UGW objective <italic>F<sub>ρ, ε</sub></italic>(∏,Γ), then so is (<inline-formula id="ID122">
<alternatives><mml:math display="inline" id="I122"><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mi>s</mml:mi></mml:mfrac><mml:mo>∏</mml:mo><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mi>Γ</mml:mi></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq122.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>) for any scale factor <italic>s</italic> &gt; 0. Hence, we can set <inline-formula id="ID123">
<alternatives><mml:math display="inline" id="I123"><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mi>s</mml:mi></mml:mfrac><mml:mo>∏</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>s</mml:mi><mml:mi>Γ</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq123.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> by choosing <inline-formula id="ID124">
<alternatives><mml:math display="inline" id="I124"><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mo>∏</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>/</mml:mo><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>Γ</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:msqrt></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq124.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>. This motivates the final step in the while loop of the UGW algorithm where the rescaling of Γ by the factor <inline-formula id="ID125">
<alternatives><mml:math display="inline" id="I125"><mml:mrow><mml:msqrt><mml:mrow><mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mo>∏</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>/</mml:mo><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>Γ</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:msqrt></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq125.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> leads to mass equality <italic>m</italic>(∏) = <italic>m</italic>(Γ) and also stabilizes the convergence of the algorithm.</p>
<p>Returning to our metabolomics matching problem, we further guide our UGW optimization procedure by discouraging it from matching metabolic feature pairs whose mass-to-charge ratios are incompatible. Namely, we choose a value <italic>m</italic><sub>gap</sub> such that for all pairs (<italic>i,j</italic>) with <italic>i</italic> ∈ [<italic>p</italic><sub>1</sub>],<italic>j</italic> ∈ [<italic>p</italic><sub>2</sub>] and mass-to-charge ratios <inline-formula id="ID126">
<alternatives><mml:math display="inline" id="I126"><mml:mrow><mml:msubsup><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>x</mml:mi></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq126.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>, <inline-formula id="ID164">
<alternatives><mml:math display="inline" id="I164"><mml:mrow>
<mml:msubsup><mml:mi>m</mml:mi><mml:mi>j</mml:mi><mml:mi>y</mml:mi></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq164.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> we enforce that
<disp-formula id="FD68">
<alternatives>
<mml:math display="block" id="M68"><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>x</mml:mi></mml:msubsup><mml:mo>−</mml:mo><mml:msubsup><mml:mi>m</mml:mi><mml:mi>j</mml:mi><mml:mi>y</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mo>&gt;</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mrow><mml:mi>g</mml:mi><mml:mi>a</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo>⇒</mml:mo><mml:msub><mml:mi>Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0.</mml:mn></mml:math>
<graphic xlink:href="2306.03218v2_eqn68.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(49)</label>
</disp-formula>
</p>
<p>In practice, this is done by taking the optimal transport cost <italic>C</italic><sup>∏</sup> in every iteration of the UGW algorithm and premultiplying it elementwise by a factor <inline-formula id="ID127">
<alternatives><mml:math display="inline" id="I127"><mml:mrow><mml:mi>W</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq127.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> given by
<disp-formula id="FD69">
<alternatives>
<mml:math display="block" id="M69"><mml:msup><mml:mi>C</mml:mi><mml:mi>Π</mml:mi></mml:msup><mml:mo>→</mml:mo><mml:mi>W</mml:mi><mml:mo>⊙</mml:mo><mml:msup><mml:mi>C</mml:mi><mml:mi>Π</mml:mi></mml:msup><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:msub><mml:mi>W</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>99</mml:mn><mml:mo>⋅</mml:mo><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>x</mml:mi></mml:msubsup><mml:mo>−</mml:mo><mml:msubsup><mml:mi>m</mml:mi><mml:mi>j</mml:mi><mml:mi>y</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mo>&gt;</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mrow><mml:mi>g</mml:mi><mml:mi>a</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:math>
<graphic xlink:href="2306.03218v2_eqn69.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(50)</label>
</disp-formula>
</p>
<p>where <bold>1</bold><sub>χ</sub> denotes the indicator function that is one when the condition χ is satisfied and zero otherwise. Such a prefactor changes the transport cost to be very large for feature matches with incompatible mass-to-charge ratio times, and hence, the entries of ∏ set small weights at these entries. Our weighted UGW algorithm is rewritten below.</p>
<table-wrap id="tbl8" orientation="portrait" position="float">
<label>Algorithm 3:</label>
<caption><title>WeightedUnbalancedGromovWasserstein</title></caption>
<alternatives>
<graphic xlink:href="2306.03218v2_tbl8.tif" mimetype="image" mime-subtype="tiff"/>
<table frame="hsides" rules="groups">
<tbody>
<tr>
<td align="left" valign="top"><bold>input :</bold> Distance matrices <italic>D<sup>x</sup>, D<sup>y</sup></italic>, marginals <italic>a, b</italic>, marginal relaxation <italic>ρ</italic>, entropic regularization <italic>ε</italic>, mass-to-charge ratios <italic>m<sup>x</sup>,m<sup>j</sup></italic>, mass-to-charge ratio gap <italic>m</italic>gap</td>
</tr>
<tr>
<td align="left" valign="top"><bold>output:</bold> Return the coupling matrix ∏</td>
</tr>
<tr>
<td align="left" valign="top">Initialize <inline-formula id="ID128">
<alternatives><mml:math display="inline" id="I128"><mml:mrow><mml:mo>∏</mml:mo><mml:mo>=</mml:mo><mml:mi>Γ</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mrow><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>/</mml:mo><mml:mrow><mml:msqrt><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>a</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>b</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msqrt></mml:mrow></mml:mrow></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq128.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>
<break/>Set <inline-formula id="ID129">
<alternatives><mml:math display="inline" id="I129"><mml:mrow><mml:msub><mml:mi>W</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mn>99.1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>x</mml:mi></mml:msubsup><mml:mo>−</mml:mo><mml:msubsup><mml:mi>m</mml:mi><mml:mi>j</mml:mi><mml:mi>y</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mo>&gt;</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mrow><mml:mi>g</mml:mi><mml:mi>a</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq129.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> for <italic>i</italic> ∈ [<italic>p</italic><sub>1</sub>] and <italic>j</italic> ∈ [<italic>p</italic><sub>2</sub>]
<break/><bold>while</bold> (∏, Γ) has not converged <bold>do</bold>
<break/>  Update ∏ ← Γ
<break/>  Update Γ = UnbalancedSinkhorn(<italic>W</italic> ⊙ <italic>C</italic><sup>∏</sup>, <italic>a, b, ρm</italic>(∏), <italic>εm</italic>(∏))
<break/>  Rescale <inline-formula id="ID130">
<alternatives><mml:math display="inline" id="I130"><mml:mrow><mml:mi>Γ</mml:mi><mml:mo>←</mml:mo><mml:msqrt><mml:mrow><mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mo>∏</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>/</mml:mo><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>Γ</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:msqrt><mml:mi>Γ</mml:mi></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq130.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>
<break/>Update ∏ ← Γ
<break/>Return ∏.</td>
</tr>
</tbody>
</table>
</alternatives>
</table-wrap>
<p>As mentioned before, the coupling matrix returned by our weighted UGW algorithm is a realvalued matrix rather than a binary matching matrix. In the next section, we describe how we incorporate metabolite retention time information to filter out unlikely pairs in our coupling matrix and transform it into a valid one-to-one matching of features across two datasets.</p>
</sec>
<sec id="s5i">
<title>Retention time drift estimation and filtering</title>
<p>To filter out unlikely matches from the coupling matrix returned by <xref ref-type="table" rid="tbl8">Algorithm 3</xref> above, we use the retention times (RTs) of the metabolites in both datasets. We remind the reader that RTs were not incorporated into the weighted UGW algorithm since they often exhibit a non-linear deviation between datasets, and hence are not directly comparable. However, using the metabolite coupling <inline-formula id="ID131">
<alternatives><mml:math display="inline" id="I131"><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">˜</mml:mo></mml:mover><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq131.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> obtained from <xref ref-type="table" rid="tbl8">Algorithm 3</xref>, it is possible to estimate this RT drift. The estimated RT drift <inline-formula id="ID132">
<alternatives><mml:math display="inline" id="I132"><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo stretchy="true">^</mml:mo></mml:mover><mml:mo>:</mml:mo><mml:msub><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo></mml:msub><mml:mo>→</mml:mo><mml:msub><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo></mml:msub></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq132.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> allows us to assess the plausibility of the pairs recovered by the restricted UGW coupling <inline-formula id="ID133">
<alternatives><mml:math display="inline" id="I133"><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">˜</mml:mo></mml:mover></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq133.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>, and discard pairs incompatible with the estimated drift.</p>
<p>We propose to learn the drift <inline-formula id="ID134">
<alternatives><mml:math display="inline" id="I134"><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq134.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> through the weighted spline regression
<disp-formula id="FD70">
<alternatives>
<mml:math display="block" id="M70"><mml:munder><mml:mrow><mml:mi>min</mml:mi></mml:mrow><mml:mrow><mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>B</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:munder><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>π</mml:mi><mml:mo stretchy="true">˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>R</mml:mi><mml:msubsup><mml:mi>T</mml:mi><mml:mi>i</mml:mi><mml:mi>x</mml:mi></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>R</mml:mi><mml:msubsup><mml:mi>T</mml:mi><mml:mi>j</mml:mi><mml:mi>y</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle></mml:math>
<graphic xlink:href="2306.03218v2_eqn70.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(51)</label>
</disp-formula>
</p>
<p>where <italic>B<sub>n,k</sub></italic> is the set of <italic>n</italic>-order B-splines with <italic>k</italic> knots. All pairs (<inline-formula id="ID135">
<alternatives><mml:math display="inline" id="I135"><mml:mrow><mml:mi>R</mml:mi><mml:msubsup><mml:mi>T</mml:mi><mml:mi>i</mml:mi><mml:mi>x</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mi>R</mml:mi><mml:msubsup><mml:mi>T</mml:mi><mml:mi>j</mml:mi><mml:mi>y</mml:mi></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq135.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>) in objective (51) are weighted by the coefficients of <inline-formula id="ID136">
<alternatives><mml:math display="inline" id="I136"><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">˜</mml:mo></mml:mover></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq136.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> so that larger weights are given to pairs identified with high confidence in the first step of our procedure.</p>
<p>Pairs identified as incompatible with the estimated RT drift are then discarded from the coupling matrix. To do this, we first take the estimated RT drift <inline-formula id="ID137">
<alternatives><mml:math display="inline" id="I137"><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq137.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>, and the set of pairs <inline-formula id="ID138">
<alternatives><mml:math display="inline" id="I138"><mml:mrow><mml:mi>S</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>≠</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq138.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> recovered in <inline-formula id="ID139">
<alternatives><mml:math display="inline" id="I139"><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">˜</mml:mo></mml:mover></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq139.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> with nonzero entries. We then define the residual associated with (<italic>i,j</italic>) ∈ <italic>S</italic> as
<disp-formula id="FD71">
<alternatives>
<mml:math display="block" id="M71"><mml:msub><mml:mi>r</mml:mi><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>R</mml:mi><mml:msubsup><mml:mi>T</mml:mi><mml:mi>i</mml:mi><mml:mi>x</mml:mi></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>R</mml:mi><mml:msubsup><mml:mi>T</mml:mi><mml:mi>j</mml:mi><mml:mi>y</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2306.03218v2_eqn71.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(52)</label>
</disp-formula>
</p>
<p>The 95% prediction interval and the median absolute deviation (MAD) of these residuals are given by
<disp-formula id="FD72">
<alternatives>
<mml:math display="block" id="M72"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mtext>PI</mml:mtext><mml:mo>=</mml:mo><mml:mn>1.96</mml:mn><mml:mo>×</mml:mo><mml:mtext>std</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtext>MAD</mml:mtext><mml:mo>=</mml:mo><mml:mtext>median</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>μ</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mi>μ</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mtext>median</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math>
<graphic xlink:href="2306.03218v2_eqn72.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(53)</label>
</disp-formula>
</p>
<p>where |<italic>S</italic>| is the size ofS and the functions std, median denote the standard deviation and median respectively. Following <italic><bold>Habra et al. (2021)</bold></italic>, we then create a new filtered coupling matrix <inline-formula id="ID140">
<alternatives><mml:math display="inline" id="I140"><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">^</mml:mo></mml:mover><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq140.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> given by
<disp-formula id="FD73">
<alternatives>
<mml:math display="block" id="M73"><mml:msub><mml:mover accent="true"><mml:mi>Π</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mover accent="true"><mml:mi>Π</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mtd><mml:mtd><mml:mrow><mml:mi>i</mml:mi><mml:mi>f</mml:mi><mml:mtext> </mml:mtext><mml:msub><mml:mi>r</mml:mi><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>&lt;</mml:mo><mml:msub><mml:mi>μ</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mtext>thresh</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mrow><mml:mtext>otherwise</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable><mml:mo>.</mml:mo></mml:mrow></mml:mrow></mml:math>
<graphic xlink:href="2306.03218v2_eqn73.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
<label>(54)</label>
</disp-formula>
</p>
<p>where <italic>r</italic><sub>thresh</sub> is a given filtering threshold. The procedure of estimating the drift function <inline-formula id="ID141">
<alternatives><mml:math display="inline" id="I141"><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq141.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> in (51) and filtering the coupling can be repeated for multiple iterations, to improve the drift and coupling estimation. In our main algorithm, we use two preliminary iterations where we estimate the RT drift and discard outliers with <italic>r</italic><sub>thresh</sub> = PI, defined as points falling outside of the 95% prediction interval. We the re-estimate the drift and perform a final filtering step with the more stringent MAD by setting <italic>r</italic><sub>thresh</sub> = 2 × MAD.</p>
<p>At this stage, it is possible for <inline-formula id="ID142">
<alternatives><mml:math display="inline" id="I142"><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq142.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> to still contain coefficients of very small magnitude. As an optional postprocessing step, we discard these coefficients by setting all entries smaller than <inline-formula id="ID143">
<alternatives><mml:math display="inline" id="I143"><mml:mrow><mml:mi>τ</mml:mi><mml:mi>max</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq143.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> to zero for some scaling constant <italic>τ</italic> ∈ [0, 1]. Lastly, a feature from either study could have multiple possible matches, since <inline-formula id="ID165">
<alternatives><mml:math display="inline" id="I165"><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq165.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> can have more than one non-zero coefficient per row or column. Although reporting multiple matches can be helpful in an exploratory context, for the sake of simplicity in our analysis, the final output of GromovMatcher returns a one-to-one matching. Consequently, we only keep those metabolite pairs (<italic>i,j</italic>) where the entry <inline-formula id="ID144">
<alternatives><mml:math display="inline" id="I144"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq144.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> is largest in its corresponding row and column. All nonzero entries of <inline-formula id="ID145">
<alternatives><mml:math display="inline" id="I145"><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq145.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> which do not satisfy this criterion are set to zero. Finally, we convert <inline-formula id="ID146">
<alternatives><mml:math display="inline" id="I146"><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq146.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> into a binary matching matrix <inline-formula id="ID147">
<alternatives><mml:math display="inline" id="I147"><mml:mrow><mml:mi>M</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq147.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> with ones in place of its nonzero entries and this final output is returned to the user.</p>
<p>As a naming convention, we use the abbreviation GM for our GromovMatcher method, and use the abbreviation GMT when running GromovMatcher with the optional <italic>τ</italic>-thresholding step.</p>
</sec>
<sec id="s5j">
<title>GromovMatcher algorithm summary</title>
<p>In summary, our full GromovMatcher algorithm consists of (1) UGW optimization followed by (2) retention time drift estimation and filtering.</p>
<p>The tuning of <italic>ρ</italic> and <italic>ε</italic> was computationally driven and the two parameters were set as low as possible, with <italic>ρ</italic> = 0.05 and <italic>ε</italic> = 0.005. Based on literature <italic><bold>Loftfield et al. (2021)</bold></italic>; <italic><bold>Hsu et al. (2019)</bold></italic>; <italic><bold>Climaco Pinto et al. (2022)</bold></italic>; <italic><bold>Habra et al. (2021)</bold></italic>; <italic><bold>Chen et al. (2021)</bold></italic> and what is considered to be a plausible variation of a feature’s <italic>m</italic>/<italic>z</italic>, we set <italic>m</italic><sub>gap</sub> = 0.01ppm. For RT drift estimation, the order of the B-splines was set to <italic>n</italic> = 3 by default, while the number of knots <italic>k</italic> was selected by 10-fold cross-validation. If the optional thresholding step was applied in GMT, we set <italic>τ</italic> = 0.3. Otherwise, we let <italic>τ</italic> = 0 which gives the unthresholded GM algorithm.</p>
<table-wrap id="tbl9" orientation="portrait" position="float">
<label>Algorithm 4:</label>
<caption><title>GromovMatcher</title></caption>
<alternatives>
<graphic xlink:href="2306.03218v2_tbl9.tif" mimetype="image" mime-subtype="tiff"/>
<table frame="hsides" rules="groups">
<tbody>
<tr>
<td align="left" valign="top"><bold>input :</bold> Distance matrices <italic>D<sup>x</sup>,D<sup>y</sup></italic>, marginals <italic>a,b</italic>, marginal relaxation <italic>ρ</italic>, entropic regularization <italic>ε</italic>, mass-to-charge ratios <italic>m<sup>x</sup>, m<sup>y</sup></italic>, mass-to-charge ratio gap <italic>m</italic>gap, retention times <italic>RT<sup>x</sup>, RT<sup>y</sup></italic>, B-spline order <italic>n</italic>, filtering threshold <italic>τ</italic></td>
</tr>
<tr>
<td align="left" valign="top"><bold>output:</bold>Return the matching matrix <italic>M</italic> and the retention time drift <inline-formula id="ID148">
<alternatives><mml:math display="inline" id="I148"><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq148.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula></td>
</tr>
<tr>
<td align="left" valign="top"># Step 1: Weighted UGW optimization
<break/>Compute <inline-formula id="ID149">
<alternatives><mml:math display="inline" id="I149"><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">˜</mml:mo></mml:mover></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq149.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> = WeightedUnbalancedGromovWasserstein(<italic>D<sup>x</sup>, D<sup>y</sup>, a, b, p, e, m<sup>x</sup>, m<sup>y</sup></italic>)</td>
</tr>
<tr>
<td align="left" valign="top"># Step 2: Retention time drift estimation and filtering
<break/><bold>for</bold> <underline><italic>i</italic> = 1:3</underline> <bold>do</bold>
<break/>  Perform weighted spline regression (51) for RT drift <inline-formula id="ID150">
<alternatives><mml:math display="inline" id="I150"><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo stretchy="true">^</mml:mo></mml:mover><mml:mo>∈</mml:mo><mml:msub><mml:mi>B</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq150.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> where <italic>k</italic> is chosen by 10-fold cross validation
<break/>  Initialize <italic>r</italic><sub>thresh</sub> =0
<break/>  <bold>if</bold> <underline><italic>i</italic> &lt; 3</underline> <bold>then</bold>
<break/>    Set <italic>r</italic><sub>thresh</sub> = PI from (53)
<break/>  <bold>else</bold>
<break/>    Set <italic>r</italic><sub>thresh</sub> = 2 × MAD from (53)
<break/>  Set <inline-formula id="ID151">
<alternatives><mml:math display="inline" id="I151"><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">˜</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq151.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula></td>
</tr>
<tr>
<td align="left" valign="top">Compute <inline-formula id="ID152">
<alternatives><mml:math display="inline" id="I152"><mml:mrow><mml:mi>U</mml:mi><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq152.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>
<break/>Set <inline-formula id="ID153">
<alternatives><mml:math display="inline" id="I153"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq153.tif" mimetype="image" mime-subtype="tiff"/></alternatives></inline-formula> if <inline-formula id="ID166">
<alternatives><mml:math display="inline" id="I166"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>&lt;</mml:mo><mml:mi>τ</mml:mi><mml:mi>U</mml:mi></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq166.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> for <italic>i</italic> ∈ [<italic>p</italic><sub>1</sub>] and <italic>j</italic> ∈ [<italic>p</italic><sub>2</sub>]
<break/>Set <inline-formula id="ID154">
<alternatives><mml:math display="inline" id="I154"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq154.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> if <inline-formula id="ID167">
<alternatives><mml:math display="inline" id="I167"><mml:mrow><mml:mi>i</mml:mi><mml:mo>≠</mml:mo><mml:mi>arg</mml:mi><mml:msub><mml:mrow><mml:mi>max</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:msub><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq167.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> or <inline-formula id="ID168">
<alternatives><mml:math display="inline" id="I168"><mml:mrow><mml:mi>j</mml:mi><mml:mo>≠</mml:mo><mml:mi>arg</mml:mi><mml:msub><mml:mrow><mml:mi>max</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:msub><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq168.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula> for <italic>i</italic> ∈ [<italic>p</italic><sub>1</sub>] and <italic>j</italic> ∈ [<italic>p</italic><sub>2</sub>]
<break/>Define the binarized matching <inline-formula id="ID155">
<alternatives><mml:math display="inline" id="I155"><mml:mrow><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mo>∏</mml:mo><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq155.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>
</td>
</tr>
<tr>
<td align="left" valign="top">Return <italic>M</italic> and <inline-formula id="ID156">
<alternatives><mml:math display="inline" id="I156"><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow></mml:math>
<inline-graphic xlink:href="2306.03218v2_ieq156.tif" mimetype="image" mime-subtype="tiff"/></alternatives>
</inline-formula>.</td>
</tr>
</tbody>
</table>
</alternatives>
</table-wrap>
</sec>
</app>
<app id="app2">
<title>Appendix 2</title>
<p>Here we discuss existing metabolomic alignments methods and the hyperparameter experiments we perform on these methods. We consider two existing alignment methods for comparison, metabCombiner <italic><bold>Habra et al. (2021)</bold></italic> and M2S <italic><bold>Climaco Pinto et al. (2022)</bold></italic>. Both of them take the same kind of input as GromovMatcher, i.e. feature tables with features identified with their <italic>m</italic>/<italic>z</italic>, RT, and intensities across samples.</p>
<sec id="s6a">
<title>MetabCombiner hyperparameter experiments</title>
<p>MetabCombiner <italic><bold>Habra et al. (2021)</bold></italic> is a three-step process that begins by grouping features based on their <italic>m</italic>/<italic>z</italic> within user-specified bins. This creates a search space for potential feature pairs. In the second step, MetabCombiner estimates the RT drift using the potential feature pairs identified in the first step, and eliminates outlying pairs over several iterations. This step can incorporate prior knowledge by identifying shared features and marking them as anchors, which are not discarded. In the final step, MetabCombiner scores the remainingfeature pairs based on their <italic>m</italic>/<italic>z</italic>, RT, and relative intensity compatibility to discriminate between multiple matches for one feature. The scoring system relies on weights assigned to <italic>m</italic>/<italic>z</italic>, RT, and feature intensities, with the magnitude of those weights reflecting the reliability of the corresponding measurements across studies.</p>
<p>MetabCombiner <italic><bold>Habra et al. (2021)</bold></italic> includes adjustable parameters throughout the pipeline. We set most of them to default values unless otherwise stated. MetabCombiner first establishes candidate pairs by binning features in the <italic>m</italic>/<italic>z</italic> dimension with a width of binGap, and pairing the features sorted by relative intensities. The ‘binGap’ parameter sets the <italic>m</italic>/<italic>z</italic> tolerance of metabCom-biner, similar to <italic>m</italic><sub>gap</sub> in GromovMatcher. We used the same value of 0.01 as in GromovMatcher.</p>
<p>MetabCombiner then estimates the RT drift using basis splines, and removes pairs associated with a high residual (twice the mean model error) from the candidate set.</p>
<p>In our main experiment, the RT drift is estimated exclusively using candidate pairs selected by the pipeline. However, it is also possible to include known ground truth pairs as ‘anchors’ to estimate the RT drift. We choose not to rely on prior knowledge for drift estimation as Habra et al. <italic><bold>Habra et al. (2021)</bold></italic> show their drift estimation to be efficient and robust, even without prior knowledge. To confirm this claim, we conduct a sensitivity analysis comparing the results obtained in our main experiment with those obtained when supplying metabCombiner with known shared metabolites to anchor the RT drift estimation. We randomly select 100 anchors from the ground truth matching and compute the metabCombiner matchings with otherwise identical settings as in our main experiment. The results from this analysis (reported in <xref ref-type="fig" rid="fig6">Appendix 2 — Figure 1</xref>) show that the unsupervised RT drift estimation (using anchors selected by the pipeline only) performs as well as the supervised RT drift estimation, showing the drift estimation to be very consistent, with or without shared entities.</p>
<p>After establishing candidate pairs and filtering out those that contradict the estimated RT drift, metabCombiner discriminates between multiple matches using a scoring system that considers <italic>m</italic>/<italic>z</italic>, RT, and rankings of the median feature intensities. Each dimension has a specific weight that can be left at default, manually adjusted, or automatically tuned using known matched pairs. Habra et al. <italic><bold>Habra et al. (2021)</bold></italic> provide qualitative guidelines for tuning the weights manually, mainly based on the experimental conditions and visual inspection of the RT drift plot. Since this approach is difficult to implement in the various settings we consider for our simulation study, we rely on the quantitative tuning function included in the metabCombiner pipeline. This function takes into account known shared features and tunes the weights to optimize the scores of those known matches. We randomly select 100 known true matches to define the objective function metab-Combiner maximizes. We search over the recommended range of values, with the <italic>m</italic>/<italic>z</italic> weight <italic>A</italic> ∈ [50, 150], the RT weight <italic>B</italic> ∈ [5, 20] and the feature intensities weight <italic>C</italic> ∈ [0, 1]. <xref ref-type="fig" rid="fig6">Appendix 2 — Figure 1</xref> presents the results obtained with the weights set at default values (<italic>A</italic> = 100, <italic>B</italic> = 15, <italic>C</italic> = 0.5), as a sensitivity analysis.</p>
<fig id="fig6" position="float" fig-type="figure">
<label>Appendix 2—figure 1.</label>
<caption><p>Performance of metabCombiner with the different parameter settings. The first setting, labelled ‘Scores’ correspond to the design of our main analysis, where 100 randomly selected true pairs are supplied to metabCombiner to set the scoring weights automatically, but are not otherwise used. In the second setting, labelled ‘Scores + RT’, metabCombiner is allowed to use the 100 true pairs not only to set the scoring weights, but also to estimate the RT drift. Finally, in the third ‘Default’ setting, we do not use any prior knowledge for the RT drift estimation and keep the scoring weights’ default values.</p></caption>
<graphic xlink:href="2306.03218v2_fig6.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
</sec>
<sec id="s6b">
<title>M2S hyperparameter experiments</title>
<p>Pinto et al. <italic><bold>Climaco Pinto et al. (2022)</bold></italic> introduce M2S as a more versatile alternative to metab-Combiner, while still adhering to most of its core principles. Like metabCombiner, M2S follows a three-step process. First it searches for matches within user-defined thresholds for <italic>m</italic>/<italic>z</italic>, retention time, and mean feature intensity. Next, M2S estimates <italic>m</italic>/<italic>z</italic>, RT and feature intensity drifts between datasets and removes any outlier pairs. Finally, M2S selects the best match using a scoring system that weighs each measurement, similar to metabCombiner. M2S notably stands out by providing greater flexibility in the methods and measurements used at each step of the procedure, resulting however in a larger number of parameters that require manual fine-tuning. To address this, we adopt two different approaches for the simulation study and the EPIC study alignment. In the simulation study, we set the initial thresholds to oracle values and investigate technical parameters. For the EPIC study alignment, we use the combination of technical parameters with the best average F1-score in the simulation study and select the best threshold values based on the performance on the validation subset.</p>
<p>More precisely, M2S first matches all pairs of metabolic features whose absolute difference in <italic>m</italic>/<italic>z</italic>, RT, and median of <italic>log</italic><sub>10</sub> FI are within the user-defined thresholds ‘MZ_intercept’, ‘RT.intercept’ and ‘log10FI_intercept’. On simulated data experiments, we set these thresholds to MZ_intercept = 0.01, RT_intercept = 3.5 and log10FI_intercept = 0.2 which are large enough to not exclude any true feature matches in any of the scenarios for our simulated data under low, medium, and high over-lap/noise (see Methods). M2S also offers more detailed options to match features whose absolute difference stays within two lower and upper bound lines with a given slope where the intercepts of these lines are defined using the values above. In our analysis, we set the slopes of these linear boundaries to zero so as to not remove any true matches. Because the reference and target studies we are matching in the simulated analysis are on the same scale, we set the FI adjust method to ‘none’.</p>
<p>The second step of M2S involves calculating penalization scores for every pair of matches which are used to determine the best set of matches between metabolic features of both datasets. This step depends on a set of hyperparameters which we perform a grid search over to optimize the performance of M2S. For estimating the <italic>m</italic>/<italic>z</italic>, RT, and FI drift, the hyperparameters are the percentage of neighbors ‘nrNeighbors‘, the neighborhood shape ‘neighMethod’, and the LOESS span percentage ‘pctPointsLoess’ used to smooth the estimated drift functions. After the drifts are estimated, they are normalized using a method specified by ‘residPercentile’ that puts the <italic>m</italic>/<italic>z</italic>, RT, and FI residuals on the same scale. We always fix residPercentile = NaN which defaults to the standard 2 X MAD normalization. Next, for every remaining metabolic feature match, the residuals/drifts of the <italic>m</italic>/<italic>z</italic>, RT, and FI are added together by taking the weighted square root sum of squares. For unnormalized data where feature intensity magnitudes are important, we weight all three drifts equally using <italic>w</italic> = (1, 1, 1) and for data with normalized feature intensities we set the FI drift weight to zero such that <italic>w</italic> = (1, 1, 0). Finally, using these weighted penalization scores, M2S selects the best matched pair within a multiple match cluster to obtain a one-to-one matching between datasets.</p>
<table-wrap id="tbl4" orientation="portrait" position="float">
<label>Appendix 2—table 1.</label>
<caption><title>Performance of M2S in a setting where the RT drift between studies is linear.</title></caption>
<alternatives>
<graphic xlink:href="2306.03218v2_tbl4.tif" mimetype="image" mime-subtype="tiff"/>
<table frame="hsides" rules="groups">
<thead>
<tr>
<th align="left" valign="top">Metric</th>
<th align="center" valign="top">Low overlap</th>
<th align="center" valign="top">Medium overlap</th>
<th align="center" valign="top">High overlap</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><bold>Precision</bold></td>
<td align="center" valign="top">0.831</td>
<td align="center" valign="top">0.917</td>
<td align="center" valign="top">0.947</td>
</tr>
<tr>
<td align="left" valign="top"><bold>Recall</bold></td>
<td align="center" valign="top">0.934</td>
<td align="center" valign="top">0.933</td>
<td align="center" valign="top">0.939</td>
</tr>
</tbody>
</table>
</alternatives>
</table-wrap>
<p>The third and final step of M2S involves removing those remaining matches which have large differences in <italic>m</italic>/<italic>z</italic>, RT, or FI. This can be performed using several methods indicated by the hyperparameter ‘methodType’. Each method excludes those matched pairs whose differences in <italic>m</italic>/<italic>z</italic>, RT, or FI exceed a certain number of median absolute deviations indicated by the parameter ‘nr-MAD’. The remaining one-to-one metabolic feature matches are returned as the final result of the M2S algorithm.</p>
<p>To optimally tune M2S on our simulated experiments, we determine the optimal M2S parameter combination for each individual simulation setting (low, medium, high overlap and noise) by performing a grid search over the product of parameter lists
<list list-type="bullet" id="L1">
<list-item><p>nrNeighbors = [0.01, 0.05, 0.1, 0.5, 1]</p></list-item>
<list-item><p>neighMethod = [’cross’, ‘circle’]</p></list-item>
<list-item><p>pctPointsLoess = [0, 0.1, 0.5]</p></list-item>
<list-item><p>methodType = [’none’, ‘scores’, ‘byBins’, ‘trend_mad’, ‘residuals_mad’]</p></list-item>
<list-item><p>nrMAD = [1, 3, 5]</p></list-item>
</list>
</p>
<p>Each parameter combination for M2S is tested across 20 randomly generated datasets at the same overlap and noise settings. For each setting, the combination of parameters above with the best average F1-score across these 20 trials is used as the optimal parameter choice.</p>
<p>M2S applies initial RT thresholds to search for candidate pairs, which may favor settings where the RT drift follows a linear trend. Therefore, as a sensitivity analysis, we apply M2S to simulated data with a linear drift. The simulation process is identical to that of our main simulation study, except for the deviation of the RT in dataset 2. Specifically, for a given overlap value, we divide the original real-world dataset into two smaller datasets and introduce random noise to the <italic>m</italic>/<italic>z</italic>, RT and intensities of the features, without introducing a systematic deviation to the RT in dataset 2. M2S parameters are kept identical to the ones used in our main analysis in comparable settings. The results obtained by M2S on three pairs of datasets generated for three overlap values (0.25, 0.5 and 0.75) and a medium noise level are reported in <xref ref-type="table" rid="tbl4">Appendix 2-Table 1</xref>. While the results obtained in a high overlap setting are close to those obtained in our main analysis M2S demonstrates better performance in a low overlap setting when the RT drift is linear than in our main analysis. This observation is consistent with the results obtained by M2S on EPIC data, considering the relatively low estimated overlap between the aligned EPIC studies in our main analysis.</p>
<p>For the EPIC data, we select the parameter combination that yields the highest F1-score across all simulated settings. However, due to the unavailability of oracle values for setting initial thresholds, we perform a search over several MZ intercept values (0.01, 0.05, and 0.1), RT intercept values (0.1, 0.5, 1, and 5), and logFI intercept values (1, 10, and 100).</p>
<table-wrap id="tbl5" orientation="portrait" position="float">
<label>Appendix 3—table 1.</label>
<caption><p>Precision and recall on the EPIC validation subset for unnormalized data in (a) positive mode, and (b) negative mode. 95% confidence intervals were computed using modified Wilson score intervals <italic>Brown et al.</italic> (<italic>2001</italic>); <italic>Agresti and Coull</italic> (<italic>1998</italic>).</p></caption>
<alternatives>
<graphic xlink:href="2306.03218v2_tbl5.tif" mimetype="image" mime-subtype="tiff"/>
<table frame="hsides" rules="groups">
<thead>
<tr style="border-bottom: solid thin">
<th align="left" valign="top"/>
<th align="center" valign="top" colspan="2">CS ↔ HCC</th>
<th align="center" valign="top" colspan="2">CS ↔ PC</th>
</tr>
<tr>
<th align="left" valign="top">Method</th>
<th align="center" valign="top">Precision</th>
<th align="center" valign="top">Recall</th>
<th align="center" valign="top">Precision</th>
<th align="center" valign="top">Recall</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><bold>GromovMatcher</bold></td>
<td align="center" valign="top">0.988 (0.937, 0.999)</td>
<td align="center" valign="top">0.944 (0.876, 0.997)</td>
<td align="center" valign="top">0.873 (0.776, 0.932)</td>
<td align="center" valign="top">0.939 (0.854, 0.976)</td>
</tr>
<tr>
<td align="left" valign="top"><bold>M2S</bold></td>
<td align="center" valign="top">0.967 (0.908, 0.991)</td>
<td align="center" valign="top">0.978 (0.923, 0.996)</td>
<td align="center" valign="top">0.855 (0.759, 0.917)</td>
<td align="center" valign="top">0.985 (0.919, 0.999)</td>
</tr>
<tr style="border-bottom: solid thin">
<td align="left" valign="top"><bold>metabCombiner</bold></td>
<td align="center" valign="top">0.979 (0.889, 0.999)</td>
<td align="center" valign="top">0.511 (0.410, 0.612)</td>
<td align="center" valign="top">0.926 (0.766, 0.987)</td>
<td align="center" valign="top">0.379 (0.271, 0.499)</td>
</tr>
<tr style="border-bottom: solid thin">
<td align="left" valign="top"><bold>(a) Positive mode</bold></td>
<td align="center" valign="top" colspan="4"/>
</tr>
<tr style="border-bottom: solid thin">
<td align="left" valign="top"/>
<td align="center" valign="top" colspan="2"><bold>CS</bold> ↔ <bold>HCC</bold></td>
<td align="center" valign="top" colspan="2"><bold>CS</bold> ↔ <bold>PC</bold></td>
</tr>
<tr style="border-bottom: solid thin">
<td align="left" valign="top"><bold>Method</bold></td>
<td align="center" valign="top"><bold>Precision</bold></td>
<td align="center" valign="top"><bold>Recall</bold></td>
<td align="center" valign="top"><bold>Precision</bold></td>
<td align="center" valign="top"><bold>Recall</bold></td>
</tr>
<tr>
<td align="left" valign="top"><bold>GromovMatcher</bold></td>
<td align="center" valign="top">0.950 (0.764, 0.997)</td>
<td align="center" valign="top">1.000 (0.832, 1.000)</td>
<td align="center" valign="top">0.964 (0.823, 0.998)</td>
<td align="center" valign="top">0.964 (0.823, 0.998)</td>
</tr>
<tr>
<td align="left" valign="top"><bold>M2S</bold></td>
<td align="center" valign="top">1.000 (0.824, 1.000)</td>
<td align="center" valign="top">0.947 (0.754, 0.997)</td>
<td align="center" valign="top">0.931 (0.780, 0.988)</td>
<td align="center" valign="top">0.964 (0.823, 0.998)</td>
</tr>
<tr style="border-bottom: solid thin">
<td align="left" valign="top"><bold>metabCombiner</bold></td>
<td align="center" valign="top">1.000 (0.566, 1.000)</td>
<td align="center" valign="top">0.263 (0.118, 0.488)</td>
<td align="center" valign="top">1.000 (0.785, 1.000)</td>
<td align="center" valign="top">0.500 (0.326, 0.674)</td>
</tr>
<tr>
<td align="left" valign="top"><bold>(b) Negative mode</bold></td>
<td align="center" valign="top" colspan="4"/>
</tr>
</tbody>
</table>
</alternatives>
</table-wrap>
</sec>
</app>
<app id="app3">
<title>Appendix 3</title>
<p>Here we describe additional preprocessing details and analyses of the EPIC data.</p>
<sec id="s7a">
<title>Centered and scaled data - Negative mode</title>
<p>In this section, we present the results obtained on centered and scaled EPIC data in negative mode, shown in <xref ref-type="fig" rid="fig4">Figure 4</xref> of our main paper. However, due to the smaller size of the validation subset (42 features examined in negative mode compared to 163 in positive mode), the evaluation of the performance of the three methods may be less reliable than in positive mode.</p>
<p>First, we align the CS and HCC studies in negative mode and detect a total of 449, 492, and 180 matches with GM, M2S, and metabCombiner, respectively. Similar to the positive mode analysis, we evaluate the precision and recall of the three methods on the 42 feature validation subset, of which 19 were manually matched. GM and M2S demonstrate identical F1-scores of 0.98, while metabCombiner performs poorly in comparison. GM is able to recover all 19 true matches and identified only 1 false positive, while M2S recovers no false positives but missed 1 true positive.</p>
<p>Next, we align the CS and PC studies in negative mode and detect a total of 485, 569, and 314 matches with GM, M2S, and metabCombiner, respectively. Again, we evaluate the precision and recall of the three methods on the 42 feature validation subset, of which 26 were manually matched. MetabCombiner performs better than in the other EPIC pairings with an F1-score of 0.857, but is still outperformed by the other two methods. GM is slightly outperformed by M2S in this setting, with an almost identical precision of 0.93, but a slightly higher recall for M2S due to detecting 1 additional true positive. However, this remains a good performance for GM since M2S was optimally tuned using the validation subset itself.</p>
</sec>
<sec id="s7b">
<title>Non-centered and non-scaled data</title>
<p>As a sensitivity analysis, we apply the three methods to EPIC data that has not been centered or scaled. The detailed results can be found in <xref ref-type="table" rid="tbl5">Appendix 3 — Table 1</xref>.</p>
<p>M2S was tuned manually on the validation subset to ignore feature intensities in both cases. As a result, it maintains its performance compared to our main experiment. On the other hand, the performance ofGM and metabCombiner is affected by the lack of consistency in feature intensities. MetabCombiner’s recall drops slightly but its precision remains comparable to that of our main experiment, with the method clearly favoring the latter. Although GM’s recall decreases slightly in positive mode, it remains more precise than the optimally tuned M2S, and it balances precision and recall better than metabCombiner. Interestingly, GM’s results in negative mode are improved compared to our main experiment, and it outperforms both mC and M2S. However, since the validation subset in negative mode is relatively small, these differences may not be significant. Nonetheless, GM maintains a good performance, similar to that of the optimally tuned M2S.</p>
<p>Similar to the analysis we conducted on centered and scaled data, we find a high number of false positives when aligning the CS study and the PC study in positive mode. Therefore, we manually examine the matches recovered by GM. Our examination reveals 2 false positives, 4 unclear matches, and 3 additional good matches that GM also identifies in our main analysis. This demonstrates that the lack of centering and scaling results in two additional false positives for GM that are not present in our main results.</p>
</sec>
<sec id="s7c">
<title>Illustration for alcohol biomarker discovery</title>
<p>Loftfield et al. <italic><bold>Loftfield et al. (2021)</bold></italic> identified 205 features associated with alcohol intake in the CS study, using a false discovery rate (FDR) correction to account for multiple testing. By applying an FDR correction in our pooled analysis, we identify 243 features associated with alcohol intake. Out of those 243 features, 185 are consistent with the features identified in the discovery step of Loftfield et al. <italic><bold>Loftfield et al. (2021)</bold></italic>, while 55 features are newly discovered (Extended Data <xref ref-type="fig" rid="fig5">Fig. 5c</xref>). We examine the 20 features identified as significant in Loftfield et al.’s discovery analysis but that are not significant in our pooled analysis. Both manual and GM matching yield identical results for these features, indicating that the loss of significance is not due to incorrect matching. Upon further investigation, we find that these features do not demonstrate a meaningful association with alcohol intake in the HCC and PC studies. This observation is reinforced by the fact that none of these features are among the 10 features that persisted after the validation step in Loftfield et al.</p>
<p>Out of the 205 features initially discovered in Loftfield et al. <italic><bold>Loftfield et al. (2021)</bold></italic>, 10 are replicated in the EPIC HCC and PC studies using the more stringent Bonferroni correction. When using a Bonferroni correction in our pooled analysis, we find significant association between alcohol intake and 92 features, 36 of which are effectively shared by the three studies. Notably, these features include all 10 features that were retained in Loftfield et al. (Extended Data <xref ref-type="fig" rid="fig5">Fig. 5c</xref>).</p>
<p>This analysis illustrates how GromovMatcher can be used in the context of biomarker discovery, and its potential to allow for increased statistical power.</p>
<fig id="fig7" position="float" fig-type="figure">
<label>Figure 3—figure supplement 1.</label>
<caption><p>Average precision and recall obtained on simulated data, with fixed overlap <italic>λ</italic> = 0.5. The noise level corresponds to different values of <italic>σ</italic><sub>RT</sub> and <italic>σ</italic><sub>FI</sub>. High, medium and low noise level correspond to (<italic>σ</italic><sub>RT</sub>, <italic>σ</italic><sub>FI</sub>) = (0.2,0.1),(0.5,0.5) and (1, 1) respectively. We run 20 simulations for each setting.</p></caption>
<graphic xlink:href="2306.03218v2_fig7.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
<fig id="fig8" position="float" fig-type="figure">
<label>Figure 3—figure supplement 2.</label>
<caption><p>Performance on centered and scaled data. The feature intensities of both datasets are centered and scaled to have means of 0 and standard deviations of 1. The average precision and recall of the three methods are computed on 20 randomly generated pairs of datasets, for (a) three levels of overlap (low, medium and high corresponding to <italic>λ</italic> = 0.25,0.5 and 0.75, respectively) with a medium noise level ((<italic>σ</italic><sub>RT</sub>, <italic>σ</italic><sub>FI</sub>) = (0.5,0.5)), and (b) fixed medium overlap (<italic>λ</italic> = 0.5) and three different noise levels (low, medium and high corresponding to (<italic>σ</italic><sub>RT</sub>, <italic>σ</italic><sub>FI</sub>) = (0.2, 0.1), (0. 5, 0. 5) and (1, 1), respectively).</p></caption>
<graphic xlink:href="2306.03218v2_fig8.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
<fig id="fig9" position="float" fig-type="figure">
<label>Figure 4—figure supplement 1.</label>
<caption><p>Consistency of the mean feature intensities (FI) in EPIC. Each scatter plot represents the mean feature intensities of manually matched features from the validation subset. Each dot represents a pair of manually matched features. The axis represent the mean feature intensities recorded in the two different studies.</p></caption>
<graphic xlink:href="2306.03218v2_fig9.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
<fig id="fig10" position="float" fig-type="figure">
<label>Figure 4—figure supplement 2.</label>
<caption><p>Overlap between the matching results obtained by metabCombiner, M2S and GromovMatcher in EPIC. Venn diagrams are not up to scale.</p></caption>
<graphic xlink:href="2306.03218v2_fig10.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
<fig id="fig11" position="float" fig-type="figure">
<label>Figure 4—figure supplement 3.</label>
<caption><p>Estimated RT drift between the EPIC studies aligned in the main experiment. Each dot correspond to a candidate matched pair after the first step of GM (<italic>m</italic>/<italic>z</italic> constrained GW matching), before the RT drift estimation and RT based filtering.</p></caption>
<graphic xlink:href="2306.03218v2_fig11.tif" mimetype="image" mime-subtype="tiff"/>
</fig>
</sec>
</app>
</app-group>
</back>
<sub-article id="sa0" article-type="editor-report">
<front-stub>
<article-id pub-id-type="doi">10.7554/eLife.91597.1.sa2</article-id>
<title-group>
<article-title>eLife Assessment</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<name>
<surname>Fernandez</surname>
<given-names>Paula</given-names>
</name>
<role specific-use="editor">Reviewing Editor</role>
<aff>
<institution-wrap>
<institution>INTA</institution>
</institution-wrap>
<city>Buenos Aires</city>
<country>Argentina</country>
</aff>
</contrib>
</contrib-group>
<kwd-group kwd-group-type="claim-importance">
<kwd>Important</kwd>
</kwd-group>
<kwd-group kwd-group-type="evidence-strength">
<kwd>Incomplete</kwd>
<kwd>Solid</kwd>
</kwd-group>
</front-stub>
<body>
<p>This paper represents <bold>important</bold> findings when identifying untargeted metabolomics and its differences between metabolomes of different biological samples. GromovMatcher is the fantasy name for the soft development. The main idea behind it is built on the assumption of featuring and matching complex datasets. Although the manuscript reflects a <bold>solid</bold> analysis, it remains <bold>incomplete</bold> for validation with putative non-curated datasets.</p>
</body>
</sub-article>
<sub-article id="sa1" article-type="referee-report">
<front-stub>
<article-id pub-id-type="doi">10.7554/eLife.91597.1.sa1</article-id>
<title-group>
<article-title>Reviewer #1 (Public Review):</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<anonymous/>
<role specific-use="referee">Reviewer</role>
</contrib>
</contrib-group>
</front-stub>
<body>
<p>Summary:</p>
<p>The authors have implemented the Optimal Transport algorithm in GromovMatcher for comparing LC/MS features from different datasets. This paper gains significance in the proteomics field for performing meta-analysis of LC/MS data.</p>
<p>Strengths:</p>
<p>The main strength is that GromovMatcher achieves significant performance metrics compared to other existing methods. The authors have done extensive comparisons to claim that GromovMatcher performs well.</p>
<p>Weaknesses:</p>
<p>There are two weaknesses.</p>
<p>1. When the number of features is reduced the precision drops to ~0.8.</p>
<p>
2. How applicable is the method for other non-human datasets?</p>
</body>
</sub-article>
<sub-article id="sa2" article-type="referee-report">
<front-stub>
<article-id pub-id-type="doi">10.7554/eLife.91597.1.sa0</article-id>
<title-group>
<article-title>Reviewer #2 (Public Review):</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<anonymous/>
<role specific-use="referee">Reviewer</role>
</contrib>
</contrib-group>
</front-stub>
<body>
<p>Summary:</p>
<p>The goal of untargeted metabolomics is to identify differences between metabolomes of different biological samples. Untargeted metabolomics identifies features with specific mass-to-charge ratio (m/z) and retention time (RT). Matching those to specific metabolites based on the model compounds from databases is laborious and not always possible, which is why methods for comparing samples on the level of unmatched features are crucial.</p>
<p>The main purpose of the GromovMatcher method presented here is to merge and compare untargeted metabolomes from different experiments. These larger datasets could then be used to advance biological analyses, for example, for the identification of metabolic disease markers. The main problem that complicates merging different experiments is m/z and RT vary slightly for the same feature (metabolite).</p>
<p>The main idea behind the GromovMatcher is built on the assumption that if two features match between two datasets (that feature i from dataset 1 matches feature j from dataset 2, and feature k from dataset 1 matches feature l from dataset 2), then the correlations or distances between the two features within each of the datasets (i and k, and j and l) will be similar. The authors then use the Gromov-Wasserstein method to find the best matches matrix from these data.</p>
<p>The variation in m/z between the same features in different experiments is a user-defined value and it is initially set to 0.01 ppm. There is no clear limit for RT deviations, so the method estimates a non-linear deviation (drift) of RT between two studies. GromovMatcher estimates the drift between the two studies and then discards the matching pairs where the drift would deviate significantly from the estimate. It learns the drift from a weighted spline regression.</p>
<p>The authors validate the performance of their GromovMatcher method by a validation experiment using a dataset of cord blood. They use 20 different splits and compare the GromovMatcher (both its GM and GMT iterations, whereby the GMT version uses the deviation from estimated RT drift to filter the matching matrix) with two other matching methods: M2S and metabCombiner.</p>
<p>The second validation was done using a (scaled and centered) dataset of metabolics from cancer datasets from the EPIC cohort that was manually matched by an expert. This dataset was also used to show that using automatic methods can identify more features that are associated with a particular group of samples than what was found by manual matching. Specifically, the authors identify additional features connected to alcohol consumption.</p>
<p>Strengths:</p>
<p>I see the main strength of this work in its combination of all levels of information (m/z, RT, and higher-order information on correlations between features) and using each of the types of information in a way that is appropriate for the measure. The most innovative aspect is using the Gromov-Wasserstein method to match the features based on distance matrices.</p>
<p>The authors of the paper identify two main shortcomings with previously established methods that attempt to match features from different experiments: a) all other methods require fine-tuning of user-defined parameters, and, more importantly, b) do not consider correlations between features. The main strength of the GromovMatcher is that it incorporates the information on distances between the features (in addition to also using m/z and RT).</p>
<p>Weaknesses:</p>
<p>The first, minor, weakness I could identify is that there seem not to be plenty of manually curated datasets that could be used for validation. The second is also emphasized by the authors in the discussion. Namely, the method as it is set up now can be directly used only to compare two datasets.</p>
</body>
</sub-article>
</article>