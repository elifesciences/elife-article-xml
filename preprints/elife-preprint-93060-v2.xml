<?xml version="1.0" ?><!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.3 20210610//EN"  "JATS-archivearticle1-mathml3.dtd"><article xmlns:ali="http://www.niso.org/schemas/ali/1.0/" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article" dtd-version="1.3" xml:lang="en">
<front>
<journal-meta>
<journal-id journal-id-type="nlm-ta">elife</journal-id>
<journal-id journal-id-type="publisher-id">eLife</journal-id>
<journal-title-group>
<journal-title>eLife</journal-title>
</journal-title-group>
<issn publication-format="electronic" pub-type="epub">2050-084X</issn>
<publisher>
<publisher-name>eLife Sciences Publications, Ltd</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">93060</article-id>
<article-id pub-id-type="doi">10.7554/eLife.93060</article-id>
<article-id pub-id-type="doi" specific-use="version">10.7554/eLife.93060.2</article-id>
<article-version-alternatives>
<article-version article-version-type="publication-state">reviewed preprint</article-version>
<article-version article-version-type="preprint-version">1.3</article-version>
</article-version-alternatives>
<article-categories>
<subj-group subj-group-type="heading">
<subject>Neuroscience</subject>
</subj-group>
</article-categories>
<title-group>
<article-title>Aligned and oblique dynamics in recurrent neural networks</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author" corresp="yes">
<name>
<surname>Schuessler</surname>
<given-names>Friedrich</given-names>
</name>
<xref ref-type="aff" rid="A1">1</xref>
<xref ref-type="aff" rid="A2">2</xref>
<email xlink:href="mailto:f.schuessler@tu-berlin.de">f.schuessler@tu-berlin.de</email>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Mastrogiuseppe</surname>
<given-names>Francesca</given-names>
</name>
<xref ref-type="aff" rid="A3">3</xref>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Ostojic</surname>
<given-names>Srdjan</given-names>
</name>
<xref ref-type="aff" rid="A4">4</xref>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Barak</surname>
<given-names>Omri</given-names>
</name>
<xref ref-type="aff" rid="A5">5</xref>
</contrib>
<aff id="A1"><label>1</label><institution>Faculty of Electrical Engineering and Computer Science, Technical University Berlin</institution>, <country>Germany</country></aff>
<aff id="A2"><label>2</label><institution>Science of Intel ligence, Research Cluster of Excel lence</institution>, <city>Berlin</city>, <country>Germany</country></aff>
<aff id="A3"><label>3</label><institution>Champalimaud Foundation</institution>, <city>Lisbon</city>, <country>Portugal</country></aff>
<aff id="A4"><label>4</label><institution>Laboratoire de Neurosciences Cognitives et Computationnel les, INSERM U960, Ecole Normale Superieure - PSL Research University</institution>, <city>Paris</city>, <country>France</country></aff>
<aff id="A5"><label>5</label><institution>Rappaport Faculty of Medicine and Network Biology Research Laboratories, Technion - Israeli Institute of Technology</institution>, <city>Haifa</city>, <country>Israel</country></aff>
</contrib-group>
<contrib-group content-type="section">
<contrib contrib-type="editor">
<name>
<surname>Sharpee</surname>
<given-names>Tatyana O</given-names>
</name>
<role>Reviewing Editor</role>
<aff>
<institution-wrap>
<institution>Salk Institute for Biological Studies</institution>
</institution-wrap>
<city>La Jolla</city>
<country>United States of America</country>
</aff>
</contrib>
<contrib contrib-type="senior_editor">
<name>
<surname>Frank</surname>
<given-names>Michael J</given-names>
</name>
<role>Senior Editor</role>
<aff>
<institution-wrap>
<institution>Brown University</institution>
</institution-wrap>
<city>Providence</city>
<country>United States of America</country>
</aff>
</contrib>
</contrib-group>
<pub-date pub-type="epub">
<day>02</day>
<month>08</month>
<year>2024</year>
</pub-date>
<pub-date date-type="original-publication" iso-8601-date="2024-03-13">
<day>13</day>
<month>03</month>
<year>2024</year>
</pub-date>
<pub-date date-type="update" iso-8601-date="2024-10-11">
<day>11</day>
<month>10</month>
<year>2024</year>
</pub-date>
<volume>13</volume>
<elocation-id>RP93060</elocation-id>
<history><date date-type="sent-for-review" iso-8601-date="2023-11-27">
<day>27</day>
<month>11</month>
<year>2023</year>
</date>
</history>
<pub-history>
<event>
<event-desc>Preprint posted</event-desc>
<date date-type="preprint" iso-8601-date="2023-09-23">
<day>23</day>
<month>09</month>
<year>2023</year>
</date>
<self-uri content-type="preprint" xlink:href="https://doi.org/10.48550/arXiv.2307.07654"/>
</event>
<event>
<event-desc>Reviewed preprint v1</event-desc>
<date date-type="reviewed-preprint" iso-8601-date="2024-03-13">
<day>13</day>
<month>03</month>
<year>2024</year>
</date>
<self-uri content-type="reviewed-preprint" xlink:href="https://doi.org/10.7554/eLife.93060.1"/>
<self-uri content-type="editor-report" xlink:href="https://doi.org/10.7554/eLife.93060.1.sa2">eLife assessment:</self-uri>
<self-uri content-type="referee-report" xlink:href="https://doi.org/10.7554/eLife.93060.1.sa1">Reviewer #1 (Public Review):</self-uri>
<self-uri content-type="referee-report" xlink:href="https://doi.org/10.7554/eLife.93060.1.sa0">Reviewer #2 (Public Review):</self-uri>
</event>
</pub-history>
<permissions>
<copyright-statement>© 2024, Schuessler et al</copyright-statement>
<copyright-year>2024</copyright-year>
<copyright-holder>Schuessler et al</copyright-holder>
<ali:free_to_read/>
<license xlink:href="https://creativecommons.org/licenses/by/4.0/">
<ali:license_ref>https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
<license-p>This article is distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution License</ext-link>, which permits unrestricted use and redistribution provided that the original author and source are credited.</license-p>
</license>
</permissions>
<self-uri content-type="pdf" xlink:href="elife-preprint-93060-v2.pdf"/>
<abstract>
<title>Abstract</title>
<p>The relation between neural activity and behaviorally relevant variables is at the heart of neuroscience research. When strong, this relation is termed a neural representation. There is increasing evidence, however, for partial dissociations between activity in an area and relevant external variables. While many explanations have been proposed, a theoretical framework for the relationship between external and internal variables is lacking. Here, we utilize recurrent neural networks (RNNs) to explore the question of when and how neural dynamics and the network’s output are related from a geometrical point of view. We find that training RNNs can lead to two dynamical regimes: dynamics can either be aligned with the directions that generate output variables, or oblique to them. We show that the choice of readout weight magnitude before training can serve as a control knob between the regimes, similar to recent findings in feedforward networks. These regimes are functionally distinct. Oblique networks are more heterogeneous and suppress noise in their output directions. They are furthermore more robust to perturbations along the output directions. Crucially, the oblique regime is specific to recurrent (but not feedforward) networks, arising from dynamical stability considerations. Finally, we show that tendencies towards the aligned or the oblique regime can be dissociated in neural recordings. Altogether, our results open a new perspective for interpreting neural activity by relating network dynamics and their output.</p>
</abstract>
<custom-meta-group>
<custom-meta specific-use="meta-only">
<meta-name>publishing-route</meta-name>
<meta-value>prc</meta-value>
</custom-meta>
</custom-meta-group>
</article-meta>
</front>
<body>
<sec id="s1" sec-type="intro">
<title>1. Introduction</title>
<p>The relation between neural activity and behavioral variables is often expressed in terms of neural representations. Sensory input and motor output have been related to the tuning curves of single neurons [<xref ref-type="bibr" rid="c23">23</xref>, <xref ref-type="bibr" rid="c26">26</xref>, <xref ref-type="bibr" rid="c45">45</xref>] and, since the advent of large-scale recordings, to population activity [<xref ref-type="bibr" rid="c7">7</xref>, <xref ref-type="bibr" rid="c64">64</xref>, <xref ref-type="bibr" rid="c80">80</xref>]. Both input and output can be decoded from population activity, [<xref ref-type="bibr" rid="c11">11</xref>, <xref ref-type="bibr" rid="c41">41</xref>], even in real-time, closed-loop settings [<xref ref-type="bibr" rid="c63">63</xref>, <xref ref-type="bibr" rid="c82">82</xref>]. However, neural activity is often not fully explained by observable behavioral variables. Some components of the unexplained neural activity have been interpreted as random trial-to-trial fluctuations [<xref ref-type="bibr" rid="c16">16</xref>], potentially linked to unobserved behavior [<xref ref-type="bibr" rid="c44">44</xref>, <xref ref-type="bibr" rid="c72">72</xref>, <xref ref-type="bibr" rid="c81">81</xref>]. Activity may further be due to other ongoing computations not immediately related to behavior, such as preparatory motor activity in a null space of the motor readout [<xref ref-type="bibr" rid="c24">24</xref>, <xref ref-type="bibr" rid="c31">31</xref>]. Finally, neural activity may partially be due to other constraints, for example related to the underlying connectivity [<xref ref-type="bibr" rid="c2">2</xref>, <xref ref-type="bibr" rid="c48">48</xref>], the process of learning [<xref ref-type="bibr" rid="c63">63</xref>], or stability, i.e., the robustness of the neural dynamics to perturbations [<xref ref-type="bibr" rid="c62">62</xref>].</p>
<p>Here we aim for a theoretical understanding of neural representations: Which factors might determine how strongly activity and behavioral output variables are related? To this end, we use trained recurrent neural networks (RNNs). In this setting, output variables are determined by the task at hand, and neural activity can be described by its projection onto the principal components (PCs). We show that these networks can operate between two extremes: an “aligned” regime in which the output weights and the largest PCs are strongly correlated; and a second, “oblique” regime, where the output weights and the largest PCs are poorly correlated.</p>
<p>What determines the regime in which a network operates? We show that quite general considerations lead to a link between the magnitude of output weights and the regime of the network. As a consequence, we can use output magnitude as a control knob for trained RNNs. Indeed, when we trained RNN models on different neuroscience tasks, large output weights led to oblique dynamics, and small output weights to aligned dynamics. Recent results in feedforward networks identified two regimes - rich and lazy - that can also arise from choices of output weights [<xref ref-type="bibr" rid="c9">9</xref>, <xref ref-type="bibr" rid="c27">27</xref>]. In an extensive Methods section, we further analyze in detail how the oblique and aligned regimes arise during learning. There we show that the dynamical nature of RNNs, in particular demanding stable dynamics, leads to the replacement of unstable, lazy, solutions by oblique ones.</p>
<p>We then considered the functional consequences of the two regimes. Building on the concept of feedback loops driving the network dynamics [<xref ref-type="bibr" rid="c57">57</xref>, <xref ref-type="bibr" rid="c75">75</xref>], we show that, in the aligned regime, the largest PCs and the output are qualitatively similar. In the oblique regime, in contrast, the two may be qualitatively different. This functional decoupling in oblique networks leads to a large freedom for neural dynamics. Different networks with oblique dynamics thus tend to employ different dynamics for the same tasks. Aligned dynamics, in contrast, are much more stereotypical. Furthermore, as a result of how neural dynamics and output are coupled, oblique and aligned networks react differently to perturbations of the neural activity along the output direction. In particular, oblique (but not aligned) networks develop an additional negative feedback loop that suppresses output noise. We finally show that neural recordings from different experiments can have different degrees of alignment, which indicates that our theoretical results may be useful in identifying different regimes for different experiments, tasks, or brain regions.</p>
<p>Altogether, our work opens a new perspective relating network dynamics and their output, yielding important insights for modeling brain dynamics as well as experimentally accessible questions about learning and dynamics in the brain.</p>
<fig id="fig1" position="float" fig-type="figure">
<label>Fig. 1:</label>
<caption><p>Schematic of aligned and oblique dynamics in recurrent neural networks. <bold>A</bold> Output generated by both networks. <bold>B</bold> Neural activity of aligned (top) and oblique (bottom) dynamics, visualized in the space spanned by three neurons. Here, the activity (green) is three-dimensional, but most of the variance is concentrated along the two largest PCs (blue). For aligned dynamics, the output weights (red) are small and lie in the subspace spanned by the largest PCs; they are hence correlated to the activity. For oblique dynamics, the output weights are large and lie outside of the subspace spanned by the largest PCs; they are hence poorly correlated to the activity. <bold>C</bold> Projection of activity onto the two largest PCs. For oblique dynamics, the output weights are orthogonal to the leading PCs. <bold>D</bold> Evolution of PC projections over time. For aligned dynamics, the projection on the PCs resembles the output <italic>z</italic>(<italic>t</italic>), and reconstructing the output from the largest two components is possible. For the oblique dynamics, such reconstruction is not possible, because the projections oscillate much more slowly than the output.</p></caption>
<graphic xlink:href="2307.07654v3_fig1.tif" mime-subtype="tif" mimetype="image"/>
</fig>
</sec>
<sec id="s2" sec-type="results">
<title>2. Results</title>
<sec id="s2-1">
<title>2.1. Aligned and oblique population dynamics</title>
<p>We consider an animal performing a task while both behavior and neural activity are recorded. For example, the task might be to produce a periodic motion, described by the output <italic>z</italic>(<italic>t</italic>) of <xref ref-type="fig" rid="fig1">Fig. 1A</xref>. For simplicity, we assume that the behavioral output can be decoded linearly from the neural activity [<xref ref-type="bibr" rid="c19">19</xref>, <xref ref-type="bibr" rid="c41">41</xref>, <xref ref-type="bibr" rid="c61">61</xref>, <xref ref-type="bibr" rid="c63">63</xref>, <xref ref-type="bibr" rid="c82">82</xref>]. We can thus write
<disp-formula id="FD1">
<alternatives>
<mml:math id="M1" display="block"><mml:mi>z</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mrow><mml:mtext>out, </mml:mtext><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mtext> </mml:mtext><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle><mml:mo>=</mml:mo><mml:msubsup><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msubsup><mml:mtext>x</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn1.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(1)</label>
</disp-formula>
</p>
<p>with readout weights <bold>w</bold><sub>out</sub>. The activity of neuron <italic>i</italic> ∈ {1, …, <italic>N</italic>} is given by <italic>x<sub>i</sub></italic>(<italic>t</italic>), and we refer to the vector <bold>x</bold> as the state of the network.</p>
<p>Neural activity has to generate the output in some subspace of the state space, where each axis represents the activity of one neuron. In the simplest case (<xref ref-type="fig" rid="fig1">Fig. 1B</xref>, top), the output is produced along the largest PCs of activity, as shown by the fact that projecting the neural activity <bold>x</bold>(<italic>t</italic>) onto the largest PCs returns the target oscillation (<xref ref-type="fig" rid="fig1">Fig. 1D</xref>, top). We call such dynamics “aligned” because of the alignment between the subspace spanned by the largest PCs and the output vector (red).</p>
<p>There is, however, another possibility. Neural activity may have many other components not directly related to the output and these other components may even dominate the overall activity. In this case (<xref ref-type="fig" rid="fig1">Fig. 1B-D</xref>, bottom), the two largest PCs are not enough to read out the output, and smaller PCs are needed. We call such dynamics “oblique” because the subspace spanned by the largest PCs and the output vector are poorly aligned.</p>
<p>We consider these two possibilities as distinct dynamical regimes, noting that intermediate situations are also possible. The actual regime of neural dynamics has important consequences for how one interprets neural recordings. For aligned dynamics, analyzing the dynamics within the largest PCs may lead to insights about the computations generating the output [<xref ref-type="bibr" rid="c80">80</xref>]. For oblique dynamics, such an analysis is hampered by the dissociation between the large PCs and the components generating the output [<xref ref-type="bibr" rid="c61">61</xref>].</p>
<fig id="fig2" position="float" fig-type="figure">
<label>Fig. 2:</label>
<caption><p>Aligned and oblique dynamics for a cycling task [<xref ref-type="bibr" rid="c61">61</xref>]. <bold>A</bold> A network with two outputs was trained to generate either clockwise or anticlockwise rotations, depending on the context (top). Our model RNN (bottom) received a context input pulse, generated dynamics <bold>x</bold>(<italic>t</italic>) via recurrent weights <italic>W</italic>, and yielded the output as linear projections of the states. We trained the recurrent weights <italic>W</italic> with gradient descent. <bold>B-C</bold> Resulting internal dynamics for two networks with small (top) and large (bottom) output weights, corresponding to aligned and oblique dynamics, respectively. <bold>B</bold> Dynamics projected on the first 2 PCs and the remaining direction <bold>w</bold><sub>out,⊥</sub> of the first output vector (for <italic>z</italic><sub>1</sub>). The output weights are amplified to be visible. Arrowheads indicate the direction of the dynamics. Note that for the large output weights, the dynamics in the first two PCs co-rotated, despite the counter-rotating output. <bold>C</bold> Output reconstructed from the largest PCs, with dimension <italic>D</italic> = 2 (full lines) or 8 (dotted). Two dimensions already yield a fit with <italic>R</italic><sup>2</sup> = 0.99 for aligned dynamics (top), but almost no output for oblique (bottom, <italic>R</italic><sup>2</sup> = 0.005, no arrows shown). For the latter, a good fit with <italic>R</italic><sup>2</sup> &gt; 90% is only reached with <italic>D</italic> = 8.</p></caption>
<graphic xlink:href="2307.07654v3_fig2.tif" mime-subtype="tif" mimetype="image"/>
</fig>
</sec>
<sec id="s2-2">
<title>2.2. Magnitude of output weights controls regime in trained RNNs</title>
<p>What determines which regime a neural network operates in? Given that behavior is the same, but representations differ, we study this question using trained RNNs. This framework constrains what networks do, but not how they do it [<xref ref-type="bibr" rid="c3">3</xref>, <xref ref-type="bibr" rid="c74">74</xref>]. The specific property of representation we are interested in is the alignment, or correlation, between output weights and states:
<disp-formula id="FD2">
<alternatives>
<mml:math id="M2" display="block"><mml:mrow><mml:mrow><mml:mi>ρ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msubsup><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msubsup><mml:mtext>x</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>/</mml:mo><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mtext> </mml:mtext><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:mtext>x</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn2.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(2)</label>
</disp-formula>
</p>
<p>where the vector norms ║w<sub>out</sub>║ and ║x║ quantify the magnitude of each vector.</p>
<p>For aligned dynamics, the correlation is large, corresponding to the alignment between the leading PCs of the neural activity and the output weights (<xref ref-type="fig" rid="fig1">Fig. 1B</xref> top). In contrast, for oblique dynamics, this correlation is small (<xref ref-type="fig" rid="fig1">Fig. 1B</xref> bottom). Note that the concept of correlation can be generalized to accommodate multiple time points and multidimensional output (see Section 4.3).</p>
<p>Studying the same task means that the output <italic>z</italic> is the same, so it is instructive to express it in terms of the correlation <italic>ρ</italic>:
<disp-formula id="FD3">
<alternatives>
<mml:math id="M3" display="block"><mml:mi>z</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>ρ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mtext> </mml:mtext><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:mtext>x</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn3.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(3)</label>
</disp-formula>
</p>
<p>Recent work on feed-forward networks showed that ║<bold>w</bold><sub>out</sub>║ can have a large effect on the resulting representations [<xref ref-type="bibr" rid="c9">9</xref>, <xref ref-type="bibr" rid="c27">27</xref>]. <xref ref-type="disp-formula" rid="FD3">Equation (3)</xref> shows that <italic>ρ</italic> is indeed linked to ║w<sub>out</sub>║, but ║x(<italic>t</italic>)║ can also vary. In a detailed analysis in the Methods (Sections 4.7 to 4.9), we show that for recurrent networks, stability considerations preclude ║<bold>x</bold>(<italic>t</italic>)║ from being small. This implies that if we choose a readout norm ║<bold>w</bold><sub>out</sub>║ and then train the RNN on a given task, the correlation must compensate.</p>
<fig id="fig3" position="float" fig-type="figure">
<label>Fig. 3:</label>
<caption><p>The magnitude of output weights determines regimes across multiple neuroscience tasks [<xref ref-type="bibr" rid="c41">41</xref>, <xref ref-type="bibr" rid="c59">59</xref>, <xref ref-type="bibr" rid="c61">61</xref>, <xref ref-type="bibr" rid="c76">76</xref>]. <bold>A</bold> Correlation and norms of output weights and neural activity. For each task, we initialized networks with small or large output weights (dark vs light orange). The initial norms ║w<sub>out</sub>║ are indicated by the dashed lines. Learning only weakly changes the norm of the output weights. Note that all y-axes are logarithmically scaled. <bold>B</bold> Variance of <bold>x</bold> explained and <italic>R</italic><sup>2</sup> of reconstructed output for projections of <bold>x</bold> on increasing number of PCs. Results from one example network trained on the cycling task are shown for each condition. <bold>C</bold> Number of PCs necessary to reach 90% of the variance of <bold>x</bold>(<italic>t</italic>) or of the <italic>R</italic><sup>2</sup> of the output reconstruction (top/bottom; dotted lines in <bold>B</bold>). In <bold>A, C</bold>, violin plots show the distribution over 5 sample networks, with vertical bars indicating the mean and the extreme values (where visible).</p></caption>
<graphic xlink:href="2307.07654v3_fig3.tif" mime-subtype="tif" mimetype="image"/>
</fig>
<p>If we choose small output weights, we expect aligned dynamics, because a large correlation is necessary to generate sufficiently large output (<xref ref-type="fig" rid="fig1">Fig. 1B</xref> top). If instead we choose large output weights, we expect oblique dynamics, because only a small correlation keeps the output magnitude from growing too large.</p>
<p>We tested whether output weights can serve as a control knob to select dynamical regimes using an RNN model trained on an abstract version of the cycling task introduced in Ref. [<xref ref-type="bibr" rid="c61">61</xref>]. The networks were trained to generate a 2D signal that rotated in the plane spanned by two outputs <italic>z</italic><sub>1</sub>(<italic>t</italic>) and <italic>z</italic><sub>2</sub>(<italic>t</italic>) (<xref ref-type="fig" rid="fig2">Fig. 2A</xref>). An input pulse at the beginning of each trial indicated the desired direction of rotation. We set up two models with either small or large output weights and trained the recurrent weights of each with gradient descent (Section 4.1).</p>
<p>After both models learned the task, we projected the network activity into a three-dimensional space spanned by the two largest PCs of the dynamics <bold>x</bold>(<italic>t</italic>). A third direction, <bold>w</bold><sub>out,⊥</sub>, spanned the remaining part of the first output vector <bold>w</bold><sub>out,1</sub>. The resulting plots, <xref ref-type="fig" rid="fig2">Fig. 2B</xref>, corroborate our hypothesis: Small output weights led to aligned dynamics with a large correlation between the largest PCs and the output weights. In contrast, the large output weights of the second network were almost orthogonal, or oblique, to the two leading PCs. Further qualitative differences between the two solutions in terms of the direction of trajectories will be discussed below.</p>
<p>Another way to quantify these regimes is by the ability to reconstruct the output from the large PCs of neural activity, as quantified by the coefficient of determination <italic>R</italic><sup>2</sup>. For the aligned network, the projection on the two largest PCs (<xref ref-type="fig" rid="fig2">Fig. 2C</xref>, solid) already led to a good reconstruction. For the oblique networks, the two largest PCs were not sufficient. We needed the first eight dimensions (<xref ref-type="fig" rid="fig2">Fig. 2C</xref>, dashed) to obtain a good reconstruction (<italic>R</italic><sup>2</sup> &gt; 0.9). In contrast to the differences in these fits, the neural dynamics themselves were much more similar between the networks. Specifically, 90% of the variance was explained by 4 and 5 dimensions for the aligned and oblique networks, respectively.</p>
<p>Can we use the output weights to induce aligned or oblique dynamics in more general settings? We trained RNN models with small or large initial output weights on five different neuroscience tasks (Section 4.2). All weights (input, recurrent, and output) were trained using the Adam algorithm (Section 4.1). After training, we measured the three quantities of <xref ref-type="disp-formula" rid="FD3">Eq. (3)</xref>: magnitudes of neural activity and output weights, and the correlation between the two. The results in <xref ref-type="fig" rid="fig3">Fig. 3A</xref> show that across tasks, initialization with large output weights led to oblique dynamics (small correlation), and with small output weights to aligned dynamics (large correlation). While training could, in principle, change the initially small output weights to large ones (and vice versa), we noticed that this does not happen. Small output weights did increase with training, but the large gap in norms remained. This shows that setting the output weights at initialization can serve to determine their scale after learning under realistic settings. While explaining this observation is beyond the scope of this work, we note that (1) changing the internal weights suffices to solve the task, and (2) the extent to which the output weights change during learning depends on the algorithm and specific parametrization [<xref ref-type="bibr" rid="c21">21</xref>, <xref ref-type="bibr" rid="c27">27</xref>, <xref ref-type="bibr" rid="c85">85</xref>].</p>
<p>In <xref ref-type="fig" rid="fig3">Fig. 3B-C</xref>, we adopted the perspective of <xref ref-type="fig" rid="fig2">Fig. 2C</xref> and quantified how well we can reconstruct the output from a projection of <bold>x</bold> onto its largest <italic>D</italic> PCs (Section 4.4). As expected, both the variance of <bold>x</bold> explained and the quality of output reconstruction increased, for an increasing number of PCs <italic>D</italic> (<xref ref-type="fig" rid="fig3">Fig. 3B</xref>). How both quantities increased, however, differs between the two regimes. While the variance explained increased similarly in both cases, the quality of the reconstruction increased much more slowly for the model with large output weights. We quantified this phenomenon by comparing the dimensions at which either the variance of <bold>x</bold> explained or <italic>R</italic><sup>2</sup> reaches 90%, denoted by <italic>D</italic><sub><italic>x</italic>,90</sub> and <italic>D</italic><sub>fit,90</sub>, respectively.</p>
<p>In <xref ref-type="fig" rid="fig3">Fig. 3C</xref>, we compare <italic>D</italic><sub><italic>x</italic>,90</sub> and <italic>D</italic><sub>fit,90</sub> across multiple networks and tasks. Generally, larger output weights led to larger numbers for both. However, for large output weights, the number of PCs necessary to obtain a good reconstruction increased much more drastically than the dimension of the data. Thus, the output was less well represented by the large PCs of the dynamics for networks with large output weights, in agreement with our notion of oblique dynamics.</p>
<p>Importantly, reaching the aligned and oblique regimes relies on ensuring robust and stable dynamics, which we achieve by adding noise to the dynamics during training. This yields a similar magnitude of neural activity ║x║ across networks and tasks (<xref ref-type="fig" rid="fig3">Fig. 3A</xref>). We show in Methods, Section 4.7, that learning in simple, noise-free conditions with large output weights can lead to solutions not captured by either aligned or oblique dynamics; those solutions, however, are unstable. Furthermore, we observed that some of the qualitative differences between aligned and oblique dynamics are less pronounced if we initialized networks with small recurrent weights and initially decaying dynamics (<xref ref-type="fig" rid="fig16">Fig. 16</xref>).</p>
</sec>
<sec id="s2-3">
<title>2.3. Neural dynamics decouple from the output for the oblique regime</title>
<p>What are the functional consequences of the two regimes? A hint might be seen in an intriguing qualitative difference between the aligned and oblique solutions for the cycling task in <xref ref-type="fig" rid="fig2">Fig. 2</xref>. For the aligned network, the two trajectories for the two different contexts (green and purple) are counterrotating (<xref ref-type="fig" rid="fig2">Fig. 2B</xref>, top). This agrees with the output, which also counter-rotates as demanded by the task (<xref ref-type="fig" rid="fig2">Fig. 2A</xref>). In contrast, the neural activity of the oblique network <italic>co-rotates</italic> in the leading two PCs (<xref ref-type="fig" rid="fig2">Fig. 2B</xref>, bottom). This is despite the counter-rotating output, since this network also solves the task (not shown). The co-rotation also indicates why reconstructing the output from the leading two PCs is not possible (<xref ref-type="fig" rid="fig2">Fig. 2C</xref>). Naturally, the dynamics also contain counter-rotating trajectories for producing the correct output, but these are only present in low-variance PCs. (Note also that for aligned networks, one can also observe co-rotation in low-variance PCs, see <xref ref-type="fig" rid="fig17">Fig. 17</xref>.) Taken together, aligned and oblique dynamics differ in the coupling between leading neural dynamics and output. For aligned dynamics, the two are strongly coupled. For oblique dynamics, the two decouple qualitatively.</p>
<p>Such a decoupling for oblique, but not aligned, dynamics leads to a prediction regarding the universality of solutions [<xref ref-type="bibr" rid="c39">39</xref>, <xref ref-type="bibr" rid="c49">49</xref>, <xref ref-type="bibr" rid="c79">79</xref>]. For aligned dynamics, the coupling implies that the internal dynamics are strongly constrained by the task. We thus expect different learners to converge to similar solutions, even if their initial connectivity is random and unstructured. In <xref ref-type="fig" rid="fig4">Fig. 4A</xref>, we show the dynamics of three randomly initialized aligned networks trained on the cycling task, projected onto the three leading PCs. Apart from global rotations, the dynamics in the three networks are very similar.</p>
<fig id="fig4" position="float" fig-type="figure">
<label>Fig. 4:</label>
<caption><p>Variability between learners for the two regimes. <bold>A-B</bold> Examples of networks trained on the cycling task with small (aligned) or large (oblique) output weights. The top left and central networks, respectively, are the same as those plotted in <xref ref-type="fig" rid="fig2">Fig. 2</xref>. <bold>C</bold> Dissimilarity between solutions across different tasks. Aligned dynamics (red) were less dissimilar to each other than oblique ones (yellow). The violin plots show the distribution over all possible different pairs for five samples (mean and extrema as bars).</p></caption>
<graphic xlink:href="2307.07654v3_fig4.tif" mime-subtype="tif" mimetype="image"/>
</fig>
<p>For oblique dynamics, the task-defined output exerts weaker constraints on the internal dynamics. Any variability experienced during learning can potentially build up, and eventually create qualitatively different solutions. Three examples of oblique networks solving the cycling tasks indeed show visibly different dynamics (<xref ref-type="fig" rid="fig4">Fig. 4B</xref>). Further analysis shows that the models also differ in the frequency components in the leading dynamics (<xref ref-type="fig" rid="fig18">Fig. 18</xref>).</p>
<p>The degree of variability between learners depends on the task. The differences observable in the PC projections were most striking for the cycling task. For the flipflop task, for example, solutions were generally noisier in the oblique regime than in the aligned but did not have observable qualitative differences in either regime (<xref ref-type="fig" rid="fig19">Fig. 19</xref>). We quantified the difference between models for the different neuroscience tasks considered before. To compare different neural dynamics, we used a dissimilarity measure invariant under rotation (Section 4.5) [<xref ref-type="bibr" rid="c83">83</xref>]. The results are shown in <xref ref-type="fig" rid="fig4">Fig. 4C</xref>. Two observations stand out: First, across tasks, the dissimilarity was higher for networks in the oblique regime than for those in the aligned. Second, both overall dissimilarity and the discrepancy between regimes differed strongly between tasks. The largest dissimilarity (for oblique dynamics) and the largest discrepancy between regimes was found for the cycling. The smallest discrepancy between regimes was found for the flipflop task. Such a difference between tasks is consistent with the differences in the range of possible solutions for different tasks, as reported in Refs. [<xref ref-type="bibr" rid="c39">39</xref>, <xref ref-type="bibr" rid="c79">79</xref>].</p>
<p>What are the underlying mechanisms for the qualitative decoupling in oblique, but not aligned networks? For aligned dynamics, we saw that the small output weights demand large activity to generate the output. In other words, the activity along the largest PCs must be coupled to the output. For oblique dynamics, this constraint is not present, which opens the possibility for small components outside the largest PCs to generate the output. If this is the case, we have a decoupling, such as the observed co-rotation in the cycling task, and the possible variability between solutions. We discuss this point in more detail in the Methods, Section 4.10.</p>
<p>In the following two sections, we will explore how the decoupling between neural dynamics and output for oblique, but not aligned, dynamics influences the response to perturbations and the effects of noise during learning.</p>
<fig id="fig5" position="float" fig-type="figure">
<label>Fig. 5:</label>
<caption><p>Perturbations differentially affect dynamics in the aligned and oblique regimes. <bold>A</bold> Cartoon illustrating the relationship between perturbations along output weights or PCs and the feedback loops driving autonomous dynamics. <bold>B</bold> Output after perturbation for aligned (top) and oblique (bottom) networks trained on the cycling task. The unperturbed network (light red line) yields a sine wave along the first output direction <italic>z</italic><sub>1</sub>. At <italic>t<sub>p</sub></italic> = 9, a perturbation with amplitude ║Δx║ = 34 is applied along the output weights (dashed red) or the first PC (dashed-dotted blue). The perturbations only differ in the directions applied. While the immediate response for the oblique network to a perturbation along the output weights is much larger, <italic>z</italic><sub>1</sub>(<italic>t<sub>p</sub></italic>) ≈ 80, the long-term dynamics yield the same output as the unperturbed network. See also <xref ref-type="fig" rid="fig20">Fig. 20</xref> for more details. <bold>C</bold> Loss for perturbations of different amplitudes for the two networks in <bold>B</bold>. Lines and shades are means and std devs over different perturbation times <italic>t<sub>p</sub></italic> ∈ [<xref ref-type="bibr" rid="c5">5</xref>, <xref ref-type="bibr" rid="c15">15</xref>] and random directions spanned by the output weights (red) or the two largest PCs (blue). The loss is the mean squared error between output and target for <italic>t</italic> &gt; 20. The gray dot indicates an example in <bold>B</bold>. <bold>D</bold> Relative susceptibility of networks to perturbation directions for different tasks and dynamical regimes. We measured the area under the curve (AUC) of loss over perturbation amplitude for perturbations along the output weights of the two largest PCs. The relative susceptibility is the ratio between the two AUCs. The example in <bold>C</bold> is indicated by gray triangles.</p></caption>
<graphic xlink:href="2307.07654v3_fig5.tif" mime-subtype="tif" mimetype="image"/>
</fig>
</sec>
<sec id="s2-4">
<title>2.4. Differences in response to perturbations</title>
<p>Understanding how networks respond to external perturbations and internal noise requires some insight into how dynamics are generated. Dynamics of trained networks are mostly generated internally, through recurrent interactions. In robust networks, these internally generated dynamics are a prominent part of the largest PCs (among input-driven components; Sections 4.7 and 4.9). Internally-generated dynamics are sustained by positive feedback loops, through which neurons excite each other. Those loops are low-dimensional, with activity along a few directions of the dynamics being amplified and fed back along the same directions. This results in dynamics being driven by effective feedback loops along the largest PCs (<xref ref-type="fig" rid="fig5">Fig. 5A</xref>). As shown above, the largest PCs can either be aligned or not aligned, with the output weights. This leads to predictions about how aligned and oblique networks differentiate in their responses to perturbations along different directions.</p>
<p>Our intuition about feedback loops suggests that networks respond strongly to a perturbation that is aligned with the directions contributing to the feedback loop, but weakly to a perturbation that is orthogonal to them. In particular, if a perturbation is applied along the output weights, aligned and oblique dynamics should dissociate, with a strong disruption of dynamics for aligned, but not for oblique dynamics (<xref ref-type="fig" rid="fig5">Fig. 5A</xref>).</p>
<p>To test this, we compare the response to perturbations along the output direction and the largest PCs. We apply perturbations to the neural activity at a single point in time: <bold>x</bold>(<italic>t</italic>) evolves undisturbed until time <italic>t<sub>p</sub></italic>. At that point, it is shifted to <bold>x</bold>(<italic>t<sub>p</sub></italic>) + Δ<bold>x</bold>. After the perturbation, we let the network evolve freely and compare this evolution to that of an unperturbed copy. Such a perturbation mimics a very short optogenetic perturbation applied to a selected neural population [<xref ref-type="bibr" rid="c14">14</xref>, <xref ref-type="bibr" rid="c46">46</xref>]. In <xref ref-type="fig" rid="fig5">Fig. 5B</xref>, we show the output after such perturbations for an aligned (top) and an oblique network (bottom) trained on the cycling task. The time point and amplitude are the same for both directions and networks. For each network and type of perturbation, there is an immediate deflection and a long-term response. For both networks, perturbing along the PCs (blue) leads to a long-term phase shift. Only in the aligned network, however, perturbation along the output direction (red) leads to a visible long-term response. In the oblique network, the amplitude of the immediate response is larger, but the long-term response is <italic>smaller</italic>. Our results for the oblique network, but not for the aligned, agree with simulations of networks generating EMG data from the cycling experiments [<xref ref-type="bibr" rid="c65">65</xref>].</p>
<fig id="fig6" position="float" fig-type="figure">
<label>Fig. 6:</label>
<caption><p>Noise suppression along the output direction in the oblique regime. <bold>A</bold> A cartoon of the feedback loop structure for aligned (top) and oblique (bottom) dynamics. The latter develops a negative feedback loop which suppresses fluctuations along the output direction. <bold>B</bold> Comparing the distribution of variance of mean-subtracted activity along different directions for networks trained on the cycling task (see <xref ref-type="fig" rid="fig21">Fig. 21</xref>): PCs of trial-averaged activity (blue), readout (red), and random (grey) directions. For the PCs and output weights, we sampled 100 normalized combinations of either the first two PCs or the two output vectors. For the random directions, we drew 1000 random vectors in the full, <italic>N</italic>-dimensional space. <bold>C</bold> Noise compression across tasks as measured by the ratio between variance along output and random directions. The dashed line indicates neither compression nor expansion. Black markers indicate the values for the two examples in <bold>B-C</bold>. Note the log-scales in <bold>B-C</bold>.</p></caption>
<graphic xlink:href="2307.07654v3_fig6.tif" mime-subtype="tif" mimetype="image"/>
</fig>
<p>To quantify the relative long-term susceptibility of networks to perturbations along output weights or PCs, we sampled from different times <italic>t<sub>p</sub></italic> and different directions in the 2D subspaces spanned either by the two output vectors or the two largest PCs. For each perturbation, we measured the loss of the perturbed networks on the original task (excluding the immediate deflection after the perturbation by starting to compute the loss at <italic>t<sub>p</sub></italic> + 5). <xref ref-type="fig" rid="fig5">Fig. 5C</xref> shows that the aligned network is almost equally susceptible to perturbations along the PCs and the output weights. In contrast, the oblique network is much more susceptible to perturbations along the PCs.</p>
<p>We repeated this analysis for oblique and aligned networks trained on the five different tasks. We computed the area under the curve (AUC) for both loss profiles in <xref ref-type="fig" rid="fig5">Fig. 5C</xref>. We then defined the “relative susceptibility” as the ratio AUC<sub>wout</sub>/AUC<sub>PC</sub>, <xref ref-type="fig" rid="fig5">Fig. 5D</xref>. For aligned networks (red), the relative susceptibility was close to 1 indicating similarly strong responses to both types of perturbations. For oblique networks (yellow), it was much smaller than 1, indicating that long-term responses to perturbations along the output direction were weaker than those to perturbations along the PCs.</p>
</sec>
<sec id="s2-5">
<title>2.5. Noise suppression for oblique dynamics</title>
<p>In the oblique regime, the output weights are large. To produce the correct output (and not a too large one), the large PCs of the dynamics are almost orthogonal to the output weights. The large output weights, however, pose a robustness problem: Small noise in the direction of the output weights is also amplified at the level of the readout. We show that learning leads to a slow process of sculpting noise statistics to avoid this effect (<xref ref-type="fig" rid="fig11">Fig. 11</xref>). Specifically, a negative feedback loop is generated that suppresses fluctuations along the output direction (<xref ref-type="fig" rid="fig6">Fig. 6A</xref>, <xref ref-type="fig" rid="fig10">Fig. 10</xref>) [<xref ref-type="bibr" rid="c29">29</xref>]. Because the positive feedback loop that gives rise to the large PCs is mostly orthogonal to the output direction, it remains unaffected by this additional negative feedback loop. A detailed analysis of how learning is affected by noise shows that, for large output weights, the network first learns a solution that is not robust to noise. This solution is then transformed to increasingly stable and oblique dynamics over longer time scales (Sections 4.8 and 4.9).</p>
<p>To illustrate the effect of the negative feedback loop, we consider the fluctuations around trial averages. We take a collection of states <bold>x</bold>(<italic>t</italic>) and then subtract the task-conditioned averages <inline-formula id="ID1">
<alternatives>
<mml:math display="inline" id="I1"><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq1.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> to compute <italic>δ</italic>x(<italic>t</italic>) = <bold>x</bold>(<italic>t</italic>) − <inline-formula id="ID2">
<alternatives>
<mml:math display="inline" id="I2"><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq2.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. We then project <italic>δ</italic><bold>x</bold>(<italic>t</italic>) onto three different direction categories: the largest PCs of the averaged data <inline-formula id="ID3">
<alternatives>
<mml:math display="inline" id="I3"><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq3.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, the output directions, or randomly drawn directions.</p>
<p>How strongly the activity fluctuates along each direction is quantified by the variance of the projections (<xref ref-type="fig" rid="fig6">Fig. 6B</xref>). For both aligned and oblique dynamics, the variance is much larger along the PCs than along random directions. This is not necessarily expected, because the PCA was performed on the <italic>averaged</italic> activity, without the fluctuations. Instead, it is a dynamical effect: the same positive feedback that generates the autonomous dynamics also amplifies the noise (Section 4.9).</p>
<p>The two network regimes, however, dissociate when considering the variance along the output direction. For aligned dynamics, there is no negative feedback loop, and <bold>w</bold>out is correlated with the PCs. The variance along the output direction is hence similar to that along the PCs, and larger than along random directions. For oblique dynamics, the negative feedback loop suppresses the fluctuations along the output direction, so that they become weaker than along random directions.</p>
<p>In <xref ref-type="fig" rid="fig6">Fig. 6C</xref>, we quantify this dissociation across different tasks. We measured the ratio between variance along output and random directions. Aligned networks have a ratio much larger than one, indicating that the fluctuations along the output direction are increased due to the autonomous dynamics along the PCs. In contrast, oblique networks have a ratio smaller than 1 for all tasks, which indicates noise compression along the output.</p>
</sec>
<sec id="s2-6">
<title>2.6. Different degrees of alignment in experimental settings</title>
<p>For the cycling task, we observed that dynamics were qualitatively different for the two regimes, with trajectories either counter- or co-rotating (<xref ref-type="fig" rid="fig2">Fig. 2B</xref>). Interestingly, the experimental results of Russo et al. [<xref ref-type="bibr" rid="c61">61</xref>] matched the oblique, but not the aligned dynamics. The authors observed co-rotating dynamics in the leading PCs of motor cortex activity despite counter-rotating activity of simultaneously recorded muscle activity. Here we test whether our theory can help to more clearly and quantitatively distinguish between the two regimes in experimental settings.</p>
<p>In typical experimental settings, we do not have direct access to output weights. We can, however, approximate these by fitting neural data to simultaneously recorded behavioral output, such as hand velocity in a motor control experiment (<xref ref-type="fig" rid="fig7">Fig. 7A</xref> top). Following the model above, where the output is a weighted average of the states, we reconstruct the output from the neural activity with linear regression. To quantify the dynamical regime, we then compute the correlation <italic>ρ</italic> between the weights from fitting and the neural data. Additionally, we can also quantify the alignment by the “relative fitting dimension” <italic>D</italic><sub>fit,90</sub>/<italic>D</italic><sub><italic>x</italic>,90</sub>, where <italic>D</italic><sub>fit,90</sub> is the number of PCs necessary to recover the output and <italic>D</italic><sub><italic>x</italic>,90</sub> number to the number of PCs necessary to represent 90% of the variance of the neural data. We computed both the correlation and the relative fitting dimension for different publicly available data sets (<xref ref-type="fig" rid="fig7">Fig. 7B</xref>). For details, see Section 4.6.</p>
<p>We started with data sets from two monkeys performing the cycling task [<xref ref-type="bibr" rid="c61">61</xref>]. The data contained motor cortex activity, hand movement, and EMG from the arms, all averaged over multiple trials of the same condition. In <xref ref-type="fig" rid="fig7">Fig. 7B</xref>, we show results for reconstructing the hand velocity. The correlation was small, <italic>ρ</italic> ∈ [0.04, 0.07]. To obtain a good reconstruction, we needed a substantial fraction of the dimension of the neural data: The relative fitting dimension was <italic>D</italic><sub>fit,90</sub>/<italic>D</italic><sub><italic>x</italic>,90</sub> ∈ [0.7, 0.8]. Our results agree with previous studies, showing that the best decoding directions are only weakly correlated with the leading PCs of motor cortex activity [<xref ref-type="bibr" rid="c66">66</xref>].</p>
<p>We also analyzed data made available through the Neural Latents Benchmark (NLB) [<xref ref-type="bibr" rid="c52">52</xref>]. In two different tasks, monkeys needed to perform movements along a screen. In a random target task (RTT), the monkeys had to point at a randomly generated target position on a screen, with a successive target point generated once the previous one was reached [<xref ref-type="bibr" rid="c40">40</xref>]. In a maze task, the monkeys were trained to follow a trajectory through a maze with their hand [<xref ref-type="bibr" rid="c10">10</xref>]. In both cases, we reconstructed the finger or hand velocity from neural activity on single trials. The correlation was higher than in the cycling task, <italic>ρ</italic> = 0.13. The relative fitting dimension was lower than in the trial-averaged cycling data, albeit still on the same order: <italic>D</italic><sub>fit,90</sub>/<italic>D</italic><sub><italic>x</italic>,90</sub> ∈ [0.4, 0.5].</p>
<fig id="fig7" position="float" fig-type="figure">
<label>Fig. 7:</label>
<caption><p>Quantifying aligned and oblique dynamics in experimental data [<xref ref-type="bibr" rid="c12">12</xref>, <xref ref-type="bibr" rid="c22">22</xref>, <xref ref-type="bibr" rid="c25">25</xref>, <xref ref-type="bibr" rid="c52">52</xref>, <xref ref-type="bibr" rid="c61">61</xref>]. <bold>A</bold> Diagram of the two types of experimental data considered. Here we always took the velocity as the output (hand, finger, or cursor). In motor control experiments (top), we first needed to obtain the output weights <bold>w</bold><sub>out</sub> via linear regression. We then computed the correlation <italic>ρ</italic> and the reconstruction dimension <italic>D</italic><sub>fit,90</sub>, i.e. the number of PCs of <bold>x</bold> necessary to obtain a coefficient of determination <italic>R</italic><sup>2</sup> &gt; 90%. In BCI experiments (bottom), the output (cursor velocity) is generated from neural activity <bold>x</bold>(<italic>t</italic>) via output weights <bold>w</bold><sub>out</sub> defined by the experimenter. This allowed us to directly compute correlations and fitting dimensions. <bold>B</bold> Correlation <italic>ρ</italic> (top) and relative fitting dimension <italic>D</italic><sub>fit,90</sub>/<italic>D</italic><sub><italic>x</italic>,90</sub> (bottom) for several publicly available data sets. The cycling task data (purple) were trial-conditioned averages, the BCI experiments (red) and NLB tasks (yellow) single-trial data. Results for the full data sets are shown as dots. Violin plots indicate results for 20 random subsets of 25% of the data points in each data set (bars indicate mean). See small text below x-axis for the number of time points and neurons.</p></caption>
<graphic xlink:href="2307.07654v3_fig7.tif" mime-subtype="tif" mimetype="image"/>
</fig>
<p>Finally, we considered brain-computer interface (BCI) experiments [<xref ref-type="bibr" rid="c63">63</xref>]. In these experiments, monkeys were trained to control a cursor on a screen via activity read out from their motor cortex (<xref ref-type="fig" rid="fig7">Fig. 7A</xref> bottom). The output weights generating the cursor velocity were set by the experimenter (so we don’t need to fit). Importantly, the output weights were typically chosen to be spanned by the largest PCs (the “neural manifold”), suggesting aligned dynamics. For three example data sets [<xref ref-type="bibr" rid="c12">12</xref>, <xref ref-type="bibr" rid="c22">22</xref>, <xref ref-type="bibr" rid="c25">25</xref>], we obtained higher correlation values, <italic>ρ</italic> ∈ [0.17, 0.23] (<xref ref-type="fig" rid="fig7">Fig. 7B</xref>). The relative fitting dimension was much smaller than for the non-BCI data sets, especially for the two largest data sets, where <italic>D</italic><sub>fit,90</sub>/<italic>D</italic><sub><italic>x</italic>,90</sub> ∈ [0.03, 0.06].</p>
<p>The higher correlation and much smaller relative fitting dimension suggest that, indeed, the neural dynamics arising in BCI experiments are more aligned, and those in non-BCI settings are more oblique. These trends also hold when decoding other behavioral outputs for the cycling task and the NLB tasks (position, acceleration, or EMG), even if the ability to decode and the numerical values for correlation and fitting dimension may fluctuate considerably (<xref ref-type="fig" rid="fig22">Fig. 22</xref>). Thus, while we do not observe strongly different regimes as in the simulations, we do see an ordering between different data sets according to the alignment between outputs and neural dynamics. It would be interesting to test the differences between BCI and non-BCI data on larger data sets, and different experiments with different dimensions of neural data [<xref ref-type="bibr" rid="c20">20</xref>, <xref ref-type="bibr" rid="c71">71</xref>].</p>
</sec>
</sec>
<sec id="s3" sec-type="discussion">
<title>3. Discussion</title>
<p>We analyzed the relationship between neural dynamics and behavior, asking to which extent a network’s output is represented in its dynamics. We identified two different limiting regimes: aligned dynamics, in which the dominant activity in a network is related to its output, and oblique dynamics, where the output is only a small modulation on top of the dominating dynamics. We demonstrated that these two regimes have different functional implications. We also examined how they arise through learning, and how they relate to experimental findings.</p>
<p>Linking neural activity to external variables is one of the core challenges of neuroscience [<xref ref-type="bibr" rid="c26">26</xref>]. In most cases, however, such links are far from perfect. The activity of single neurons can be related in a nonlinear, mixed manner, to task variables [<xref ref-type="bibr" rid="c56">56</xref>]. Even when considering populations of neurons, a large fraction of neural activity is not easily accounted for by external variables [<xref ref-type="bibr" rid="c1">1</xref>]. Various explanations have been proposed for this disconnect. In the visual cortex, activity has been shown to be related to “irrelevant” external variables, such as body movements [<xref ref-type="bibr" rid="c72">72</xref>]. Follow-up work showed that, in primates, some of these effects can be explained by the induced changes on retinal images [<xref ref-type="bibr" rid="c78">78</xref>], but this study still explained only half of the neural variability. An alternative explanation hinges on the redundancy of the neural code, which allows “null spaces” in which activity can visit without affecting behavior [<xref ref-type="bibr" rid="c30">30</xref>, <xref ref-type="bibr" rid="c31">31</xref>, <xref ref-type="bibr" rid="c58">58</xref>]. Through the oblique regime, our study offers a simple explanation for this phenomenon: in the presence of large output weights, resistance to noise or perturbations requires large, potentially task-unrelated neural dynamics. Conversely, generating task-related output in the presence of large, task-unrelated dynamics requires large readout weights.</p>
<p>We showed theoretically and in simulations that, when training recurrent neural networks, the magnitude of output weights is a central parameter that controls which regime is reached. This finding is vital for the use of RNNs as hypothesis generators [<xref ref-type="bibr" rid="c3">3</xref>, <xref ref-type="bibr" rid="c74">74</xref>, <xref ref-type="bibr" rid="c80">80</xref>], where it is often implicitly assumed that training results in universal solutions [<xref ref-type="bibr" rid="c39">39</xref>] (even though biases in the distribution of solutions have been discussed [<xref ref-type="bibr" rid="c77">77</xref>]). Here, we show that a specific control knob allows one to move between qualitatively different solutions of the same task, thereby expanding the control over the hypothesis space [<xref ref-type="bibr" rid="c49">49</xref>, <xref ref-type="bibr" rid="c79">79</xref>]. Note in particular that the default initialization in standard learning frameworks has large output weights, which results in oblique dynamics (or unstable solutions if training without noise, see Methods, Section 4.7).</p>
<p>The role of the magnitude of output weights is also discussed in machine learning settings, where different learning regimes have been found [<xref ref-type="bibr" rid="c9">9</xref>, <xref ref-type="bibr" rid="c27">27</xref>, <xref ref-type="bibr" rid="c28">28</xref>, <xref ref-type="bibr" rid="c43">43</xref>]. In particular, “lazy” solutions were observed for large output weights in feed-forward networks. We show in Methods, Section 4.7, that these are unstable for recurrent networks and are replaced in a second phase of learning by oblique solutions. This second, slower, phase is reminiscent of implicit regularization in overparameterized networks [<xref ref-type="bibr" rid="c5">5</xref>, <xref ref-type="bibr" rid="c35">35</xref>, <xref ref-type="bibr" rid="c55">55</xref>, <xref ref-type="bibr" rid="c86">86</xref>]. On a broader scale, which learning regime is relevant when modeling biological learning is an open question that has only just begun to be explored [<xref ref-type="bibr" rid="c15">15</xref>, <xref ref-type="bibr" rid="c37">37</xref>].</p>
<p>The particular control knob we studied has an analog in the biological circuit - the synaptic weights. We can thus use experimental data to study whether the brain might rely on oblique or aligned dynamics. Existing experimental work has partially addressed this question. In particular, the work by Russo et al. [<xref ref-type="bibr" rid="c61">61</xref>] has been a major inspiration for our study. Our results share some of the key findings from that paper - the importance of stability leading to “untangled” dynamics [<xref ref-type="bibr" rid="c73">73</xref>] and a dissociation between hidden dynamics and output. In addition, we suggest a specific mechanism to reach oblique dynamics - training networks with large output weights. Furthermore, we characterize the aligned and oblique regimes along experimentally accessible axes.</p>
<p>We see three avenues for exploring our results experimentally. First, simultaneous measurements of neural dynamics and muscle activity could be used to quantify noise along the output direction. This would allow checking whether noise is compressed in this direction, and in particular, whether such compression occurs on a slow timescale after initial task acquisition. We suggest how to test this in <xref ref-type="fig" rid="fig6">Fig. 6C</xref>. Second, we show how the dynamical regimes dissociate under perturbations along specific directions. Experiments along these lines have recently become possible [<xref ref-type="bibr" rid="c8">8</xref>, <xref ref-type="bibr" rid="c14">14</xref>, <xref ref-type="bibr" rid="c60">60</xref>]. Future work is left to combine our model with biological constraints that induce additional effects during perturbations, e.g., through non-normal synaptic connectivity [<xref ref-type="bibr" rid="c6">6</xref>, <xref ref-type="bibr" rid="c32">32</xref>, <xref ref-type="bibr" rid="c38">38</xref>, <xref ref-type="bibr" rid="c46">46</xref>]. Third, our work connects to the setting of brain-computer interfaces, where the experimenter chooses the output weights at the beginning of learning [<xref ref-type="bibr" rid="c22">22</xref>, <xref ref-type="bibr" rid="c54">54</xref>, <xref ref-type="bibr" rid="c63">63</xref>, <xref ref-type="bibr" rid="c82">82</xref>]. Typically, the output weights are set to lie “within the manifold” of the leading PCs so that we expect aligned dynamics [<xref ref-type="bibr" rid="c63">63</xref>]. In experiments where the output weights were rotated out of the manifold (without changing the norm), learning took longer and led to a rotation of the manifold, i.e. at least a partial alignment [<xref ref-type="bibr" rid="c47">47</xref>]. Our theory suggests directly comparing the degree of alignment between dynamics obtained from within- and out-of-manifold initializations. Furthermore, it would be interesting to systematically change the norm of the output weights (in particular for out-of-manifold initializations) to see whether larger output weights lead to more oblique solutions. If this is the case, we suggest testing whether such more oblique solutions meet our predictions, e.g. higher variability between individuals and noise suppression.</p>
<p>Overall, our results provide an explanation for the plethora of relationships between neural activity and external variables. It will be interesting to see whether future studies will find hallmarks of either regime for different experiments, tasks, or brain regions.</p>
</sec>
<sec id="s7" sec-type="methods">
<title>4. Methods</title>
<sec id="s7-1">
<title>4.1. Details on RNN models and training</title>
<table-wrap id="tbl1" position="float" orientation="portrait">
<label>Table 1:</label>
<caption><p>Task, simulation, and network parameters for <xref ref-type="fig" rid="fig3">Figs. 3</xref> to <xref ref-type="fig" rid="fig6">6</xref></p></caption>
<alternatives>
<graphic xlink:href="2307.07654v3_tbl1.tif" mime-subtype="tif" mimetype="image"/>
<table frame="hsides" rules="groups">
<thead>
<tr>
<th align="left" valign="top">Parameter</th>
<th align="left" valign="top">Symbol</th>
<th align="right" valign="top">Cycling</th>
<th align="right" valign="top">Flip-flop</th>
<th align="right" valign="top">Mante</th>
<th align="right" valign="top">Romo</th>
<th align="right" valign="top">Complex Sine</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"># inputs</td>
<td align="left" valign="top"><italic>N</italic><sub>in</sub></td>
<td align="right" valign="top">2</td>
<td align="right" valign="top">3</td>
<td align="right" valign="top">4</td>
<td align="right" valign="top">1</td>
<td align="right" valign="top">1</td>
</tr>
<tr>
<td align="left" valign="top"># outputs</td>
<td align="left" valign="top"><italic>N</italic><sub>out</sub></td>
<td align="right" valign="top">2</td>
<td align="right" valign="top">3</td>
<td align="right" valign="top">1</td>
<td align="right" valign="top">1</td>
<td align="right" valign="top">1</td>
</tr>
<tr>
<td align="left" valign="top">Trial duration</td>
<td align="left" valign="top"><italic>T</italic></td>
<td align="right" valign="top">72</td>
<td align="right" valign="top">25</td>
<td align="right" valign="top">48</td>
<td align="right" valign="top">29</td>
<td align="right" valign="top">50</td>
</tr>
<tr>
<td align="left" valign="top">Fixation duration</td>
<td align="left" valign="top"><italic>t</italic><sub>fix</sub></td>
<td align="right" valign="top">0</td>
<td align="right" valign="top">U(0,1)</td>
<td align="right" valign="top">3</td>
<td align="right" valign="top">U (1.3)</td>
<td align="right" valign="top">0</td>
</tr>
<tr>
<td align="left" valign="top">Stimulus duration</td>
<td align="left" valign="top"><italic>t</italic><sub>stim</sub></td>
<td align="right" valign="top">1</td>
<td align="right" valign="top">1</td>
<td align="right" valign="top">20</td>
<td align="right" valign="top">1</td>
<td align="right" valign="top">50</td>
</tr>
<tr>
<td align="left" valign="top">Stimulus delay</td>
<td align="left" valign="top"><italic>t</italic><sub>sd</sub></td>
<td align="right" valign="top">–</td>
<td align="right" valign="top">U(3, 10)</td>
<td align="right" valign="top">–</td>
<td align="right" valign="top">U(2, 12)</td>
<td align="right" valign="top">–</td>
</tr>
<tr>
<td align="left" valign="top">Decision delay</td>
<td align="left" valign="top"><italic>t</italic><sub>delay</sub></td>
<td align="right" valign="top">1</td>
<td align="right" valign="top">2</td>
<td align="right" valign="top">5</td>
<td align="right" valign="top">4</td>
<td align="right" valign="top">0</td>
</tr>
<tr>
<td align="left" valign="top">Decision duration</td>
<td align="left" valign="top"><italic>t</italic><sub>dec</sub></td>
<td align="right" valign="top">71</td>
<td align="right" valign="top"><italic>t</italic><sub>sd</sub></td>
<td align="right" valign="top">20</td>
<td align="right" valign="top">8</td>
<td align="right" valign="top">50</td>
</tr>
<tr>
<td align="left" valign="top">Simulation time step</td>
<td align="left" valign="top">△<sub><italic>t</italic></sub></td>
<td align="right" valign="top"/>
<td align="right" valign="top"/>
<td align="right" valign="top">− 0.2 −</td>
<td align="right" valign="top"/>
<td align="right" valign="top"/>
</tr>
<tr>
<td align="left" valign="top">Target time step</td>
<td align="left" valign="top">△<italic>t</italic><sub>target</sub></td>
<td align="right" valign="top">1.0</td>
<td align="right" valign="top">1.0</td>
<td align="right" valign="top">1.0</td>
<td align="right" valign="top">1.0</td>
<td align="right" valign="top">0.2</td>
</tr>
<tr>
<td align="left" valign="top">Activation noise</td>
<td align="left" valign="top"><inline-formula id="ID4">
<alternatives>
<mml:math display="inline" id="I4"><mml:mrow><mml:msqrt><mml:mn>2</mml:mn></mml:msqrt><mml:msub><mml:mi>σ</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>i</mml:mi><mml:mi>s</mml:mi><mml:mi>e</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq4.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula></td>
<td align="right" valign="top">0.2</td>
<td align="right" valign="top">0.2</td>
<td align="right" valign="top">0.05</td>
<td align="right" valign="top">0.2</td>
<td align="right" valign="top">0.2</td>
</tr>
<tr>
<td align="left" valign="top">Initial state noise</td>
<td align="left" valign="top"><italic>σ</italic><sub>init</sub></td>
<td align="right" valign="top"/>
<td align="right" valign="top"/>
<td align="right" valign="top">− 1.0 −</td>
<td align="right" valign="top"/>
<td align="right" valign="top"/>
</tr>
<tr>
<td align="left" valign="top">Network size</td>
<td align="left" valign="top"><italic>N</italic></td>
<td align="right" valign="top"/>
<td align="right" valign="top"/>
<td align="right" valign="top">− 512 −</td>
<td align="right" valign="top"/>
<td align="right" valign="top"/>
</tr>
<tr>
<td align="left" valign="top"># training epochs</td>
<td align="left" valign="top"/>
<td align="right" valign="top">1000</td>
<td align="right" valign="top">4000</td>
<td align="right" valign="top">4000</td>
<td align="right" valign="top">6000</td>
<td align="right" valign="top">6000</td>
</tr>
<tr>
<td align="left" valign="top">Learning rate aligned</td>
<td align="left" valign="top"><italic>η</italic>0</td>
<td align="right" valign="top">0.02</td>
<td align="right" valign="top">0.005</td>
<td align="right" valign="top">0.002</td>
<td align="right" valign="top">0.005</td>
<td align="right" valign="top">0.005</td>
</tr>
<tr>
<td align="left" valign="top">Learning rate oblique</td>
<td align="left" valign="top"><italic>η</italic>0</td>
<td align="right" valign="top">0.02</td>
<td align="right" valign="top">0.01</td>
<td align="right" valign="top">0.02</td>
<td align="right" valign="top">0.01</td>
<td align="right" valign="top">0.005</td>
</tr>
<tr>
<td align="left" valign="top">Batch size</td>
<td align="left" valign="top"/>
<td align="right" valign="top"/>
<td align="right" valign="top"/>
<td align="right" valign="top">− 32 −</td>
<td align="right" valign="top"/>
<td align="right" valign="top"/>
</tr>
</tbody>
</table>
</alternatives>
</table-wrap>
<p>We consider rate-based RNNs with <italic>N</italic> neurons. The states <bold>x</bold>(<italic>t</italic>) ∈ ℝ<sup><italic>N</italic></sup> are governed by
<disp-formula id="FD4">
<alternatives>
<mml:math id="M4" display="block"><mml:mrow><mml:mtext>ẋ</mml:mtext><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mtext>x</mml:mtext><mml:mo>+</mml:mo><mml:mi>W</mml:mi><mml:mi>ϕ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mtext>x</mml:mtext><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:msub><mml:mi>W</mml:mi><mml:mrow><mml:mtext>in</mml:mtext></mml:mrow></mml:msub><mml:mtext>s</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>ξ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math>
<graphic xlink:href="2307.07654v3_eqn4.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(4)</label>
</disp-formula>
</p>
<p>where <italic>W</italic> is a recurrent weight matrix and <italic>ϕ</italic> = tanh a nonlinearity applied element-wise. The network receives a low-dimensional input <bold>s</bold>(<italic>t</italic>) ∈ ℝ<sup><italic>N</italic><sub>in</sub></sup> via input weights <italic>W</italic><sub>in</sub>. It is also driven by white, isotropic noise with zero mean and covariance <inline-formula id="ID5">
<alternatives>
<mml:math display="inline" id="I5"><mml:mrow><mml:mi mathvariant="double-struck">E</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mi>ξ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>ξ</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>noise</mml:mtext></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:msub><mml:mi>δ</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mi>δ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq5.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. The initial states <bold>x</bold>(0) are drawn from a centered normal distribution with variance <inline-formula id="ID6">
<alternatives>
<mml:math display="inline" id="I6"><mml:msubsup><mml:mn>2</mml:mn><mml:mrow><mml:mtext>init</mml:mtext></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq6.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> at each trial. This serves as additional noise. The output is a low-dimensional, linear projection of the states: <bold>z</bold>(<italic>t</italic>) = <italic>W</italic><sub>out</sub><bold>x</bold>(<italic>t</italic>) with <italic>W</italic><sub>out</sub> = [<bold>w</bold><sub>out, 1</sub>, …, <bold>w</bold><sub>out</sub>, <italic>N</italic><sub>out</sub>]<sup><italic>T</italic></sup>.</p>
<p>The initial output weights are drawn from centered normal distributions with variance <inline-formula id="ID7">
<alternatives>
<mml:math display="inline" id="I7"><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mo>/</mml:mo><mml:mi>N</mml:mi></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq7.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. “Small” output weights refer to <inline-formula id="ID8">
<alternatives>
<mml:math display="inline" id="I8"><mml:msub><mml:mi>σ</mml:mi><mml:mrow><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq8.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, and “large” ones to <italic>σ</italic><sub>out</sub> = 1. We have ║w<sub>out,<italic>i</italic></sub>║ = <italic>σ</italic><sub>out</sub>[1 + <italic>O</italic>(1/<inline-formula id="ID9">
<alternatives>
<mml:math display="inline" id="I9"><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq9.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>)] at initialization. Note that large initial output weights are the current default in standard learning environments [<xref ref-type="bibr" rid="c50">50</xref>, <xref ref-type="bibr" rid="c85">85</xref>]. The recurrent weights were initialized from centered normal distributions with variance <italic>g</italic><sup>2</sup><italic>/N</italic>. We chose <italic>g</italic> = 1.5 so that dynamics were chaotic before learning [<xref ref-type="bibr" rid="c70">70</xref>].</p>
<p>To simulate the noisy RNN dynamics numerically, we used the Euler-Maruyama method [<xref ref-type="bibr" rid="c34">34</xref>] with a time step of Δ<italic>t</italic>. We used the Adam algorithm [<xref ref-type="bibr" rid="c33">33</xref>] implemented in PyTorch [<xref ref-type="bibr" rid="c50">50</xref>]. Apart from the learning rate, we kept the parameters for Adam at the default (some filtering, no weight decay). We selected learning rates and the number of training steps such that learning was relatively smooth and converged sufficiently within the given number of trials. Learning rates were set to <italic>η</italic> = <italic>η</italic>0<italic>/N</italic>· Details for all simulation parameters can be found in <xref ref-type="table" rid="tbl1">Table 1</xref>.</p>
<p>For the comparisons over different tasks (<xref ref-type="fig" rid="fig3">Figs. 3</xref> to <xref ref-type="fig" rid="fig6">6</xref>), we trained 5 networks for each task. All weights (<italic>W</italic><sub>out</sub>, <italic>W</italic>, <italic>W</italic><sub>in</sub>) were adapted. For the example networks trained on the cycling task (<xref ref-type="fig" rid="fig2">Figs. 2</xref>, <xref ref-type="fig" rid="fig5">5</xref> and <xref ref-type="fig" rid="fig6">6</xref>), we used networks with <italic>N</italic> = 256 neurons and only changed the recurrent weights <italic>W</italic>. We also trained for longer (5000 training steps) and with a higher learning rate (<italic>η</italic> = 0.1/<italic>N</italic>).</p>
</sec>
<sec id="s7-2">
<title>4.2. Task details</title>
<p>The tasks the networks were trained on are taken from the neuroscience literature: a cycling task [<xref ref-type="bibr" rid="c61">61</xref>], a 3- bit flip-flop task and a “complex sine” task (with input-dependent frequencies) [<xref ref-type="bibr" rid="c76">76</xref>], a context-dependent decision making task (“Mante”) [<xref ref-type="bibr" rid="c41">41</xref>, <xref ref-type="bibr" rid="c68">68</xref>], and a working memory task comparing the amplitudes of two pulse stimuli (“Romo”) [<xref ref-type="bibr" rid="c59">59</xref>, <xref ref-type="bibr" rid="c68">68</xref>]. All tasks have similar structure [<xref ref-type="bibr" rid="c69">69</xref>]: A trial of length <italic>T</italic> starts with a fixation period (length <italic>t</italic><sub>fix</sub>). This is followed by an input for <italic>t</italic><sub>stim</sub>. For the cycling and flip-flop task, the inputs are pulses of amplitude 1; else see below. After a delay <italic>t</italic><sub>delay</sub>, the output of the network is required to reach an input-dependent value during a time period <italic>t</italic><sub>dec</sub>. During this decision period, we set target points <italic>t<sub>i</sub></italic> every Δ<italic>t</italic><sub>target</sub> time steps. The loss was defined as the mean squared error between network output and target at these time points. Below we provide further details for each task.</p>
<sec id="s7-2-1">
<sec id="s7-2-1-1">
<title>Cycling task</title>
<p>The network receives an initial pulse, whose direction ([1, 0]<sup><italic>T</italic></sup> or [0, 1]<sup><italic>T</italic></sup>) determines the sense of direction of the target. The target is a given by a rotation in 2D, <bold>ẑ</bold>(<italic>t</italic>) = [sin(<italic>a</italic>2<italic>πft</italic>), cos(2<italic>πft</italic>)]<sup><italic>T</italic></sup>, with frequency <italic>f</italic> = 0.1 and <italic>a</italic> = ±1 for the two directions (clockwise or anticlockwise).</p>
</sec>
<sec id="s7-2-1-2">
<title>Flip-flop task</title>
<p>The network repeatedly receives input pulses along one of 3 directions, followed by decision periods. In each decision period, the output coordinate corresponding to the last input should reach ±1 depending on the sign of the input. All other coordinates should remain at ±1 as defined by the last time they were triggered. To make sure that this is well-defined, we trigger all inputs at time steps <italic>k△t</italic> for <italic>k</italic> ∈ [<italic>N</italic><sub>in</sub>] with random signs.</p>
</sec>
<sec id="s7-2-1-3">
<title>Mante task</title>
<p>Input channels for this task are split into two groups of size <italic>N</italic><sub>in</sub>/2: half of the channels for the signal and the other half for the context, indicating which of the signal channels is relevant. All signal channels <italic>s<sub>i</sub></italic>(<italic>t</italic>) deliver a constant mean <italic>ŝ<sub>i</sub></italic> plus additional white noise: <italic>s<sub>i</sub></italic>(<italic>t</italic>) = <italic>ŝ<sub>i</sub> + a</italic><sub>noise</sub><italic>η<sub>i</sub></italic>(<italic>t</italic>). The mean is drawn uniformly from <inline-formula id="ID10">
<alternatives>
<mml:math display="inline" id="I10"><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mo>±</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>±</mml:mo><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac></mml:mstyle><mml:mo>,</mml:mo><mml:mo>±</mml:mo><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mn>4</mml:mn></mml:mfrac></mml:mstyle><mml:mo>,</mml:mo><mml:mo>±</mml:mo><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mn>8</mml:mn></mml:mfrac></mml:mstyle></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq10.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, and the noise amplitude is <italic>a</italic><sub>noise</sub> = 0.05. For simulations, we draw a standard normal variable <italic>n<sub>i,k</sub></italic> ~ <italic>N</italic>(0, 1) at time step <italic>k</italic>, and set <italic>η<sub>i,k</sub></italic> = <italic>n</italic><sub>i,k</sub>/<inline-formula id="ID11">
<alternatives>
<mml:math display="inline" id="I11"><mml:msqrt><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msqrt></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq11.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. Only a single contextual input is active at each trial, <italic>s<sub>i</sub></italic>+<italic>N</italic><sub>in</sub>/2 = <italic>δ<sub>ij</sub></italic>, with <italic>j</italic> chosen uniformly from the number of context <italic>N</italic><sub>in</sub>/2. The target during the decision period is the sign of the relevant input, <italic>ẑ(t)</italic> = sign(<italic>ŝ<sub>j</sub></italic>).</p>
</sec>
<sec id="s7-2-1-4">
<title>Romo task</title>
<p>For the Romo task, the input consists of two input pulses separated by random delays <italic>t</italic><sub>sd</sub>. The amplitude of the inputs is drawn independently from <italic>U</italic>(0.5, 1.5) with the condition of being at least 0.2 apart (else both are redrawn). During the decision period, the network needs to yield <italic>ẑ</italic>(<italic>t</italic>) = ±1, depending on which of the two pulses was larger.</p>
</sec>
<sec id="s7-2-1-5">
<title>Complex Sine</title>
<p>The target is ẑ(<italic>t</italic>) = sin(2<italic>πft</italic>), with frequency <italic>f</italic> = (1 − <italic>a</italic>)<italic>f</italic><sub>min</sub> + <italic>af</italic><sub>max</sub>, and boundaries <italic>f</italic><sub>min</sub> = 0.04, <italic>f</italic><sub>max</sub> = 0.2, and where <italic>a</italic> ~ <italic>U</italic>(0, 1). The input is a constant input of amplitude <italic>s</italic> = <italic>a</italic> + 0.25.</p>
</sec>
</sec>
</sec>
<sec id="s7-3">
<title>4.3. Generalized correlation</title>
<p>For <xref ref-type="fig" rid="fig3">Fig. 3A</xref>, we used a generalized correlation measure which allows for multiple output dimensions, multiple time points, and noisy data. Consider neural activity of <italic>N</italic> neurons at <italic>P</italic> time points stacked into the matrix <italic>X</italic> = [<bold>x</bold>(1), …, <bold>x</bold>(<italic>P</italic>)] ∈ ℝ<sup><italic>N×P</italic></sup>. We assume the states to be centered in time, <inline-formula id="ID12">
<alternatives>
<mml:math display="inline" id="I12"><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mi>P</mml:mi></mml:mfrac></mml:mstyle><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>P</mml:mi></mml:msubsup><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq12.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> 0 for <italic>i</italic> ∈ [<italic>N</italic>]. The corresponding <italic>D</italic>-dimensional output is summarized in the <italic>D</italic> ×<italic>P</italic> matrix
<disp-formula id="FD5">
<alternatives>
<mml:math id="M5" display="block"><mml:mi>Z</mml:mi><mml:mo>=</mml:mo><mml:msubsup><mml:mi>W</mml:mi><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msubsup><mml:mi>X</mml:mi><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn5.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(5)</label>
</disp-formula>
</p>
<p>with weights <italic>W</italic><sub>out</sub> ∈ ℝ<sup><italic>N × D</italic></sup>. We define the generalized correlation as
<disp-formula id="FD6">
<alternatives>
<mml:math id="M6" display="block"><mml:mi>ρ</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msubsup><mml:mi>W</mml:mi><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msubsup><mml:mi>X</mml:mi></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mi>W</mml:mi><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mi>X</mml:mi><mml:mo>‖</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn6.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(6)</label>
</disp-formula>
</p>
<p>The norm is the Frobenius norm, <inline-formula id="ID13">
<alternatives>
<mml:math display="inline" id="I13"><mml:mrow><mml:mo>‖</mml:mo><mml:mi>X</mml:mi><mml:mo>‖</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:mstyle displaystyle="true"><mml:msub><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:msubsup><mml:mi>X</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mstyle></mml:mrow></mml:msqrt></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq13.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. In particular, we have
<disp-formula id="FD7">
<alternatives>
<mml:math id="M7" display="block"><mml:mrow><mml:mo>‖</mml:mo><mml:mi>Z</mml:mi><mml:mo>‖</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>ρ</mml:mi><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mi>W</mml:mi><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mi>X</mml:mi><mml:mo>‖</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn7.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(7)</label>
</disp-formula>
</p>
<p>The case of one-dimensional output and a single time step discussed in the main text, <xref ref-type="disp-formula" rid="FD3">Eq. (3)</xref>, is recovered up to the sign, which we discard. Note that in that case, the vectors <bold>w</bold><sub>out</sub> and <bold>x</bold>(<italic>t</italic>) should be centered along coordinates to receive a valid correlation. Our numerical results did not change qualitatively when centering across coordinates only or both coordinates and time.</p>
<p>For trajectories with multiple conditions, we stack these instances in a matrix <italic>X</italic> ∈ ℝ<sup><italic>N × N<sub>c</sub>N<sub>t</sub></italic></sup>, with <italic>N<sub>c</sub></italic> the number of conditions, and <italic>N<sub>t</sub></italic> the number of time points per trajectory. For noisy trajectories, we first average over multiple instances per condition and time point to obtain a similar matrix <inline-formula id="ID14">
<alternatives>
<mml:math display="inline" id="I14"><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq14.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>.</p>
</sec>
<sec id="s7-4">
<title>4.4. Regression</title>
<p>In <xref ref-type="fig" rid="fig3">Fig. 3B-C</xref> we computed the number of PCs necessary to either represent the dynamics or fit the output. We simulated the trained networks again on their corresponding tasks. We did not apply noise during these simulations, since keeping the same noise as during training would reduce the quality of the output for large output weights; trial averaging yielded similar results to the ones obtained without noise (not shown).</p>
<p>The simulations yielded neural states <italic>X</italic> ∈ <italic>ℝ</italic><sup><italic>N×P</italic></sup> and outputs <italic>Z</italic> ∈ <italic>ℝ</italic><sup><italic>N</italic><sub>out</sub></sup> × <italic>P</italic>, where <italic>P</italic> is the number data points (batch size times number of time points <italic>T</italic>). We applied PCA to the states <italic>X</italic>. The cumulative explained variance ratio obtained from PCA is plotted in <xref ref-type="fig" rid="fig3">Fig. 3B</xref>. We then projected <italic>X</italic> onto the first <italic>k</italic> PCs and fitted these projections to the output with ridge regression (cross-validated, using scikit-learn’s RidgeCV [<xref ref-type="bibr" rid="c51">51</xref>]).</p>
</sec>
<sec id="s7-5">
<title>4.5. Dissimilarity measure</title>
<p>For measuring the dissimilarity between learners in <xref ref-type="fig" rid="fig4">Fig. 4</xref>, we apply a measure following Williams et al. [<xref ref-type="bibr" rid="c83">83</xref>]. We define the distance between two sets with <italic>P</italic> data points <italic>X, Y</italic> ∈ ℝ<sup><italic>N</italic> × <italic>P</italic></sup> as
<disp-formula id="FD8">
<alternatives>
<mml:math id="M8" display="block"><mml:mi>d</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>X</mml:mi><mml:mo>,</mml:mo><mml:mi>Y</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mi>arg</mml:mi><mml:mtext> </mml:mtext><mml:mi>min</mml:mi><mml:mtext> </mml:mtext><mml:mi>arccos</mml:mi></mml:mrow><mml:mrow><mml:mi>Q</mml:mi><mml:mo>∈</mml:mo><mml:mi>O</mml:mi></mml:mrow></mml:munder><mml:mfrac><mml:mrow><mml:mi>T</mml:mi><mml:mi>r</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:msup><mml:mover accent="true"><mml:mi>Y</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mi>T</mml:mi></mml:msup><mml:mi>Q</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo>‖</mml:mo></mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mover accent="true"><mml:mi>Y</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo>‖</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn8.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(8)</label>
</disp-formula>
</p>
<p>where the hat corresponds to centering along the rows, and <italic>Q</italic> is an orthogonal matrix. The solution to this so-called orthogonal Procrustes’ problem is found via the singular value decomposition <inline-formula id="ID15">
<alternatives>
<mml:math display="inline" id="I15"><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq15.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula><italic>Ŷ<sup>T</sup> = UΣV<sup>T</sup></italic>. The optimal transformation is <italic>Q* = VU<sup>T</sup></italic>, and the numerator in <xref ref-type="disp-formula" rid="FD8">Eq. (8)</xref> is then Tr(<inline-formula id="ID16">
<alternatives>
<mml:math display="inline" id="I16"><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq16.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula><italic>Ŷ<sup>T</sup> Q*)</italic> = Tr(Σ).</p>
<p>Note that this is more restricted than canonical correlation analysis (CCA), which is also commonly used [<xref ref-type="bibr" rid="c17">17</xref>, <xref ref-type="bibr" rid="c18">18</xref>]. In particular, CCA involves whitening the matrices <italic>X</italic> and <italic>Y</italic> before applying a rotation [<xref ref-type="bibr" rid="c83">83</xref>]. This sets all singular values to 1. For originally low-D data, this mostly means amplifying the noise, unless the data was previously projected onto a small number of PCs. In the latter case, the procedure still removes the information about how much each PC contributes.</p>
</sec>
<sec id="s7-6">
<title>4.6. Experimental data</title>
<p>We detail the analyses of neural data in Section 2.6. We made use of publicly available data sets: data from the cycling task of Ref. [<xref ref-type="bibr" rid="c61">61</xref>], two data sets available through the Neural Latents Benchmark (NLB) [<xref ref-type="bibr" rid="c52">52</xref>], and data from monkeys trained on a center-out reaching task with a BCI [<xref ref-type="bibr" rid="c12">12</xref>, <xref ref-type="bibr" rid="c22">22</xref>, <xref ref-type="bibr" rid="c25">25</xref>]. For all data sets, we first obtain firing rates <italic>X</italic> ∈ ℝ<sup><italic>N×T</italic></sup> where <italic>N</italic> is the number of measured neurons, and <italic>T</italic> the number of data points, (see <xref ref-type="fig" rid="fig7">Fig. 7B</xref> for these numbers). We also collect the simultaneously measured behavior in the matrix <italic>Z</italic> ∈ ℝ<sup><italic>D×T</italic></sup>. In <xref ref-type="fig" rid="fig7">Fig. 7</xref>, we only analyzed cursor or hand velocity for behavior, so that the output dimension is <italic>D</italic> = 2. See <xref ref-type="fig" rid="fig22">Fig. 22</xref> for similar results for hand position and acceleration or the largest two PCs of the EMG data recorded for the cycling task.</p>
<p>For the cycling task, the firing rates were binned in 1 ms bins and convolved with a 25 ms Gaussian filter. The mean firing rate was 22 and 18 Hz for the two monkeys, respectively. For the NLB data, spikes came in 1 ms bins. We binned data to 45 ms bins and applied a Gaussian filter with 45 ms width. This increased the quality of the fit, as firing rates were much lower (mean of 5 Hz for both) than in the cycling data set. For the BCI experiments, firing rates came as spike counts in 45 ms bins. The mean firing rate was (45, 45, 55) Hz for the data of Refs. [<xref ref-type="bibr" rid="c12">12</xref>, <xref ref-type="bibr" rid="c22">22</xref>, <xref ref-type="bibr" rid="c25">25</xref>], respectively. In agreement with the original BCI experiments, we did not apply a filter to the neural data.</p>
<p>For fitting, we centered both firing rates <italic>X</italic> and output <italic>Z</italic> across time (but not coordinates). We also added a delay of 100 ms between firing rates and output for the cycling and NLB data sets, which increased the quality of the fits. We then fitted the output <italic>Z</italic> to the firing rates <italic>X</italic> with ridge regression, with regularization obtained from cross-validation. We treated the coefficients as output weights <italic>W</italic><sub>out</sub>. The trial average data of the cycling tasks was very well fitted for both monkeys, <italic>R</italic><sup>2</sup> = [0.97, 0.98]. For the NLB tasks with single-trial data, the fits were not as good, <italic>R</italic><sup>2</sup> = [0.73, 0.69]. For two of the BCI data sets [<xref ref-type="bibr" rid="c22">22</xref>, <xref ref-type="bibr" rid="c25">25</xref>], the output weights were also given, and we checked that the fit recovers these. For the third BCI data set [<xref ref-type="bibr" rid="c12">12</xref>], we did not have access to the output weights, and only access to the cursor velocity after Kalman filtering. Here, fitting yielded <italic>R</italic><sup>2</sup> = 0.83.</p>
<p>For the fitting dimension <italic>D</italic><sub>fit,90</sub>/<italic>D</italic><sub>x,90</sub> in <xref ref-type="fig" rid="fig7">Fig. 7B</xref> bottom, we used an adapted definition of <italic>D</italic><sub>fit,90</sub>: Because <italic>R</italic><sup>2</sup> = 90% is not reached for all data sets, we asked for the number of PCs necessary to obtain 90% of the <italic>R</italic><sup>2</sup> value obtained for the full data set.</p>
<p>We also considered whether the correlation <italic>ρ</italic> scales with the number of neurons <italic>N</italic>. In our model, oblique and aligned dynamics can be defined in terms of such a scaling: aligned dynamics have highly correlated output weights and low-dimensional dynamics, so that <italic>ρ ~ N</italic><sup>0</sup> = 1, i.e. independent of the network size. For oblique dynamics, large output weights with norm <bold>w</bold><sub>out</sub> ~ 1 lead to vanishing correlation, <inline-formula id="ID17">
<alternatives>
<mml:math display="inline" id="I17"><mml:mi>ρ</mml:mi><mml:mo>~</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq17.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. This is indeed similar to the relation between two random vectors, for which the correlation in precisely <inline-formula id="ID18">
<alternatives>
<mml:math display="inline" id="I18"><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq18.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> (in the limit of large <italic>N</italic>). In <xref ref-type="fig" rid="fig8">Fig. 8</xref>, we show the scaling of <italic>R<sup>2</sup></italic> and <italic>ρ</italic> with the number of subsampled neurons. For the cycling task and NLB data, the correlation scaled slightly weaker than <italic>ρ ~ N</italic><sup>-1/2</sup>. For the BCI data, the scaling was closer to <italic>ρ ~ N</italic><sup>−1/4</sup> which is in between the aligned and oblique regimes of the model. These insights, however, are limited due to the trial averaging for the cycling task and the limited number of time points for the NLB tasks (not enough to reach <italic>R</italic><sup>2</sup> = 1). Applying these measures to larger data sets could yield more definitive insights.</p>
</sec>
<sec id="s7-7">
<title>4.7. Analysis of solutions under noiseless conditions</title>
<p>In the sections below, we explore in detail under which conditions aligned and oblique solutions arise, and which other solutions arise if these conditions are not met.</p>
<p>We first consider small output weights and show that these lead to aligned solutions. Then, for large output weights, we show that without noise, two different, unstable solutions arise. Finally, we consider how adding noise affects learning dynamics. For a linear model, we can solve the dynamics of learning analytically and show how a negative feedback loop arises, that suppresses noise along the output direction. However, the linear model does not yield an oblique solution, so we also consider a nonlinear model for which we show in detail why oblique solutions arise.</p>
<p>We start by analyzing a simplified version of the network dynamics <xref ref-type="disp-formula" rid="FD4">Eq. (4)</xref>: autonomous dynamics without noise,
<disp-formula id="FD9">
<alternatives>
<mml:math id="M9" display="block"><mml:mtext>ẋ</mml:mtext><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mtext>x</mml:mtext><mml:mo>+</mml:mo><mml:mi>W</mml:mi><mml:mi>ϕ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mtext>x</mml:mtext><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn9.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(9)</label>
</disp-formula>
</p>
<p>with fixed initial condition <bold>x</bold>(0). We assume a one-dimensional output <italic>z</italic>(<italic>t</italic>) and a target <italic>ẑ</italic>(<italic>t<sub>i</sub></italic>) defined on a finite set of time points <italic>t<sub>i</sub></italic>.</p>
<p>We illustrate the theory with an example of a simple sine wave task (<xref ref-type="fig" rid="fig9">Fig. 9</xref>). We demand the network to autonomously produce a sine wave with fixed frequency <italic>f</italic> = 0.1. At the beginning of the task, the network receives an input pulse that sets the starting point of the trajectory. We set the noise <italic>σ</italic><sub>init</sub> on the initial state <bold>x</bold>(0) to zero. We define the target as 20 target points in the interval <italic>t</italic> ∈ [<xref ref-type="bibr" rid="c1">1</xref>, <xref ref-type="bibr" rid="c21">21</xref>] (two cycles; purple dots in <xref ref-type="fig" rid="fig9">Fig. 9</xref>).</p>
<sec id="s7-7-1">
<title>4.7.1. Small weights lead to aligned solutions</title>
<p>For small output weights, <inline-formula id="ID19">
<alternatives>
<mml:math display="inline" id="I19"><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mrow><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq19.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, gradient-based learning in such a noise-less system has been analyzed by Schuessler et al. [<xref ref-type="bibr" rid="c69">69</xref>]. Learning changes the dynamics qualitatively through low-rank weight changes Δ<italic>W</italic>. These weight changes are spanned by existing directions such as the output weights. The resulting dynamics <bold>x</bold>(<italic>t</italic>) are thus aligned to the output weights. This means that the correlation between the two is large, independently of the network size, <italic>ρ</italic> = <italic>O</italic>(1). The target of the task is also independent of <italic>N</italic>, so that after learning we have <italic>z</italic> = <italic>O</italic>(1). Given the small output weights, we can thus infer the size of the states:
<disp-formula id="FD10">
<alternatives>
<mml:math id="M10" display="block"><mml:munder><mml:munder><mml:mi>z</mml:mi><mml:mo stretchy="true">︸</mml:mo></mml:munder><mml:mrow><mml:mi>o</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:munder><mml:mo>=</mml:mo><mml:munder><mml:munder><mml:mi>ρ</mml:mi><mml:mo stretchy="true">︸</mml:mo></mml:munder><mml:mrow><mml:mi>o</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:munder><mml:munder><mml:munder><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mtext>W</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mo stretchy="true">︸</mml:mo></mml:munder><mml:mrow><mml:mi>o</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mrow><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:munder><mml:munder><mml:munder><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mtext>x</mml:mtext><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mo stretchy="true">︸</mml:mo></mml:munder><mml:mrow><mml:mi>o</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:munder><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn10.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(10)</label>
</disp-formula>
</p>
<fig id="fig8" position="float" fig-type="figure">
<label>Fig. 8:</label>
<caption><p>Scaling of the correlation <italic>ρ</italic> with the number of neurons <italic>N</italic> in experimental data. We fitted the output weights to subsets of <italic>N</italic> neurons and computed the quality of fit (top) and the correlation between the resulting output weight and firing rates (bottom). To compare with random vectors, the correlation is scaled by <inline-formula id="ID20">
<alternatives>
<mml:math display="inline" id="I20"><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq20.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. Dashed lines are <italic>N<sup>p</sup></italic>/2, for <italic>p</italic> ∈ {1/2, 1/4, 0} for comparison. The aligned regime corresponds to <italic>p</italic> = 1/2, and the oblique one to <italic>p</italic> = 0.</p></caption>
<graphic xlink:href="2307.07654v3_fig8.tif" mime-subtype="tif" mimetype="image"/>
</fig>
<p>so that <inline-formula id="ID21">
<alternatives>
<mml:math display="inline" id="I21"><mml:mrow><mml:mo>‖</mml:mo><mml:mtext>x</mml:mtext><mml:mo>‖</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq21.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, or equivalently single neuron activations <italic>x<sub>i</sub></italic> = <italic>O</italic>(1). This scaling corresponds to the aligned regime.</p>
<p>For the sine wave task, training with small output weights converges to an intuitive solution (<xref ref-type="fig" rid="fig9">Fig. 9A</xref>). Neural activity evolves on a limit cycle, and the output is a sine wave that extrapolates beyond the training interval. Plotting activity and output weights along the largest two PCs and the remaining direction <bold>w</bold><sub>out,⊥</sub> confirms substantial correlation, <italic>ρ = O</italic>(1), as expected. The solution was robust to adding noise after training (not shown). Changes in the initial dynamics or the presence of noise during training did not lead to qualitatively different solutions (<xref ref-type="fig" rid="fig24">Fig. 24</xref>). A further look at the eigenvalue spectrum of the trained recurrent weights revealed a pair of complex conjugate outliers corresponding to the limit cycle [<xref ref-type="bibr" rid="c42">42</xref>, <xref ref-type="bibr" rid="c68">68</xref>], and a bulk of remaining eigenvalues concentrated on a disk with radius <italic>g</italic>, <xref ref-type="fig" rid="fig23">Fig. 23</xref>.</p>
</sec>
<sec id="s7-7-2">
<title>4.7.2. Large weights, no noise: linearization of dynamics</title>
<p>We now consider learning with large output weights, ║<bold>w</bold><sub>out</sub>║ = 1, for noise-less dynamics, <xref ref-type="disp-formula" rid="FD9">Eq. (9)</xref>. We start with the assumption that the activity changes for each neuron are small, <inline-formula id="ID22">
<alternatives>
<mml:math display="inline" id="I22"><mml:mi>Δ</mml:mi><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq22.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, or ║Δ<bold>x</bold>║ = <italic>O</italic>(1). Here, Δ<bold>x</bold>(<italic>t</italic>) = <bold>x</bold>(<italic>t</italic>) − <bold>x</bold><sub>0</sub>(<italic>t</italic>), where <bold>x</bold><sub>0</sub>(<italic>t</italic>) is the activity before learning. To perform a task, learning needs to induce output changes Δ<sub><italic>z</italic></sub> = <italic>O</italic>(1) to reach the target <italic>ẑ(t)</italic>. Note that a possible order-one initial output <italic>z</italic>0 must also be compensated. Together with the output weight scale, we arrive at
<disp-formula id="FD11">
<alternatives>
<mml:math id="M11" display="block"><mml:munder><mml:munder><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>z</mml:mi></mml:mrow><mml:mo stretchy="true">︸</mml:mo></mml:munder><mml:mrow><mml:mi>o</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:munder><mml:mo>=</mml:mo><mml:munder><mml:munder><mml:mrow><mml:mi>ρ</mml:mi><mml:mi>Δ</mml:mi></mml:mrow><mml:mo stretchy="true">︸</mml:mo></mml:munder><mml:mrow><mml:mi>o</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:munder><mml:mtext> </mml:mtext><mml:munder><mml:munder><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mo stretchy="true">︸</mml:mo></mml:munder><mml:mrow><mml:mi>o</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:munder><mml:mtext> </mml:mtext><mml:munder><mml:munder><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:mi>Δ</mml:mi><mml:mtext>x</mml:mtext></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mo stretchy="true">︸</mml:mo></mml:munder><mml:mrow><mml:mi>o</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:munder><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn11.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(11)</label>
</disp-formula>
</p>
<fig id="fig9" position="float" fig-type="figure">
<label>Fig. 9:</label>
<caption><p>Different solutions for networks trained on a sine wave task. All networks have <italic>N</italic> = 512 neurons. Four regimes: <bold>A</bold>: aligned for small output weights, <bold>B</bold>: marginal for large output weights, small recurrent weights, <bold>C</bold>: lazy for both large output and recurrent weights, <bold>D</bold>: oblique for large output weights and noise added during training. Left: Output (dark), target (purple dots), and four states (light) of the network after training. Black bars indicate the scales for output and states (length = 1; same for all regimes). The output beyond the target interval <italic>t</italic> ∈ [<xref ref-type="bibr" rid="c1">1</xref>, <xref ref-type="bibr" rid="c21">21</xref>] can be considered as extrapolation. The network in the oblique regime, <bold>D</bold>, receives white noise during training, and the evaluation is shown with the same noise. Without noise, this network still produces a sine wave (not shown). Right: Projection of states on the first 2 PCs and the orthogonal component <bold>w</bold><sub>out,⊥</sub> of the output vector. All axes have the same scale, which allows for comparison between the dynamics. Vectors show the (amplified) output weights, dotted lines the projection on the PCs (not visible for lazy and oblique). The insets for the marginal solution (B, left and right) show the dynamics magnified by <inline-formula id="ID23">
<alternatives>
<mml:math display="inline" id="I23"><mml:mrow><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq23.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>.</p></caption>
<graphic xlink:href="2307.07654v3_fig9.tif" mime-subtype="tif" mimetype="image"/>
</fig>
<p>where <italic>ρ</italic>△ = corr(<bold>w</bold><sub>out</sub>, △<bold>x</bold>). This shows that our assumption of small state changes △<bold>x</bold> is consistent - it allows for a solution - and that such small changes need to be strongly correlated to the output weights. Note that we make the distinction between the changes △<bold>x</bold> and the final activity <bold>x</bold> = <bold>x</bold><sub>0</sub> + △<bold>x</bold>, because the latter may be dominated by <bold>x</bold><sub>0</sub>. In the main text, we only consider the correlation between <bold>x</bold> and <bold>w</bold><sub>out</sub>, because (as we show below) solutions with small △<bold>x</bold> are not robust, and the final <bold>x</bold> will be dominated by △<bold>x</bold>.</p>
<p>For now, however, we ignore robustness and continue with the assumption of small △<bold>x</bold>. Given this assumption, we linearize the dynamics around the initial trajectory <bold>x</bold><sub>0</sub>(<italic>t</italic>):
<disp-formula id="FD12">
<alternatives>
<mml:math id="M12" display="block"><mml:mfrac><mml:mrow><mml:mtext>dΔx</mml:mtext></mml:mrow><mml:mrow><mml:mtext>d</mml:mtext><mml:mi>t</mml:mi></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:munder><mml:munder><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>W</mml:mi><mml:mi>ϕ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mtext>x</mml:mtext><mml:mn>0</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo stretchy="true">︸</mml:mo></mml:munder><mml:mtext>a</mml:mtext></mml:munder><mml:mo>+</mml:mo><mml:munder><mml:munder><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mi>I</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>W</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mi>Δ</mml:mi><mml:mi>W</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msup><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mtext>x</mml:mtext><mml:mn>0</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mi>Δ</mml:mi><mml:mtext>x</mml:mtext></mml:mrow><mml:mo stretchy="true">︸</mml:mo></mml:munder><mml:mtext>b</mml:mtext></mml:munder><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Δ</mml:mi><mml:msup><mml:mtext>x</mml:mtext><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn12.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(12)</label>
</disp-formula>
</p>
<p>with diagonal matrix <italic>R</italic><sup>′</sup>(<bold>x</bold>)<sub><italic>ij</italic></sub> = <italic>δ<sub>ij</sub>ϕ<sup>′</sup>(x<sub>i</sub></italic>) and the weights changes △<italic>W</italic> = <italic>W − W</italic><sub>0</sub> that induce △<bold>x</bold>. Note that we haven’t yet constrained the weight changes △<italic>W</italic> so we cannot discard the terms of the kind △<italic>W</italic> △<bold>x</bold>. The next steps depend on the initial trajectories <bold>x</bold><sub>0</sub>(<italic>t</italic>).</p>
</sec>
<sec id="s7-7-3">
<title>4.7.3. Initially decaying dynamics lead to a marginal regime</title>
<p>We first consider networks with decaying dynamics before learning. This is obtained by drawing the initial recurrent weights independently from <inline-formula id="ID24">
<alternatives>
<mml:math display="inline" id="I24"><mml:mrow><mml:msub><mml:mi>W</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>~</mml:mo><mml:mi>N</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mrow><mml:msup><mml:mi>g</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mi>N</mml:mi></mml:mfrac></mml:mstyle></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq24.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, with <italic>g &lt;</italic> 1 [<xref ref-type="bibr" rid="c70">70</xref>]. With such dynamics, <bold>x</bold><sub>0</sub>(<italic>t</italic>) vanishes exponentially in time. In <xref ref-type="disp-formula" rid="FD12">Eq. (12)</xref>, we disregard the term <bold>a</bold> and have <italic>R<sup>′</sup></italic> = <italic>I</italic>, so that
<disp-formula id="FD13">
<alternatives>
<mml:math id="M13" display="block"><mml:mfrac><mml:mrow><mml:mtext>dΔx</mml:mtext></mml:mrow><mml:mrow><mml:mtext>d</mml:mtext><mml:mi>t</mml:mi></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mi>I</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mi>W</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mi>Δ</mml:mi><mml:mi>W</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mi>Δ</mml:mi><mml:mtext>x</mml:mtext><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Δ</mml:mi><mml:msup><mml:mtext>x</mml:mtext><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn13.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(13)</label>
</disp-formula>
</p>
<p>To have self-sustained dynamics, the matrix <italic>W<sub>0</sub></italic> + △<italic>W</italic> must have a leading eigenvalue λ<sub>+</sub> with real part above the stability line: <italic>ℜ</italic>λ<sub>+</sub> = 1 + <italic>∈</italic>.</p>
<p>The distance <italic>∈</italic> &gt; 0 must be small, else the states would become large. To understand how <italic>∈</italic> needs to scale with <italic>N</italic>, we turn to a simple model studied before [<xref ref-type="bibr" rid="c42">42</xref>, <xref ref-type="bibr" rid="c68">68</xref>]: an autonomously generated fixed point and rank-one connectivity <inline-formula id="ID25">
<alternatives>
<mml:math display="inline" id="I25"><mml:mi>W</mml:mi><mml:mo>=</mml:mo><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac></mml:mstyle><mml:msub><mml:mi>λ</mml:mi><mml:mo>+</mml:mo></mml:msub><mml:mi>u</mml:mi><mml:msup><mml:mi>u</mml:mi><mml:mi>T</mml:mi></mml:msup></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq25.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. The vector <bold>u</bold> has entries <italic>u<sub>i</sub> ~ N</italic>(0, 1). A fixed point of the dynamics <xref ref-type="disp-formula" rid="FD9">Eq. (9)</xref> fulfills <inline-formula id="ID26">
<alternatives>
<mml:math display="inline" id="I26"><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac></mml:mstyle><mml:msub><mml:mi>λ</mml:mi><mml:mo>+</mml:mo></mml:msub><mml:mi>u</mml:mi><mml:msup><mml:mi>u</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>ϕ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>x</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq26.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. Projecting on <bold>u</bold> and applying partial integration in the limit <italic>N</italic> → ∞, we obtain
<disp-formula id="FD14">
<alternatives>
<mml:math id="M14" display="block"><mml:msub><mml:mtext>λ</mml:mtext><mml:mo>+</mml:mo></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>〉</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn14.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(14)</label>
</disp-formula>
</p>
<p>where <inline-formula id="ID27">
<alternatives>
<mml:math display="inline" id="I27"><mml:mrow><mml:mo>〈</mml:mo><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>〉</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mo>∫</mml:mo><mml:mi>D</mml:mi><mml:mi>u</mml:mi><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mi>u</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq27.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, with standard normal measure <inline-formula id="ID28">
<alternatives>
<mml:math display="inline" id="I28"><mml:mi>D</mml:mi><mml:mi>u</mml:mi><mml:mo>=</mml:mo><mml:mi>d</mml:mi><mml:mi>u</mml:mi><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msqrt><mml:mrow><mml:mn>2</mml:mn><mml:mi>π</mml:mi></mml:mrow></mml:msqrt></mml:mrow></mml:mfrac></mml:mstyle><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:msup><mml:mi>u</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq28.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. Here, <italic>σ<sub>x</sub></italic> is the scale of the states, <inline-formula id="ID29">
<alternatives>
<mml:math display="inline" id="I29"><mml:msub><mml:mi>σ</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>‖</mml:mo><mml:mtext>x</mml:mtext><mml:mo>‖</mml:mo></mml:mrow><mml:mo>/</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq29.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> or <italic>x<sub>i</sub></italic> = <italic>O</italic>(<italic>σ<sub>x</sub></italic>). The fixed point is situated along the vector <bold>u</bold>. To have the smallest possible fixed point generate some output, we set the output weights to <inline-formula id="ID30">
<alternatives>
<mml:math display="inline" id="I30"><mml:msub><mml:mi>w</mml:mi><mml:mrow><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:mfrac></mml:mstyle><mml:mtext>u</mml:mtext></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq30.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. Then we have correlation <italic>ρ</italic> =1 and <inline-formula id="ID31">
<alternatives>
<mml:math display="inline" id="I31"><mml:mi>z</mml:mi><mml:mo>=</mml:mo><mml:msubsup><mml:mi>w</mml:mi><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow><mml:mtext>T</mml:mtext></mml:msubsup><mml:mtext>x=</mml:mtext><mml:mi>ρ</mml:mi><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mtext>x</mml:mtext><mml:mo>‖</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>⋅</mml:mo><mml:mn>1</mml:mn><mml:mo>⋅</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt><mml:msub><mml:mi>σ</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq31.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. In other words, a small fixed point with <inline-formula id="ID32">
<alternatives>
<mml:math display="inline" id="I32"><mml:msub><mml:mi>σ</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo>~</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:mfrac></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq32.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. We expand <italic>ϕ<sup>′</sup></italic> in <xref ref-type="disp-formula" rid="FD14">Eq. (14)</xref> around zero. For even <italic>ϕ</italic>, we have <italic>ϕ<sup>″</sup></italic>(0) = 0 and
<disp-formula id="FD15">
<alternatives>
<mml:math id="M15" display="block"><mml:msub><mml:mtext>λ</mml:mtext><mml:mo>+</mml:mo></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>‴</mml:mo></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:msubsup><mml:mi>σ</mml:mi><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>‴</mml:mo></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:msubsup><mml:mi>σ</mml:mi><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn15.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(15)</label>
</disp-formula>
</p>
<p>Sigmoidal functions have <italic>ϕ<sup>‴</sup></italic> &lt; 0, e.g. <italic>ϕ<sup>‴</sup></italic>(0) = −2 for <italic>ϕ</italic> = tanh. Hence <italic>λ</italic> = 1 + <italic>∈</italic>, with <inline-formula id="ID33">
<alternatives>
<mml:math display="inline" id="I33"><mml:mo>∈</mml:mo><mml:mo>=</mml:mo><mml:msubsup><mml:mi>σ</mml:mi><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo>~</mml:mo><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac></mml:mstyle></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq33.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. Remarkably, the perturbation leading to states with <inline-formula id="ID34">
<alternatives>
<mml:math display="inline" id="I34"><mml:msub><mml:mi>σ</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq34.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> only needs to have a distance <italic>∈</italic> = <italic>O</italic>(1/<italic>N</italic>) away from the stability line.</p>
<p>The insights from this simplified setting extend to the example of the sine wave task (<xref ref-type="fig" rid="fig9">Fig. 9B</xref>). The mo del with large output weights, <italic>g</italic> = 0.7, and no noise yields a limit cycle. The output extrapolates in time, but the states are very small, scaling as <inline-formula id="ID35">
<alternatives>
<mml:math display="inline" id="I35"><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq35.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> (analysis over different <italic>N</italic> not shown). Such a solution is only marginally stable − adding a white noise with <italic>σ</italic><sub>noise</sub> = 0.2 after training destroyed the rotation (not shown). The eigenvalues were again split into two outliers and a bulk (<xref ref-type="fig" rid="fig23">Fig. 23</xref>). However, the two outliers now had a real part 1 + <italic>∈</italic>, that is, they were very close to the stability line of the fixed point at zero. To better illustrate the marginal solution, we also set the initial state <bold>x</bold>(<italic>t</italic> = 0) to small values, <italic>x<sub>i</sub></italic>(<italic>t</italic> = 0) ~ <italic>N</italic>(0, 1/<italic>N</italic>). For <italic>x<sub>i</sub></italic>(<italic>t</italic> =0) ~ <italic>N</italic>(0, 1), there would be an initial decay much larger than the limit cycle.</p>
</sec>
<sec id="s7-7-4">
<title>4.7.4. Initially chaotic dynamics lead to a lazy regime</title>
<p>In contrast to the situation before, initially chaotic dynamics (for <italic>g</italic> &gt; 1) imply order-one initial states, (<italic>x</italic><sub>0</sub>(<italic>t</italic>))<sub><italic>i</italic></sub> = <italic>O</italic>(1) for all trial times <italic>t</italic>. The driving term <bold>a</bold> in <xref ref-type="disp-formula" rid="FD12">Eq. (12)</xref> can thus not be ignored and we expect it to be on the same scale as Δ<bold>x</bold>:
<disp-formula id="FD16">
<alternatives>
<mml:math id="M16" display="block"><mml:mn>1</mml:mn><mml:mo>∼</mml:mo><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:mi>Δ</mml:mi><mml:mtext>x</mml:mtext></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mo>∼</mml:mo><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>W</mml:mi><mml:mi>ϕ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mtext>x</mml:mtext><mml:mn>0</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn16.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(16)</label>
</disp-formula>
</p>
<p>The smallest possible weight changes Δ<italic>W</italic> will be those for which <italic>ϕ</italic>(<bold>x</bold><sub>0</sub>) yields a maximal response, but other vectors do not yield a strong response. This is captured by the operator norm, ║Δ<italic>W</italic>║<sub>2</sub> = max{║Δ<italic>W</italic><sub><bold>x</bold></sub>║ : <bold>x</bold> ∈ ℝ<sup><italic>N</italic></sup> with ║<bold>x</bold>║ = 1}. We can then write ║Δ<italic>Wϕ</italic>(<bold>x</bold><sub>0</sub>)| ~ ║Δ<italic>W</italic>║<sub>2</sub>║<bold>x</bold><sub>0</sub>║, and hence <inline-formula id="ID36">
<alternatives>
<mml:math display="inline" id="I36"><mml:msub><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>W</mml:mi></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>~</mml:mo><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:mfrac></mml:mstyle></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq36.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. The operator norm also bounds the eigenvalues Δ<italic>W</italic> and hence the effect of the matrix on the dynamics of the system. For large <italic>N</italic>, this implies that the changes Δ<italic>W</italic> are too small to change the dynamics qualitatively, and the latter remain chaotic. Note that because the network dynamics are chaotic, the term <bold>b</bold> in <xref ref-type="disp-formula" rid="FD12">Eq. (12)</xref> diverges, so that our discussion is only valid for short times. Numerically, we find small weight changes and chaotic solutions even for large target times <italic>t<sub>i</sub></italic> (not shown).</p>
<p>For the sine wave task, the network with initially chaotic dynamics indeed converges to such a solution (<xref ref-type="fig" rid="fig9">Fig. 9C</xref>). The output does not extrapolate beyond the training interval <italic>t</italic> ∈ [<xref ref-type="bibr" rid="c1">1</xref>, <xref ref-type="bibr" rid="c21">21</xref>], and dynamics remain qualitatively similar to those before training. During the training interval, the dynamics also remain close to the initial trajectories (dashed line). Testing the response to small perturbations in <bold>x</bold>(0) indicated that the dynamics remain chaotic (not shown). No limit cycle was formed, and the spectrum of eigenvalues did not show outliers (<xref ref-type="fig" rid="fig23">Fig. 23</xref>).</p>
<p>We called this regime “lazy”, following similar settings in feedforward networks [<xref ref-type="bibr" rid="c9">9</xref>, <xref ref-type="bibr" rid="c27">27</xref>]. Note that there, the output <italic>z</italic>(<italic>t</italic>) is linearized around the weights at initialization (as opposed to the dynamics, <xref ref-type="disp-formula" rid="FD9">Eq. (9)</xref>). This can be done in our case as well:
<disp-formula id="FD17">
<alternatives>
<mml:math id="M17" display="block"><mml:mi>z</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msubsup><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msubsup></mml:mrow></mml:mstyle><mml:mfrac><mml:mrow><mml:mtext>dx</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mtext>d</mml:mtext><mml:msub><mml:mi>W</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>W</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mi>Δ</mml:mi><mml:msub><mml:mi>W</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Δ</mml:mi><mml:msup><mml:mi>W</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn17.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(17)</label>
</disp-formula>
</p>
<p>Demanding <italic>ẑ</italic>(<italic>t</italic>) = <italic>z</italic>(<italic>t</italic>) yields a linear equation for each time point <italic>t</italic>. As we have <italic>N</italic><sup>2</sup> parameters, this system is typically underconstrained. Gradient descent for this linear system leads to the minimal norm solution, which can also be found directly using the Moore-Penrose pseudo-inverse. Numerically, we found that the weights Δ<italic>W</italic><sub>lin</sub> obtained by this linearization are very close to those found by gradient descent (GD) on the nonlinear system, Δ<italic>W</italic><sub>GD</sub>, with Frobenius norm <inline-formula id="ID37">
<alternatives>
<mml:math display="inline" id="I37"><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>W</mml:mi><mml:mrow><mml:mtext>GD</mml:mtext></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>Δ</mml:mi><mml:msub><mml:mi>W</mml:mi><mml:mrow><mml:mtext>lin</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mo>~</mml:mo><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac></mml:mstyle></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq37.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> (Appendix A.1).</p>
</sec>
<sec id="s7-7-5">
<title>4.7.5. Marginal and lazy solutions disappear with noise during training</title>
<p>The deduction above hinges on the assumption that Δ<bold>x</bold> is small. This assumption does not hold if dynamics are noisy, <xref ref-type="disp-formula" rid="FD4">Eq. (4)</xref>. For marginal dynamics, the noise would push solutions to different attractors or different positions along the limit cycle. For lazy dynamics, the chaotic dynamics would amplify any perturbations along the trajectory (if chaos persists under noise [<xref ref-type="bibr" rid="c67">67</xref>]).</p>
<p>We will explore how learning is affected by noise in the sections below. Here we only show that adding noise for our example task abolishes the marginal or lazy solutions and leads to oblique ones (<xref ref-type="fig" rid="fig9">Fig. 9D</xref>). We added white noise with amplitude <inline-formula id="ID38">
<alternatives>
<mml:math display="inline" id="I38"><mml:msub><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>noise</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msqrt><mml:mn>2</mml:mn></mml:msqrt></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq38.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> to the dynamics during learning. After training, the output was a noisy sine wave. States were order one, and the 3D projection showed dynamics along a limit cycle that was almost orthogonal to the output vector. The noise in the 2D subspace of the first two PCs was small, <inline-formula id="ID39">
<alternatives>
<mml:math display="inline" id="I39"><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac></mml:mstyle><mml:mo stretchy="false">)</mml:mo></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq39.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, and thus did not disrupt the dynamics (e.g. very little phase shift). The eigenvalue spectrum had two outliers whose real part was increased in comparison to those in the aligned regime (<xref ref-type="fig" rid="fig23">Fig. 23</xref>). Note that for the chosen values <italic>g</italic> = 1.5 and <inline-formula id="ID40">
<alternatives>
<mml:math display="inline" id="I40"><mml:msub><mml:mi>σ</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>i</mml:mi><mml:mi>s</mml:mi><mml:mi>e</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msqrt><mml:mn>2</mml:mn></mml:msqrt></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq40.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, the network actually was not chaotic at initialization [<xref ref-type="bibr" rid="c67">67</xref>]. However, the choice of <italic>g</italic> does not influence the solution in the oblique regime qualitatively, so both marginal and lazy solutions cease to exist (<xref ref-type="fig" rid="fig25">Fig. 25</xref>).</p>
<fig id="fig10" position="float" fig-type="figure">
<label>Fig. 10:</label>
<caption><p>Noise-induced learning for a linear network with input-driven fixed point. Learning separates into fast learning of the bias part of the loss (left), and slow learning reducing the variance part (right). Learning rates are <italic>η = η<sub>0</sub>/N</italic> and <italic>η = η</italic><sub>0</sub>, respectively, with <italic>η</italic><sub>0</sub> = 0.002 and network size <italic>N</italic> = 256. Learning epochs in the first phase are counted from -1000, so that the second phase starts at 0. In the right column, the initial learning phase with learning time steps multiplied by 1/<italic>N</italic> is shown for comparison. In all plots, simulations (full lines) are compared with theory (dashed lines). <bold>A</bold> Loss <italic>L</italic> = <italic>L</italic><sub>bias</sub> + <italic>L</italic><sub>var</sub>. The two components are obtained by averaging over a batch with 32 examples at each learning step. The full loss is not plotted in the slow phase, because it is indistinguishable from <italic>L</italic><sub>var</sub>. <bold>B</bold> Coefficients of the 2-by-2 coupling matrix <italic>M</italic>. <italic>M</italic><sub>11</sub> = <italic>λ</italic><sub>−</sub> is the feedback loop along the output weights, <inline-formula id="ID41">
<alternatives>
<mml:math display="inline" id="I41"><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>b</mml:mi><mml:mo>/</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq41.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> a feedforward coupling from input to output. The theory predicts <italic>M<sub>21</sub> ~ M<sub>22</sub> ~ O</italic>(1/<italic>N</italic>). <bold>C</bold> Norm of state changes during training. The theory predicts that it remains constant during the second phase and small compared to <inline-formula id="ID42">
<alternatives>
<mml:math display="inline" id="I42"><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mover accent="true"><mml:mtext>x</mml:mtext><mml:mo>¯</mml:mo></mml:mover><mml:mn>0</mml:mn></mml:msub></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq42.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. Other parameters: target <italic>ẑ</italic> = 1, <italic>σ</italic><sub>noise</sub> = 1, overlap between input and output vectors <inline-formula id="ID43">
<alternatives>
<mml:math display="inline" id="I43"><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>o</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mn>0.5</mml:mn><mml:mo>/</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq43.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>.</p></caption>
<graphic xlink:href="2307.07654v3_fig10.tif" mime-subtype="tif" mimetype="image"/>
</fig>
</sec>
</sec>
<sec id="s7-8">
<title>4.8. Learning with noise for linear RNNs</title>
<p>In the next two sections, we aim to understand how adding noise affects dynamics and training. We start with a simple setting of a linear RNN which allows us to track the learning dynamics analytically. Despite its simplicity, this setting already captures a range of observations: different time scales for learning the bias and variance part, and the rise of a negative feedback loop for noise suppression. Oblique dynamics, however, do not arise, showing that these need autonomously generated, nonlinear dynamics, covered in Section 4.9.</p>
<p>We consider a linear network driven by a constant input and additional white noise. The dynamics read
<disp-formula id="FD18">
<alternatives>
<mml:math id="M18" display="block"><mml:mover accent="true"><mml:mtext>x</mml:mtext><mml:mo>˙</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mi>I</mml:mi><mml:mo>+</mml:mo><mml:mi>W</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mtext>x</mml:mtext><mml:mo>+</mml:mo><mml:msub><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>in</mml:mtext></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>ξ</mml:mi><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn18.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(18)</label>
</disp-formula>
</p>
<p>with noise <italic><bold>ξ</bold></italic> as in <xref ref-type="disp-formula" rid="FD4">Eq. (4)</xref>. We focus on a simplified task, which is to produce a constant nonzero output <italic>ẑ</italic> once the average dynamics converged, i.e., for large trial times. The output is <inline-formula id="ID44">
<alternatives>
<mml:math display="inline" id="I44"><mml:mi>z</mml:mi><mml:mo>=</mml:mo><mml:msubsup><mml:mtext>w</mml:mtext><mml:mrow><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi></mml:mrow><mml:mi>T</mml:mi></mml:msubsup><mml:mtext>x</mml:mtext><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>+</mml:mo><mml:mi>δ</mml:mi><mml:mi>z</mml:mi></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq44.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, where the bar denotes average over the noise, and the delta fluctuations around the average. The average is given by <inline-formula id="ID45">
<alternatives>
<mml:math display="inline" id="I45"><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:msubsup><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msubsup><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>W</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mtext>win</mml:mtext></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq45.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. We train the network by changing only the recurrent weights <italic>W</italic> via gradient descent. For small output weights, the fluctuations are too small to affect training: <inline-formula id="ID46">
<alternatives>
<mml:math display="inline" id="I46"><mml:mi>δ</mml:mi><mml:mi>z</mml:mi><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq46.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. Apart from a small correction, learning dynamics are then the same as for small output weights and no noise, a setting analyzed in Ref. [<xref ref-type="bibr" rid="c69">69</xref>]. Here we only consider the case of large output weights.</p>
<p>The loss separates into two parts, <italic>L = L</italic><sub>bias</sub> + <italic>L</italic><sub>var</sub> with <inline-formula id="ID47">
<alternatives>
<mml:math display="inline" id="I47"><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mi>b</mml:mi><mml:mi>i</mml:mi><mml:mi>a</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq47.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> and <inline-formula id="ID48">
<alternatives>
<mml:math display="inline" id="I48"><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mi>var</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>δ</mml:mi><mml:msup><mml:mi>z</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mi>var</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>δ</mml:mi><mml:mi>z</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq48.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. Learning aims to minimize the sum. We first consider learning based on each part alone and then join both to describe the full learning dynamics.</p>
<p>Learning based on the bias part alone converges to a lazy solution (see Appendix A.2). For no initial weights, <italic>W</italic><sub>0</sub> = 0, we have to leading order
<disp-formula id="FD19">
<alternatives>
<mml:math id="M19" display="block"><mml:mi>Δ</mml:mi><mml:mi>W</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:mfrac><mml:msub><mml:mover accent="true"><mml:mtext>w</mml:mtext><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub><mml:msubsup><mml:mover accent="true"><mml:mtext>w</mml:mtext><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mtext>in,</mml:mtext><mml:mo>⊥</mml:mo></mml:mrow><mml:mi>T</mml:mi></mml:msubsup><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn19.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(19)</label>
</disp-formula>
</p>
<p>with
<disp-formula id="FD20">
<alternatives>
<mml:math id="M20" display="block"><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>N</mml:mi><mml:mi>η</mml:mi><mml:mi>τ</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo>−</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>o</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn20.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(20)</label>
</disp-formula>
</p>
<p>Thus, △<italic>W</italic> is rank one with norm <inline-formula id="ID49">
<alternatives>
<mml:math display="inline" id="I49"><mml:msub><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>W</mml:mi></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>~</mml:mo><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:mfrac></mml:mstyle></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq49.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. Furthermore, for a learning rate <italic>η</italic>, it converges in <inline-formula id="ID50">
<alternatives>
<mml:math display="inline" id="I50"><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mi>η</mml:mi><mml:mi>N</mml:mi></mml:mrow></mml:mfrac></mml:mstyle></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq50.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> time steps. We will see that this is very fast compared to learning the variance part.</p>
<sec id="s7-8-1">
<title>4.8.1. Learning to reduce noise alone slowly produces a negative feedback loop</title>
<p>Next, we consider learning based on the variance part <italic>L</italic><sub>var</sub> alone, that is, to reduce fluctuations in the output while ignoring the mean. The network dynamics are linear, so that <italic>δ<bold>x</bold></italic> is an Ornstein-Uhlenbeck process. Its stationary variance ∑ is the solution to the Lyapunov equation
<disp-formula id="FD21">
<alternatives>
<mml:math id="M21" display="block"><mml:mn>0</mml:mn><mml:mo>=</mml:mo><mml:mi>A</mml:mi><mml:mi>Σ</mml:mi><mml:mo>+</mml:mo><mml:mi>Σ</mml:mi><mml:msup><mml:mi>A</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>noise</mml:mtext></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mi>I</mml:mi><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn21.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(21)</label>
</disp-formula>
</p>
<p>where <italic>A = −I + W</italic>. The variance part of the loss is then
<disp-formula id="FD22">
<alternatives>
<mml:math id="M22" display="block"><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mi>var</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msubsup><mml:mi>Σ</mml:mi><mml:msub><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn22.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(22)</label>
</disp-formula>
</p>
<p>One can state the gradient of this loss in terms of a second Lyapunov <xref ref-type="disp-formula" rid="FD84">equation [84]</xref>:
<disp-formula id="FD23">
<alternatives>
<mml:math id="M23" display="block"><mml:msub><mml:mi>G</mml:mi><mml:mrow><mml:mi>var</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mtext>d</mml:mtext><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mi>var</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mtext>d</mml:mtext><mml:mi>W</mml:mi></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>Ω</mml:mi><mml:mi>Σ</mml:mi><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn23.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(23)</label>
</disp-formula>
</p>
<p>where Ω is the soulution to
<disp-formula id="FD24">
<alternatives>
<mml:math id="M24" display="block"><mml:mn>0</mml:mn><mml:mo>=</mml:mo><mml:mi>A</mml:mi><mml:mi>Ω</mml:mi><mml:mo>+</mml:mo><mml:mi>Ω</mml:mi><mml:msup><mml:mi>A</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mo>+</mml:mo><mml:msub><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub><mml:msubsup><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msubsup><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn24.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(24)</label>
</disp-formula>
</p>
<p>Generally, solving both Lyapunov equations analytically is not possible, and even results for random matrices are still sparse (e.g. for symmetric Wigner matrices <italic>W</italic> [<xref ref-type="bibr" rid="c53">53</xref>]). To gain intuition, we thus restrict ourselves to the case of no initial connectivity, which leads to the connectivity spanned by input and output weights only. We start with the simplest case of a rank-one matrix only spanned by the output weights, <inline-formula id="ID51">
<alternatives>
<mml:math display="inline" id="I51"><mml:mi>W</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mtext>λ</mml:mtext><mml:mo>−</mml:mo></mml:msub><mml:msub><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub><mml:msubsup><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msubsup></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq51.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, and extend to rank two in the following section. The Lyapunov equations then become one-dimensional, and we obtain
<disp-formula id="FD25">
<alternatives>
<mml:math id="M25" display="block"><mml:mi>Σ</mml:mi><mml:mo>=</mml:mo><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>noise</mml:mtext></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>I</mml:mi><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mtext>λ</mml:mtext><mml:mo>−</mml:mo></mml:msub></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mtext>λ</mml:mtext><mml:mo>−</mml:mo></mml:msub></mml:mrow></mml:mfrac><mml:msub><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub><mml:msubsup><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn25.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(25)</label>
</disp-formula>
<disp-formula id="FD26">
<alternatives>
<mml:math id="M26" display="block"><mml:mi>Ω</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mtext>λ</mml:mtext><mml:mo>−</mml:mo></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:msub><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub><mml:msubsup><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msubsup><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn26.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(26)</label>
</disp-formula>
</p>
<p>The gradient <italic>G<sub>var</sub></italic> = 2∑Ω is therefore in the same subspace as <italic>W</italic>, and we can evaluate the onedimensional dynamics
<disp-formula id="FD27">
<alternatives>
<mml:math id="M27" display="block"><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mtext>dλ</mml:mtext></mml:mrow><mml:mo>−</mml:mo></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mtext>d</mml:mtext><mml:mi>τ</mml:mi></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mo>−</mml:mo><mml:mi>η</mml:mi><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>noise</mml:mtext></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mtext>λ</mml:mtext><mml:mo>−</mml:mo></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn27.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(27)</label>
</disp-formula>
</p>
<p>where <italic>τ</italic> is the number of update steps. We assume <italic>τ</italic> to be continuous, that is, we assume a sufficiently small learning rate and approximate the discrete dynamics of gradient descent with gradient flow. With initial condition <italic>λ</italic><sub>−</sub>(0) = 0, the solution is
<disp-formula id="FD28">
<alternatives>
<mml:math id="M28" display="block"><mml:msub><mml:mtext>λ</mml:mtext><mml:mo>−</mml:mo></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>3</mml:mn><mml:mi>η</mml:mi><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>noise</mml:mtext></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mi>τ</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mn>3</mml:mn></mml:mfrac></mml:mrow></mml:msup><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn28.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(28)</label>
</disp-formula>
</p>
<p>which is negative for <italic>τ</italic> &gt; 0. The loss then decays as
<disp-formula id="FD29">
<alternatives>
<mml:math id="M29" display="block"><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mi>var</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>noise</mml:mtext></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>3</mml:mn><mml:mi>η</mml:mi><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>noise</mml:mtext></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mi>τ</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>3</mml:mn></mml:mfrac></mml:mrow></mml:msup><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn29.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(29)</label>
</disp-formula>
</p>
<p>namely at order <italic>O</italic>(<italic>τ</italic><sup>−1/3</sup>) in learning time. We thus obtained that, during the variance phase of learning, connectivity develops a negative feedback look aligned with the output weights, which serves to suppress output noise. For very long learning times, <italic>τ ~ N<sup>3</sup>/η</italic>, learning can in principle reduce the output fluctuations to <inline-formula id="ID52">
<alternatives>
<mml:math display="inline" id="I52"><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:mfrac></mml:mstyle></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq52.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. Note, however, that this implies a huge negative feedback loop, <italic>λ</italic><sub>−</sub> = <italic>O</italic>(<italic>N</italic>), which potentially leads to instability in a system with delays or discretized dynamics [<xref ref-type="bibr" rid="c29">29</xref>].</p>
</sec>
<sec id="s7-8-2">
<title>4.8.2. Optimizing mean and fluctuations occurs on different time scales</title>
<p>We now consider learning both the mean and the variance part. For zero initial recurrent weights, <italic>W</italic>0 = 0, the input and output vectors make up the only relevant directions in space. We thus express the recurrent weights as a rank-two matrix, <italic>W</italic> = <italic>ÛMÛ<sup>T</sup></italic>, with orthonormal basis <italic>Û</italic> = [<bold>ŵ</bold><sub>out</sub>, <bold>ŵ</bold><sub>in, ⊥</sub>]. The hats indicate normalized vectors. For large networks and large output weights, the first vector is already normalized, <bold>ŵ</bold><sub>out</sub> = <bold>w</bold><sub>out</sub>. The second vector is the input weights after Gram-Schmidt. Assuming that <bold>w</bold><sub>out</sub> and <bold>w</bold><sub>in</sub> are drawn independently, we have a small, random correlation <inline-formula id="ID53">
<alternatives>
<mml:math display="inline" id="I53"><mml:mrow><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>o</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq53.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, and can write <inline-formula id="ID54">
<alternatives>
<mml:math display="inline" id="I54"><mml:msub><mml:mover accent="true"><mml:mtext>w</mml:mtext><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mtext>in,</mml:mtext><mml:mo>⊥</mml:mo></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mover accent="true"><mml:mtext>w</mml:mtext><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mtext>in</mml:mtext></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mtext>W</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>o</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac></mml:mstyle></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq54.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>.</p>
<p>We computed the learning dynamics in terms of the coefficient matrix <italic>M</italic>, using the same tools introduced above, and the insight that learning the mean is much faster than learning to reduce the variance. The details are relegated to Appendix A.3, here we summarize the results. We obtained
<disp-formula id="FD30">
<alternatives>
<mml:math id="M30" display="block"><mml:mi>M</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mtext>λ</mml:mtext><mml:mo>−</mml:mo></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mfrac><mml:mrow><mml:mi>b</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:mfrac></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn30.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(30)</label>
</disp-formula>
</p>
<p>Before discussing the temporal evolution of the two components, we analyze the structure of the matrix. The eigenvalue <italic>M</italic><sub>11</sub> = <italic>λ</italic><sub>−</sub> is a negative feedback loop along the eigenvector <bold>w<sub>out</sub></bold>, and <inline-formula id="ID55">
<alternatives>
<mml:math display="inline" id="I55"><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>b</mml:mi><mml:mo>/</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq55.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> is a small feedforward component <italic>b</italic> which maps the input to the output. Along the input direction <bold>ŵ</bold><sub>in</sub>, learning does not change the dynamics: The second eigenvalue, corresponding to this direction, is zero.</p>
<p>The dynamics unfold on two time scales. First, there is a very fast learning of the bias via the feedforward coefficient
<disp-formula id="FD31">
<alternatives>
<mml:math id="M31" display="block"><mml:mi>b</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>N</mml:mi><mml:mi>η</mml:mi><mml:mi>τ</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo>−</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>o</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn31.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(31)</label>
</disp-formula>
</p>
<p>During this phase, the eigenvalue <italic>M</italic><sub>11</sub> = <italic>λ</italic><sub>−</sub> remains at zero, so that overall weight changes remain small, <inline-formula id="ID56">
<alternatives>
<mml:math display="inline" id="I56"><mml:mrow><mml:mo>‖</mml:mo><mml:mi>W</mml:mi><mml:mo>‖</mml:mo></mml:mrow><mml:mo>~</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq56.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. The average fixed point also does not change much, <inline-formula id="ID57">
<alternatives>
<mml:math display="inline" id="I57"><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:mi>Δ</mml:mi><mml:mover accent="true"><mml:mtext>x</mml:mtext><mml:mo>¯</mml:mo></mml:mover><mml:mrow><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq57.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, in comparison to the fixed point before learning, <inline-formula id="ID58">
<alternatives>
<mml:math display="inline" id="I58"><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mover accent="true"><mml:mtext>x</mml:mtext><mml:mo>¯</mml:mo></mml:mover><mml:mn>0</mml:mn></mml:msub></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>in</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq58.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. The loss evolves as
<disp-formula id="FD32">
<alternatives>
<mml:math id="M32" display="block"><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mtext>bias</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>4</mml:mn><mml:mi>N</mml:mi><mml:mi>η</mml:mi><mml:mi>τ</mml:mi></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo>−</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>o</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn32.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(32)</label>
</disp-formula>
</p>
<p>The variance part of the loss does not change during this phase.</p>
<p>In a second, slower learning phase, the eigenvalue <italic>λ</italic><sub>−</sub> evolves like above, <xref ref-type="disp-formula" rid="FD28">Eq. (28)</xref>, the case where only the variance part is learned. The second coefficient compensates for the resulting change in the output. This compensation happens at a much faster time scale (<italic>N</italic><sup>3</sup> times faster than <italic>λ</italic><sub>−</sub>), so we consider its steady state:
<disp-formula id="FD33">
<alternatives>
<mml:math id="M33" display="block"><mml:mi>b</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mtext>λ</mml:mtext><mml:mo>−</mml:mo></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>o</mml:mi></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn33.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(33)</label>
</disp-formula>
</p>
<p>Because of this compensation, the bias part of the loss always remains at zero, and the full loss <italic>L</italic>(<italic>τ</italic>) = <italic>L</italic><sub>var</sub>(<italic>τ</italic>) evolves as before, <xref ref-type="disp-formula" rid="FD29">Eq. (29)</xref>. Meanwhile, the average fixed point does not change anymore; we have <inline-formula id="ID59">
<alternatives>
<mml:math display="inline" id="I59"><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:mi>Δ</mml:mi><mml:mover accent="true"><mml:mtext>x</mml:mtext><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo>−</mml:mo><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>o</mml:mi></mml:mrow></mml:msub><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq59.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>.</p>
<fig id="fig11" position="float" fig-type="figure">
<label>Fig. 11:</label>
<caption><p>Cartoon illustrating the split into bias and variance components of the loss, and noise suppression along the output direction. The two-dimensional subspace spanned by <italic>U</italic> illustrates the main directions under consideration: the PCs of the average trajectories (here only a fixed point <inline-formula id="ID60">
<alternatives>
<mml:math display="inline" id="I60"><mml:mover accent="true"><mml:mtext>x</mml:mtext><mml:mo>¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mi>U</mml:mi><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq60.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>), and the direction of output weights <inline-formula id="ID61">
<alternatives>
<mml:math display="inline" id="I61"><mml:msub><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:mfrac></mml:mstyle><mml:mi>U</mml:mi><mml:msub><mml:mtext>v</mml:mtext><mml:mrow><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq61.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. Left: During learning, a fast process keeps the average output close to the target so that <italic>L</italic><sub>bias</sub> = 0. Center: The variance component, <italic>L</italic><sub>var</sub>, is determined by the projection of the fluctuations <italic>δκ</italic> onto the output vector. Note that the noise in the low-D subspace is very small, <inline-formula id="ID62">
<alternatives>
<mml:math display="inline" id="I62"><mml:mi>δ</mml:mi><mml:mi>κ</mml:mi><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq62.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, but the output is still affected due to the large output weights. Right: During training, the noise becomes non-isotropic. Along the average direction <inline-formula id="ID63">
<alternatives>
<mml:math display="inline" id="I63"><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq63.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, the fluctuations are increased as a byproduct of the positive feedback <italic>λ</italic><sub>+</sub>. Meanwhile, a slow learning process suppresses the output variance via a negative feedback <italic>λ</italic><sub>−</sub>.</p></caption>
<graphic xlink:href="2307.07654v3_fig11.tif" mime-subtype="tif" mimetype="image"/>
</fig>
<p>We compare our theoretical predictions against numerical simulations in <xref ref-type="fig" rid="fig10">Fig. 10</xref>. For the task, we let the linear network dynamics converge from <bold>x</bold>(0) = <bold>0</bold> until <italic>t</italic> = 15, and demand the output <italic>z</italic>(<italic>t</italic>) to be at the target <italic>ẑ</italic> during the interval <italic>t</italic> ∈ [<xref ref-type="bibr" rid="c15">15</xref>, <xref ref-type="bibr" rid="c20">20</xref>]. Because the first learning phase converges <italic>N</italic> times faster than the second one (with <italic>N</italic> = 256), using a single learning rate <italic>η</italic> is problematic. One can either observe the first phase only (for small <italic>η</italic>) or risk unstable learning during the first phase (for large <italic>η</italic>). We thus split learning into two parts with adapted learning rates. For the initial phase, we set a learning rate to <italic>η</italic> = <italic>η</italic><sub>0</sub>/<italic>N</italic>, with <italic>η</italic><sub>0</sub> = 0.002 (<xref ref-type="fig" rid="fig10">Fig. 10</xref> left column). For the second phase, we set <italic>η</italic> = <italic>η</italic><sub>0</sub> (<xref ref-type="fig" rid="fig10">Fig. 10</xref> right column). Theory and simulation agree well for both phases. Small deviations can be observed for the second phase and long learning times: nonzero coefficients <italic>M</italic><sub>21</sub> and <italic>M</italic><sub>22</sub> and a corresponding increase in the norm <inline-formula id="ID64">
<alternatives>
<mml:math display="inline" id="I64"><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:mi>Δ</mml:mi><mml:mover accent="true"><mml:mtext>x</mml:mtext><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq64.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. Testing with larger network sizes showed that these errors decreased as <italic>O</italic>(1/<italic>N</italic>), which is consistent with our theory above (not shown).</p>
<p>Our results show that learning in this linear system is a hybrid between oblique and aligned during the second phase. We have a large term that compresses the output noise, but a very small, “lazy” correction in the feedforward component that corrects the output, and the states are only marginally changed. Although this system is a somewhat degenerate limiting case, we can still derive important insights. The two most striking features – the different time scales of the two learning processes, and the slow emergence of negative feedback, <inline-formula id="ID65">
<alternatives>
<mml:math display="inline" id="I65"><mml:mrow><mml:msub><mml:mi>λ</mml:mi><mml:mo>−</mml:mo></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>~</mml:mo><mml:mo>−</mml:mo><mml:msup><mml:mi>τ</mml:mi><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq65.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, along the output – are found robustly also for nonlinear networks and other tasks.</p>
</sec>
</sec>
<sec id="s7-9">
<title>4.9. Oblique solutions arise for noisy, nonlinear systems</title>
<p>We now examine the origin of oblique solutions. The linear system did not yield oblique solutions, so we turn to a nonlinear model. We consider a 1D flip-flop task, where the network has to yield a constant, nonzero output <italic>ǩ</italic> depending on the sign of the last input pulse. We further simplify the analysis by only considering the steady state of a network, not how the input pulse mediates the transition. At the output, we thus only consider the average <inline-formula id="ID66">
<alternatives>
<mml:math display="inline" id="I66"><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq66.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> and the fluctuations <italic>δz</italic>. As for the linear network, the loss splits into a bias part <inline-formula id="ID67">
<alternatives>
<mml:math display="inline" id="I67"><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mi>b</mml:mi><mml:mi>i</mml:mi><mml:mi>a</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq67.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> and variance part <inline-formula id="ID68">
<alternatives>
<mml:math display="inline" id="I68"><mml:mrow><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mi>var</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>δ</mml:mi><mml:msup><mml:mi>z</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq68.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. As before, we assume that learning only acts on a low-dimensional parameter matrix <italic>M</italic>.</p>
<p>Because following the learning dynamics in nonlinear networks is difficult, we take a different approach. We develop a mean field theory to show how noise affects the dynamics of a nonlinear network with autonomous fixed points. This allows us to compute the loss components <italic>L</italic><sub>bias</sub> and <italic>L</italic><sub>var</sub> in terms of <italic>M</italic>. We then show that the minimum of the loss function corresponds to oblique solutions. This leads to a clear interpretation of the mechanisms pushing for oblique solutions. Finally, we show that the theory quantitatively predicts the outcome of learning with gradient descent.</p>
<sec id="s7-9-1">
<title>4.9.1. Rank-two connectivity model with fixed point</title>
<p>We first introduce the connectivity model and compute the latent dynamics using mean field theory. We constrain the recurrent connectivity to a rank-two model of the form <inline-formula id="ID69">
<alternatives>
<mml:math display="inline" id="I69"><mml:mi>W</mml:mi><mml:mo>=</mml:mo><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac></mml:mstyle><mml:mi>U</mml:mi><mml:mi>M</mml:mi><mml:msup><mml:mi>U</mml:mi><mml:mi>T</mml:mi></mml:msup></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq69.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, where <italic>M</italic> is a 2 × 2 coefficient matrix to be learned. The randomly drawn projection matrix <italic>U</italic> ∈ ℝ<sup><italic>N</italic>×2</sup> has entries <italic>U<sub>ia</sub></italic> drawn independently from a standard normal distribution. This implies orthogonality to leading order, <inline-formula id="ID70">
<alternatives>
<mml:math display="inline" id="I70"><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac></mml:mstyle><mml:msup><mml:mi>U</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>U</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>I</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq70.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. We will discard the correction term, as it does not change our results apart from a constant bias. We further assume that the input and output vectors are spanned by <italic>U</italic>, although not necessarily identified with the components of <italic>U</italic> as in the previous section. Note also that for clarity we do not normalize <italic>U</italic> as <italic>Û</italic> before. The assumption of Gaussian connectivity greatly simplifies the math, while its restrictions are irrelevant to the task considered here [<xref ref-type="bibr" rid="c4">4</xref>, <xref ref-type="bibr" rid="c13">13</xref>, <xref ref-type="bibr" rid="c68">68</xref>].</p>
<p>To understand the dynamics <xref ref-type="disp-formula" rid="FD4">Eq. (4)</xref> analytically, we make use of the low-rank connectivity. Following previous work [<xref ref-type="bibr" rid="c29">29</xref>, <xref ref-type="bibr" rid="c57">57</xref>], we split the dynamics into two parts: a parallel part <bold>X</bold><sub>║</sub> in the subspace spanned by <italic>U</italic>, and an orthogonal part <bold>x</bold><sub>⊥</sub>. This yields
<disp-formula id="FD34">
<alternatives>
<mml:math id="M34" display="block"><mml:msub><mml:mover accent="true"><mml:mtext>x</mml:mtext><mml:mo>˙</mml:mo></mml:mover><mml:mo>∥</mml:mo></mml:msub><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mtext>x</mml:mtext><mml:mo>∥</mml:mo></mml:msub><mml:mo>+</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:mi>U</mml:mi><mml:mi>M</mml:mi><mml:msup><mml:mi>U</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>ϕ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mtext>x</mml:mtext><mml:mo>∥</mml:mo></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mtext>x</mml:mtext><mml:mo>⊥</mml:mo></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:mi>U</mml:mi><mml:msup><mml:mi>U</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>ξ</mml:mi><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn34.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(34)</label>
</disp-formula>
<disp-formula id="FD35">
<alternatives>
<mml:math id="M35" display="block"><mml:msub><mml:mover accent="true"><mml:mtext>x</mml:mtext><mml:mo>˙</mml:mo></mml:mover><mml:mo>⊥</mml:mo></mml:msub><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mtext>x</mml:mtext><mml:mo>⊥</mml:mo></mml:msub><mml:mo>+</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>I</mml:mi><mml:mo>−</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:mi>U</mml:mi><mml:msup><mml:mi>U</mml:mi><mml:mi>T</mml:mi></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mi>ξ</mml:mi><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn35.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(35)</label>
</disp-formula>
</p>
<p>Notice that the parallel part is partially driven by the orthogonal one, but not vice versa. The parallel part can be expressed in terms of the latent variable
<disp-formula id="FD36">
<alternatives>
<mml:math id="M36" display="block"><mml:mi>κ</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:msup><mml:mi>U</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mtext>x</mml:mtext><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:msup><mml:mi>U</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mtext>x</mml:mtext><mml:mo>∥</mml:mo></mml:msub><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn36.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(36)</label>
</disp-formula>
</p>
<p>The scaling here ensures that <italic><bold>κ</bold></italic> is order one if <bold>X</bold><sub>║</sub> has order-one states. Because the readout is assumed to be spanned by <italic>U</italic>, the output is fully determined by the parallel part. We can write
<disp-formula id="FD37">
<alternatives>
<mml:math id="M37" display="block"><mml:mi>z</mml:mi><mml:mo>=</mml:mo><mml:msubsup><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msubsup><mml:msub><mml:mtext>x</mml:mtext><mml:mo>∥</mml:mo></mml:msub><mml:mo>=</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt><mml:msubsup><mml:mtext>v</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msubsup><mml:mi>κ</mml:mi><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn37.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(37)</label>
</disp-formula>
</p>
<p>with projected output weights <inline-formula id="ID71">
<alternatives>
<mml:math display="inline" id="I71"><mml:msub><mml:mtext>v</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:mfrac></mml:mstyle><mml:msup><mml:mi>U</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq71.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. Note that we assume large output weights, ║w<sub>out</sub>║ = 1, so that <bold>v</bold>out is also normalized.</p>
<p>We split the latent state into its average over the noise <italic><bold>ξ</bold></italic> and fluctuations, <inline-formula id="ID72">
<alternatives>
<mml:math display="inline" id="I72"><mml:mi>κ</mml:mi><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>+</mml:mo><mml:mi>δ</mml:mi><mml:mi>κ</mml:mi></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq72.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. Similarly, the output splits into <inline-formula id="ID73">
<alternatives>
<mml:math display="inline" id="I73"><mml:mi>z</mml:mi><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>+</mml:mo><mml:mi>δ</mml:mi><mml:mi>z</mml:mi></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq73.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. The loss then has two components, <italic>L = L</italic><sub>bias</sub> + <italic>L</italic><sub>var</sub>, with
<disp-formula id="FD38">
<alternatives>
<mml:math id="M38" display="block"><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mtext>bias</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt><mml:msubsup><mml:mtext>v</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msubsup><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn38.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(38)</label>
</disp-formula>
<disp-formula id="FD39">
<alternatives>
<mml:math id="M39" display="block"><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mi>var</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>δ</mml:mi><mml:msup><mml:mi>z</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mi>N</mml:mi><mml:mtext> </mml:mtext><mml:msubsup><mml:mtext>v</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msubsup><mml:mover accent="true"><mml:mrow><mml:mi>δ</mml:mi><mml:mi>κ</mml:mi><mml:mi>δ</mml:mi><mml:msup><mml:mi>κ</mml:mi><mml:mi>T</mml:mi></mml:msup></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:msub><mml:mtext>v</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn39.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(39)</label>
</disp-formula>
</p>
<p>We want to understand situations with small loss. For the bias term, the average <inline-formula id="ID74">
<alternatives>
<mml:math display="inline" id="I74"><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq74.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> must be either small or oblique to the readout weights. For the variance term, the covariance of the fluctuations, <inline-formula id="ID75">
<alternatives>
<mml:math display="inline" id="I75"><mml:mi>cov</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>δ</mml:mi><mml:mi>κ</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>δ</mml:mi><mml:mi>κ</mml:mi><mml:mi>δ</mml:mi><mml:msup><mml:mi>κ</mml:mi><mml:mi>T</mml:mi></mml:msup></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq75.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, must be compressed along the output direction: Even though the covariance is <italic>O</italic>(1/<italic>N</italic>), it still projects to the output at <italic>O</italic>(1), as reflected by the factor <italic>N</italic> in <xref ref-type="disp-formula" rid="FD39">Eq. (39)</xref>. <xref ref-type="fig" rid="fig11">Fig. 11</xref> illustrates the situation in a cartoon from this high-level perspective.</p>
<p>To understand the underlying mechanisms in detail, we next explore how the relevant variables <inline-formula id="ID76">
<alternatives>
<mml:math display="inline" id="I76"><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq76.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> and <italic>δκ</italic> are determined by the coupling matrix <italic>M</italic>. We do so by applying mean field theory, following previous works [<xref ref-type="bibr" rid="c29">29</xref>, <xref ref-type="bibr" rid="c42">42</xref>, <xref ref-type="bibr" rid="c67">67</xref>, <xref ref-type="bibr" rid="c68">68</xref>]. Detailed derivations can be found in Appendix A.4. Here we present the high-level results. The average dynamics converge to a fixed point determined by the equation for the latent variable,
<disp-formula id="FD40">
<alternatives>
<mml:math id="M40" display="block"><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mrow><mml:mo>〈</mml:mo><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>〉</mml:mo></mml:mrow><mml:mi>M</mml:mi><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn40.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(40)</label>
</disp-formula>
</p>
<p>The <inline-formula id="ID77">
<alternatives>
<mml:math display="inline" id="I77"><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq77.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> term is a constant offset for any given network that we ignore without loss of generality. The average slope is
<disp-formula id="FD41">
<alternatives>
<mml:math id="M41" display="block"><mml:mrow><mml:mo>〈</mml:mo><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>〉</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>〈</mml:mo><mml:mrow><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mi>u</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>〉</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:mrow><mml:mo>∫</mml:mo><mml:mrow><mml:mi>D</mml:mi><mml:mi>u</mml:mi><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mi>u</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mstyle><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn41.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(41)</label>
</disp-formula>
</p>
<p>with variance
<disp-formula id="FD42">
<alternatives>
<mml:math id="M42" display="block"><mml:mover accent="true"><mml:mrow><mml:msubsup><mml:mi>σ</mml:mi><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo>‖</mml:mo><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>‖</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:mover accent="true"><mml:mrow><mml:msubsup><mml:mi>σ</mml:mi><mml:mo>⊥</mml:mo><mml:mn>2</mml:mn></mml:msubsup></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn42.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(42)</label>
</disp-formula>
</p>
<p>(We have <inline-formula id="ID78">
<alternatives>
<mml:math display="inline" id="I78"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msubsup><mml:mi>σ</mml:mi><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover></mml:mrow></mml:msqrt></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq78.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> because the fluctuations are small.) The orthogonal variance is simply the variance of the noise, <inline-formula id="ID79">
<alternatives>
<mml:math display="inline" id="I79"><mml:msubsup><mml:mi>σ</mml:mi><mml:mo>⊥</mml:mo><mml:mn>2</mml:mn></mml:msubsup><mml:mo>=</mml:mo><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>noise</mml:mtext></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq79.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. The fixed point <xref ref-type="disp-formula" rid="FD40">Eq. (40)</xref>, implies that for a nonzero fixed point, the matrix <italic>M</italic> must have an eigenvalue
<disp-formula id="FD43">
<alternatives>
<mml:math id="M43" display="block"><mml:msub><mml:mtext>λ</mml:mtext><mml:mo>+</mml:mo></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>〉</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn43.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(43)</label>
</disp-formula>
</p>
<p>This is very similar to the noiseless situation discussed briefly above, <xref ref-type="disp-formula" rid="FD14">Eq. (14)</xref>. However, here the additional variance <inline-formula id="ID80">
<alternatives>
<mml:math display="inline" id="I80"><mml:msubsup><mml:mi>σ</mml:mi><mml:mo>⊥</mml:mo><mml:mn>2</mml:mn></mml:msubsup></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq80.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> decreases the average slope due to saturation of the nonlinearity. This in turn increases the minimal eigenvalue for a nonzero fixed point, which can be found by setting <inline-formula id="ID81">
<alternatives>
<mml:math display="inline" id="I81"><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq81.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, and hence <inline-formula id="ID82">
<alternatives>
<mml:math display="inline" id="I82"><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mo>⊥</mml:mo></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq82.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>:
<disp-formula id="FD44">
<alternatives>
<mml:math id="M44" display="block"><mml:msub><mml:mtext>λ</mml:mtext><mml:mrow><mml:mo>+</mml:mo><mml:mo>,</mml:mo><mml:mi>min</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:mrow><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mo>⊥</mml:mo></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mi>u</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>〉</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn44.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(44)</label>
</disp-formula>
</p>
<p>In other words, the noise decreases the effective gain <inline-formula id="ID83">
<alternatives>
<mml:math display="inline" id="I83"><mml:mrow><mml:mo>〈</mml:mo><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>〉</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq83.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, and thus the connectivity eigenvalue <italic>A</italic> + needs to compensate. From the point of view of the spectrum, we are thus pushed away from the margin 1 + <italic>e</italic>. These considerations, however, do not exclude the possibility that dynamics converge to an average fixed point that is small and correlated, which is at odds with oblique dynamics. To understand why learning leads to oblique dynamics, we need to move beyond the average <inline-formula id="ID84">
<alternatives>
<mml:math display="inline" id="I84"><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq84.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> and take into account the fluctuations <italic>δκ</italic>.</p>
</sec>
<sec id="s7-9-2">
<title>4.9.2. Fluctuations of the latent variable</title>
<p>The fluctuations <italic>δκ</italic> around a fixed point <inline-formula id="ID85">
<alternatives>
<mml:math display="inline" id="I85"><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq85.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> are driven by the noise, both directly and indirectly via the dynamics. The direct contribution is a white noise term of order <inline-formula id="ID86">
<alternatives>
<mml:math display="inline" id="I86"><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq86.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> because <italic>ξ</italic> is isotropic and independent of <italic>U</italic>. A detailed analysis (Appendix A.4) shows that the indirect contribution is given by a colored noise term which originates from the finite size fluctuations in the variance of the orthogonal part. This second term is also <inline-formula id="ID87">
<alternatives>
<mml:math display="inline" id="I87"><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq87.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, which implies that the fluctuations are small, <inline-formula id="ID88">
<alternatives>
<mml:math display="inline" id="I88"><mml:mi>δ</mml:mi><mml:mi>κ</mml:mi><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq88.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. We can thus linearize their dynamics around the mean <inline-formula id="ID89">
<alternatives>
<mml:math display="inline" id="I89"><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq89.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, which yields
<disp-formula id="FD45">
<alternatives>
<mml:math id="M45" display="block"><mml:mfrac><mml:mrow><mml:mtext>d</mml:mtext><mml:mi>δ</mml:mi><mml:mi>κ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mtext>d</mml:mtext><mml:mi>t</mml:mi></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mi>A</mml:mi><mml:mi>δ</mml:mi><mml:mi>κ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:mfrac><mml:mi>ζ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn45.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(45)</label>
</disp-formula>
</p>
<p>where the order-one term <italic>ζ</italic> contains both the white and the colored noise term. The Jacobian <italic>A</italic> depends on <italic>M</italic> and <inline-formula id="ID90">
<alternatives>
<mml:math display="inline" id="I90"><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq90.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>:
<disp-formula id="FD46">
<alternatives>
<mml:math id="M46" display="block"><mml:mi>A</mml:mi><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mi>I</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:mo>〈</mml:mo><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>〉</mml:mo></mml:mrow><mml:mi>M</mml:mi><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>‴</mml:mo></mml:msup><mml:mo>〉</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>〉</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:msup><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mi>T</mml:mi></mml:msup><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn46.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(46)</label>
</disp-formula>
</p>
<p>The averages are again evaluated at the joint variance <inline-formula id="ID91">
<alternatives>
<mml:math display="inline" id="I91"><mml:msubsup><mml:mi>σ</mml:mi><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo>‖</mml:mo><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>‖</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:msubsup><mml:mi>σ</mml:mi><mml:mo>⊥</mml:mo><mml:mn>2</mml:mn></mml:msubsup></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq91.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. Apart from the increased variance, the stability analysis yields the same results as in the noise-free case [<xref ref-type="bibr" rid="c68">68</xref>]: The Jacobian has the eigenvalues <inline-formula id="ID92">
<alternatives>
<mml:math display="inline" id="I92"><mml:mtext>γ</mml:mtext><mml:mo>+</mml:mo><mml:mo>=</mml:mo><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>″</mml:mo></mml:msup><mml:mo>〉</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>〉</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mstyle><mml:msup><mml:mrow><mml:mo>‖</mml:mo><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>‖</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq92.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> and <inline-formula id="ID93">
<alternatives>
<mml:math display="inline" id="I93"><mml:msub><mml:mtext>γ</mml:mtext><mml:mo>−</mml:mo></mml:msub><mml:mo>=</mml:mo><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mrow><mml:msub><mml:mi>λ</mml:mi><mml:mo>−</mml:mo></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>λ</mml:mi><mml:mo>+</mml:mo></mml:msub></mml:mrow></mml:mfrac></mml:mstyle><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq93.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. The average over the third derivative <inline-formula id="ID94">
<alternatives>
<mml:math display="inline" id="I94"><mml:mrow><mml:mo>〈</mml:mo><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>‴</mml:mo></mml:msup><mml:mo>〉</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq94.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> is negative, so that γ<sub>+</sub> &lt; 0. We assume that the second eigenvalue is smaller than the first, <italic>γ</italic><sub>−</sub> &lt; <italic>γ</italic><sub>+</sub>, so that <italic>γ</italic><sub>−</sub> &lt; 0. The fixed point under consideration is hence stable.</p>
<p>Next, we compute the covariance of the fluctuations at steady state, see Appendix A.4. The outcome is
<disp-formula id="FD47">
<alternatives>
<mml:math id="M47" display="block"><mml:mover accent="true"><mml:mrow><mml:mi>δ</mml:mi><mml:mi>κ</mml:mi><mml:mi>δ</mml:mi><mml:msup><mml:mi>κ</mml:mi><mml:mi>T</mml:mi></mml:msup></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>noise</mml:mtext></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:msub><mml:mi>Σ</mml:mi><mml:mi>A</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>noise</mml:mtext></mml:mrow><mml:mn>4</mml:mn></mml:msubsup></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac><mml:mfrac><mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>γ</mml:mi><mml:mo>+</mml:mo></mml:msub></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>γ</mml:mi><mml:mo>+</mml:mo></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mtext>v</mml:mtext><mml:mo>+</mml:mo><mml:msubsup><mml:mtext>v</mml:mtext><mml:mo>+</mml:mo><mml:mi>T</mml:mi></mml:msubsup></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn47.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(47)</label>
</disp-formula>
</p>
<p>where <inline-formula id="ID95">
<alternatives>
<mml:math display="inline" id="I95"><mml:msub><mml:mtext>v</mml:mtext><mml:mo>+</mml:mo></mml:msub><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>/</mml:mo><mml:mrow><mml:mo>‖</mml:mo><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>‖</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq95.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> is the normalized eigenvector of <italic>M</italic> corresponding to eigenvalue <italic>γ</italic><sub>+</sub>. The 2 × 2 matrix <italic>∑<sub>A</sub></italic> is the covariance introduced by the white noise part alone and obeys the Lyapunov equation
<disp-formula id="FD48">
<alternatives>
<mml:math id="M48" display="block"><mml:mn>0</mml:mn><mml:mo>=</mml:mo><mml:mi>A</mml:mi><mml:msub><mml:mi>Σ</mml:mi><mml:mi>A</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>Σ</mml:mi><mml:mi>A</mml:mi></mml:msub><mml:msup><mml:mi>A</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:msub><mml:mi>I</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn48.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(48)</label>
</disp-formula>
</p>
<p>The second term in <xref ref-type="disp-formula" rid="FD47">Eq. (47)</xref> stems from the colored noise component of <italic><bold>ζ</bold></italic>.</p>
<p>The loss <xref ref-type="disp-formula" rid="FD39">Eq. (39)</xref> is obtained by projecting the covariance on the output weights. Importantly, the factor 1<italic>/N</italic> in the covariance is compensated by the factor <italic>N</italic> in the loss. Hence, even if the covariance shrinks with increasing network size, the output is still affected at order one. We next explore the implications of minimizing this loss.</p>
</sec>
<sec id="s7-9-3">
<title>4.9.3. Minimizing the loss by balancing saturation and negative feedback loop</title>
<p>To gain an understanding of how the output fluctuations responsible for <italic>L</italic><sub>bias</sub> can be reduced, we first consider the case of a symmetric coefficient matrix <italic>M</italic>. Simulations of networks trained with gradient descent below show that this approximation is reasonable. For symmetric <italic>M</italic> , the orthogonal eigenvectors <bold>v</bold><sub>±</sub> with eigenvalues <italic>λ</italic><sub>±</sub> of the recurrent weights <italic>M</italic> are also eigenvectors of <italic>A</italic>, in that case corresponding to the eigenvalues <italic>γ</italic><sub>±</sub>. This allows to diagonalize the Lyapunov <xref ref-type="disp-formula" rid="FD48">Eq. (48)</xref> and yields the solution
<disp-formula id="FD49">
<alternatives>
<mml:math id="M49" display="block"><mml:msub><mml:mi>Σ</mml:mi><mml:mi>A</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mtext>v</mml:mtext><mml:mo>+</mml:mo></mml:msub><mml:msubsup><mml:mtext>v</mml:mtext><mml:mo>+</mml:mo><mml:mi>T</mml:mi></mml:msubsup></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>γ</mml:mi><mml:mo>+</mml:mo></mml:msub></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mtext>v</mml:mtext><mml:mo>−</mml:mo></mml:msub><mml:msubsup><mml:mtext>v</mml:mtext><mml:mo>−</mml:mo><mml:mi>T</mml:mi></mml:msubsup></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>γ</mml:mi><mml:mo>−</mml:mo></mml:msub></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn49.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(49)</label>
</disp-formula>
</p>
<p>For the loss <xref ref-type="disp-formula" rid="FD39">Eq. (39)</xref>, we further need the relation between the eigenvectors <bold>v</bold><sub>±</sub> and the output weights. Because the fixed point <inline-formula id="ID97">
<alternatives>
<mml:math display="inline" id="I97"><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq97.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> is parallel to the eigenvector, we have <inline-formula id="ID98">
<alternatives>
<mml:math display="inline" id="I98"><mml:msubsup><mml:mtext>v</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msubsup><mml:msub><mml:mtext>v</mml:mtext><mml:mo>+</mml:mo></mml:msub><mml:mo>=</mml:mo><mml:mi>ρ</mml:mi></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq98.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. For the other eigenvector, orthogonality yields <inline-formula id="ID99">
<alternatives>
<mml:math display="inline" id="I99"><mml:msubsup><mml:mtext>v</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msubsup><mml:msub><mml:mtext>v</mml:mtext><mml:mo>−</mml:mo></mml:msub><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mi>ρ</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:msqrt></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq99.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. Inserting this into <xref ref-type="disp-formula" rid="FD39">Eqs. (39)</xref> and <xref ref-type="disp-formula" rid="FD47">(47)</xref> yields an expression in terms of the Jacobian eigenvalues <italic>γ</italic><sub>±</sub>, the correlation <italic>ρ</italic>, and the norm of the fixed point <inline-formula id="ID100">
<alternatives>
<mml:math display="inline" id="I100"><mml:mrow><mml:mo>‖</mml:mo><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>‖</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq100.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>:
<disp-formula id="FD50">
<alternatives>
<mml:math id="M50" display="block"><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mi>var</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mi>ρ</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>noise</mml:mtext></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>γ</mml:mi><mml:mo>+</mml:mo></mml:msub></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>noise</mml:mtext></mml:mrow><mml:mn>4</mml:mn></mml:msubsup></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac><mml:mfrac><mml:mrow><mml:msub><mml:mi>γ</mml:mi><mml:mo>+</mml:mo></mml:msub></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>γ</mml:mi><mml:mo>+</mml:mo></mml:msub><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mi>ρ</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mfrac><mml:mrow><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>noise</mml:mtext></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>γ</mml:mi><mml:mo>−</mml:mo></mml:msub></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn50.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(50)</label>
</disp-formula>
</p>
<p>For more explicit insight, we choose the nonlinearity <italic>ϕ</italic>(<italic>x</italic>) = erf(<italic>αx</italic>) with <inline-formula id="ID101">
<alternatives>
<mml:math display="inline" id="I101"><mml:mi>α</mml:mi><mml:mo>=</mml:mo><mml:msqrt><mml:mi>π</mml:mi></mml:msqrt><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq101.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. Similar to tanh, this function is bounded between ±1 and has slope <inline-formula id="ID102">
<alternatives>
<mml:math display="inline" id="I102"><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq102.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> at the origin. For this function, we can explicitly compute the relevant Gaussian integrals. The minimal eigenvalue of <italic>M</italic> to produce a fixed point, <xref ref-type="disp-formula" rid="FD44">Eq. (44)</xref>, is then given by <inline-formula id="ID103">
<alternatives>
<mml:math display="inline" id="I103"><mml:msub><mml:mi>λ</mml:mi><mml:mrow><mml:mo>+</mml:mo><mml:mo>,</mml:mo><mml:mi>min</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:msup><mml:mi>α</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>noise</mml:mtext></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq103.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. For <italic>λ</italic><sub>+</sub> &gt; <italic>λ</italic><sub>+,min</sub>, the resulting fixed point has norm
<disp-formula id="FD51">
<alternatives>
<mml:math id="M51" display="block"><mml:msup><mml:mrow><mml:mo>‖</mml:mo><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>‖</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mtext>λ</mml:mtext><mml:mo>+</mml:mo><mml:mn>2</mml:mn></mml:msubsup><mml:mo>−</mml:mo><mml:msubsup><mml:mtext>λ</mml:mtext><mml:mrow><mml:mo>+</mml:mo><mml:mo>,</mml:mo><mml:mi>min</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:msup><mml:mi>α</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn51.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(51)</label>
</disp-formula>
</p>
<p>as shown in <xref ref-type="fig" rid="fig12">Fig. 12A</xref>. The larger eigenvalue of the Jacobian is <inline-formula id="ID104">
<alternatives>
<mml:math display="inline" id="I104"><mml:mtext>γ</mml:mtext><mml:mo>+</mml:mo><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mtext>λ</mml:mtext><mml:mo>+</mml:mo><mml:mn>2</mml:mn></mml:msubsup><mml:mo>−</mml:mo><mml:msubsup><mml:mtext>λ</mml:mtext><mml:mrow><mml:mo>+</mml:mo><mml:mo>,</mml:mo><mml:mi>min</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>/</mml:mo><mml:msubsup><mml:mtext>λ</mml:mtext><mml:mo>+</mml:mo><mml:mn>2</mml:mn></mml:msubsup></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq104.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. We next obtain the correlation between fixed point and output weights by assuming that the bias part of the loss <xref ref-type="disp-formula" rid="FD38">Eq. (38)</xref>, is kept at zero. This is reasonable because it requires only a small adaptation to the weights that leaves the variance part mostly untouched. The resulting correlation is
<disp-formula id="FD52">
<alternatives>
<mml:math id="M52" display="block"><mml:msup><mml:mi>ρ</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:mfrac><mml:mrow><mml:msup><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn52.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(52)</label>
</disp-formula>
</p>
<p>so that increasing <italic>λ</italic><sub>+</sub> also decreases the correlation (<xref ref-type="fig" rid="fig12">Fig. 12B</xref>). Finally, we obtain an expression for the variance part of the loss only in terms of the eigenvalues of <italic>M</italic>:
<disp-formula id="FD53">
<alternatives>
<mml:math id="M53" display="block"><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mi>var</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mi>ρ</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>i</mml:mi><mml:mi>s</mml:mi><mml:mi>e</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:msubsup><mml:mtext>λ</mml:mtext><mml:mo>+</mml:mo><mml:mn>2</mml:mn></mml:msubsup></mml:mrow><mml:mrow><mml:msubsup><mml:mtext>λ</mml:mtext><mml:mo>+</mml:mo><mml:mn>2</mml:mn></mml:msubsup><mml:mo>−</mml:mo><mml:msubsup><mml:mtext>λ</mml:mtext><mml:mrow><mml:mo>+</mml:mo><mml:mo>,</mml:mo><mml:mi>min</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>i</mml:mi><mml:mi>s</mml:mi><mml:mi>e</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msubsup><mml:msup><mml:mi>α</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mrow><mml:mn>3</mml:mn><mml:msubsup><mml:mtext>λ</mml:mtext><mml:mo>+</mml:mo><mml:mn>2</mml:mn></mml:msubsup><mml:mo>−</mml:mo><mml:msubsup><mml:mtext>λ</mml:mtext><mml:mrow><mml:mo>+</mml:mo><mml:mo>,</mml:mo><mml:mi>min</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mi>ρ</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mfrac><mml:mrow><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>noise</mml:mtext></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mtext>λ</mml:mtext><mml:mo>−</mml:mo></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mtext>λ</mml:mtext><mml:mo>+</mml:mo></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn53.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(53)</label>
</disp-formula>
</p>
<fig id="fig12" position="float" fig-type="figure">
<label>Fig. 12:</label>
<caption><p>Mechanisms behind oblique solutions predicted by mean field theory. <bold>A-D</bold>: Mean-field theory predictions as a function of positive feedback strength <italic>λ</italic><sub>+</sub>. The dotted lines indicate <italic>λ</italic><sub>+,min</sub>, the minimal eigenvalue necessary to generate fixed points. <bold>A</bold>: Norm of fixed point <inline-formula id="ID96">
<alternatives>
<mml:math display="inline" id="I96"><mml:mrow><mml:mo>‖</mml:mo><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>‖</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq96.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. <bold>B</bold>: Correlation <italic>ρ</italic> so that <italic>L</italic><sub>bias</sub> = 0. <bold>C,D</bold>: Loss due to fluctuations for different <italic>λ</italic><sub>−</sub> or networks sizes <italic>N</italic>. Dots indicate minima. <bold>E-G</bold>: Latent states <italic><bold>κ</bold></italic> of simulated networks for randomly drawn projections <italic>U</italic>. The symmetric matrix <italic>M</italic> is fixed by setting <italic>λ</italic><sub>+</sub> as noted, <italic>λ</italic><sub>−</sub> = −5, and demanding <italic>L</italic><sub>bias</sub> = 0 (for the mean field prediction). Dots are samples from the simulation interval <italic>t</italic> ∈ [20, 100]. <bold>H-J</bold>: Histogram for the corresponding output <italic>z</italic>. Mean is indicated by full lines, the dashed lines indicate the target <italic>ẑ</italic>. Other parameters: <italic>N</italic> = 256, <italic>σ</italic><sub>noise</sub> = 1 <italic>ẑ</italic> = 1</p></caption>
<graphic xlink:href="2307.07654v3_fig12.tif" mime-subtype="tif" mimetype="image"/>
</fig>
<p>We show <italic>L</italic><sub>var</sub> over <italic>λ</italic><sub>+</sub> for different negative feedback loop sizes <italic>λ</italic><sub>−</sub> (<xref ref-type="fig" rid="fig12">Fig. 12C</xref>) and different network sizes <italic>N</italic> (<xref ref-type="fig" rid="fig12">Fig. 12D</xref>). The first term diverges at the phase transition where the fixed point appears, <italic>λ</italic><sub>+</sub> ↘ <italic>λ</italic><sub>+,min</sub>. Learning will thus push the weights away from the phase transition towards larger <italic>λ</italic><sub>+</sub>. With such increasing <italic>λ</italic><sub>+</sub> , the fixed point norm increases, and the fixed point rotates away from the output, decreasing the correlation. This in term emphasizes the last term, scaled by 1 — <italic>ρ</italic><sup>2</sup>. The last term is reduced with increasingly negative <italic>λ</italic><sub>−</sub>, corresponding to the negative feedback loop that suppresses noise.</p>
<p>Learning can in principle strengthen this feedback further and further, <italic>λ</italic><sub>−</sub> → −∞ (apart from possible stability issues [<xref ref-type="bibr" rid="c29">29</xref>]). However, as for the linear network, Section 4.8, this process takes time. We thus assume <italic>λ</italic><sub>−</sub> to be fixed and search for a minimum across <italic>λ</italic><sub>+</sub>. For <italic>λ</italic><sub>−</sub> &lt; 0, the last term in <xref ref-type="disp-formula" rid="FD53">Eq. (53)</xref> <italic>increases</italic> with increasing <italic>λ</italic><sub>+</sub>: the effective feedback loop in the full, nonlinear system is weakened by saturation. The loss <italic>L</italic><sub>var</sub> thus has a minimum at some moderate <italic>λ</italic><sub>+</sub>.</p>
<p>To illustrate the mechanisms described above, we simulated networks at different <italic>λ</italic><sub>+</sub> and with <italic>λ</italic><sub>−</sub> = −5. For each <italic>λ</italic><sub>+</sub>, we compute <italic>ρ</italic> according to <xref ref-type="disp-formula" rid="FD52">Eq. (52)</xref>. Setting <bold>v</bold><sub>out</sub> = [1, 0]<sup><italic>T</italic></sup>, we then set the resulting symmetric <italic>M</italic> = <italic>V</italic>Λ<italic>V<sup>T</sup></italic>. For each network sample, we then draw independent random projections <italic>U</italic> ∈ ℝ<sup><italic>N</italic>×2</sup>. We started simulations at either one of the two nonzero fixed points. For <italic>λ</italic><sub>+</sub> just above <italic>λ</italic><sub>+,min</sub>, the noise pushes activity from one basin of attraction to the next (<xref ref-type="fig" rid="fig12">Fig. 12C</xref>). The resulting output becomes centered around zero and independent of the initial condition for long simulation times (<xref ref-type="fig" rid="fig12">Fig. 12F</xref>). For the optimal <italic>λ</italic><sub>+</sub>, the trajectories remain close to either one fixed point (<xref ref-type="fig" rid="fig12">Fig. 12F</xref>). The output forms two overlapping distributions, each closely matching the target on average (<xref ref-type="fig" rid="fig12">Fig. 12I</xref>). For larger <italic>λ</italic><sub>+</sub>, the fixed points become increasingly larger (<xref ref-type="fig" rid="fig12">Fig. 12G</xref>). While this decreases the probability of leaving the basin of attraction even further, the variance along the output weights becomes larger (slightly wider histograms in <xref ref-type="fig" rid="fig12">Fig. 12J</xref>). Note that the mean starts to deviate from the prediction. This is not covered by our theory and is potentially due to the linearization of the fluctuations.</p>
<p>All-in-all, this section revealed a potential path to oblique solutions, initiated by the large fluctuations close to a phase transition, and the interplay between the negative feedback loop and saturation. In the following section, we show that learning via gradient descent actually follows this path and that the parameters predicted by the minimum of <italic>L</italic><sub>var</sub> quantitatively predict solutions from learning.</p>
</sec>
<sec id="s7-9-4">
<title>4.9.4. Oblique solutions from learning are predicted by the mean field theory</title>
<p>We trained neural networks on the fixed points task described above by applying gradient descent to the 2 × 2 matrix <italic>M</italic>, initialized at <italic>M</italic><sub>0</sub> = 0. The gradients <italic>G<sub>M</sub></italic> with respect to <italic>M</italic> are equivalent to those with respect to <inline-formula id="ID106">
<alternatives>
<mml:math display="inline" id="I106"><mml:mi>W</mml:mi><mml:mo>=</mml:mo><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac></mml:mstyle><mml:mi>U</mml:mi><mml:mi>M</mml:mi><mml:msup><mml:mi>U</mml:mi><mml:mi>T</mml:mi></mml:msup></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq106.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> restricted to the subspace spanned by <italic>U</italic>, i.e. <inline-formula id="ID107">
<alternatives>
<mml:math display="inline" id="I107"><mml:msub><mml:mi>G</mml:mi><mml:mi>M</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac></mml:mstyle><mml:mi>U</mml:mi><mml:msup><mml:mi>U</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mi>G</mml:mi><mml:mi>W</mml:mi></mml:msub><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac></mml:mstyle><mml:mi>U</mml:mi><mml:msup><mml:mi>U</mml:mi><mml:mi>T</mml:mi></mml:msup></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq107.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. Such a restriction is exact in the case of linear RNNs without random initial connectivity, and yields qualitative insights even for nonlinear networks with random initial connectivity [<xref ref-type="bibr" rid="c69">69</xref>].</p>
<p>The output weights were set to <inline-formula id="ID108">
<alternatives>
<mml:math display="inline" id="I108"><mml:msub><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:mfrac></mml:mstyle><mml:mtext>u</mml:mtext><mml:mn>1</mml:mn></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq108.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, where <bold>u</bold><sub>1</sub> is the first of the two projection vectors <italic>U</italic> = [<bold>u</bold><sub>1</sub>, <bold>u</bold><sub>2</sub>]. We thus have large output weights with norm ║<bold>w</bold><sub>out</sub>║ = 1. Trajectories were initialized at <bold>x</bold>(0) = <bold>0</bold>. At the beginning of a trial with target output <italic>ẑ</italic> = ±1, the network receives one pulse <italic>s</italic>(<italic>t</italic>) = ±<italic>δ</italic>(<italic>t</italic>) along the input weights <bold>w</bold><sub>in</sub> = <bold>u</bold><sub>2</sub>. The input direction is hence the second available direction for the rank-two connectivity. This is a sensible choice as networks without the restriction to rank-two weights would span the recurrent weights from existing directions, and a rank-two connectivity would hence also be spanned by <bold>w</bold><sub>out</sub> and <bold>w</bold><sub>in</sub> [<xref ref-type="bibr" rid="c69">69</xref>].</p>
<p>The loss over learning time for one network is shown in <xref ref-type="fig" rid="fig13">Fig. 13A</xref>. Learning consisted of two phases: a first phase in which the network did not possess a fixed point and hence did not match the target on average, <italic>L</italic><sub>bias</sub> &gt; 0. At some point, <italic>L</italic><sub>bias</sub> rapidly decreases, and <italic>L</italic><sub>var</sub> dominates the overall loss. During the second phase, <italic>L</italic><sub>var</sub> slowly decreases, with <italic>L</italic><sub>bias</sub> hovering around zero.</p>
<fig id="fig13" position="float" fig-type="figure">
<label>Fig. 13:</label>
<caption><p>Mean field theory predicts learning with gradient descent. <bold>A-C</bold>: Learning dynamics with gradient descent for example network with <italic>N</italic> = 1024 neurons and with noise variance <inline-formula id="ID105">
<alternatives>
<mml:math display="inline" id="I105"><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>noise</mml:mtext></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq105.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. <bold>A</bold>: Loss with separate bias and variance components. <bold>B</bold>: Matrix coefficients <italic>M<sub>ij</sub></italic>. The dotted lines almost identical to <italic>M</italic><sub>22</sub> and <italic>M</italic><sub>11</sub> indicate the eigenvalues <italic>λ</italic><sub>+</sub> and <italic>λ</italic><sub>−</sub>, respectively. The dashed line indicates <italic>λ</italic><sub>+,min</sub>. <bold>C</bold>: Fixed point norm and correlation. <bold>D-F</bold>: Final loss, fixed point norm, and correlation for networks of different sizes <italic>N</italic>. Shown are mean (dots and lines) and std dev (shades) for 5 sample networks, and the prediction by the mean field theory. Grey lines indicate scaling as <italic>aN<sup>k</sup></italic>, with <italic>k</italic> ∈ {0, − 1/4, −1/2}. Note the log-log axes for <bold>E, F</bold>.</p></caption>
<graphic xlink:href="2307.07654v3_fig13.tif" mime-subtype="tif" mimetype="image"/>
</fig>
<p>The coefficients of the matrix <italic>M</italic> indicate the underlying learning dynamics (<xref ref-type="fig" rid="fig13">Fig. 13B</xref>). The coefficient along the output weights, <italic>M</italic><sub>11</sub>, is almost identical with <italic>λ</italic><sub>−</sub>. It continually grows in the negative direction, unaffected by the different phases. Its time course is very similar to the time course observed for the linear system (<xref ref-type="fig" rid="fig10">Fig. 10B</xref>). In contrast, the coefficient along the input weights, <italic>M</italic>22, mirrors the two phases. It grows increasingly fast in the first phase and saturates during the second phase. Its value is very close to the larger eigenvalue, <italic>λ</italic><sub>+</sub>. The transition between the two phases of learning happens at the phase transition of the dynamical system when the fixed point emerges for <italic>λ</italic><sub>+</sub> = <italic>λ</italic><sub>+,min</sub>. The off-diagonal entries show that <italic>M</italic> is asymmetric during the first phase and becomes symmetric later on. The coefficient <italic>M</italic><sub>12</sub> corresponds to the feedforward mode mapping the state decaying from <bold>x</bold>(0) = <bold>u</bold><sub>2</sub> after the pulse to the output weights <inline-formula id="ID109">
<alternatives>
<mml:math display="inline" id="I109"><mml:msub><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:mfrac></mml:mstyle><mml:mtext>u</mml:mtext><mml:mn>1</mml:mn></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq109.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>.</p>
<p>Tracing the fixed point norm <inline-formula id="ID110">
<alternatives>
<mml:math display="inline" id="I110"><mml:mrow><mml:mo>‖</mml:mo><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>‖</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq110.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> and the correlation <italic>ρ</italic> over learning time shows what we expected (<xref ref-type="fig" rid="fig13">Fig. 13C</xref>): The norm grows rapidly at the phase transition, which is accompanied by a decrease in the correlation. The example yields a fixed point with norm <inline-formula id="ID111">
<alternatives>
<mml:math display="inline" id="I111"><mml:mrow><mml:mo>‖</mml:mo><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>‖</mml:mo></mml:mrow><mml:mo>≈</mml:mo><mml:mn>0.7</mml:mn></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq111.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> and correlation <italic>ρ</italic> ≈ 0.05 for a network with <italic>N</italic> = 1024. The mere numbers already suggest that we call this an oblique solution, but the theory description above is based on how these numbers scale with network size <italic>N</italic>. We trained networks with different <italic>N</italic> but otherwise the same conditions. They reached the same loss (<xref ref-type="fig" rid="fig13">Fig. 13A</xref>, <italic>L</italic><sub>bias</sub> ≈ 0 not shown). The fixed point norm decrease weakly with <italic>N</italic>, with <inline-formula id="ID112">
<alternatives>
<mml:math display="inline" id="I112"><mml:mrow><mml:mo>‖</mml:mo><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>‖</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>N</mml:mi><mml:mi>k</mml:mi></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq112.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, for some <italic>k</italic> ≥ ∔1/4 (<xref ref-type="fig" rid="fig13">Fig. 13E</xref>). The correlation decreases faster, yet not quite with <inline-formula id="ID113">
<alternatives>
<mml:math display="inline" id="I113"><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq113.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> (<xref ref-type="fig" rid="fig13">Fig. 13F</xref>).</p>
<p>We compared the outcome of learning to our mean field theory. Given that <italic>M</italic> is approximately symmetric at the end of learning, we directly applied our results from the previous sections, again assuming <italic>L</italic><sub>bias</sub> = 0. We fixated <italic>λ</italic><sub>−</sub> to match the value at the end of training and computed the <italic>λ</italic><sub>+</sub> that minimized <italic>L</italic><sub>var</sub>, <xref ref-type="disp-formula" rid="FD53">Eq. (53)</xref>. The results for the norm and correlation match those values obtained with gradient descent very closely.</p>
<p>Our high-level description of oblique and aligned dynamics did not involve scaling with network size (Section 2.1). However, the underlying assumption was that the activity of single neurons <italic>x<sub>i</sub></italic> is not vanishing for large networks, i.e., <italic>x<sub>i</sub> = O</italic>(1). This would imply <inline-formula id="ID114">
<alternatives>
<mml:math display="inline" id="I114"><mml:mrow><mml:mo>‖</mml:mo><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>‖</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq114.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> and <inline-formula id="ID115">
<alternatives>
<mml:math display="inline" id="I115"><mml:mi>ρ</mml:mi><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq115.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. This is indeed what we observed for the more complex tasks when training networks of different sizes (not shown). We note that our results for the simple fixed point task deviate weakly from this (<xref ref-type="fig" rid="fig13">Fig. 13</xref> E, F). This hints at other factors pushing solutions to <inline-formula id="ID116">
<alternatives>
<mml:math display="inline" id="I116"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mrow><mml:mo>‖</mml:mo><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>‖</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>π</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq116.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. One such factor may be that the loss function <italic>L</italic><sub>var</sub>(<italic>λ</italic><sub>+</sub>) is very flat for <italic>λ</italic><sub>+</sub> larger than the optimum (<xref ref-type="fig" rid="fig12">Fig. 12C-D</xref>). If learning pushes trajectories beyond the optimum at some point, e.g. due to large updates or if the optimum shifts over learning (<xref ref-type="fig" rid="fig26">Fig. 26</xref>), then the learning signal to reduce <italic>λ</italic><sub>+</sub> afterward may be too small to yield visible effects in finite learning time.</p>
<p>In summary, the last two sections capture the main mechanisms that drive solutions to the oblique regime in nonlinear, noise-driven networks. Although marginally small solutions seem possible for large output weights, such solutions are close to a phase transition, so the resulting system is very susceptible to noise. To accommodate robust solutions, the trajectories (here the fixed points) must increase in magnitude, while rotating away from the output weights. This further allows the implementation of a negative feedback loop that suppresses noise along the output direction. Its efficacy can be reduced by too much saturation, which in turn keeps solutions from growing ever larger. The resulting sweet spot is a network with oblique dynamics.</p>
</sec>
</sec>
<sec id="s7-10">
<title>4.10. Mechanisms behind decoupling of neural dynamics and output</title>
<p>Here we discuss in more detail the underlying mechanisms for the qualitative decoupling in oblique networks. We make a high-level argument that splits into two parts: first the possibility of decoupling in oblique, but not aligned, networks, and second a putative mechanism driving the decoupling.</p>
<p>For the first part, we observe that the output in oblique networks can be obtained from the leading components of the dynamics (along the PCs), but importantly also from the non-leading ones. To see this, we unpack the output in <xref ref-type="disp-formula" rid="FD1">Eq. (1)</xref> in a slightly different way than before, <xref ref-type="disp-formula" rid="FD3">Eq. (3)</xref>. Namely, we split the activity vector <bold>x</bold> into its component along the leading PCs, <bold>x</bold><sub>lead</sub>, and the remaining, trailing component, <bold>x</bold><sub>trail</sub>. By definition of the leading PCs as the directions of largest variance, the leading component is expected to be large, and the trailing one small. Inserting this decomposition <bold>x</bold> = <bold>x</bold><sub>lead</sub> + <bold>x</bold><sub>trail</sub>, into <xref ref-type="disp-formula" rid="FD1">Eq. (1)</xref> leads to
<disp-formula id="FD54">
<alternatives>
<mml:math id="M54" display="block"><mml:mi>z</mml:mi><mml:mo>=</mml:mo><mml:msubsup><mml:mi>w</mml:mi><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mtext>x</mml:mtext><mml:mrow><mml:mtext>lead</mml:mtext></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mtext>x</mml:mtext><mml:mrow><mml:mtext>trial</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mtext>lead</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mtext>x</mml:mtext><mml:mrow><mml:mtext>lead</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mtext>trial</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mtext>x</mml:mtext><mml:mrow><mml:mtext>trial</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn54.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(54)</label>
</disp-formula>
</p>
<p>with separately defined correlations <italic>ρ</italic><sub>lead</sub> = corr(<bold>w</bold><sub>out</sub>, <bold>x</bold><sub>lead</sub>) and <italic>ρ</italic><sub>trail</sub> = corr(<bold>w</bold><sub>out</sub>, <bold>x</bold><sub>trail</sub>).</p>
<p>For aligned networks, we recover the results from before: <bold>w</bold><sub>out</sub> is small so that the output can only be generated by the leading part with large correlation <italic>ρ</italic><sub>lead</sub>. The trailing part is unconstrained but is also not contributing to either the output or the leading dynamics, and hence not of interest.</p>
<p>For oblique networks, <bold>w</bold><sub>out</sub> is large so that the output can be generated by either of the two terms in <xref ref-type="disp-formula" rid="FD54">Eq. (54)</xref>. The correlation <italic>ρ</italic><sub>lead</sub> has to be small because else the output would be too large. The other correlation, <italic>ρ</italic><sub>trail</sub>, can be large, because non-dominant component <bold>x</bold><sub>trail</sub> is small. Both terms are potentially of the same magnitude, which means both can potentially contribute to the output. If the dominant part alone generates the output, then neural dynamics and output are coupled and the solution is similar to an aligned one (<xref ref-type="fig" rid="fig14">Fig. 14</xref>, right). If, however, the non-dominant part alone generates the output, and the correlation <italic>ρ</italic><sub>lead</sub> is so small that the dominant part does not contribute to the output, then the dominant part is not constrained by the task (<xref ref-type="fig" rid="fig14">Fig. 14</xref>, center right). In that case, the dominant dynamics and the output can decouple qualitatively, and we may see the large variability between learners observed above.</p>
<fig id="fig14" position="float" fig-type="figure">
<label>Fig. 14:</label>
<caption><p>Path to oblique solutions for networks with large output weights. Left: all networks produce the same output (cf. <xref ref-type="fig" rid="fig1">Fig. 1</xref>). Center: Unstable solutions that arise early in learning. For lazy solutions, initial chaotic activity is slightly adapted, without changing the dynamics qualitatively. For marginal solutions, vanishingly small initial activity is replaced with very small dynamics sufficient to generate the output. Right: With more learning time and noise added during the learning process, stable, oblique solutions arise. The neural dynamics along the largest PCs can be either decoupled from the output (center right), or coupled (right). For decoupled dynamics, the components along the largest PCs (blue subspace) differ qualitatively from those generating the output (same as <xref ref-type="fig" rid="fig1">Fig. 1B</xref>, bottom). The dynamics along the largest PCs inherit task-unrelated components from the initial dynamics or randomness during learning. Another possibility are oblique, but coupled dynamics (right). Such solutions don’t inherit task-unrelated components of the dynamics at initialization. They are qualitatively similar to aligned solutions, and the output is generated by a small projection of the output weights onto the largest PCs (dashed orange arrow).</p></caption>
<graphic xlink:href="2307.07654v3_fig14.tif" mime-subtype="tif" mimetype="image"/>
</fig>
<p>The existence of decoupled solutions for oblique dynamics leads to the second question: Why and when do such solutions arise? Understanding this requires more detailed insights into the learning process. Roughly speaking, learning in the oblique regime has two opposite goals: first, to generate the desired output as fast as possible, and hence to induce changes to activity that are as small as possible (Section 4.7); and second, to generate solutions that are robust and stable, and hence to induce changes in activity that are large enough to not be disrupted by noise (Section 4.9). During the process of learning, small, unstable solutions appear first (<xref ref-type="fig" rid="fig14">Fig. 14</xref> center). These may be highly variable, depending strongly on random initialization or other randomness experienced during learning. Such solutions then slowly solidify into stable solutions, that may inherit the variability of the early solutions (<xref ref-type="fig" rid="fig14">Fig. 14</xref> right).</p>
<p>The process of how learning transforms small, unstable solutions to larger, robust ones is analyzed in Sections 4.8 and 4.9. The details of how this process introduces variability between learners, however, are not discussed there and left for future work.</p>
<fig id="fig15" position="float" fig-type="figure">
<label>Fig. 15:</label>
<caption><p>Solution to linearized network dynamics in the lazy regime. <bold>A</bold> Network output for weight changes Δ<italic>W</italic><sub>lin</sub> obtained from linearized dynamics for different network sizes. Each plot shows 10 different networks (one example in bold). Target points in purple. <bold>B</bold> Output for networks trained with GD from the same initial conditions as those above. <bold>C</bold> Loss on the training set for the linear (lin) and GD solutions. <bold>D</bold> Frobenius norms of weight changes Δ<italic>W</italic> of the linear and GD solutions, as well as of the difference between the two. Δ<italic>W</italic><sub>lin</sub> − Δ<italic>W</italic><sub>GD</sub> (dashed green). Grey and black dashed lines for comparison of scales.</p></caption>
<graphic xlink:href="2307.07654v3_fig15.tif" mime-subtype="tif" mimetype="image"/>
</fig>
</sec>
</sec>
</body>
<back>
<sec id="s6" sec-type="data-availability">
<title>Data availability</title>
<p>The code for all simulations and generation of figures is available on github, <ext-link ext-link-type="uri" xlink:href="https://github.com/frschu/aligned_oblique_in_rnns/">https://github.com/frschu/aligned_oblique_in_rnns/</ext-link>.</p>
</sec>
<ack>
<title>Acknowledgements</title>
<p>FS was supported by the Deutsche Forschungsgemeinschaft (German Research Foundation) under Germany’s Excellence Strategy - EXC 2002/1 “Science of Intelligence” - project no. 390523135. OB was supported by the Israeli Science Foundation (grant 1442/21) and an HFSP research grant (RGP0017/2021). SO was supported by the program “Ecoles Universitaires de Recherche” ANR-17-EURE-0017</p>
</ack>
<sec id="s4">
<title>Author contributions</title>
<p>Conceptualization, F.S., F.M., S.O., and O.B.; Methodology, F.S.; Formal Analysis, F.S.; Investigation, F.S.; Writing - Original Draft, F.S., F.M., S.O., and O.B.; Writing - Review &amp; Editing, F.S., F.M., S.O., and O.B.; Supervision, F.M., S.O., O.B..</p>
</sec>
<sec id="s5">
<title>Declaration of Interests</title>
<p>The authors declare no competing interests.</p>
</sec>
<ref-list>
<title>References</title>
<ref id="c1"><label>[1]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Amos</given-names> <surname>Arieli</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Dynamics of ongoing activity: explanation of the large variability in evoked cortical responses</article-title>.” In: <source>Science</source> <volume>273.5283</volume> (<year>1996</year>), pp. <fpage>1868</fpage>–<lpage>1871</lpage>.</mixed-citation></ref>
<ref id="c2"><label>[2]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Bassam V</given-names> <surname>Atallah</surname></string-name> and <string-name><given-names>Massimo</given-names> <surname>Scanziani</surname></string-name></person-group>. “<article-title>Instantaneous modulation of gamma oscillation frequency by balancing excitation with inhibition</article-title>.” In: <source>Neuron</source> <volume>62.4</volume> (<year>2009</year>), pp. <fpage>566</fpage>–<lpage>577</lpage>.</mixed-citation></ref>
<ref id="c3"><label>[3]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Omri</given-names> <surname>Barak</surname></string-name></person-group>. “<article-title>Recurrent neural networks as versatile tools of neuroscience research</article-title>.” In: <source>Current Opinion in Neurobiology</source> <volume>46</volume> (<year>2017</year>), pp. <fpage>1</fpage>–<lpage>6</lpage>.</mixed-citation></ref>
<ref id="c4"><label>[4]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Manuel</given-names> <surname>Beiran</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Shaping dynamics with multiple populations in low-rank recurrent networks</article-title>.” In: <source>Neural computation</source> <volume>33.6</volume> (<year>2021</year>), pp. <fpage>1572</fpage>–<lpage>1615</lpage>.</mixed-citation></ref>
<ref id="c5"><label>[5]</label><mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><given-names>Guy</given-names> <surname>Blanc</surname></string-name> <etal>et al.</etal></person-group> “<chapter-title>Implicit regularization for deep neural networks driven by an ornstein-uhlenbeck like process</chapter-title>.” In: <source>Conference on learning theory</source>. <publisher-name>PMLR</publisher-name>. <year>2020</year>, pp. <fpage>483</fpage>–<lpage>513</lpage>.</mixed-citation></ref>
<ref id="c6"><label>[6]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Giulio</given-names> <surname>Bondanelli</surname></string-name> and <string-name><given-names>Srdjan</given-names> <surname>Ostojic</surname></string-name></person-group>. “<article-title>Coding with transient trajectories in recurrent neural networks</article-title>.” In: <source>PLoS computational biology</source> <volume>16.2</volume> (<year>2020</year>), <elocation-id>e1007655</elocation-id>.</mixed-citation></ref>
<ref id="c7"><label>[7]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Dean V</given-names> <surname>Buonomano</surname></string-name> and <string-name><given-names>Wolfgang</given-names> <surname>Maass</surname></string-name></person-group>. “<article-title>State-dependent computations: spatiotemporal processing in cortical networks</article-title>.” In: <source>Nature Reviews Neuroscience</source> <volume>10.2</volume> (<year>2009</year>), pp. <fpage>113</fpage>–<lpage>125</lpage>.</mixed-citation></ref>
<ref id="c8"><label>[8]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Selmaan N</given-names> <surname>Chettih</surname></string-name> and <string-name><given-names>Christopher D</given-names> <surname>Harvey</surname></string-name></person-group>. “<article-title>Single-neuron perturbations reveal feature-specific competition in V1</article-title>.” In: <source>Nature</source> <volume>567.7748</volume> (<year>2019</year>), pp. <fpage>334</fpage>–<lpage>340</lpage>.</mixed-citation></ref>
<ref id="c9"><label>[9]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Lenaic</given-names> <surname>Chizat</surname></string-name>, <string-name><given-names>Edouard</given-names> <surname>Oyallon</surname></string-name>, and <string-name><given-names>Francis</given-names> <surname>Bach</surname></string-name></person-group>. “<article-title>On lazy training in differentiable programming</article-title>.” In: <source>Advances in Neural Information Processing Systems</source>. <year>2019</year>, pp. <fpage>2937</fpage>–<lpage>2947</lpage>.</mixed-citation></ref>
<ref id="c10"><label>[10]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Mark M</given-names> <surname>Churchland</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Cortical preparatory activity: representation of movement or first cog in a dynamical machine?</article-title>” In: <source>Neuron</source> <volume>68.3</volume> (<year>2010</year>), pp. <fpage>387</fpage>–<lpage>400</lpage>.</mixed-citation></ref>
<ref id="c11"><label>[11]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Mark M</given-names> <surname>Churchland</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Neural population dynamics during reaching</article-title>.” In: <source>Nature</source> <volume>487.7405</volume> (<year>2012</year>), pp. <fpage>51</fpage>–<lpage>56</lpage>.</mixed-citation></ref>
<ref id="c12"><label>[12]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Alan D</given-names> <surname>Degenhart</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Stabilization of a brain-computer interface via the alignment of lowdimensional spaces of neural activity</article-title>.” In: <source>Nature biomedical engineering</source> <volume>4.7</volume> (<year>2020</year>), pp. <fpage>672</fpage>–<lpage>685</lpage>.</mixed-citation></ref>
<ref id="c13"><label>[13]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Alexis</given-names> <surname>Dubreuil</surname></string-name> <etal>et al.</etal></person-group> “<article-title>The role of population structure in computations through neural dynamics</article-title>.” In: <source>bioRxiv</source> (<year>2021</year>), pp. <fpage>2020</fpage>–<lpage>07</lpage>.</mixed-citation></ref>
<ref id="c14"><label>[14]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Arseny</given-names> <surname>Finkelstein</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Attractor dynamics gate cortical information flow during decisionmaking</article-title>.” In: <source>Nature Neuroscience</source> <volume>24.6</volume> (<year>2021</year>), pp. <fpage>843</fpage>–<lpage>850</lpage>.</mixed-citation></ref>
<ref id="c15"><label>[15]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Timo</given-names> <surname>Flesch</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Orthogonal representations for robust context-dependent task performance in brains and neural networks</article-title>.” In: <source>Neuron</source> <volume>110.7</volume> (<year>2022</year>), pp. <fpage>1258</fpage>–<lpage>1270</lpage>.</mixed-citation></ref>
<ref id="c16"><label>[16]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Aniruddh R</given-names> <surname>Galgali</surname></string-name>, <string-name><given-names>Maneesh</given-names> <surname>Sahani</surname></string-name>, and <string-name><given-names>Valerio</given-names> <surname>Mante</surname></string-name></person-group>. “<article-title>Residual dynamics resolves recurrent contributions to neural computation</article-title>.” In: <source>Nature Neuroscience</source> <volume>26.2</volume> (<year>2023</year>), pp. <fpage>326</fpage>–<lpage>338</lpage>.</mixed-citation></ref>
<ref id="c17"><label>[17]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Juan A</given-names> <surname>Gallego</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Cortical population activity within a preserved neural manifold underlies multiple motor behaviors</article-title>.” In: <source>Nature communications</source> <volume>9.1</volume> (<year>2018</year>), pp. <fpage>1</fpage>–<lpage>13</lpage>.</mixed-citation></ref>
<ref id="c18"><label>[18]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Juan A</given-names> <surname>Gallego</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Long-term stability of cortical population dynamics underlying consistent behavior</article-title>.” In: <source>Nature neuroscience</source> <volume>23.2</volume> (<year>2020</year>), pp. <fpage>260</fpage>–<lpage>270</lpage>.</mixed-citation></ref>
<ref id="c19"><label>[19]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Juan A</given-names> <surname>Gallego</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Neural manifolds for the control of movement</article-title>.” In: <source>Neuron</source> <volume>94.5</volume> (<year>2017</year>), pp. <fpage>978</fpage>–<lpage>984</lpage>.</mixed-citation></ref>
<ref id="c20"><label>[20]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Peiran</given-names> <surname>Gao</surname></string-name> <etal>et al.</etal></person-group> “<article-title>A theory of multineuronal dimensionality, dynamics and measurement</article-title>.” In: <source>bioRxiv doi: 10.1101/214262v2</source> (<year>2017</year>).</mixed-citation></ref>
<ref id="c21"><label>[21]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Mario</given-names> <surname>Geiger</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Disentangling feature and lazy training in deep neural networks</article-title>.” In: <source>Journal of Statistical Mechanics: Theory and Experiment</source> <volume>2020.11</volume> (<year>2020</year>), p. <fpage>113301</fpage>.</mixed-citation></ref>
<ref id="c22"><label>[22]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Matthew D</given-names> <surname>Golub</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Learning by neural reassociation</article-title>.” In: <source>Nature neuroscience</source> <volume>21.4</volume> (<year>2018</year>), pp. <fpage>607</fpage>–<lpage>616</lpage>.</mixed-citation></ref>
<ref id="c23"><label>[23]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Torkel</given-names> <surname>Hafting</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Microstructure of a spatial map in the entorhinal cortex</article-title>.” In: <source>Nature</source> <volume>436.7052</volume> (<year>2005</year>), pp. <fpage>801</fpage>–<lpage>806</lpage>.</mixed-citation></ref>
<ref id="c24"><label>[24]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Guillaume</given-names> <surname>Hennequin</surname></string-name>, <string-name><given-names>Tim P</given-names> <surname>Vogels</surname></string-name>, and <string-name><given-names>Wulfram</given-names> <surname>Gerstner</surname></string-name></person-group>. “<article-title>Optimal control of transient dynamics in balanced networks supports generation of complex movements</article-title>.” In: <source>Neuron</source> <volume>82.6</volume> (<year>2014</year>), pp. <fpage>1394</fpage>–<lpage>1406</lpage>.</mixed-citation></ref>
<ref id="c25"><label>[25]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Jay A</given-names> <surname>Hennig</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Constraints on neural redundancy</article-title>.” In: <source>Elife</source> <volume>7</volume> (<year>2018</year>), <elocation-id>e36774</elocation-id>.</mixed-citation></ref>
<ref id="c26"><label>[26]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>David H</given-names> <surname>Hubel</surname></string-name> and <string-name><given-names>Torsten N</given-names> <surname>Wiesel</surname></string-name></person-group>. “<article-title>Receptive fields, binocular interaction and functional architecture in the cat’s visual cortex</article-title>.” In: <source>The Journal of physiology</source> <volume>160.1</volume> (<year>1962</year>), p. <fpage>106</fpage>.</mixed-citation></ref>
<ref id="c27"><label>[27]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Arthur</given-names> <surname>Jacot</surname></string-name>, <string-name><given-names>Franck</given-names> <surname>Gabriel</surname></string-name>, and <string-name><given-names>Clément</given-names> <surname>Hongler</surname></string-name></person-group>. “<article-title>Neural tangent kernel: Convergence and generalization in neural networks</article-title>.” In: <source>Advances in neural information processing systems</source>. <year>2018</year>, pp. <fpage>8571</fpage>–<lpage>8580</lpage>.</mixed-citation></ref>
<ref id="c28"><label>[28]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Arthur</given-names> <surname>Jacot</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Saddle-to-Saddle Dynamics in Deep Linear Networks: Small Initialization Training, Symmetry, and Sparsity</article-title>.” In: <source>arXiv:2106.15933</source> (<year>2022</year>).</mixed-citation></ref>
<ref id="c29"><label>[29]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Jonathan</given-names> <surname>Kadmon</surname></string-name>, <string-name><given-names>Jonathan</given-names> <surname>Timcheck</surname></string-name>, and <string-name><given-names>Surya</given-names> <surname>Ganguli</surname></string-name></person-group>. “<article-title>Predictive coding in balanced neural networks with noise, chaos and delays</article-title>.” In: <source>Advances in Neural Information Processing Systems</source> <volume>33</volume> (<year>2020</year>), pp. <fpage>16677</fpage>–<lpage>16688</lpage>.</mixed-citation></ref>
<ref id="c30"><label>[30]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Ta-Chu</given-names> <surname>Kao</surname></string-name>, <string-name><given-names>Mahdieh S</given-names> <surname>Sadabadi</surname></string-name>, and <string-name><given-names>Guillaume</given-names> <surname>Hennequin</surname></string-name></person-group>. “<article-title>Optimal anticipatory control as a theory of motor preparation: A thalamo-cortical circuit model</article-title>.” In: <source>Neuron</source> <volume>109.9</volume> (<year>2021</year>), pp. <fpage>1567</fpage>–<lpage>1581</lpage>.</mixed-citation></ref>
<ref id="c31"><label>[31]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Matthew T</given-names> <surname>Kaufman</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Cortical activity in the null space: permitting preparation without movement</article-title>.” In: <source>Nature neuroscience</source> <volume>17.3</volume> (<year>2014</year>), pp. <fpage>440</fpage>–<lpage>448</lpage>.</mixed-citation></ref>
<ref id="c32"><label>[32]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Christopher M</given-names> <surname>Kim</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Distributing task-related neural activity across a cortical network through task-independent connections</article-title>.” In: <source>Nature Communications</source> <volume>14.1</volume> (<year>2023</year>), p. <fpage>2851</fpage>.</mixed-citation></ref>
<ref id="c33"><label>[33]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Diederik P</given-names> <surname>Kingma</surname></string-name> and <string-name><given-names>Jimmy</given-names> <surname>Ba</surname></string-name></person-group>. “<article-title>Adam: A method for stochastic optimization</article-title>.” In: <source>arXiv: 1412.6980</source> (<year>2014</year>).</mixed-citation></ref>
<ref id="c34"><label>[34]</label><mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><given-names>Peter E.</given-names> <surname>Kloeden</surname></string-name> and <string-name><given-names>Eckhard</given-names> <surname>Platen</surname></string-name></person-group>. <source>Numerical Solution of Stochastic Differential Equations</source>. <publisher-name>Springer</publisher-name>, <year>1992</year>.</mixed-citation></ref>
<ref id="c35"><label>[35]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Zhiyuan</given-names> <surname>Li</surname></string-name>, <string-name><given-names>Tianhao</given-names> <surname>Wang</surname></string-name>, and <string-name><given-names>Sanjeev</given-names> <surname>Arora</surname></string-name></person-group>. “<article-title>What Happens after SGD Reaches Zero Loss?-A Mathematical Framework</article-title>.” In: <source>arXiv:2110.06914</source> (<year>2021</year>).</mixed-citation></ref>
<ref id="c36"><label>[36]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Chaoyue</given-names> <surname>Liu</surname></string-name>, <string-name><given-names>Libin</given-names> <surname>Zhu</surname></string-name>, and <string-name><given-names>Mikhail</given-names> <surname>Belkin</surname></string-name></person-group>. “<article-title>On the linearity of large non-linear models: when and why the tangent kernel is constant</article-title>.” In: <source>Advances in Neural Information Processing Systems</source> <volume>33</volume> (<year>2020</year>).</mixed-citation></ref>
<ref id="c37"><label>[37]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Yuhan Helena</given-names> <surname>Liu</surname></string-name> <etal>et al.</etal></person-group> “<article-title>How connectivity structure shapes rich and lazy learning in neural circuits</article-title>.” In: <source>arXiv:2310.08513</source> (<year>2023</year>).</mixed-citation></ref>
<ref id="c38"><label>[38]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Laureline</given-names> <surname>Logiaco</surname></string-name>, <string-name><given-names>LF</given-names> <surname>Abbott</surname></string-name>, and <string-name><given-names>Sean</given-names> <surname>Escola</surname></string-name></person-group>. “<article-title>Thalamic control of cortical dynamics in a model of flexible motor sequencing</article-title>.” In: <source>Cell reports</source> <volume>35.9</volume> (<year>2021</year>), p. <fpage>109090</fpage>.</mixed-citation></ref>
<ref id="c39"><label>[39]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Niru</given-names> <surname>Maheswaranathan</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Universality and individuality in neural dynamics across large populations of recurrent networks</article-title>.” In: <source>Advances in Neural Information Processing Systems</source>. <year>2019</year>, pp. <fpage>15603</fpage>–<lpage>15615</lpage>.</mixed-citation></ref>
<ref id="c40"><label>[40]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Joseph G</given-names> <surname>Makin</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Superior arm-movement decoding from cortex with a new, unsupervised-learning algorithm</article-title>.” In: <source>Journal of neural engineering</source> <volume>15.2</volume> (<year>2018</year>), p. <fpage>026010</fpage>.</mixed-citation></ref>
<ref id="c41"><label>[41]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Valerio</given-names> <surname>Mante</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Context-dependent computation by recurrent dynamics in prefrontal cortex</article-title>.” In: <source>Nature</source> <volume>503.7474</volume> (<year>2013</year>), p. <fpage>78</fpage>.</mixed-citation></ref>
<ref id="c42"><label>[42]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Francesca</given-names> <surname>Mastrogiuseppe</surname></string-name> and <string-name><given-names>Srdjan</given-names> <surname>Ostojic</surname></string-name></person-group>. “<article-title>Linking connectivity, dynamics, and computations in low-rank recurrent neural networks</article-title>.” In: <source>Neuron</source> <volume>99.3</volume> (<year>2018</year>), pp. <fpage>609</fpage>–<lpage>623</lpage>.</mixed-citation></ref>
<ref id="c43"><label>[43]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Song</given-names> <surname>Mei</surname></string-name>, <string-name><given-names>Andrea</given-names> <surname>Montanari</surname></string-name>, and <string-name><given-names>Phan-Minh</given-names> <surname>Nguyen</surname></string-name></person-group>. “<article-title>A mean field view of the landscape of two-layer neural networks</article-title>.” In: <source>Proceedings of the National Academy of Sciences</source> <volume>115.33</volume> (<year>2018</year>), <elocation-id>E7665-E7671</elocation-id>.</mixed-citation></ref>
<ref id="c44"><label>[44]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Simon</given-names> <surname>Musall</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Single-trial neural dynamics are dominated by richly varied movements</article-title>.” In: <source>Nature neuroscience</source> <volume>22.10</volume> (<year>2019</year>), pp. <fpage>1677</fpage>–<lpage>1686</lpage>.</mixed-citation></ref>
<ref id="c45"><label>[45]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>John</given-names> <surname>O’Keefe</surname></string-name> and <string-name><given-names>Jonathan</given-names> <surname>Dostrovsky</surname></string-name></person-group>. “<article-title>The hippocampus as a spatial map: preliminary evidence from unit activity in the freely-moving rat</article-title>.” In: <source>Brain research</source> (<year>1971</year>).</mixed-citation></ref>
<ref id="c46"><label>[46]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Daniel J</given-names> <surname>O’Shea</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Direct neural perturbations reveal a dynamical mechanism for robust computation</article-title>.” In: <source>bioRxiv</source> (<year>2022</year>).</mixed-citation></ref>
<ref id="c47"><label>[47]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Emily R</given-names> <surname>Oby</surname></string-name> <etal>et al.</etal></person-group> “<article-title>New neural activity patterns emerge with long-term learning</article-title>.” In: <source>Proceedings of the National Academy of Sciences</source> <volume>116.30</volume> (<year>2019</year>), pp. <fpage>15210</fpage>–<lpage>15215</lpage>.</mixed-citation></ref>
<ref id="c48"><label>[48]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Michael</given-names> <surname>Okun</surname></string-name> and <string-name><given-names>Ilan</given-names> <surname>Lampl</surname></string-name></person-group>. “<article-title>Instantaneous correlation of excitation and inhibition during ongoing and sensory-evoked activities</article-title>.” In: <source>Nature neuroscience</source> <volume>11.5</volume> (<year>2008</year>), pp. <fpage>535</fpage>–<lpage>537</lpage>.</mixed-citation></ref>
<ref id="c49"><label>[49]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Marino</given-names> <surname>Pagan</surname></string-name> <etal>et al.</etal></person-group> “<article-title>A new theoretical framework jointly explains behavioral and neural variability across subjects performing flexible decision-making</article-title>.” In: <source>bioRxiv</source> (<year>2022</year>).</mixed-citation></ref>
<ref id="c50"><label>[50]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Adam</given-names> <surname>Paszke</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Automatic differentiation in PyTorch</article-title>.” In: <source>none</source> (<year>2017</year>).</mixed-citation></ref>
<ref id="c51"><label>[51]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>F.</given-names> <surname>Pedregosa</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Scikit-learn: Machine Learning in Python</article-title>.” In: <source>Journal of Machine Learning Research</source> <volume>12</volume> (<year>2011</year>), pp. <fpage>2825</fpage>–<lpage>2830</lpage>.</mixed-citation></ref>
<ref id="c52"><label>[52]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Felix</given-names> <surname>Pei</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Neural Latents Benchmark ‘21: Evaluating latent variable models of neural population activity</article-title>.” In: <source>Advances in Neural Information Processing Systems</source>. <year>2021</year>, p. <fpage>1</fpage>.</mixed-citation></ref>
<ref id="c53"><label>[53]</label><mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><given-names>Victor M</given-names> <surname>Preciado</surname></string-name> and <string-name><given-names>M Amin</given-names> <surname>Rahimian</surname></string-name></person-group>. “<chapter-title>Controllability gramian spectra of random networks</chapter-title>.” In: <source>2016 American Control Conference (ACC)</source>. <publisher-name>IEEE</publisher-name>. <year>2016</year>, pp. <fpage>3874</fpage>–<lpage>3879</lpage>.</mixed-citation></ref>
<ref id="c54"><label>[54]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Pavithra</given-names> <surname>Rajeswaran</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Assistive sensory-motor perturbations influence learned neural representations</article-title>.” In: <source>bioRxiv</source> (<year>2024</year>).</mixed-citation></ref>
<ref id="c55"><label>[55]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Aviv</given-names> <surname>Ratzon</surname></string-name>, <string-name><given-names>Dori</given-names> <surname>Derdikman</surname></string-name>, and <string-name><given-names>Omri</given-names> <surname>Barak</surname></string-name></person-group>. “<article-title>Representational drift as a result of implicit regularization</article-title>.” In: <source>Elife</source> <volume>12</volume> (<year>2024</year>), <fpage>RP90069</fpage>.</mixed-citation></ref>
<ref id="c56"><label>[56]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Mattia</given-names> <surname>Rigotti</surname></string-name> <etal>et al.</etal></person-group> “<article-title>The importance of mixed selectivity in complex cognitive tasks</article-title>.” In: <source>Nature</source> <volume>497.7451</volume> (<year>2013</year>), p. <fpage>585</fpage>.</mixed-citation></ref>
<ref id="c57"><label>[57]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Alexander</given-names> <surname>Rivkind</surname></string-name> and <string-name><given-names>Omri</given-names> <surname>Barak</surname></string-name></person-group>. “<article-title>Local dynamics in trained recurrent neural networks</article-title>.” In: <source>Physical Review Letters</source> <volume>118.25</volume> (<year>2017</year>), p. <fpage>258101</fpage>.</mixed-citation></ref>
<ref id="c58"><label>[58]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Uri</given-names> <surname>Rokni</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Motor learning with unstable neural representations</article-title>.” In: <source>Neuron</source> <volume>54.4</volume> (<year>2007</year>), pp. <fpage>653</fpage>–<lpage>666</lpage>.</mixed-citation></ref>
<ref id="c59"><label>[59]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Ranulfo</given-names> <surname>Romo</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Neuronal correlates of parametric working memory in the prefrontal cortex</article-title>.” In: <source>Nature</source> <volume>399.6735</volume> (<year>1999</year>), p. <fpage>470</fpage>.</mixed-citation></ref>
<ref id="c60"><label>[60]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Lloyd E</given-names> <surname>Russell</surname></string-name> <etal>et al.</etal></person-group> “<article-title>All-optical interrogation of neural circuits in behaving mice</article-title>.” In: <source>Nature Protocols</source> <volume>17.7</volume> (<year>2022</year>), pp. <fpage>1579</fpage>–<lpage>1620</lpage>.</mixed-citation></ref>
<ref id="c61"><label>[61]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Abigail A</given-names> <surname>Russo</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Motor cortex embeds muscle-like commands in an untangled population response</article-title>.” In: <source>Neuron</source> <volume>97.4</volume> (<year>2018</year>), pp. <fpage>953</fpage>–<lpage>966</lpage>.</mixed-citation></ref>
<ref id="c62"><label>[62]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Abigail A</given-names> <surname>Russo</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Neural trajectories in the supplementary motor area and motor cortex exhibit distinct geometries, compatible with different classes of computation</article-title>.” In: <source>Neuron</source> <volume>107.4</volume> (<year>2020</year>), pp. <fpage>745</fpage>–<lpage>758</lpage>.</mixed-citation></ref>
<ref id="c63"><label>[63]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Patrick T</given-names> <surname>Sadtler</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Neural constraints on learning</article-title>.” In: <source>Nature</source> <volume>512.7515</volume> (<year>2014</year>), pp. <fpage>423</fpage>–<lpage>426</lpage>.</mixed-citation></ref>
<ref id="c64"><label>[64]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Shreya</given-names> <surname>Saxena</surname></string-name> and <string-name><given-names>John P</given-names> <surname>Cunningham</surname></string-name></person-group>. “<article-title>Towards the neural population doctrine</article-title>.” In: <source>Current opinion in neurobiology</source> <volume>55</volume> (<year>2019</year>), pp. <fpage>103</fpage>–<lpage>111</lpage>.</mixed-citation></ref>
<ref id="c65"><label>[65]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Shreya</given-names> <surname>Saxena</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Motor cortex activity across movement speeds is predicted by network-level strategies for generating muscle activity</article-title>.” In: <source>Elife</source> <volume>11</volume> (<year>2022</year>), <elocation-id>e67620</elocation-id>.</mixed-citation></ref>
<ref id="c66"><label>[66]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Karen E</given-names> <surname>Schroeder</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Cortical control of virtual self-motion using task-specific subspaces</article-title>.” In: <source>Journal of Neuroscience</source> <volume>42.2</volume> (<year>2022</year>), pp. <fpage>220</fpage>–<lpage>239</lpage>.</mixed-citation></ref>
<ref id="c67"><label>[67]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Jannis</given-names> <surname>Schuecker</surname></string-name>, <string-name><given-names>Sven</given-names> <surname>Goedeke</surname></string-name>, and <string-name><given-names>Moritz</given-names> <surname>Helias</surname></string-name></person-group>. “<article-title>Optimal sequence memory in driven random networks</article-title>.” In: <source>Physical Review X</source> <volume>8.4</volume> (<year>2018</year>), p. <fpage>041029</fpage>.</mixed-citation></ref>
<ref id="c68"><label>[68]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Friedrich</given-names> <surname>Schuessler</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Dynamics of random recurrent networks with correlated low-rank structure</article-title>.” In: <source>Physical Review Research</source> <volume>2.1</volume> (<year>2020</year>), p. <fpage>013111</fpage>.</mixed-citation></ref>
<ref id="c69"><label>[69]</label><mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><given-names>Friedrich</given-names> <surname>Schuessler</surname></string-name> <etal>et al.</etal></person-group> “<chapter-title>The interplay between randomness and structure during learning in RNNs</chapter-title>.” In: <source>Advances in Neural Information Processing Systems</source>. Ed. by <person-group person-group-type="editor"><string-name><given-names>H.</given-names> <surname>Larochelle</surname></string-name> <etal>et al.</etal></person-group> Vol. <volume>33</volume>. <publisher-name>Curran Associates, Inc.</publisher-name>, <year>2020</year>, pp. <fpage>13352</fpage>–<lpage>13362</lpage>.</mixed-citation></ref>
<ref id="c70"><label>[70]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Haim</given-names> <surname>Sompolinsky</surname></string-name>, <string-name><given-names>Andrea</given-names> <surname>Crisanti</surname></string-name>, and <string-name><given-names>Hans-Jurgen</given-names> <surname>Sommers</surname></string-name></person-group>. “<article-title>Chaos in random neural networks</article-title>.” In: <source>Physical Review Letters</source> <volume>61.3</volume> (<year>1988</year>), p. <fpage>259</fpage>.</mixed-citation></ref>
<ref id="c71"><label>[71]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Carsen</given-names> <surname>Stringer</surname></string-name> <etal>et al.</etal></person-group> “<article-title>High-dimensional geometry of population responses in visual cortex</article-title>.” In: <source>Nature</source> <volume>571.7765</volume> (<year>2019</year>), pp. <fpage>361</fpage>–<lpage>365</lpage>.</mixed-citation></ref>
<ref id="c72"><label>[72]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Carsen</given-names> <surname>Stringer</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Spontaneous behaviors drive multidimensional, brainwide activity</article-title>.” In: <source>Science</source> <volume>364.6437</volume> (<year>2019</year>), <elocation-id>eaav7893</elocation-id>.</mixed-citation></ref>
<ref id="c73"><label>[73]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Lee</given-names> <surname>Susman</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Quality of internal representation shapes learning performance in feedback neural networks</article-title>.” In: <source>Physical Review Research</source> <volume>3.1</volume> (<year>2021</year>), p. <fpage>013176</fpage>.</mixed-citation></ref>
<ref id="c74"><label>[74]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>David</given-names> <surname>Sussillo</surname></string-name></person-group>. “<article-title>Neural circuits as computational dynamical systems</article-title>.” In: <source>Current Opinion in Neurobiology</source> <volume>25</volume> (<year>2014</year>), pp. <fpage>156</fpage>–<lpage>163</lpage>.</mixed-citation></ref>
<ref id="c75"><label>[75]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>David</given-names> <surname>Sussillo</surname></string-name> and <string-name><given-names>Larry F</given-names> <surname>Abbott</surname></string-name></person-group>. “<article-title>Generating coherent patterns of activity from chaotic neural networks</article-title>.” In: <source>Neuron</source> <volume>63.4</volume> (<year>2009</year>), pp. <fpage>544</fpage>–<lpage>557</lpage>.</mixed-citation></ref>
<ref id="c76"><label>[76]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>David</given-names> <surname>Sussillo</surname></string-name> and <string-name><given-names>Omri</given-names> <surname>Barak</surname></string-name></person-group>. “<article-title>Opening the black box: low-dimensional dynamics in highdimensional recurrent neural networks</article-title>.” In: <source>Neural computation</source> <volume>25.3</volume> (<year>2013</year>), pp. <fpage>626</fpage>–<lpage>649</lpage>.</mixed-citation></ref>
<ref id="c77"><label>[77]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>David</given-names> <surname>Sussillo</surname></string-name> <etal>et al.</etal></person-group> “<article-title>A neural network that finds a naturalistic solution for the production of muscle activity</article-title>.” In: <source>Nature neuroscience</source> <volume>18.7</volume> (<year>2015</year>), p. <fpage>1025</fpage>.</mixed-citation></ref>
<ref id="c78"><label>[78]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Bharath C</given-names> <surname>Talluri</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Activity in primate visual cortex is minimally driven by spontaneous movements</article-title>.” In: <source>bioRxiv</source> (<year>2022</year>), pp. <fpage>2022</fpage>–<lpage>09</lpage>.</mixed-citation></ref>
<ref id="c79"><label>[79]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Elia</given-names> <surname>Turner</surname></string-name>, <string-name><given-names>Kabir</given-names> <surname>Dabholkar</surname></string-name>, and <string-name><given-names>Omri</given-names> <surname>Barak</surname></string-name></person-group>. “<article-title>Charting and navigating the space of solutions for recurrent neural networks</article-title>.” In: <source>Advances in Neural Information Processing Systems</source> <volume>34</volume> (<year>2021</year>).</mixed-citation></ref>
<ref id="c80"><label>[80]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Saurabh</given-names> <surname>Vyas</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Computation through neural population dynamics</article-title>.” In: <source>Annual Review of Neuroscience</source> <volume>43</volume> (<year>2020</year>), pp. <fpage>249</fpage>–<lpage>275</lpage>.</mixed-citation></ref>
<ref id="c81"><label>[81]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Ziyue Aiden</given-names> <surname>Wang</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Not everything, not everywhere, not all at once: a study of brain-wide encoding of movement</article-title>.” In: <source>bioRxiv</source> (<year>2023</year>), pp. <fpage>2023</fpage>–<lpage>06</lpage>.</mixed-citation></ref>
<ref id="c82"><label>[82]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Francis R</given-names> <surname>Willett</surname></string-name> <etal>et al.</etal></person-group> “<article-title>High-performance brain-to-text communication via handwriting</article-title>.” In: <source>Nature</source> <volume>593.7858</volume> (<year>2021</year>), pp. <fpage>249</fpage>–<lpage>254</lpage>.</mixed-citation></ref>
<ref id="c83"><label>[83]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Alex</given-names> <surname>Williams</surname></string-name> <etal>et al.</etal></person-group> “<article-title>Generalized Shape Metrics on Neural Representations</article-title>.” In: <source>Advances in Neural Information Processing Systems</source> <volume>34</volume> (<year>2021</year>).</mixed-citation></ref>
<ref id="c84"><label>[84]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Kun</given-names> <surname>Yan</surname></string-name>, <string-name><given-names>Gengdong</given-names> <surname>Cheng</surname></string-name>, and <string-name><given-names>Bo Ping</given-names> <surname>Wang</surname></string-name></person-group>. “<article-title>Adjoint methods of sensitivity analysis for Lyapunov equation</article-title>.” In: <source>Structural and Multidisciplinary Optimization</source> <volume>53.2</volume> (<year>2016</year>), pp. <fpage>225</fpage>–<lpage>237</lpage>.</mixed-citation></ref>
<ref id="c85"><label>[85]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Greg</given-names> <surname>Yang</surname></string-name> and <string-name><given-names>Edward J</given-names> <surname>Hu</surname></string-name></person-group>. “<article-title>Feature Learning in Infinite-Width Neural Networks</article-title>.” In: <source>arXiv: 2011.14522</source> (<year>2020</year>).</mixed-citation></ref>
<ref id="c86"><label>[86]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Ning</given-names> <surname>Yang</surname></string-name>, <string-name><given-names>Chao</given-names> <surname>Tang</surname></string-name>, and <string-name><given-names>Yuhai</given-names> <surname>Tu</surname></string-name></person-group>. “<article-title>Stochastic gradient descent introduces an effective landscape-dependent regularization favoring flat solutions</article-title>.” In: <source>Physical Review Letters</source> <volume>130.23</volume> (<year>2023</year>), p. <fpage>237101</fpage>.</mixed-citation></ref>
</ref-list>
<sec id="s8">
<title>A. Supplementary Information</title>
<sec id="s8-1">
<title>A.1 Linear approximation for lazy learning</title>
<p>We numerically investigated the linearization, <xref ref-type="disp-formula" rid="FD17">Eq. (17)</xref>, of the output trajectory <italic>z</italic>(<italic>t</italic>) in weight changes Δ<italic>W</italic>, <xref ref-type="disp-formula" rid="FD17">Eq. (17)</xref>. For this, we used the sine wave task and the same configuration as for the lazy network in <xref ref-type="fig" rid="fig9">Fig. 9</xref>(c). In <xref ref-type="fig" rid="fig15">Fig. 15</xref>(a), we plot the output of the full network after inserting the linear solution Δ<italic>W</italic><sub>lin</sub>. The fit to the training points got more accurate with increasing network size. However, it did not reach zero error for the networks shown. In general, the error increased with increasing trial time. This indicates that the linear approximation was not valid. This is in line with the nature of the dynamical system: Trajectories become more nonlinear in <italic>W</italic> with increasing time. The loss on the training set [<xref ref-type="fig" rid="fig15">Fig. 15(c)</xref>] summarizes the observations seen before: The linear solution became more accurate with increasing network size.</p>
<p>How close was the linear solution to the one found by GD? To test this, we optimized the network with GD starting the same initial condition <italic>W</italic><sub>0</sub>. The output of this network is shown in orange in <xref ref-type="fig" rid="fig15">Fig. 15</xref>(b). As seen before [<xref ref-type="fig" rid="fig9">Fig. 9(c)</xref>] training points were met, but the dynamics after the last training points remained chaotic. We then quantified the norms of the two solutions and the difference between both. As shown in <xref ref-type="fig" rid="fig15">Fig. 15</xref>(d), both solutions had similar norm, which decays as <inline-formula id="ID117">
<alternatives>
<mml:math display="inline" id="I117"><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq117.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. The difference decayed faster, as 1<italic>/N</italic>. This indicates that the linearized system can give a good insight into the solution found by training with GD, despite the inaccuracies of the linear approximation. In particular, the main features (scaling, unstable solutions, no extrapolation) are the same for the linear and the gradient descent solutions.</p>
</sec>
<sec id="s8-2">
<title>A.2. Details linear model: Bias only: lazy learning</title>
<p>We consider learning for the linear, input-driven model, <xref ref-type="disp-formula" rid="FD4">Eq. (4)</xref>. We start with the bias part, which is equivalent to the noise-free model [<xref ref-type="bibr" rid="c69">69</xref>]. Disregarding initial transients, the average output is <inline-formula id="ID118">
<alternatives>
<mml:math display="inline" id="I118"><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>=</mml:mo></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq118.tif" mime-subtype="tif" mimetype="image"/>
</alternatives></inline-formula> <inline-formula id="ID119">
<alternatives>
<mml:math display="inline" id="I119"><mml:mrow><mml:msubsup><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msubsup><mml:mi>B</mml:mi><mml:msub><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>in</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq119.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, with <italic>B</italic> = (1 − <italic>W</italic>)<sup>−1</sup>. The gradient of the loss <inline-formula id="ID120">
<alternatives>
<mml:math display="inline" id="I120"><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mtext>bias</mml:mtext></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq120.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> is then
<disp-formula id="FD55">
<alternatives>
<mml:math id="M55" display="block"><mml:msub><mml:mi>G</mml:mi><mml:mrow><mml:mtext>bias</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mtext>d</mml:mtext><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mi>b</mml:mi><mml:mi>i</mml:mi><mml:mi>a</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mtext>d</mml:mtext><mml:mi>W</mml:mi></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:msup><mml:mi>B</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msubsup><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>in</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msubsup><mml:msup><mml:mi>B</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn55.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(55)</label>
</disp-formula>
</p>
<p>We make the ansatz of small weight changes and hence linearize the output in weights (like in feedforward networks, [<xref ref-type="bibr" rid="c36">36</xref>]):
<disp-formula id="FD56">
<alternatives>
<mml:math id="M56" display="block"><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mn>0</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>G</mml:mi><mml:mrow><mml:mi>z</mml:mi><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>⋅</mml:mo><mml:mi>Δ</mml:mi><mml:mi>W</mml:mi><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Δ</mml:mi><mml:msup><mml:mi>W</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn56.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(56)</label>
</disp-formula>
</p>
<p>with <italic>G</italic><sub><italic>z</italic>,0</sub> the gradient of the output at initialization,
<disp-formula id="FD57">
<alternatives>
<mml:math id="M57" display="block"><mml:mrow><mml:msub><mml:mi>G</mml:mi><mml:mrow><mml:mi>z</mml:mi><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>W</mml:mi></mml:mrow></mml:mfrac><mml:msub><mml:mo>|</mml:mo><mml:mn>0</mml:mn></mml:msub><mml:mtext> </mml:mtext><mml:mo>=</mml:mo><mml:msubsup><mml:mi>B</mml:mi><mml:mn>0</mml:mn><mml:mi>T</mml:mi></mml:msubsup><mml:msub><mml:mi>w</mml:mi><mml:mrow><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mi>w</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mrow><mml:mi>T</mml:mi></mml:msubsup><mml:msubsup><mml:mi>B</mml:mi><mml:mn>0</mml:mn><mml:mi>T</mml:mi></mml:msubsup><mml:mo>,</mml:mo></mml:mrow></mml:math>
<graphic xlink:href="2307.07654v3_eqn57.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(57)</label>
</disp-formula>
</p>
<p>and <italic>B</italic><sub>0</sub> = (1 - <italic>W</italic><sub>0</sub>)<sup>−1</sup>. The dot-product signifies sum over all entries, <inline-formula id="ID121">
<alternatives>
<mml:math display="inline" id="I121"><mml:mi>A</mml:mi><mml:mo>⋅</mml:mo><mml:mi>B</mml:mi><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:msub><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>B</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq121.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> for two matrices <italic>A, B</italic>. Because the output is linear, the weight changes are spanned by the gradient, Δ<italic>W</italic> = <italic>b</italic>(τ)<italic>G</italic><sub><italic>z</italic>,0</sub>/║<italic>G</italic><sub><italic>z</italic>,0</sub>║. Insertion into gradient descent dynamics yields
<disp-formula id="FD58">
<alternatives>
<mml:math id="M58" display="block"><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˙</mml:mo></mml:mover><mml:mrow><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>η</mml:mi><mml:mi>m</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mn>0</mml:mn></mml:msub><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo>−</mml:mo><mml:mi>b</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn58.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(58)</label>
</disp-formula>
</p>
<p>with
<disp-formula id="FD59">
<alternatives>
<mml:math id="M59" display="block"><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mi>G</mml:mi><mml:mrow><mml:mi>z</mml:mi><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msubsup><mml:mi>B</mml:mi><mml:mn>0</mml:mn><mml:mi>T</mml:mi></mml:msubsup><mml:msub><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msubsup><mml:mi>B</mml:mi><mml:mn>0</mml:mn><mml:mi>T</mml:mi></mml:msubsup><mml:msub><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>in</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>in</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mi>g</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mi>g</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn59.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(59)</label>
</disp-formula>
</p>
<p>We used that <inline-formula id="ID122">
<alternatives>
<mml:math display="inline" id="I122"><mml:msup><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mi>B</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mtext>v</mml:mtext></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msubsup><mml:mi>B</mml:mi><mml:mn>0</mml:mn><mml:mi>T</mml:mi></mml:msubsup><mml:mtext>v</mml:mtext></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>=</mml:mo><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mi>g</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac></mml:mstyle><mml:msup><mml:mrow><mml:mo>‖</mml:mo><mml:mtext>v</mml:mtext><mml:mo>‖</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq122.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> for any vector <bold>v</bold> independent of <italic>W</italic><sub>0</sub> (which is the case for the input and output vectors) [<xref ref-type="bibr" rid="c69">69</xref>]. For initial condition <italic>b</italic>(0) = 0, the solution to <xref ref-type="disp-formula" rid="FD58">Eq. (58)</xref> is
<disp-formula id="FD60">
<alternatives>
<mml:math id="M60" display="block"><mml:mi>b</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo>−</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow><mml:mi>m</mml:mi></mml:mfrac><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:msup><mml:mi>m</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mi>η</mml:mi><mml:mi>τ</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn60.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(60)</label>
</disp-formula>
</p>
<p>The corresponding output changes are <inline-formula id="ID123">
<alternatives>
<mml:math display="inline" id="I123"><mml:mi>Δ</mml:mi><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>−</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mi>b</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mi>m</mml:mi></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq123.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. Because <italic>m</italic><sup>2</sup> ~ <italic>N</italic>, the output converges to the target in <italic>O</italic>(<italic>ηN</italic>) learning steps. The resulting weights are
<disp-formula id="FD61">
<alternatives>
<mml:math id="M61" display="block"><mml:mi>Δ</mml:mi><mml:mi>W</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo>−</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mn>0</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mi>g</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mrow><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:mfrac><mml:msubsup><mml:mi>B</mml:mi><mml:mn>0</mml:mn><mml:mi>T</mml:mi></mml:msubsup><mml:msub><mml:mover accent="true"><mml:mtext>w</mml:mtext><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub><mml:msubsup><mml:mover accent="true"><mml:mtext>w</mml:mtext><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mtext>in</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msubsup><mml:msubsup><mml:mi>B</mml:mi><mml:mn>0</mml:mn><mml:mi>T</mml:mi></mml:msubsup><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn61.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(61)</label>
</disp-formula>
</p>
<p>where the hats indicate normalized vectors. Consistent with linearization, the norm (both Frobenius and operator) of the changes is small: <inline-formula id="ID124">
<alternatives>
<mml:math display="inline" id="I124"><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>W</mml:mi></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>W</mml:mi></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo>−</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mn>0</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mi>g</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>/</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt><mml:mo>~</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq124.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>.</p>
<p>To connect with the following paragraph, we consider the case <italic>g</italic> = 0, so that Δ<italic>W</italic> = <italic>W</italic>. This is for reference, and <xref ref-type="fig" rid="fig10">Fig. 10</xref>; see details below. We express the results in the orthonormalized bases introduced below:
<disp-formula id="FD62">
<alternatives>
<mml:math id="M62" display="block"><mml:mi>Δ</mml:mi><mml:mi>W</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:mfrac><mml:msub><mml:mover accent="true"><mml:mtext>w</mml:mtext><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub><mml:msubsup><mml:mover accent="true"><mml:mtext>w</mml:mtext><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mtext>in,</mml:mtext><mml:mo>⊥</mml:mo></mml:mrow><mml:mi>T</mml:mi></mml:msubsup><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn62.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(62)</label>
</disp-formula>
</p>
<p>with
<disp-formula id="FD63">
<alternatives>
<mml:math id="M63" display="block"><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>N</mml:mi><mml:mi>η</mml:mi><mml:mi>τ</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo>−</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>o</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn63.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(63)</label>
</disp-formula>
</p>
<p>The corresponding activity changes are <inline-formula id="ID125">
<alternatives>
<mml:math display="inline" id="I125"><mml:mrow><mml:mi>Δ</mml:mi><mml:mover accent="true"><mml:mtext>x</mml:mtext><mml:mo>¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mover accent="true"><mml:mtext>w</mml:mtext><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq125.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, with norm <inline-formula id="ID126">
<alternatives>
<mml:math display="inline" id="I126"><mml:mrow><mml:mi>Δ</mml:mi><mml:mover accent="true"><mml:mtext>x</mml:mtext><mml:mo>¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq126.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. The output changes are Δ<italic>z</italic> = <italic>b</italic><sub>1</sub>(<italic>τ</italic>), so that the loss is <inline-formula id="ID127">
<alternatives>
<mml:math display="inline" id="I127"><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mi>b</mml:mi><mml:mi>i</mml:mi><mml:mi>a</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>o</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>4</mml:mn><mml:mi>N</mml:mi><mml:mi>η</mml:mi><mml:mi>τ</mml:mi></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo>−</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>o</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq127.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>.</p>
</sec>
<sec id="s8-3">
<title>A.3. Details linear model:, Bias and variance combined</title>
<p>We now combine results from the previous section, concerning the bias, with results from the Methods, concerning the variance, to derive the full learning dynamics of the linear model. For the case of no initial connectivity, <italic>W</italic>0 = 0, the gradients for both the bias and the variance component, <xref ref-type="disp-formula" rid="FD23">Eqs. (23)</xref> and <xref ref-type="disp-formula" rid="FD55">(55)</xref>, are spanned by the output and input vector. By orthonormalizing, we define <italic>Û</italic> = [ŵ<sub>out</sub>, ŵ<sub>in, ⊥</sub>] with <italic>Û<sup>T</sup>Û</italic> = 1<sub>2</sub>. The weights are then constrained to <italic>W</italic> = <italic>ÛMÛ<sup>T</sup></italic>. For ease of writing, we define the vectors <bold>V</bold><sub>out</sub> = <italic>Û<sup>T</sup></italic><bold>ŵ</bold><sub>out</sub> = [1, 0]<sup><italic>T</italic></sup> and <inline-formula id="ID128">
<alternatives>
<mml:math display="inline" id="I128"><mml:msub><mml:mtext>v</mml:mtext><mml:mrow><mml:mtext>in</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mover accent="true"><mml:mtext>w</mml:mtext><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mtext>in</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>o</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msqrt><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msubsup><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>o</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:msqrt></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mi>T</mml:mi></mml:msup></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq128.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, where <inline-formula id="ID129">
<alternatives>
<mml:math display="inline" id="I129"><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>o</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mover accent="true"><mml:mtext>w</mml:mtext><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msubsup><mml:msub><mml:mover accent="true"><mml:mtext>w</mml:mtext><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mtext>in</mml:mtext></mml:mrow></mml:msub><mml:mo>~</mml:mo><mml:mi>Ν</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mi>N</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq129.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> is the random, <inline-formula id="ID130">
<alternatives>
<mml:math display="inline" id="I130"><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:mfrac></mml:mstyle></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq130.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> correlation between input and output vector. As before, the norms of input and output vectors are <inline-formula id="ID131">
<alternatives>
<mml:math display="inline" id="I131"><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>in</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq131.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> and ║<bold>w</bold><sub>out</sub>║ = <italic>σ</italic><sub>out</sub>.</p>
<p>The projection of the deterministic gradient is then
<disp-formula id="FD64">
<alternatives>
<mml:math id="M64" display="block"><mml:msub><mml:mi>G</mml:mi><mml:mrow><mml:mi>det</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mi>G</mml:mi><mml:mrow><mml:mi>det</mml:mi></mml:mrow></mml:msub><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub><mml:msubsup><mml:mi>B</mml:mi><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mi>T</mml:mi></mml:msubsup><mml:msub><mml:mtext>v</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub><mml:msubsup><mml:mtext>v</mml:mtext><mml:mrow><mml:mtext>in</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msubsup><mml:msubsup><mml:mi>B</mml:mi><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mi>T</mml:mi></mml:msubsup><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn64.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(64)</label>
</disp-formula>
</p>
<p>with deterministic output
<disp-formula id="FD65">
<alternatives>
<mml:math id="M65" display="block"><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub><mml:msubsup><mml:mtext>v</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msubsup><mml:msub><mml:mi>B</mml:mi><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:msub><mml:msub><mml:mtext>v</mml:mtext><mml:mrow><mml:mtext>in</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn65.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(65)</label>
</disp-formula>
</p>
<p>and projection <italic>B<sub>Û</sub></italic> = <italic>Û<sup>T</sup>BÛ</italic> = (1 − <italic>M</italic>)<sup>−1</sup>.</p>
<p>For the stochastic part, we need to solve the two Lyapunov <xref ref-type="disp-formula" rid="FD21">Eqs. (21)</xref> and <xref ref-type="disp-formula" rid="FD24">(24)</xref>. They reduce to low-D versions after projection. For the first one, we have
<disp-formula id="FD66">
<alternatives>
<mml:math id="M66" display="block"><mml:mi>Σ</mml:mi><mml:mo>=</mml:mo><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>noise</mml:mtext></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>Σ</mml:mi><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msup><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mi>T</mml:mi></mml:msup></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn66.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(66)</label>
</disp-formula>
</p>
<p>and the projection solves the 2-dimensional Lyapunov equation
<disp-formula id="FD67">
<alternatives>
<mml:math id="M67" display="block"><mml:msub><mml:mi>A</mml:mi><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:msub><mml:msub><mml:mi>Σ</mml:mi><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>Σ</mml:mi><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:msub><mml:msubsup><mml:mi>A</mml:mi><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mi>T</mml:mi></mml:msubsup><mml:mo>+</mml:mo><mml:msub><mml:mn>21</mml:mn><mml:mn>2</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn67.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(67)</label>
</disp-formula>
</p>
<p>with <italic>A<sub>Û</sub></italic> = −1<sub>2</sub> + <italic>M</italic>. Similarly, the low-D version of the second Lyapunov <xref ref-type="disp-formula" rid="FD24">Eq. (24)</xref> is obtained by defining <inline-formula id="ID132">
<alternatives>
<mml:math display="inline" id="I132"><mml:mrow><mml:mi>Ω</mml:mi><mml:mo>=</mml:mo><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:msub><mml:mi>Ω</mml:mi><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:msub><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mi>T</mml:mi></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq132.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, with
<disp-formula id="FD68">
<alternatives>
<mml:math id="M68" display="block"><mml:msub><mml:mi>A</mml:mi><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:msub><mml:msub><mml:mi>Ω</mml:mi><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>Ω</mml:mi><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:msub><mml:msubsup><mml:mi>A</mml:mi><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mi>T</mml:mi></mml:msubsup><mml:mo>+</mml:mo><mml:msub><mml:mtext>v</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub><mml:msubsup><mml:mtext>v</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:mn>0.</mml:mn></mml:math>
<graphic xlink:href="2307.07654v3_eqn68.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(68)</label>
</disp-formula>
</p>
<p>The full learning dynamics for gradient flow are then given by
<disp-formula id="FD69">
<alternatives>
<mml:math id="M69" display="block"><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˙</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mi>η</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>G</mml:mi><mml:mrow><mml:mi>det</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>G</mml:mi><mml:mrow><mml:mtext>sto</mml:mtext><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn69.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(69)</label>
</disp-formula>
</p>
<p>with <italic>M</italic>(0) = 0 and
<disp-formula id="FD70">
<alternatives>
<mml:math id="M70" display="block"><mml:msub><mml:mi>G</mml:mi><mml:mrow><mml:mtext>sto,</mml:mtext><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mi>G</mml:mi><mml:mrow><mml:mtext>sto</mml:mtext></mml:mrow></mml:msub><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>noise</mml:mtext></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:msub><mml:mi>Ω</mml:mi><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:msub><mml:msub><mml:mi>Σ</mml:mi><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:msub><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn70.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(70)</label>
</disp-formula>
</p>
<p>For a small output scale, the deterministic part is order one, while the stochastic one is order 1/<italic>N</italic> (through Ω). Assuming <italic>η = O</italic>(1), learning thus reaches an arbitrary small order-one loss after <italic>O</italic>(1) updates, with noise adding a 1/<italic>N</italic> stochastic loss, and noise-driven learning equally adding order 1/<italic>N</italic> deviations to the entries of <italic>M</italic>. Hence, learning remains unaffected by the noise unless it is continued for <italic>O</italic>(<italic>ηN<sup>2</sup>)</italic> steps.</p>
<p>For a large output scale, the deterministic part is fast but only leads to <inline-formula id="ID133">
<alternatives>
<mml:math display="inline" id="I133"><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq133.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> entries. In such a situation, the stochastic part can be expanded in orders of <inline-formula id="ID134">
<alternatives>
<mml:math display="inline" id="I134"><mml:mo>∈</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq134.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. To leading order, it yields dynamics along the first entry of <italic>M</italic>.</p>
<p>In detail: For a large readout, <italic>σ</italic><sub>out</sub> = 1, we expand <italic>M</italic> to first order in <inline-formula id="ID135">
<alternatives>
<mml:math display="inline" id="I135"><mml:mo>∈</mml:mo><mml:mo>=</mml:mo><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:mfrac></mml:mstyle></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq135.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>:
<disp-formula id="FD71">
<alternatives>
<mml:math id="M71" display="block"><mml:mi>M</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn71.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(71)</label>
</disp-formula>
</p>
<p>The leading order of the output is
<disp-formula id="FD72">
<alternatives>
<mml:math id="M72" display="block"><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>ε</mml:mi></mml:mfrac><mml:mfrac><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>o</mml:mi></mml:msub><mml:msub><mml:mi>d</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:msub><mml:mi>c</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn72.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(72)</label>
</disp-formula>
</p>
<p>which implies that <italic>b</italic><sub>0</sub> = 0 throughout learning. Under this assumption, we have
<disp-formula id="FD73">
<alternatives>
<mml:math id="M73" display="block"><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>o</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>ε</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn73.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(73)</label>
</disp-formula>
</p>
<p>Furthermore, the deterministic gradient is
<disp-formula id="FD74">
<alternatives>
<mml:math id="M74" display="block"><mml:msub><mml:mi>G</mml:mi><mml:mrow><mml:mi>det</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mn>2</mml:mn><mml:mi>ε</mml:mi></mml:mfrac><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mrow><mml:mfrac><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn74.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(74)</label>
</disp-formula>
</p>
<p>This component of learning converges on the order of <italic>η/∈</italic><sup>2</sup> learning steps due to the prefactor 1/<italic>∈</italic> and the fact that <italic>b</italic><sub>1</sub> enters <inline-formula id="ID136">
<alternatives>
<mml:math display="inline" id="I136"><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq136.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> at order one. The higher order terms therefore only lead to <italic>O</italic>(<italic>∈</italic><sup>2</sup>) corrections.</p>
<p>The stochastic part of the gradient simplifies by assuming <italic>b</italic><sub>0</sub> = <italic>c</italic><sub>0</sub> = <italic>d</italic><sub>0</sub> = 0. The latter two are justified self-consistently because neither the deterministic nor the stochastic part contribute to <italic>c</italic> and <italic>d</italic> at order one if we start with <italic>M</italic> = 0. With this assumption, we have
<disp-formula id="FD75">
<alternatives>
<mml:math id="M75" display="block"><mml:msub><mml:mi>G</mml:mi><mml:mrow><mml:mtext>sto,</mml:mtext><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>noise</mml:mtext></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>ε</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn75.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(75)</label>
</disp-formula>
</p>
<p>Consistent with our assumption, we only have order-one growth for the entry <italic>a</italic>. The resulting dynamics are
<disp-formula id="FD76">
<alternatives>
<mml:math id="M76" display="block"><mml:msub><mml:mi>a</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>3</mml:mn><mml:mi>η</mml:mi><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>noise</mml:mtext></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mi>τ</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mn>3</mml:mn></mml:mfrac></mml:mrow></mml:msup><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn76.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(76)</label>
</disp-formula>
</p>
<p>where <italic>τ</italic> is the number of learning steps. Further, because the deterministic part is so much faster, we can assume that the second entry, <italic>b</italic> = <italic>b</italic><sub>1</sub>, is always constrained by the target. Namely, from <xref ref-type="disp-formula" rid="FD73">Eq. (73)</xref>, we have
<disp-formula id="FD77">
<alternatives>
<mml:math id="M77" display="block"><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>o</mml:mi></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn77.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(77)</label>
</disp-formula>
</p>
<p>Lastly, the first-order corrections for the other entries all vanish due to vanishing initial conditions:
<disp-formula id="FD78">
<alternatives>
<mml:math id="M78" display="block"><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>0.</mml:mn></mml:math>
<graphic xlink:href="2307.07654v3_eqn78.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(78)</label>
</disp-formula>
</p>
<p>The loss due to the stochastic part is then
<disp-formula id="FD79">
<alternatives>
<mml:math id="M79" display="block"><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mi>var</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>noise</mml:mtext></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>3</mml:mn><mml:mi>η</mml:mi><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>noise</mml:mtext></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mi>τ</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>3</mml:mn></mml:mfrac></mml:mrow></mml:msup><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn79.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(79)</label>
</disp-formula>
</p>
<p>while the deterministic part is kept at O(1/<italic>N</italic>).</p>
<p>During learning, the average states change only very little. To see this, we express the connectivity as <inline-formula id="ID137">
<alternatives>
<mml:math display="inline" id="I137"><mml:mi>W</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mover accent="true"><mml:mtext>w</mml:mtext><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub><mml:msubsup><mml:mtext>w</mml:mtext><mml:mi>r</mml:mi><mml:mi>T</mml:mi></mml:msubsup></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq137.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> with
<disp-formula id="FD80">
<alternatives>
<mml:math id="M80" display="block"><mml:msub><mml:mtext>w</mml:mtext><mml:mtext>r</mml:mtext></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mtext>λ</mml:mtext><mml:mo>−</mml:mo></mml:msub><mml:msubsup><mml:mover accent="true"><mml:mtext>w</mml:mtext><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msubsup><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:mfrac><mml:msub><mml:mover accent="true"><mml:mtext>w</mml:mtext><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mtext>in,</mml:mtext><mml:mo>⊥</mml:mo></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn80.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(80)</label>
</disp-formula>
</p>
<p>and orthonormalized input weights
<disp-formula id="FD81">
<alternatives>
<mml:math id="M81" display="block"><mml:msub><mml:mover accent="true"><mml:mtext>w</mml:mtext><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mtext>in,</mml:mtext><mml:mo>⊥</mml:mo></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mover accent="true"><mml:mtext>w</mml:mtext><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mtext>in</mml:mtext></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mover accent="true"><mml:mtext>w</mml:mtext><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>o</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msqrt><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msubsup><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>o</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:msqrt></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:msub><mml:mover accent="true"><mml:mtext>w</mml:mtext><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mtext>in</mml:mtext></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mover accent="true"><mml:mtext>w</mml:mtext><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>o</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn81.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(81)</label>
</disp-formula>
</p>
<p>The output is then
<disp-formula id="FD82">
<alternatives>
<mml:math id="M82" display="block"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mover accent="true"><mml:mtext>x</mml:mtext><mml:mo>¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>W</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:msub><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>in</mml:mtext></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtext> </mml:mtext><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mover accent="true"><mml:mtext>w</mml:mtext><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub><mml:msubsup><mml:mtext>w</mml:mtext><mml:mtext>r</mml:mtext><mml:mi>T</mml:mi></mml:msubsup></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>in</mml:mtext></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtext> </mml:mtext><mml:mo>=</mml:mo><mml:msub><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>in</mml:mtext></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mover accent="true"><mml:mtext>w</mml:mtext><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub><mml:mfrac><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>o</mml:mi></mml:mrow></mml:msub><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt><mml:mo>+</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math>
<graphic xlink:href="2307.07654v3_eqn82.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(82)</label>
</disp-formula>
</p>
<p>The initial states are <inline-formula id="ID138">
<alternatives>
<mml:math display="inline" id="I138"><mml:msub><mml:mover accent="true"><mml:mtext>x</mml:mtext><mml:mo>¯</mml:mo></mml:mover><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>in</mml:mtext></mml:mrow></mml:msub></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq138.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, so the changes are
<disp-formula id="FD83">
<alternatives>
<mml:math id="M83" display="block"><mml:mi>Δ</mml:mi><mml:mover accent="true"><mml:mtext>x</mml:mtext><mml:mo>¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>o</mml:mi></mml:mrow></mml:msub><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt><mml:mo>+</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mfrac><mml:msub><mml:mover accent="true"><mml:mtext>w</mml:mtext><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo>−</mml:mo><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>o</mml:mi></mml:mrow></mml:msub><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mover accent="true"><mml:mtext>w</mml:mtext><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn83.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(83)</label>
</disp-formula>
</p>
<p>where the scalar part is also the norm. Thus, <inline-formula id="ID139">
<alternatives>
<mml:math display="inline" id="I139"><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:mi>Δ</mml:mi><mml:mover accent="true"><mml:mtext>x</mml:mtext><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mo>~</mml:mo><mml:mn>1</mml:mn></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq139.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, which is small, because the entries are <inline-formula id="ID140">
<alternatives>
<mml:math display="inline" id="I140"><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq140.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. Paradoxically, the norm does not change with learning time. Essentially, once the lazy learning takes place at the beginning of learning, the norm does not change anymore (to leading order).</p>
</sec>
<sec id="s8-4">
<title>A.4. Details nonlinear autonomous system with noise</title>
<p>This section contains detailed derivations for the average and fluctuations of the latent projection <italic><bold>κ</bold></italic>. The theoretical treatment of the network dynamics is very similar to that for a network with only a negative feedback loop for “balance” by Kadmon et al. [<xref ref-type="bibr" rid="c29">29</xref>]. What is added here is a colored noise term that enters via the variance <inline-formula id="ID141">
<alternatives>
<mml:math display="inline" id="I141"><mml:msubsup><mml:mi>σ</mml:mi><mml:mo>⊥</mml:mo><mml:mn>2</mml:mn></mml:msubsup></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq141.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> of the orthogonal dynamics. This is dependent on a nonzero fixed point (not present in Ref. [<xref ref-type="bibr" rid="c29">29</xref>]).</p>
<p>The dynamics of the latent variable are
<disp-formula id="FD84">
<alternatives>
<mml:math id="M84" display="block"><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>˙</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mi>κ</mml:mi><mml:mo>+</mml:mo><mml:mi>M</mml:mi><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:msup><mml:mi>U</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>ϕ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>U</mml:mi><mml:mi>κ</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mtext>x</mml:mtext><mml:mo>⊥</mml:mo></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:msup><mml:mi>U</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>ξ</mml:mi><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn84.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(84)</label>
</disp-formula>
</p>
<p>That is, the low-D variable is driven autonomously by itself, but externally by the high-D orthogonal part <bold>x</bold><sub>⊥</sub>. To resolve this into low-D dynamics only, we apply two averages: the trial-conditioned average, which is over the noise <italic><bold>ξ</bold></italic>, and denoted by the bar, <inline-formula id="ID142">
<alternatives>
<mml:math display="inline" id="I142"><mml:mover accent="true"><mml:mo>⋅</mml:mo><mml:mo>¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:msub><mml:mi>𝔼</mml:mi><mml:mi>ξ</mml:mi></mml:msub><mml:mrow><mml:mo>[</mml:mo><mml:mo>⋅</mml:mo><mml:mo>]</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq142.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>; and the average over the statistics of <italic>U</italic>, which arises naturally from the projection on <italic>U</italic> (a population average). We start with the latter, writing
<disp-formula id="FD85">
<alternatives>
<mml:math id="M85" display="block"><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:msup><mml:mi>U</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>ϕ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mtext>x</mml:mtext><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:msub><mml:mtext>E</mml:mtext><mml:mi>U</mml:mi></mml:msub><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msup><mml:mi>U</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>ϕ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mtext>x</mml:mtext><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn85.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(85)</label>
</disp-formula>
</p>
<p>One can show that the error is small, 𝔼<sub><italic>U</italic></sub>[<italic>∈<sub>a</sub></italic>] = 0 and 𝔼<sub><italic>U</italic></sub>[<italic>∈</italic><sub><italic>a</italic></sub><italic>∈</italic><sub><italic>a</italic></sub>] ~ 1 /<italic>N</italic>. For the average, we apply partial integration as in the noise-free case, <xref ref-type="disp-formula" rid="FD14">Eq. (14)</xref>, and arrive at
<disp-formula id="FD86">
<alternatives>
<mml:math id="M86" display="block"><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:msub><mml:mtext>E</mml:mtext><mml:mi>U</mml:mi></mml:msub><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msup><mml:mi>U</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>ϕ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mtext>x</mml:mtext><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>〈</mml:mo><mml:mrow><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mi>u</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>〉</mml:mo></mml:mrow><mml:mi>κ</mml:mi><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn86.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(86)</label>
</disp-formula>
</p>
<p>where the average on the right-hand side is over the standard normal variable <italic>u</italic>. In contrast to the noise-free case, the variance is now comprised of two terms,
<disp-formula id="FD87">
<alternatives>
<mml:math id="M87" display="block"><mml:msub><mml:mi>σ</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:mi>κ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mo>⊥</mml:mo></mml:msub><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn87.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(87)</label>
</disp-formula>
</p>
<p>and <inline-formula id="ID143">
<alternatives>
<mml:math display="inline" id="I143"><mml:msubsup><mml:mi>σ</mml:mi><mml:mo>⊥</mml:mo><mml:mn>2</mml:mn></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac></mml:mstyle><mml:msub><mml:mtext>x</mml:mtext><mml:mo>⊥</mml:mo></mml:msub><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mtext>x</mml:mtext><mml:mo>⊥</mml:mo></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq143.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> is the population average of <bold>x</bold><sub>⊥</sub>(<italic>t</italic>). We included the time index here to emphasize that both variables still contain fluctuations around the trial-conditioned average.</p>
<p>We now split the term <xref ref-type="disp-formula" rid="FD85">Eq. (85)</xref> into average and fluctuations around this. We self-consistently assume that all fluctuations, denoted with a <italic>δ</italic>, are small, which allows us to linearize around the respective averages. We have
<disp-formula id="FD88">
<alternatives>
<mml:math id="M88" display="block"><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:msup><mml:mi>U</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>ϕ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mtext>x</mml:mtext><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:mrow><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mi>u</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>〉</mml:mo></mml:mrow></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mtext> </mml:mtext><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>+</mml:mo><mml:mover accent="true"><mml:mi>ε</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>+</mml:mo><mml:mover accent="true"><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:mrow><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mi>u</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>〉</mml:mo></mml:mrow></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mtext> </mml:mtext><mml:mi>δ</mml:mi><mml:mi>κ</mml:mi><mml:mo>+</mml:mo><mml:mi>δ</mml:mi><mml:mrow><mml:mo>〈</mml:mo><mml:mrow><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mi>u</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>〉</mml:mo></mml:mrow><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn88.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(88)</label>
</disp-formula>
</p>
<p>We only keep terms up to order <inline-formula id="ID144">
<alternatives>
<mml:math display="inline" id="I144"><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq144.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. The fluctuations of the error are <italic>δ</italic><bold>∈</bold> ~ 1 /<italic>N</italic> and hence discarded. By linearization, we further have <inline-formula id="ID145">
<alternatives>
<mml:math display="inline" id="I145"><mml:mover accent="true"><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:mrow><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mi>u</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>〉</mml:mo></mml:mrow></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mrow><mml:mo>〈</mml:mo><mml:mrow><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mi>u</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>〉</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq145.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, with
<disp-formula id="FD89">
<alternatives>
<mml:math id="M89" display="block"><mml:mover accent="true"><mml:mrow><mml:msubsup><mml:mi>σ</mml:mi><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo>‖</mml:mo><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>‖</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:mover accent="true"><mml:mrow><mml:msubsup><mml:mi>σ</mml:mi><mml:mo>⊥</mml:mo><mml:mn>2</mml:mn></mml:msubsup></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn89.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(89)</label>
</disp-formula>
</p>
<p>The orthogonal part is an Ornstein-Uhlenbeck process with steady-state covariance
<disp-formula id="FD90">
<alternatives>
<mml:math id="M90" display="block"><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mo>⊥</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mo>⊥</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mi>s</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:msub><mml:mi>δ</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mover accent="true"><mml:mrow><mml:msubsup><mml:mi>σ</mml:mi><mml:mo>⊥</mml:mo><mml:mn>2</mml:mn></mml:msubsup></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mtext> </mml:mtext><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:msup><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn90.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(90)</label>
</disp-formula>
</p>
<p>where the variance is inherited from the white noise, <inline-formula id="ID146">
<alternatives>
<mml:math display="inline" id="I146"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msubsup><mml:mi>σ</mml:mi><mml:mo>⊥</mml:mo><mml:mn>2</mml:mn></mml:msubsup></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>noise</mml:mtext></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq146.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>.</p>
<p>We take the average over the latent dynamics <xref ref-type="disp-formula" rid="FD84">Eq. (84)</xref>. Apart from an initial transient, which we discard, this leaves us with a fixed point
<disp-formula id="FD91">
<alternatives>
<mml:math id="M91" display="block"><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mrow><mml:mo>〈</mml:mo><mml:mrow><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mi>u</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>〉</mml:mo></mml:mrow><mml:mi>M</mml:mi><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>+</mml:mo><mml:mover accent="true"><mml:mi>ε</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn91.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(91)</label>
</disp-formula>
</p>
<p>We now discuss the fluctuations in <xref ref-type="disp-formula" rid="FD88">Eq. (88)</xref>. There are two sources of fluctuations, <italic>δ<bold>κ</bold></italic> and <inline-formula id="ID147">
<alternatives>
<mml:math display="inline" id="I147"><mml:mi>δ</mml:mi><mml:msubsup><mml:mi>σ</mml:mi><mml:mo>⊥</mml:mo><mml:mn>2</mml:mn></mml:msubsup></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq147.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>, so that we have
<disp-formula id="FD92">
<alternatives>
<mml:math id="M92" display="block"><mml:mi>δ</mml:mi><mml:mrow><mml:mo>〈</mml:mo><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>〉</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mo>∂</mml:mo><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:mo>〈</mml:mo><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>〉</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mo>∂</mml:mo><mml:mi>κ</mml:mi><mml:mi>T</mml:mi></mml:msubsup><mml:msub><mml:mi>σ</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mi>δ</mml:mi><mml:mi>κ</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mo>∂</mml:mo><mml:mrow><mml:msubsup><mml:mi>σ</mml:mi><mml:mo>⊥</mml:mo><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:msub><mml:msub><mml:mi>σ</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mi>δ</mml:mi><mml:msubsup><mml:mi>σ</mml:mi><mml:mo>⊥</mml:mo><mml:mn>2</mml:mn></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn92.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(92)</label>
</disp-formula>
</p>
<p>All derivatives are evaluated at the averages (we discard the bar in the following lines to keep notation at bay). We further compute
<disp-formula id="FD93">
<alternatives>
<mml:math id="M93" display="block"><mml:msub><mml:mo>∂</mml:mo><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:mo>〈</mml:mo><mml:mrow><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mi>u</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>〉</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>〈</mml:mo><mml:mrow><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>″</mml:mo></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mi>u</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mo>〉</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mrow><mml:mo>〈</mml:mo><mml:mrow><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>‴</mml:mo></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mi>u</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>〉</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn93.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(93)</label>
</disp-formula>
<disp-formula id="FD94">
<alternatives>
<mml:math id="M94" display="block"><mml:msub><mml:mo>∂</mml:mo><mml:mi>κ</mml:mi></mml:msub><mml:msub><mml:mi>σ</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:mfrac><mml:mi>κ</mml:mi><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn94.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(94)</label>
</disp-formula>
<disp-formula id="FD95">
<alternatives>
<mml:math id="M95" display="block"><mml:msub><mml:mo>∂</mml:mo><mml:mrow><mml:msubsup><mml:mi>σ</mml:mi><mml:mo>⊥</mml:mo><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:msub><mml:msub><mml:mi>σ</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:msub><mml:mi>σ</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn95.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(95)</label>
</disp-formula>
</p>
<p>Inserting these terms into the dynamics <xref ref-type="disp-formula" rid="FD84">Eq. (84)</xref>, we arrive at
<disp-formula id="FD96">
<alternatives>
<mml:math id="M96" display="block"><mml:mfrac><mml:mrow><mml:mtext>d</mml:mtext><mml:mi>δ</mml:mi><mml:mi>κ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mtext>d</mml:mtext><mml:mi>t</mml:mi></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mrow><mml:mo>〈</mml:mo><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>〉</mml:mo></mml:mrow><mml:mi>M</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:mo>〈</mml:mo><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>‴</mml:mo></mml:msup><mml:mo>〉</mml:mo></mml:mrow><mml:mi>M</mml:mi><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:msup><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mi>T</mml:mi></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mi>δ</mml:mi><mml:mi>κ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>‴</mml:mo></mml:msup><mml:mo>〉</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:mfrac><mml:mi>M</mml:mi><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mi>δ</mml:mi><mml:msubsup><mml:mi>σ</mml:mi><mml:mo>⊥</mml:mo><mml:mn>2</mml:mn></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:msup><mml:mi>U</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>ξ</mml:mi><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn96.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(96)</label>
</disp-formula>
</p>
<p>The white noise term has variance
<disp-formula id="FD97">
<alternatives>
<mml:math id="M97" display="block"><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msup><mml:mi>N</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac><mml:mover accent="true"><mml:mrow><mml:msup><mml:mi>U</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>ξ</mml:mi><mml:msup><mml:mi>ξ</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>U</mml:mi></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>noise</mml:mtext></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:mrow><mml:mi>N</mml:mi></mml:mfrac><mml:msub><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:msub><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn97.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(97)</label>
</disp-formula>
</p>
<p>For the fluctuations in the population average of the variance, we use <xref ref-type="disp-formula" rid="FD90">Eq. (90)</xref> to compute the covariance function between different time points,
<disp-formula id="FD98">
<alternatives>
<mml:math id="M98" display="block"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mover accent="true"><mml:mrow><mml:mi>δ</mml:mi><mml:msubsup><mml:mi>σ</mml:mi><mml:mo>⊥</mml:mo><mml:mn>2</mml:mn></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mi>δ</mml:mi><mml:msubsup><mml:mi>σ</mml:mi><mml:mo>⊥</mml:mo><mml:mn>2</mml:mn></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msup><mml:mi>N</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:msub><mml:mo>⊥</mml:mo><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:msub><mml:mo>⊥</mml:mo><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mi>s</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover></mml:mrow></mml:mstyle><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi>σ</mml:mi><mml:mo>⊥</mml:mo><mml:mn>2</mml:mn></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtext>       </mml:mtext><mml:mo>=</mml:mo><mml:msup><mml:mover accent="true"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi>σ</mml:mi><mml:mo>⊥</mml:mo><mml:mn>2</mml:mn></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mn>2</mml:mn></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mi>N</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msup><mml:mi>N</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mi>i</mml:mi></mml:munder><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:msub><mml:mo>⊥</mml:mo><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:msub><mml:mi>x</mml:mi><mml:mo>⊥</mml:mo></mml:msub><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mi>s</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtext>       </mml:mtext><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>noise</mml:mtext></mml:mrow><mml:mn>4</mml:mn></mml:msubsup></mml:mrow><mml:mi>N</mml:mi></mml:mfrac><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mrow><mml:mo>〈</mml:mo><mml:mrow><mml:msup><mml:mi>u</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:msup><mml:mi>u</mml:mi><mml:mo>+</mml:mo><mml:msqrt><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mrow><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:msup><mml:msup><mml:mi>u</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:msqrt></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo>〉</mml:mo></mml:mrow></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtext>       </mml:mtext><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>noise</mml:mtext></mml:mrow><mml:mn>4</mml:mn></mml:msubsup></mml:mrow><mml:mi>N</mml:mi></mml:mfrac><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mrow><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:msup><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math>
<graphic xlink:href="2307.07654v3_eqn98.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(98)</label>
</disp-formula>
</p>
<p>For the third line, the average is taken over the independent standard normal variables <italic>u</italic>, <italic>u</italic><sup>′</sup>. Putting all the pieces together, we have
<disp-formula id="FD99">
<alternatives>
<mml:math id="M99" display="block"><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:mtext> </mml:mtext><mml:mi>δ</mml:mi><mml:mi>κ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mtext>d</mml:mtext><mml:mi>t</mml:mi></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mi>A</mml:mi><mml:mi>δ</mml:mi><mml:mi>κ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:mfrac><mml:mi>ζ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn99.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(99)</label>
</disp-formula>
</p>
<p>with Jacobian
<disp-formula id="FD100">
<alternatives>
<mml:math id="M100" display="block"><mml:mi>A</mml:mi><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mrow><mml:mo>〈</mml:mo><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>〉</mml:mo></mml:mrow><mml:mi>M</mml:mi><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>‴</mml:mo></mml:msup><mml:mo>〉</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>〉</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:msup><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mi>T</mml:mi></mml:msup><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn100.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(100)</label>
</disp-formula>
</p>
<p>and noise term <italic>ς</italic>(<italic>t</italic>) with zero average and covariance
<disp-formula id="FD101">
<alternatives>
<mml:math id="M101" display="block"><mml:mover accent="true"><mml:mrow><mml:mi>ζ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mi>ζ</mml:mi><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mi>s</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mi>T</mml:mi></mml:msup></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>2</mml:mn><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>noise</mml:mtext></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mi>δ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>s</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mi>β</mml:mi><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mrow><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:msup><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:msup><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mi>T</mml:mi></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn101.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(101)</label>
</disp-formula>
</p>
<p>with
<disp-formula id="FD102">
<alternatives>
<mml:math id="M102" display="block"><mml:mi>β</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>noise</mml:mtext></mml:mrow><mml:mn>4</mml:mn></mml:msubsup></mml:mrow><mml:mn>2</mml:mn></mml:mfrac><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>‴</mml:mo></mml:msup><mml:mo>〉</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>〉</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn102.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(102)</label>
</disp-formula>
</p>
<p>We inserted the eigenvalue equation, <inline-formula id="ID148">
<alternatives>
<mml:math display="inline" id="I148"><mml:mi>M</mml:mi><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mstyle scriptlevel="+1"><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>〉</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mstyle><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq148.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. We note that the colored noise term did not appear in previous studies such as [<xref ref-type="bibr" rid="c29">29</xref>], because there was no positive feedback and corresponding fixed point <inline-formula id="ID149">
<alternatives>
<mml:math display="inline" id="I149"><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq149.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>.</p>
<p>We now compute the variance of the fluctuations <italic>δ<bold>κ</bold></italic>. The computation is simplified by the fact the <inline-formula id="ID150">
<alternatives>
<mml:math display="inline" id="I150"><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq150.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> is also eigenvector of <italic>A</italic>, with eigenvalue
<disp-formula id="FD103">
<alternatives>
<mml:math id="M103" display="block"><mml:msub><mml:mi>γ</mml:mi><mml:mo>+</mml:mo></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>‴</mml:mo></mml:msup><mml:mo>〉</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>〉</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:msup><mml:mrow><mml:mo>‖</mml:mo><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>‖</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn103.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(103)</label>
</disp-formula>
</p>
<p>The eigenvector is also the direction in which the colored noise acts. Because of this, we can write
<disp-formula id="FD104">
<alternatives>
<mml:math id="M104" display="block"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mover accent="true"><mml:mrow><mml:mi>δ</mml:mi><mml:mi>κ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mi>δ</mml:mi><mml:mi>κ</mml:mi><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mi>T</mml:mi></mml:msup></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:mstyle displaystyle="true"><mml:mrow><mml:msubsup><mml:mo>∫</mml:mo><mml:mn>0</mml:mn><mml:mi>t</mml:mi></mml:msubsup><mml:mrow><mml:mtext>d</mml:mtext><mml:msup><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:mstyle><mml:mstyle displaystyle="true"><mml:mrow><mml:msubsup><mml:mo>∫</mml:mo><mml:mn>0</mml:mn><mml:mi>t</mml:mi></mml:msubsup><mml:mrow><mml:mtext>d</mml:mtext><mml:msup><mml:mi>t</mml:mi><mml:mo>″</mml:mo></mml:msup><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mi>A</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msup><mml:mover accent="true"><mml:mrow><mml:mi>ζ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>)</mml:mo></mml:mrow><mml:mi>ζ</mml:mi><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>″</mml:mo></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mi>T</mml:mi></mml:msup></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:msup><mml:mi>A</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtext>     </mml:mtext><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>noise</mml:mtext></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:msub><mml:mi>Σ</mml:mi><mml:mi>A</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>β</mml:mi><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:msup><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mi>T</mml:mi></mml:msup><mml:munder><mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:mrow><mml:msubsup><mml:mo>∫</mml:mo><mml:mn>0</mml:mn><mml:mi>t</mml:mi></mml:msubsup><mml:mrow><mml:mtext>d</mml:mtext><mml:msup><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:mstyle><mml:mstyle displaystyle="true"><mml:mrow><mml:msubsup><mml:mo>∫</mml:mo><mml:mn>0</mml:mn><mml:mi>t</mml:mi></mml:msubsup><mml:mrow><mml:mtext>d</mml:mtext><mml:msup><mml:mi>t</mml:mi><mml:mo>″</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:mstyle><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:msub><mml:mi>γ</mml:mi><mml:mo>+</mml:mo></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>2</mml:mn><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>−</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>″</mml:mo></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>−</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>″</mml:mo></mml:msup></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:msup></mml:mrow><mml:mo stretchy="true">︸</mml:mo></mml:munder><mml:mrow><mml:mi>I</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:munder></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math>
<graphic xlink:href="2307.07654v3_eqn104.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(104)</label>
</disp-formula>
</p>
<p>The first summand stems from the white noise term,
<disp-formula id="FD105">
<alternatives>
<mml:math id="M105" display="block"><mml:msub><mml:mi>Σ</mml:mi><mml:mi>A</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mstyle displaystyle="true"><mml:mrow><mml:msubsup><mml:mo>∫</mml:mo><mml:mn>0</mml:mn><mml:mi>t</mml:mi></mml:msubsup><mml:mrow><mml:mtext>d</mml:mtext><mml:msup><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:mstyle><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mi>A</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msup><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:msup><mml:mi>A</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msup><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn105.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(105)</label>
</disp-formula>
</p>
<p>The integral <italic>I(t)</italic> can be computed to yield
<disp-formula id="FD106">
<alternatives>
<mml:math id="M106" display="block"><mml:mi>I</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:msub><mml:mn>2</mml:mn><mml:mrow><mml:mi>γ</mml:mi><mml:mo>+</mml:mo></mml:mrow></mml:msub><mml:mi>t</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:msub><mml:mi>γ</mml:mi><mml:mo>+</mml:mo></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>γ</mml:mi><mml:mo>+</mml:mo></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:msub><mml:mi>γ</mml:mi><mml:mo>+</mml:mo></mml:msub><mml:mi>t</mml:mi></mml:mrow></mml:msup><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:msub><mml:mi>γ</mml:mi><mml:mo>+</mml:mo></mml:msub></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mo>+</mml:mo><mml:msub><mml:mi>γ</mml:mi><mml:mo>+</mml:mo></mml:msub></mml:mrow></mml:mfrac><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>2</mml:mn><mml:mo>+</mml:mo><mml:msub><mml:mi>γ</mml:mi><mml:mo>+</mml:mo></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn106.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(106)</label>
</disp-formula>
</p>
<p>For the steady-state variance, we take <italic>t</italic> → ∞. The first term yields lim<italic><sub>t → ∞</sub></italic> <italic>∑</italic><sub>A</sub>(<italic>t</italic>) = <italic>∑</italic><sub>A</sub>, which can be expressed as the solution of the Lyapunov equation
<disp-formula id="FD107">
<alternatives>
<mml:math id="M107" display="block"><mml:mn>0</mml:mn><mml:mo>=</mml:mo><mml:mi>A</mml:mi><mml:msub><mml:mi>Σ</mml:mi><mml:mi>A</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>Σ</mml:mi><mml:mi>A</mml:mi></mml:msub><mml:msup><mml:mi>A</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mo>+</mml:mo><mml:msub><mml:mn>21</mml:mn><mml:mn>2</mml:mn></mml:msub><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn107.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(107)</label>
</disp-formula>
</p>
<p>The integral converges to
<disp-formula id="FD108">
<alternatives>
<mml:math id="M108" display="block"><mml:munder><mml:mrow><mml:mi>lim</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>→</mml:mo><mml:mi>∞</mml:mi></mml:mrow></mml:munder><mml:mi>I</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>γ</mml:mi><mml:mo>+</mml:mo></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>γ</mml:mi><mml:mo>+</mml:mo></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn108.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(108)</label>
</disp-formula>
</p>
<p>Joining all the bits and pieces, we have the steady-state covariance
<disp-formula id="FD109">
<alternatives>
<mml:math id="M109" display="block"><mml:mover accent="true"><mml:mrow><mml:mi>δ</mml:mi><mml:mi>κ</mml:mi><mml:mi>δ</mml:mi><mml:msup><mml:mi>κ</mml:mi><mml:mi>T</mml:mi></mml:msup></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>noise</mml:mtext></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:msub><mml:mi>Σ</mml:mi><mml:mi>A</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>noise</mml:mtext></mml:mrow><mml:mn>4</mml:mn></mml:msubsup></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>‖</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac><mml:mfrac><mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>γ</mml:mi><mml:mo>+</mml:mo></mml:msub></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>γ</mml:mi><mml:mo>+</mml:mo></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:msub><mml:mtext>v</mml:mtext><mml:mo>+</mml:mo></mml:msub><mml:msubsup><mml:mtext>v</mml:mtext><mml:mo>+</mml:mo><mml:mi>T</mml:mi></mml:msubsup></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn109.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(109)</label>
</disp-formula>
</p>
<p>with normalized eigenvector
<disp-formula id="FD110">
<alternatives>
<mml:math id="M110" display="block"><mml:msub><mml:mtext>v</mml:mtext><mml:mo>+</mml:mo></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>‖</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn110.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(110)</label>
</disp-formula>
</p>
<p>For the loss, we only need to consider the variance along the output vector. Namely, we have the output fluctuations
<disp-formula id="FD111">
<alternatives>
<mml:math id="M111" display="block"><mml:mi>δ</mml:mi><mml:mi>z</mml:mi><mml:mo>=</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:msubsup><mml:mtext>v</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msubsup><mml:mi>δ</mml:mi><mml:mi>κ</mml:mi><mml:mo>,</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn111.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(111)</label>
</disp-formula>
</p>
<p>with projected output weights
<disp-formula id="FD112">
<alternatives>
<mml:math id="M112" display="block"><mml:msub><mml:mtext>v</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:mfrac><mml:msup><mml:mi>U</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mrow><mml:mrow><mml:msub><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>/</mml:mo><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msub><mml:mtext>w</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn112.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(112)</label>
</disp-formula>
</p>
<p>Thus,
<disp-formula id="FD113">
<alternatives>
<mml:math id="M113" display="block"><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mi>var</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>δ</mml:mi><mml:msup><mml:mi>z</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mi>N</mml:mi><mml:msubsup><mml:mtext>v</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msubsup><mml:mover accent="true"><mml:mrow><mml:mi>δ</mml:mi><mml:mi>κ</mml:mi><mml:mi>δ</mml:mi><mml:msup><mml:mi>κ</mml:mi><mml:mi>T</mml:mi></mml:msup></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:msub><mml:mtext>v</mml:mtext><mml:mrow><mml:mtext>out</mml:mtext></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:math>
<graphic xlink:href="2307.07654v3_eqn113.tif" mime-subtype="tif" mimetype="image"/></alternatives>
<label>(113)</label>
</disp-formula>
</p>
</sec>
<sec id="s8-5">
<title>A.5. Additional figures</title>
<fig id="fig16" position="float" fig-type="figure">
<label>Fig. 16:</label>
<caption><p>Summary of all measures for initially decaying or chaotic networks.</p></caption>
<graphic xlink:href="2307.07654v3_fig16.tif" mime-subtype="tif" mimetype="image"/>
</fig>
<fig id="fig17" position="float" fig-type="figure">
<label>Fig. 17:</label>
<caption><p>Projection of neural dynamics onto first 4 PCs for the cycling task, <xref ref-type="fig" rid="fig2">Fig. 2</xref>. The x-axis for all plots is PC 1 of the respective dynamics (left: aligned, right: oblique). The y-axes are PCs 2 to 4. Axis labels indicate the relative variance explained by each PC. Arrows indicate direction. Note that there is co-rotation for the aligned network for PCs 1 and 3, as well as the counter-rotation for the oblique network for PCs 1 and 4.</p></caption>
<graphic xlink:href="2307.07654v3_fig17.tif" mime-subtype="tif" mimetype="image"/>
</fig>
<fig id="fig18" position="float" fig-type="figure">
<label>Fig. 18:</label>
<caption><p>Power spectral densities for the six networks shown in <xref ref-type="fig" rid="fig4">Fig. 4</xref>. The dashed orange line indicates the output frequency. Note the high power for non-target frequencies in the first PCs in some of the large output solutions.</p></caption>
<graphic xlink:href="2307.07654v3_fig18.tif" mime-subtype="tif" mimetype="image"/>
</fig>
<fig id="fig19" position="float" fig-type="figure">
<label>Fig. 19:</label>
<caption><p>Example of task variability for the flipflop task. The titles in each row indicate the spectral radius <italic>g</italic> of the initial recurrent connectivity (<italic>g</italic> &gt; 1 for initially chaotic, else decaying, activity), and the norm of initial output weights.</p></caption>
<graphic xlink:href="2307.07654v3_fig19.tif" mime-subtype="tif" mimetype="image"/>
</fig>
<fig id="fig20" position="float" fig-type="figure">
<label>Fig. 20:</label>
<caption><p>Neural activity in response to the perturbations applied in <xref ref-type="fig" rid="fig5">Fig. 5</xref>. Activity is plotted in the space spanned by the leading two PCs and the output weights <italic>w</italic><sub>out,1</sub>. We first show the unperturbed trajectories in each network (left), then the perturbed ones for perturbations along the first output direction (center) and along the first PC (right). The unperturbed trajectories are also plotted for comparison. Yellow dots indicate the point where the perturbation is applied. All perturbations but the one along the output for aligned lead to trajectories on the same attractor, but potentially with a phase shift. Note that in general, perturbations can also lead to the activity converging on a different attractor. Here, we see a specific example of this happening for the cycling task in the aligned regime.</p></caption>
<graphic xlink:href="2307.07654v3_fig20.tif" mime-subtype="tif" mimetype="image"/>
</fig>
<fig id="fig21" position="float" fig-type="figure">
<label>Fig. 21:</label>
<caption><p>Noise compression over training time for the cycling task. Example networks trained on the cycling tasks with <italic>σ</italic><sub>noise</sub> = 0.2 and <italic>N</italic> = 256. The network at the end of training is analyzed in <xref ref-type="fig" rid="fig6">Fig. 6B</xref>. <bold>A</bold> Full loss (grey) and decomposition in bias (golden) and variance (purple) parts over learning time. The bias part decays rapidly (the y-axis is clipped, initial loss <italic>L</italic><sub>0</sub> = 1.4), whereas the variance part needs many more training steps to decrease. Dotted lines indicate the two examples in <bold>B-D</bold>. <bold>B</bold> Output fluctuations <inline-formula id="ID151">
<alternatives>
<mml:math display="inline" id="I151"><mml:mi>δ</mml:mi><mml:msub><mml:mi>z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq151.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> around the trial-conditioned average <inline-formula id="ID152">
<alternatives>
<mml:math display="inline" id="I152"><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq152.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. Mean is over 16 samples for each of the two trial conditions (clockwise and anticlockwise rotation). Because both output dimensions <italic>i</italic> ∈ {1, 2} are equivalent in scale, we collected both for the histogram. <bold>C-D</bold> Example output trajectories early (<bold>C</bold>) and late (<bold>D</bold>) in learning. Shown are the mean (dark) and 5 samples (light).</p></caption>
<graphic xlink:href="2307.07654v3_fig21.tif" mime-subtype="tif" mimetype="image"/>
</fig>
<fig id="fig22" position="float" fig-type="figure">
<label>Fig. 22:</label>
<caption><p>Fitting neural activity to different output modalities (hand position, velocity, acceleration, EMG). Output modality is indicated by the x-ticks, the corresponding datasets by the color and the labels below. A, B: Correlation and relative fitting dimension. Similar to <xref ref-type="fig" rid="fig7">Fig. 7B</xref>, where these are shown for velocity alone. C-E: Additional details. C: Coefficient of determination <italic>R</italic><sup>2</sup> of the linear regression. D: Number of PCs necessary to reach 90 % of the variance of the neural activity <italic>X</italic>. E: Number of PCs necessary to reach 90 % of the <italic>R</italic><sup>2</sup> value of the full neural activity. For each output modality, the delay between activity and output is optimized. Position decodes earlier (300–200ms) than velocity or acceleration (100–50ms); no delay for EMG. The data <italic>X</italic> is the same with each dataset apart from a potential shift by the respective delay, so that dimension <italic>D</italic><sub><italic>x</italic>,90</sub> in D is almost the same. Note that we also computed trial averages for the NLB maze task to test for the effect of trial averaging. These, however, have a small sample number (189 data points, but 162 neurons), which leads to considerable discrepancy between the dots (full data) and the subsamples with only 25% of the data points, for example in the correlation (A).</p></caption>
<graphic xlink:href="2307.07654v3_fig22.tif" mime-subtype="tif" mimetype="image"/>
</fig>
<fig id="fig23" position="float" fig-type="figure">
<label>Fig. 23:</label>
<caption><p>Learning curves and eigenvalue spectra for sine wave task. <bold>(a)</bold> Loss over training steps for four networks. The light red line is the bias term of the loss for the oblique network. <bold>(b)</bold> Norm of weight changes over learning time. <bold>(c)</bold> Eigenvalue spectra of connectivity matrix <italic>W<sub>f</sub></italic> after training. The dashed line indicates the stability line for the fixed point at the origin.</p></caption>
<graphic xlink:href="2307.07654v3_fig23.tif" mime-subtype="tif" mimetype="image"/>
</fig>
<fig id="fig24" position="float" fig-type="figure">
<label>Fig. 24:</label>
<caption><p>The aligned regime is robust to the choice of other hyperparameters.</p></caption>
<graphic xlink:href="2307.07654v3_fig24.tif" mime-subtype="tif" mimetype="image"/>
</fig>
<fig id="fig25" position="float" fig-type="figure">
<label>Fig. 25:</label>
<caption><p>The oblique regime is robust to the choice of other hyperparameters.</p></caption>
<graphic xlink:href="2307.07654v3_fig25.tif" mime-subtype="tif" mimetype="image"/>
</fig>
<fig id="fig26" position="float" fig-type="figure">
<label>Fig. 26:</label>
<caption><p>Training history leads to order-one fixed point norm. We trained RNNs on the example fixed point task. Similar to <xref ref-type="fig" rid="fig13">Fig. 13</xref>, but with smaller noise, <italic>a</italic> noise = 0.2, and with learning rate increased by 2 and number of epochs by 2.5. <bold>A-C</bold>: Learning dynamics with gradient descent for one network with <italic>N</italic> = 256 neurons. The first 400 epochs are dominated by <italic>L</italic><sub>bias</sub>, and <italic>M</italic><sub>11</sub> ≈ <italic>λ</italic><sub>−</sub> becomes <italic>positive</italic>. The negative feedback loop, <italic>λ</italic><sub>−</sub> &lt; 0 only forms later in learning. The matrix <italic>M</italic> does not become symmetric during learning. <bold>D-F</bold>: Fixed point norm and correlation for different <italic>N</italic> evaluated when <italic>λ</italic><sub>−</sub> = 0 (left) and at the end of learning (right). The time points are indicated by a square and triangle in <bold>C</bold>, respectively. At <italic>λ</italic><sub>−</sub> = 0, simulation and theory agree for the scaling: <inline-formula id="ID153">
<alternatives>
<mml:math display="inline" id="I153"><mml:mrow><mml:mo>‖</mml:mo><mml:mover accent="true"><mml:mi>κ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>‖</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq153.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula> and <inline-formula id="ID154">
<alternatives>
<mml:math display="inline" id="I154"><mml:mi>ρ</mml:mi><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math>
<inline-graphic xlink:href="2307.07654v3_ieq154.tif" mime-subtype="tif" mimetype="image"/></alternatives>
</inline-formula>. At the end of training, the theory predicts a decreasing fixed point norm, but the simulated networks inherit the order-one norm from the training history.</p></caption>
<graphic xlink:href="2307.07654v3_fig26.tif" mime-subtype="tif" mimetype="image"/>
</fig>
</sec>
</sec>
</back>
<sub-article id="sa0" article-type="editor-report">
<front-stub>
<article-id pub-id-type="doi">10.7554/eLife.93060.2.sa3</article-id>
<title-group>
<article-title>eLife Assessment</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<name>
<surname>Sharpee</surname>
<given-names>Tatyana O</given-names>
</name>
<role specific-use="editor">Reviewing Editor</role>
<aff>
<institution-wrap>
<institution>Salk Institute for Biological Studies</institution>
</institution-wrap>
<city>La Jolla</city>
<country>United States of America</country>
</aff>
</contrib>
</contrib-group>
<kwd-group kwd-group-type="evidence-strength">
<kwd>Convincing</kwd>
</kwd-group>
<kwd-group kwd-group-type="claim-importance">
<kwd>Important</kwd>
</kwd-group>
</front-stub>
<body>
<p>This work provides an <bold>important</bold> and novel framework for interpreting the interactions between recurrent dynamics across stages of neural processing. The authors report that two different kinds of dynamics exist in recurrent networks differing in the extent to which they align with the output weights. The authors also present <bold>convincing</bold> evidence that both types of dynamics exist in the brain.</p>
</body>
</sub-article>
<sub-article id="sa1" article-type="referee-report">
<front-stub>
<article-id pub-id-type="doi">10.7554/eLife.93060.2.sa2</article-id>
<title-group>
<article-title>Reviewer #1 (Public review):</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<anonymous/>
<role specific-use="referee">Reviewer</role>
</contrib>
</contrib-group>
</front-stub>
<body>
<p>Summary:</p>
<p>In this work, authors utilize recurrent neural networks (RNNs) to explore the question of when and how neural dynamics and the network's output are related from a geometrical point of view. The authors found that RNNs operate between two extremes: an 'aligned' regime in which the weights and the largest PCs are strongly correlated and an 'oblique' regime where the output weights and the largest PCs are poorly correlated. Large output weights led to oblique dynamics, and small output weights to aligned dynamics. This feature impacts whether networks are robust to perturbation along output directions. Results were linked to experimental data by showing that these different regimes can be identified in neural recordings from several experiments.</p>
<p>Strengths:</p>
<p>Diverse set of relevant tasks</p>
<p>
Similarity measure well chosen</p>
<p>
Explored various hyperparameter settings</p>
<p>Weaknesses:</p>
<p>One of the major connections to found BCI data with neural variance aligned to the outputs. Maybe I was confused about something, but doesn't this have to be the case based on the design of the experiment? The outputs of the BCI are chosen to align with the largest principal components of the data.</p>
<p>Proposed experiments maybe have already been done (New neural activity patterns emerge with long-term learning, Oby et al. 2019). My understanding of these results is that activity moved to be aligned as the manifold changed, but more analyses could be done to more fully understand the relationship between those experiments and this work.</p>
<p>Analysis of networks was thorough, but connections to neural data were weak. I am thoroughly convinced of the reported effect of large or small output weights in networks. I also think this framing could aid in future studies of interactions between brain regions.</p>
<p>This is an interesting framing to consider the relationship between upstream activity and downstream outputs. As more labs record from several brain regions simultaneously, this work will provide an important theoretical framework for thinking about the relative geometries of neural representations between brain regions.</p>
<p>It will be interesting to compare the relationship between geometries of representations and neural dynamics across connected different brain areas that are closer to the periphery vs. more central.</p>
<p>Exciting to think about the versatility of the oblique regime for shared representations and network dynamics across different computations.</p>
<p>Versatility of oblique regime could lead to differences between subjects in neural data.</p>
</body>
</sub-article>
<sub-article id="sa2" article-type="referee-report">
<front-stub>
<article-id pub-id-type="doi">10.7554/eLife.93060.2.sa1</article-id>
<title-group>
<article-title>Reviewer #2 (Public review):</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<anonymous/>
<role specific-use="referee">Reviewer</role>
</contrib>
</contrib-group>
</front-stub>
<body>
<p>Summary:</p>
<p>This paper tackles the problem of understanding when the dynamics of neural population activity do and do not align with some target output, such as an arm movement. The authors develop a theoretical framework based on RNNs showing that an alignment of neural dynamics to an output can be simply controlled by the magnitude of the read-out weight vector while the RNN is being trained: small magnitude vectors result in aligned dynamics, where low-dimensional neural activity recapitulates the target; large magnitude vectors result in &quot;oblique&quot; dynamics, where encoding is spread across many dimensions. The paper further explores how the aligned and oblique regimes differ, in particular that the oblique regime allows degenerate solutions for the same target output.</p>
<p>Strengths:</p>
<p>- A really interesting new idea that different dynamics of neural circuits can arise simply from the initial magnitude of the output weight vector: once written out (Eq 3) it becomes obvious, which I take as the mark of a genuinely insightful idea</p>
<p>- The offered framework potentially unifies a collection of separate experimental results and ideas, largely from studies of motor cortex in primate: the idea that much of the ongoing dynamics do not encode movement parameters; the existence of the &quot;null space&quot; of preparatory activity; and that ongoing dynamics of motor cortex can rotate in the same direction even when the arm movement is rotating in opposite directions.</p>
<p>- The main text is well written, with a wide-ranging set of key results synthesised and illustrated well and concisely</p>
<p>- Shows the occurrence of the aligned and oblique regimes generalises across a range of simulated behavioural tasks</p>
<p>- A deep analytical investigation of when the regimes occur and how they evolve over training</p>
<p>- Shows where the oblique regime may be advantageous: allows multiple solutions to the same problem; and differs in sensitivity to perturbation and noise</p>
<p>- An insightful corollary result that noise in training is needed to obtain the oblique regime</p>
<p>- Tests whether the aligned and oblique regimes can be seen in neural recordings from primate cortex in a range of motor control tasks</p>
<p>- The revised text offers greater clarity and precision about when the aligned and oblique regimes occur and in the interpretation of the analyses of neural data</p>
<p>Weaknesses:</p>
<p>- The depth of analytical treatment in the Methods is impressive; however, the paper and the Methods analyses are largely independent, with the numerous results in the latter not being mentioned in the Results or Discussion. It in effect operates as two papers.</p>
</body>
</sub-article>
<sub-article id="sa3" article-type="author-comment">
<front-stub>
<article-id pub-id-type="doi">10.7554/eLife.93060.2.sa0</article-id>
<title-group>
<article-title>Author response:</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<name>
<surname>Schuessler</surname>
<given-names>Friedrich</given-names>
</name>
<role specific-use="author">Author</role>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Mastrogiuseppe</surname>
<given-names>Francesca</given-names>
</name>
<role specific-use="author">Author</role>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Ostojic</surname>
<given-names>Srdjan</given-names>
</name>
<role specific-use="author">Author</role>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Barak</surname>
<given-names>Omri</given-names>
</name>
<role specific-use="author">Author</role>
</contrib>
</contrib-group>
</front-stub>
<body>
<p>The following is the authors’ response to the original reviews.</p>
<disp-quote content-type="editor-comment">
<p><bold>Public Reviews:</bold></p>
<p><bold>Reviewer #1 (Public Review):</bold></p>
<p>Summary:</p>
<p>In this work, the authors utilize recurrent neural networks (RNNs) to explore the question of when and how neural dynamics and the network's output are related from a geometrical point of view. The authors found that RNNs operate between two extremes: an 'aligned' regime in which the weights and the largest PCs are strongly correlated and an 'oblique' regime where the output weights and the largest PCs are poorly correlated. Large output weights led to oblique dynamics, and small output weights to aligned dynamics. This feature impacts whether networks are robust to perturbation along output directions. Results were linked to experimental data by showing that these different regimes can be identified in neural recordings from several experiments.</p>
<p>Strengths:</p>
<p>A diverse set of relevant tasks.</p>
<p>A well-chosen similarity measure.</p>
<p>Exploration of various hyperparameter settings.</p>
<p>Weaknesses:</p>
<p>One of the major connections found BCI data with neural variance aligned to the outputs.</p>
<p>Maybe I was confused about something, but doesn't this have to be the case based on the design of the experiment? The outputs of the BCI are chosen to align with the largest principal components of the data.</p>
</disp-quote>
<p>The reviewer is correct. We indeed expected the BCI experiments to yield aligned dynamics. Our goal was to use this as a comparison for other, non-BCI recordings in which the correlation is smaller, i.e. dynamics closer to the oblique regime. We adjusted our wording accordingly and added a small discussion at the end of the experimental results, Section 2.6.</p>
<disp-quote content-type="editor-comment">
<p>Proposed experiments may have already been done (new neural activity patterns emerge with long-term learning, Oby et al. 2019). My understanding of these results is that activity moved to be aligned as the manifold changed, but more analyses could be done to more fully understand the relationship between those experiments and this work.</p>
</disp-quote>
<p>The on- vs. off-manifold experiments are indeed very close to our work. On-manifold initializations, as stated above, are expected to yield aligned solutions. Off-manifold initializations allow, in principle, for both aligned and oblique solutions and are thus closer to our RNN simulations. If, during learning, the top PCs (dominant activity) rotate such that they align with the pre-defined output weights, then the system has reached an aligned solution. If the top PCs hardly change, and yet the behavior is still good, this is an oblique solution. There is some indication of an intermediate result (Figure 4C in Oby et al.), but the existing analysis there did not fully characterize these properties. Furthermore, our work suggests that systematically manipulating the norm of readout weights in off-manifold experiments can yield new insights. We thus view these as relevant results but suggest both further analysis and experiments. We rewrote the corresponding section in the discussion to include these points.</p>
<disp-quote content-type="editor-comment">
<p>Analysis of networks was thorough, but connections to neural data were weak. I am thoroughly convinced of the reported effect of large or small output weights in networks. I also think this framing could aid in future studies of interactions between brain regions.</p>
<p>This is an interesting framing to consider the relationship between upstream activity and downstream outputs. As more labs record from several brain regions simultaneously, this work will provide an important theoretical framework for thinking about the relative geometries of neural representations between brain regions.</p>
<p>It will be interesting to compare the relationship between geometries of representations and neural dynamics across connected different brain areas that are closer to the periphery vs. more central.</p>
<p>It is exciting to think about the versatility of the oblique regime for shared representations and network dynamics across different computations.</p>
<p>The versatility of the oblique regime could lead to differences between subjects in neural data.</p>
</disp-quote>
<p>Thank you for the suggestions. Indeed, this is precisely why relative measures of the regime are valuable, even in the absence of absolute thresholds for regimes. We included your suggestions in the discussion.</p>
<disp-quote content-type="editor-comment">
<p><bold>Reviewer #2 (Public Review):</bold></p>
<p>Summary:</p>
<p>This paper tackles the problem of understanding when the dynamics of neural population activity do and do not align with some target output, such as an arm movement. The authors develop a theoretical framework based on RNNs showing that an alignment of neural dynamics to output can be simply controlled by the magnitude of the read-out weight vector while the RNN is being trained. Small magnitude vectors result in aligned dynamics, where low-dimensional neural activity recapitulates the target; large magnitude vectors result in &quot;oblique&quot; dynamics, where encoding is spread across many dimensions. The paper further explores how the aligned and oblique regimes differ, in particular, that the oblique regime allows degenerate solutions for the same target output.</p>
<p>Strengths:</p>
<p>- A really interesting new idea that different dynamics of neural circuits can arise simply from the initial magnitude of the output weight vector: once written out (Eq 3) it becomes obvious, which I take as the mark of a genuinely insightful idea.</p>
<p>- The offered framework potentially unifies a collection of separate experimental results and ideas, largely from studies of the motor cortex in primates: the idea that much of the ongoing dynamics do not encode movement parameters; the existence of the &quot;null space&quot; of preparatory activity; and that ongoing dynamics of the motor cortex can rotate in the same direction even when the arm movement is rotating in opposite directions.</p>
<p>- The main text is well written, with a wide-ranging set of key results synthesised and illustrated well and concisely.</p>
<p>- The study shows that the occurrence of the aligned and oblique regimes generalises across a range of simulated behavioural tasks.</p>
<p>- A deep analytical investigation of when the regimes occur and how they evolve over training.</p>
<p>- The study shows where the oblique regime may be advantageous: allows multiple solutions to the same problem; and differs in sensitivity to perturbation and noise.</p>
<p>- An insightful corollary result that noise in training is needed to obtain the oblique regime.</p>
<p>- Tests whether the aligned and oblique regimes can be seen in neural recordings from primate cortex in a range of motor control tasks.</p>
<p>Weaknesses:</p>
<p>- The magnitude of the output weights is initially discussed as being fixed, and as far as I can tell all analytical results (sections 4.6-4.9) also assume this. But in all trained models that make up the bulk of the results (Figures 3-6) all three weight vectors/matrices (input, recurrent, and output) are trained by gradient descent. It would be good to see an explanation or results offered in the main text as to why the training always ends up in the same mapping (small-&gt;aligned; large-&gt;oblique) when it could, for example, optimise the output weights instead, which is the usual target (e.g. Sussillo &amp; Abbott 2009 Neuron).</p>
</disp-quote>
<p>We understand the reviewer’s surprise. We chose a typical setting (training all weights of an RNN with Adam) to show that we don’t have to fine-tune the setting (e.g. by fixing the output weights) to see the two regimes. However, other scenarios in which the output weights do change are possible, depending on the algorithm and details in the way the network is parameterized. Understanding why some settings lead to our scenario (no change in scale) and others don’t is not a simple question. A short explanation here, nonetheless:</p>
<p>- Small changes to the internal weights are sufficient to solve the tasks.</p>
<p>- Different versions of gradient descent and different ways of parametrizing the network lead to different results in which parts of the weights get trained. This goes in particular for how weight scales are introduced, e.g. [Jacot et al. 2018 Neurips], [Geiger et al. 2020 Journal of Statistical Mechanics], or [Yang, Hu 2020, arXiv, Feature learning in infinite-width networks]. One insight from these works is that plain gradient descent (GD) with small output weights leads to learning only at the output (and often divergence or unsuccessful learning). For this reason, plain GD (or stochastic GD) is not suitable for small output weights (the aligned regime). Other variants of GD, such as Adam or RMSprop, don’t have this problem because they shift the emphasis of learning to the hidden layers (here the recurrent weights). This is due to the normalization of the gradients.</p>
<p>- FORCE learning [Sussillo &amp; Abbott 2009] is somewhat special in that the output weights are simultaneously also used as feedback weights. That is, not only the output weights but also an additional low-rank feedback loop through these output weights is trained. As a side note: By construction, such a learning algorithm thus links the output directly to the internal dynamics, so that one would only expect aligned solutions – and the output weights remain correspondingly small in these algorithms [Mastrogiuseppe, Ostojic, 2019, Neural Comp].</p>
<p>- In our setting, the output is not fed back to the network, so training the output alone would usually not suffice. Indeed, optimizing just the output weights is similar to what happens in the lazy training regime. These solutions, however, are not robust to noise, and we show that adding noise during the training does away with these solutions.</p>
<p>To address this issue in the manuscript, we added the following sentence to section 2.2: “While explaining this observation is beyond the scope of this work, we note that (1) changing the internal weights suffices to solve the task, and that (2) the extent to which the output weights change during learning depends on the algorithm and specific parametrization [21, 27, 85].”</p>
<disp-quote content-type="editor-comment">
<p>- It is unclear what it means for neural activity to be &quot;aligned&quot; for target outputs that are not continuous time-series, such as the 1D or 2D oscillations used to illustrate most points here.</p>
<p>Two of the modeled tasks have binary outputs; one has a 3-element binary vector.</p>
</disp-quote>
<p>For any dynamics and output, we compare the alignment between the vector of output weights and the main PCs (the leading component of the dynamics). In the extreme of binary internal dynamics, i.e., two points {x_1, x_2}, there would only be one leading PC (the line connecting the two points, i.e. the choice decoder).</p>
<disp-quote content-type="editor-comment">
<p>- It is unclear what criteria are used to assign the analysed neural data to the oblique or aligned regimes of dynamics.</p>
</disp-quote>
<p>Such an assignment is indeed difficult to achieve. The RNN models we showed were at the extremes of the two regimes, and these regimes are well characterized in the case of large networks (as described in the methods section). For the neural data, we find different levels of alignment for different experiments. These differences may not be strong enough to assign different regimes. Instead, our measures (correlation and relative fitting dimension) allow us to order the datasets. Here, the BCI data is more aligned than non-BCI data – perhaps unsurprisingly, given the experimental design of the prior and the previous findings for the rotation task [Russo et al, 2018]. We changed the manuscript accordingly, now focusing on the relative measure of alignment, even in the absence of absolute thresholds. We are curious whether future studies with more data, different tasks, or other brain regions might reveal stronger differentiation towards either extreme.</p>
<disp-quote content-type="editor-comment">
<p><bold>Recommendations for the authors:</bold></p>
<p><bold>Reviewer #1 (Recommendations For The Authors):</bold></p>
<p>There's so much interesting content in the supplement - it seemed like a whole other paper! It is interesting to read about the dynamics over the course of learning. Maybe you want to put this somewhere else so that more people read it?</p>
</disp-quote>
<p>We are glad the reviewer appreciated this content. We think developing these analysis methods is essential for a more complete understanding of the oblique regime and how it arises, and that it should therefore be part of the current paper.</p>
<disp-quote content-type="editor-comment">
<p>Nice schematic in Figure 1.</p>
<p>There were some statements in the text highlighting co-rotation in the top 2 PCs for oblique networks. Figure 4a looks like aligned networks might also co-rotate in a particular subspace that is not highlighted. I could be wrong, but the authors should look into this and correct it if so. If both aligned and oblique networks have co-rotation within the top 5 or so PCs, some text should be updated to reflect this.</p>
</disp-quote>
<p>This is indeed the case, thanks for pointing this out! For one example, there is co-rotation for the aligned network already in the subspace spanned by PCs 1 and 3, see the figure below. We added a sentence indicating that co-rotation can take place at low-variance PCs for the aligned regime and pointed to this figure, which we added to the appendix (Fig. 17).</p>
<p>While these observations are an important addition, we don’t think they qualitatively alter our results, particularly the stronger dissociation between output and internal dynamics for oblique than aligned dynamics.</p>
<disp-quote content-type="editor-comment">
<p>Figure 4 color labels were 'dark' and 'light'. I wasn't sure if this was a typo or if it was designed for colorblind readers? Either way, it wasn't too confusing, but adding more description might be useful.</p>
</disp-quote>
<p>Fixed to red and yellow.</p>
<disp-quote content-type="editor-comment">
<p>Typo &quot;Aligned networks have a ratio much large than one&quot;</p>
<p>Typo &quot;just started to be explored&quot; Typo &quot;hence allowing to test&quot;</p>
</disp-quote>
<p>Fixed all typos.</p>
<disp-quote content-type="editor-comment">
<p><bold>Reviewer #2 (Recommendations For The Authors):</bold></p>
<p>- Explain/discuss in the main text why the initial output weights reliably result in the required internal RNN dynamics (small-&gt;aligned; large-&gt;oblique) after training. The magnitude of the output weights is initially discussed as being fixed, and as far as I can tell all analytical results (sections 4.6-4.9) also assume this. But in all trained models that make up the bulk of the results (Figures 3-6) all three weight vectors/matrices (input, recurrent, and output) are trained by gradient descent. It would be good to see an explanation or results offered in the main text as to why the training always ends up in the same mapping (small-&gt;aligned; large-&gt;oblique) when it could, for example, just optimise the output weights instead.</p>
</disp-quote>
<p>See the answer to a similar comment by Reviewer #1 above.</p>
<disp-quote content-type="editor-comment">
<p>- Page 6: explain the 5 tasks.</p>
</disp-quote>
<p>We added a link to methods where the tasks are described.</p>
<disp-quote content-type="editor-comment">
<p>- Page 6/Fig 3 &amp; Methods: explain assumptions used to compute a reconstruction R^2 between RNN PCs and a binary or vector target output.</p>
</disp-quote>
<p>We added a new methods section, 4.4, where we explain the fitting process in Fig. 3. For all tasks, the target output was a time series with P specified target values in N_out dimensions. We thus always applied regression and did not differentiate between binary and non-binary tasks.</p>
<disp-quote content-type="editor-comment">
<p>- Page 8: methods and predictions are muddled up: paragraph ending &quot;along different directions&quot; should be followed by paragraph starting &quot;Our intuition...&quot;. The intervening paragraph (&quot;We apply perturbations...&quot;) should start after the first sentence of the paragraph &quot;To test this,...&quot;.</p>
</disp-quote>
<p>Right, these sentences were muddled up indeed. We put them in the correct order.</p>
<disp-quote content-type="editor-comment">
<p>- Page 10: what are the implications of the differences in noise alignment between the aligned and oblique regimes?</p>
</disp-quote>
<p>The noise suppression in the oblique regime is a slow learning process that gradually renders the solution more stable. With a large readout, learning separates into two phases. An early phase, in which a “lazy” solution is learned quickly. This solution is not robust to noise. In a second, slower phase, learning gradually leads to a more robust solution: the oblique solution. The main text emphasizes the result of this process (noise suppression). In the methods, we closely follow this process. This process is possibly related to other slow learning process fine-tuning solutions, e.g., [Blanc et al. 2020, Li et al. 2021, Yang et al. 2023]. Furthermore, it would be interesting to see whether such fine-tuning happens in animals [Ratzon et al. 2024]. We added corresponding sentences to the discussion.</p>
<disp-quote content-type="editor-comment">
<p>- Neural data analysis:</p>
<p>(i) Page 11 &amp; Fig 7: the assignment of &quot;aligned&quot; or &quot;oblique&quot; to each neural dataset is based on the ratio of D_fit/D_x. But in all cases this ratio is less than 1, indicating fewer dimensions are needed for reconstruction than for explaining variance. Given the example in Figure 2 suggests this is an aligned regime, why assign any of them as &quot;oblique&quot;?</p>
</disp-quote>
<p>We weakened the wording in the corresponding section, and now only state that BCI data leans more towards aligned, non-BCI data more towards oblique. This is consistent with the intuition that BCI is by construction aligned (decoder along largest PCs) and non-BCI data already showed signs of oblique dynamics (co-rotating leading PCs in the cycling task, Russo et al. 2018).</p>
<p>We agree that Fig 2 (and Fig 3) could suggest distinguishing the regimes at a threshold D_fit/D_x = 1, although we hadn’t considered such a formal criterion.</p>
<disp-quote content-type="editor-comment">
<p>(ii) Figure 23 and main text page 11: discuss which outputs for NLB and BCI datasets were used in Figure 7 &amp; and main text; the NLB results vary widely by output type - discuss in the main text; D_fit for NLB-maze-accuracy is missing from panel D; as the criterion is D_fit/D_x, plot this too.</p>
</disp-quote>
<p>We now discuss which outputs were used in Fig. 7 in its caption: the velocity of the task-relevant entity (hand/finger/cursor). This was done to have one quantity across studies. We added a sentence to the main text, p. 11, which points to Fig 22 (which used to be Fig 23) and states that results are qualitatively similar for other decoded outputs, despite some fluctuations in numerical values and decodability.</p>
<p>Regarding Fig 22: D_fit for NLB-maze-accuracy was beyond the manually set y-limit (for visibility of the other data points). We also extended the figure to include D_fit/D_x. We also discovered a small bug in the analysis code which required us to rerun the analysis and reproduce the plots. This also changed some of the numbers in the main text.</p>
<disp-quote content-type="editor-comment">
<p>- Discussion:</p>
<p>&quot;They do not explain why it [the &quot;irrelevant activity&quot;] is necessary&quot;, implies that the following sentence(s) will explain this, but do not. Instead, they go on to say:</p>
<p>&quot;Here, we showed that merely ensuring stability of neural dynamics can lead to the oblique regime&quot;: this does not explain why it is necessary, merely that it exists; and it is unclear what results &quot;stability of neural dynamics&quot; is referring to.</p>
</disp-quote>
<p>We agree this was not a very clear formulation. We replaced these last three sentences with the following:</p>
<p>“Our study systematically explains this phenomenon: generating task-related output in the presence of large, task-unrelated dynamics requires large readout weights. Conversely, in the presence of large output weights, resistance to noise or perturbations requires large, potentially task-unrelated neural dynamics (the oblique regime).”</p>
<disp-quote content-type="editor-comment">
<p>- The need for all 27 figures was unclear, especially as some seemed not to be referenced or were referenced out of order. Please check and clarify.</p>
</disp-quote>
<p>Fig 16 (Details for network dynamics in cycling tasks) and Fig 21 (loss over learning time for the different tasks) were not referenced, and are now removed.</p>
<p>We also reordered the figures in the appendix so that they would appear in the order they are referenced. Note that we added another figure (now Fig. 17) following a question from Reviewer #1.</p>
</body>
</sub-article>
</article>