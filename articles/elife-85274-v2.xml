<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD with MathML3 v1.3 20210610//EN"  "JATS-archivearticle1-3-mathml3.dtd"><article xmlns:ali="http://www.niso.org/schemas/ali/1.0/" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article" dtd-version="1.3"><front><journal-meta><journal-id journal-id-type="nlm-ta">elife</journal-id><journal-id journal-id-type="publisher-id">eLife</journal-id><journal-title-group><journal-title>eLife</journal-title></journal-title-group><issn publication-format="electronic" pub-type="epub">2050-084X</issn><publisher><publisher-name>eLife Sciences Publications, Ltd</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="publisher-id">85274</article-id><article-id pub-id-type="doi">10.7554/eLife.85274</article-id><article-categories><subj-group subj-group-type="display-channel"><subject>Tools and Resources</subject></subj-group><subj-group subj-group-type="heading"><subject>Neuroscience</subject></subj-group></article-categories><title-group><article-title>RatInABox, a toolkit for modelling locomotion and neuronal activity in continuous environments</article-title></title-group><contrib-group><contrib contrib-type="author" corresp="yes" id="author-299965"><name><surname>George</surname><given-names>Tom M</given-names></name><contrib-id authenticated="true" contrib-id-type="orcid">https://orcid.org/0000-0002-4527-8810</contrib-id><email>tom.george.20@ucl.ac.uk</email><xref ref-type="aff" rid="aff1">1</xref><xref ref-type="fn" rid="con1"/><xref ref-type="fn" rid="conf1"/></contrib><contrib contrib-type="author" id="author-348842"><name><surname>Rastogi</surname><given-names>Mehul</given-names></name><xref ref-type="aff" rid="aff1">1</xref><xref ref-type="fn" rid="con2"/><xref ref-type="fn" rid="conf1"/></contrib><contrib contrib-type="author" id="author-92353"><name><surname>de Cothi</surname><given-names>William</given-names></name><xref ref-type="aff" rid="aff2">2</xref><xref ref-type="fn" rid="fn1">†</xref><xref ref-type="other" rid="fund1"/><xref ref-type="fn" rid="con3"/><xref ref-type="fn" rid="conf1"/></contrib><contrib contrib-type="author" id="author-17772"><name><surname>Clopath</surname><given-names>Claudia</given-names></name><contrib-id authenticated="true" contrib-id-type="orcid">https://orcid.org/0000-0003-4507-8648</contrib-id><xref ref-type="aff" rid="aff1">1</xref><xref ref-type="aff" rid="aff3">3</xref><xref ref-type="fn" rid="fn1">†</xref><xref ref-type="fn" rid="con4"/><xref ref-type="fn" rid="conf1"/></contrib><contrib contrib-type="author" id="author-301108"><name><surname>Stachenfeld</surname><given-names>Kimberly</given-names></name><xref ref-type="aff" rid="aff4">4</xref><xref ref-type="aff" rid="aff5">5</xref><xref ref-type="fn" rid="fn1">†</xref><xref ref-type="fn" rid="con5"/><xref ref-type="fn" rid="conf1"/></contrib><contrib contrib-type="author" id="author-75558"><name><surname>Barry</surname><given-names>Caswell</given-names></name><xref ref-type="aff" rid="aff2">2</xref><xref ref-type="fn" rid="fn1">†</xref><xref ref-type="fn" rid="con6"/><xref ref-type="fn" rid="conf1"/></contrib><aff id="aff1"><label>1</label><institution-wrap><institution-id institution-id-type="ror">https://ror.org/02jx3x895</institution-id><institution>Sainsbury Wellcome Centre, University College London</institution></institution-wrap><addr-line><named-content content-type="city">London</named-content></addr-line><country>United Kingdom</country></aff><aff id="aff2"><label>2</label><institution-wrap><institution-id institution-id-type="ror">https://ror.org/02jx3x895</institution-id><institution>Department of Cell and Developmental Biology, University College London</institution></institution-wrap><addr-line><named-content content-type="city">London</named-content></addr-line><country>United Kingdom</country></aff><aff id="aff3"><label>3</label><institution-wrap><institution-id institution-id-type="ror">https://ror.org/041kmwe10</institution-id><institution>Department of Bioengineering, Imperial College London</institution></institution-wrap><addr-line><named-content content-type="city">London</named-content></addr-line><country>United Kingdom</country></aff><aff id="aff4"><label>4</label><institution>Google DeepMind</institution><addr-line><named-content content-type="city">London</named-content></addr-line><country>United Kingdom</country></aff><aff id="aff5"><label>5</label><institution-wrap><institution-id institution-id-type="ror">https://ror.org/00hj8s172</institution-id><institution>Columbia University</institution></institution-wrap><addr-line><named-content content-type="city">New York</named-content></addr-line><country>United States</country></aff></contrib-group><contrib-group content-type="section"><contrib contrib-type="editor"><name><surname>Mathis</surname><given-names>Mackenzie W</given-names></name><role>Reviewing Editor</role><aff><institution-wrap><institution-id institution-id-type="ror">https://ror.org/02s376052</institution-id><institution>École Polytechnique Fédérale de Lausanne</institution></institution-wrap><country>Switzerland</country></aff></contrib><contrib contrib-type="senior_editor"><name><surname>Frank</surname><given-names>Michael J</given-names></name><role>Senior Editor</role><aff><institution-wrap><institution-id institution-id-type="ror">https://ror.org/05gq02987</institution-id><institution>Brown University</institution></institution-wrap><country>United States</country></aff></contrib></contrib-group><author-notes><fn fn-type="other" id="fn1"><label>†</label><p>Joint lead authors</p></fn></author-notes><pub-date publication-format="electronic" date-type="publication"><day>09</day><month>02</month><year>2024</year></pub-date><pub-date pub-type="collection"><year>2024</year></pub-date><volume>13</volume><elocation-id>e85274</elocation-id><history><date date-type="received" iso-8601-date="2022-11-30"><day>30</day><month>11</month><year>2022</year></date><date date-type="accepted" iso-8601-date="2024-01-03"><day>03</day><month>01</month><year>2024</year></date></history><pub-history><event><event-desc>This manuscript was published as a preprint at bioRxiv.</event-desc><date date-type="preprint" iso-8601-date="2022-08-13"><day>13</day><month>08</month><year>2022</year></date><self-uri content-type="preprint" xlink:href="https://doi.org/10.1101/2022.08.10.503541"/></event></pub-history><permissions><copyright-statement>© 2024, George et al</copyright-statement><copyright-year>2024</copyright-year><copyright-holder>George et al</copyright-holder><ali:free_to_read/><license xlink:href="http://creativecommons.org/licenses/by/4.0/"><ali:license_ref>http://creativecommons.org/licenses/by/4.0/</ali:license_ref><license-p>This article is distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution License</ext-link>, which permits unrestricted use and redistribution provided that the original author and source are credited.</license-p></license></permissions><self-uri content-type="pdf" xlink:href="elife-85274-v2.pdf"/><abstract><p>Generating synthetic locomotory and neural data is a useful yet cumbersome step commonly required to study theoretical models of the brain’s role in spatial navigation. This process can be time consuming and, without a common framework, makes it difficult to reproduce or compare studies which each generate test data in different ways. In response, we present RatInABox, an open-source Python toolkit designed to model realistic rodent locomotion and generate synthetic neural data from spatially modulated cell types. This software provides users with (i) the ability to construct one- or two-dimensional environments with configurable barriers and visual cues, (ii) a physically realistic random motion model fitted to experimental data, (iii) rapid online calculation of neural data for many of the known self-location or velocity selective cell types in the hippocampal formation (including place cells, grid cells, boundary vector cells, head direction cells) and (iv) a framework for constructing custom cell types, multi-layer network models and data- or policy-controlled motion trajectories. The motion and neural models are spatially and temporally continuous as well as topographically sensitive to boundary conditions and walls. We demonstrate that out-of-the-box parameter settings replicate many aspects of rodent foraging behaviour such as velocity statistics and the tendency of rodents to over-explore walls. Numerous tutorial scripts are provided, including examples where RatInABox is used for decoding position from neural data or to solve a navigational reinforcement learning task. We hope this tool will significantly streamline computational research into the brain’s role in navigation.</p></abstract><abstract abstract-type="plain-language-summary"><title>eLife digest</title><p>The brain is a complex system made up of over 100 billion neurons that interact to give rise to all sorts of behaviours. To understand how neural interactions enable distinct behaviours, neuroscientists often build computational models that can reproduce some of the interactions and behaviours observed in the brain.</p><p>Unfortunately, good computational models can be hard to build, and it can be wasteful for different groups of scientists to each write their own software to model a similar system. Instead, it is more effective for  scientists to share their code so that different models can be quickly built from an identical set of core elements. These toolkits should be well made, free and easy to use.</p><p>One of the largest fields within neuroscience and machine learning concerns navigation: how does an organism – or an artificial agent – know where they are and how to get where they are going next? Scientists have identified many different types of neurons in the brain that are important for navigation. For example, ‘place cells’ fire whenever the animal is at a specific location, and ‘head direction cells’ fire when the animal's head is pointed in a particular direction. These and other neurons interact to support navigational behaviours.</p><p>Despite the importance of navigation, no single computational toolkit existed to model these behaviours and neural circuits. To fill this gap, George et al. developed RatInABox, a toolkit that contains the building blocks needed to study the brain’s role in navigation. One module, called the ‘Environment’, contains code for making arenas of arbitrary shapes. A second module contains code describing how organisms or ‘Agents’ move around the arena and interact with walls, objects, and other agents. A final module, called ‘Neurons’, contains code that reproduces the reponse patterns  of well-known cell types involved in navigation. This module also has code for more generic, trainable neurons that can be used to model how machines and organisms learn.</p><p>Environments, Agents and Neurons can be combined and modified in many ways, allowing users to rapidly construct complex models and generate artificial datasets. A diversity of tutorials, including how the package can be used for reinforcement learning (the study of how agents learn optimal motions) are provided.</p><p>RatInABox will benefit many researchers interested in neuroscience and machine learning. It is particularly well positioned to bridge the gap between these two fields and drive a more brain-inspired approach to machine learning. RatInABox’s userbase is fast growing, and it is quickly becoming one of the core computational tools used by scientists to understand the brain and navigation. Additionally, its ease of use and visual clarity means that it can be used as an accessible teaching tool for learning about spatial representations and navigation.</p></abstract><kwd-group kwd-group-type="author-keywords"><kwd>hippocampus</kwd><kwd>locomotion</kwd><kwd>neural data</kwd><kwd>trajectory</kwd><kwd>software</kwd><kwd>open source</kwd></kwd-group><kwd-group kwd-group-type="research-organism"><title>Research organism</title><kwd>None</kwd></kwd-group><funding-group><award-group id="fund1"><funding-source><institution-wrap><institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/100010269</institution-id><institution>Wellcome</institution></institution-wrap></funding-source><award-id>SRF 212281_Z_18_Z</award-id><principal-award-recipient><name><surname>de Cothi</surname><given-names>William</given-names></name></principal-award-recipient></award-group><funding-statement>The funders had no role in study design, data collection and interpretation, or the decision to submit the work for publication. For the purpose of Open Access, the authors have applied a CC BY public copyright license to any Author Accepted Manuscript version arising from this submission.</funding-statement></funding-group><custom-meta-group><custom-meta specific-use="meta-only"><meta-name>Author impact statement</meta-name><meta-value>A new python package standardises and simplifies how spatial behaviour and neural representations are modelled in continuous environments.</meta-value></custom-meta></custom-meta-group></article-meta></front><body><sec id="s1" sec-type="intro"><title>Introduction</title><p>Computational modelling provides a means to understand how neural circuits represent the world and influence behaviour, interfacing between experiment and theory to express and test how information is processed in the brain. Such models have been central to understanding a range of neural mechanisms, from action potentials (<xref ref-type="bibr" rid="bib23">Hodgkin and Huxley, 1952</xref>) and synaptic transmission between neurons (<xref ref-type="bibr" rid="bib12">del Castillo and Katz, 1954</xref>), to how neurons represent space and guide complex behaviour (<xref ref-type="bibr" rid="bib19">Hartley et al., 2000</xref>; <xref ref-type="bibr" rid="bib20">Hartley et al., 2004</xref>; <xref ref-type="bibr" rid="bib9">Byrne et al., 2007</xref>; <xref ref-type="bibr" rid="bib1">Banino et al., 2018</xref>; <xref ref-type="bibr" rid="bib11">de Cothi et al., 2022</xref>). Relative to empirical approaches, models can offer considerable advantages, providing a means to generate large amounts of data quickly with limited physical resources, and are a precise means to test and communicate complex hypotheses. To fully realise these benefits, computational modelling must be accessible and standardised, something which has not always been the case.</p><p>Spurred on by the proposition of a ‘cognitive map’ (<xref ref-type="bibr" rid="bib46">Tolman and Honzik, 1930</xref>), and the discovery of neurons with position-(<xref ref-type="bibr" rid="bib32">O’Keefe and Dostrovsky, 1971</xref>), velocity-(<xref ref-type="bibr" rid="bib37">Sargolini et al., 2006</xref>; <xref ref-type="bibr" rid="bib26">Kropff et al., 2015</xref>) and head direction-(<xref ref-type="bibr" rid="bib44">Taube et al., 1990</xref>) selective receptive fields in the hippocampal formation, understanding the brain’s role in navigation and spatial memory has been a key goal of the neuroscience, cognitive science, and psychology communities. In this field, it is common for theoretical or computational models to rely on artificially generated data sets. For example, for the direct testing of a normative model, or to feed a learning algorithm with training data from a motion model used to generate a time series of states, or feature-vectors. Not only is this data more cost-effective, quicker to acquire, and less resource-intensive than conducting spatial experiments (no rats required), but it also offers the advantage of being flexibly hand-designed to support the validation or refutation of theoretical propositions. Indeed, many past (<xref ref-type="bibr" rid="bib30">Mehta et al., 2000</xref>; <xref ref-type="bibr" rid="bib7">Burak et al., 2009</xref>; <xref ref-type="bibr" rid="bib17">Gustafson and Daw, 2011</xref>) and recent (<xref ref-type="bibr" rid="bib41">Stachenfeld et al., 2017</xref>; <xref ref-type="bibr" rid="bib10">de Cothi and Barry, 2020</xref>; <xref ref-type="bibr" rid="bib5">Bono et al., 2023</xref>; <xref ref-type="bibr" rid="bib15">George et al., 2022</xref>; <xref ref-type="bibr" rid="bib1">Banino et al., 2018</xref>; <xref ref-type="bibr" rid="bib39">Schaeffer et al., 2022</xref>; <xref ref-type="bibr" rid="bib4">Benna and Fusi, 2021</xref>) models have relied on artificially generated movement trajectories and neural data.</p><p>Artificially generating data can still be a bottleneck in the scientific process. We observe a number of issues: First, the lack of a universal standard for trajectory and cell activity modelling hinders apples-to-apples comparisons between theoretical models whose conclusions may differ depending on the specifics of the models being used. Secondly, researchers must begin each project reinventing the wheel, writing software capable of generating pseudo-realistic trajectories and neural data before the more interesting theoretical work can begin. Thirdly, inefficiently written software can significantly slow down simulation time or, worse, push users to seek solutions which are more complex and power-intensive (multithreading, GPUs, etc.) than the underlying task requires, decreasing reproducibility. Finally, even the relatively modest complexities of motion modelling in continuous environments raises the technical entry barrier to computational research and can impel researchers towards studying only one-dimensional environments or biologically unrealistic ‘gridworlds’ with tabularised state spaces. Not only can gridworld models scale poorly in large environments but they typically disregard aspects of motion which can be non-trivial, for example speed variability and inertia. Whilst there are valid reasons why gridworld and/or tabularised state-space models may be preferred – and good open source packages for modelling this (<xref ref-type="bibr" rid="bib29">Maxime et al., 2023</xref>; <xref ref-type="bibr" rid="bib25">Juliani et al., 2022</xref>) – we suspect that coding simplicity, rather than theory-based justifications, remain a common reason these are used over continuous analogs.</p><p>To overcome these issues we built RatInABox (<ext-link ext-link-type="uri" xlink:href="https://github.com/RatInABox-Lab/RatInABox">https://github.com/RatInABox-Lab/RatInABox</ext-link>) (<xref ref-type="bibr" rid="bib14">George, 2022</xref>): an open source Python toolkit for efficient and realistic motion modelling in complex continuous environments <italic>and</italic> concurrent simulation of neuronal activity data for many cell types including those typically found in the hippocampal formation (<xref ref-type="fig" rid="fig1">Figure 1</xref>).</p><fig id="fig1" position="float"><label>Figure 1.</label><caption><title>RatInABox is a flexible toolkit for simulating locomotion and neural data in complex continuous environments.</title><p>(<bold>a</bold>) One minute of motion in a 2D <monospace>Environment</monospace> with a wall. By default the <monospace>Agent</monospace> follows a physically realistic random motion model fitted to experimental data. (<bold>b</bold>) Premade neuron models include the most commonly observed position/velocity selective cells types (6 of which are displayed here). Users can also build more complex cell classes based on these primitives. Receptive fields interact appropriately with walls and boundary conditions. (<bold>c</bold>) As the <monospace>Agent</monospace> explores the <monospace>Environment</monospace>, <monospace>Neurons</monospace> generate neural data. This can be extracted for downstream analysis or visualised using in-built plotting functions. Solid lines show firing rates, and dots show sampled spikes. (<bold>d</bold>) One minute of random motion in a 1D environment with solid boundary conditions. (<bold>e</bold>) Users can easily construct complex <monospace>Environment</monospace>s by defining boundaries and placing walls, holes and objects. Six example <monospace>Environments</monospace>, some chosen to replicate classic experimental set-ups, are shown here.</p></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-85274-fig1-v2.tif"/></fig><sec id="s1-1"><title>RatInABox</title><p>RatInABox is an open source software package comprising three component classes:</p><list list-type="bullet"><list-item><p><monospace>Environment</monospace>: The environment (or ‘box’) that the <monospace>Agent</monospace> exists in. An <monospace>Environment</monospace> can be one- or two-dimensional, contain walls/barriers, holes, and objects and they can have periodic or solid boundary conditions (<xref ref-type="fig" rid="fig1">Figure 1a, b, d, e</xref>).</p></list-item><list-item><p><monospace>Agent</monospace>: The agent (or ‘rat’) moving around the <monospace>Environment</monospace> (<xref ref-type="fig" rid="fig1">Figure 1a, d</xref>). <monospace>Agent</monospace>s are 0-dimensional and <monospace>Environment</monospace>s can contain multiple <monospace>Agent</monospace>s simultaneously.</p></list-item><list-item><p><monospace>Neurons</monospace>: A population of neurons whose firing rates update to encode the ‘state’ of the <monospace>Agent</monospace> in a rich variety of ways. Specific subclasses are provided corresponding to commonly studied cell-types (including, but not limited to, <monospace>PlaceCells</monospace>, <monospace>GridCells</monospace>, <monospace>BoundaryVectorCells</monospace> and <monospace>HeadDirectionCells</monospace>, <xref ref-type="fig" rid="fig1">Figure 1b, c</xref>). Users can also write their own <monospace>Neurons</monospace> subclasses or build/train complex function-approximator <monospace>Neurons</monospace> based on these primitives.</p></list-item></list><p>A typical workflow would be as follows: Firstly, an <monospace>Environment</monospace> is initialised with parameters specifying its dimensionality, size, shape and boundary conditions. Walls, holes and objects (which act as ‘visual cues’) can be added to make the <monospace>Environment</monospace> more complex. Secondly, an <monospace>Agent</monospace> is initialised with parameters specifying the characteristics of its motion (mean/standard deviation of its speed and rotational velocity, as well as behaviour near walls). Thirdly, populations of <monospace>Neurons</monospace> are initialised with parameters specifying their characteristics (number of cells, receptive field parameters, maximum firing rates etc.).</p><p>Next, a period of simulated motion occurs: on each step the <monospace>Agent</monospace> updates its position and velocity within the <monospace>Environment</monospace>, given the duration of the step, and <monospace>Neurons</monospace> update their firing rates to reflect the new state of the <monospace>Agent</monospace>. After each step, data (timestamps, position, velocities, firing rates and spikes sampled according to an inhomogenous Poisson process) are saved into their respective classes for later analysis, <xref ref-type="fig" rid="fig1">Figure 1</xref>.</p><p>RatInABox is fundamentally continuous in space and time. Position and velocity are never discretised but are instead stored as continuous values and used to determine cell activity online, as exploration occurs. This differs from other models which are either discrete (e.g. ‘gridworld’ or Markov decision processes) (<xref ref-type="bibr" rid="bib29">Maxime et al., 2023</xref>; <xref ref-type="bibr" rid="bib25">Juliani et al., 2022</xref>) or approximate continuous rate maps using a cached list of rates precalculated on a discretised grid of locations (<xref ref-type="bibr" rid="bib10">de Cothi and Barry, 2020</xref>). Modelling time and space continuously more accurately reflects real-world physics, making simulations smooth and amenable to fast or dynamic neural processes which are not well accommodated by discretised motion simulators. Despite this, RatInABox is still fast; to simulate 100 <monospace>PlaceCells</monospace> for 10 min of random 2D motion (dt = 0.1 s) it takes about 2 s on a consumer grade CPU laptop (or 7 s for boundary vector cells).</p><p>By default the <monospace>Agent</monospace> follows a temporally continuous smooth random motion model, closely matched to the statistics of rodent foraging in an open field (<xref ref-type="bibr" rid="bib37">Sargolini et al., 2006</xref>, <xref ref-type="fig" rid="fig2">Figure 2</xref>); however, functionality is also provided for non-random velocity control via a user provided control signal or for the <monospace>Agent</monospace> to follow an imported trajectory (<xref ref-type="fig" rid="fig3">Figure 3a</xref>). Once generated, data can be plotted using in-built <ext-link ext-link-type="uri" xlink:href="https://github.com/RatInABox-Lab/RatInABox/blob/main/demos/list_of_plotting_fuctions.md">plotting functions</ext-link> (which cover most of the figures in this manuscript) or extracted to be used in the theoretical model being constructed by the user.</p><fig id="fig2" position="float"><label>Figure 2.</label><caption><title>The RatInABox random motion model closely matches features of real rat locomotion.</title><p>(<bold>a</bold>) An example 5-min trajectory from the <xref ref-type="bibr" rid="bib37">Sargolini et al., 2006</xref>. dataset. Linear velocity (Rayleigh fit) and rotational velocity (Gaussian fit) histograms and the temporal autocorrelations (exponential fit) of their time series’. (<bold>b</bold>) A sampled 5-min trajectory from the RatInABox motion model with parameters matched to the Sargolini data. (<bold>c</bold>) Figure reproduced from Figure 8D in <xref ref-type="bibr" rid="bib38">Satoh et al., 2011</xref> showing 10 min of open-field exploration. ‘Thigmotaxis’ is the tendency of rodents to over-explore near boundaries/walls and has been linked to anxiety. (<bold>d</bold>) RatInABox replicates the tendency of agents to over-explore walls and corners, flexibly controlled with a ‘thigmotaxis’ parameter. (<bold>e</bold>) Histogram of the area-normalised time spent in annuli at increasing distances, <inline-formula><mml:math id="inf1"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>d</mml:mi></mml:mstyle></mml:math></inline-formula>, from the wall. RatInABox and real data are closely matched in their tendency to over-explore locations near walls without getting too close.</p></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-85274-fig2-v2.tif"/></fig><fig id="fig3" position="float"><label>Figure 3.</label><caption><title>Advanced features and computational efficiency analysis.</title><p>(<bold>a</bold>) Low temporal-resolution trajectory data (2 Hz) imported into RatInABox is upsampled (‘augmented’) using cubic spline interpolation. The resulting trajectory is a close match to the ground truth trajectory (<xref ref-type="bibr" rid="bib37">Sargolini et al., 2006</xref>) from which the low resolution data was sampled. (<bold>b</bold>) Movement can be controlled by a user-provided ‘drift velocity’ enabling arbitrarily complex motion trajectories to be generated. Here, we demonstrate how circular motion can be achieved by setting a drift velocity (grey arrows) which is tangential to the vector from the centre of the <monospace>Environment</monospace> to the <monospace>Agent</monospace>’s position. (<bold>c</bold>) Egocentric <monospace>VectorCells</monospace> can be arranged to tile the <monospace>Agent</monospace>’s field of view, providing an efficient encoding of what an <monospace>Agent</monospace> can ‘see’. Here, two <monospace>Agent</monospace>s explore an <monospace>Environment</monospace> containing walls and an object. <monospace>Agent</monospace>-1 (purple) is endowed with three populations of Boundary- (grey), Object- (red), and <monospace>Agent</monospace>- (green) selective field of view <monospace>VectorCells</monospace>. Each circle represents a cell, its position (in the head-centred reference frame of the <monospace>Agent</monospace>) corresponds to its angular and distance preferences and its shading denotes its current firing rate. The lower panel shows the firing rate of five example cells from each population over time. (<bold>d</bold>) A <monospace>Neurons</monospace> class containing a feed forward neural network learns, from data collect online over a period of 300 min, to approximate a complex target receptive field from a set of grid cell inputs. This demonstrates how learning processes can be incorporated and modelled into RatInABox. (<bold>e</bold>) RatInABox used in a simple reinforcement learning example. A policy iteration technique converges onto an optimal value function (heatmap) and policy (trajectories) for an Environment where a reward is hidden behind a wall. State encoding, policy control and the <monospace>Environment</monospace> are handled naturally by RatInABox. (<bold>f</bold>) Compute times for common RatInABox (purple) and non-RatInABox (red) operations on a consumer grade CPU. Updating the random motion model and calculating boundary vector cell firing rates is slower than place or grid cells (note log-scale) but comparable, or faster than, size-matched non-RatInABox operations. Inset shows how the total update time (random motion model and place cell update) scales with the number of place cells.</p></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-85274-fig3-v2.tif"/></fig></sec><sec id="s1-2"><title>Intended use-cases</title><p>RatInABox can be used whenever locomotion and/or populations of cells need to be modelled in continuous one- or two-dimensional environments. These functionalities are coupled (locomotion directly adjusts the cell firing rates) but can also be used independently (for example an <monospace>Environment</monospace> and <monospace>Agent</monospace> can be modelled without any <monospace>Neurons</monospace> if users only require the motion model, or alternatively users can calculate cell activity on an imported trajectory without using the random motion model).</p><p>We envisage use cases falling into two broad categories. (i) Data generation: The user is interested in generating realistic trajectories and/or neural data for use in a downstream analysis or model training procedure (<xref ref-type="bibr" rid="bib27">Lee et al., 2023</xref>). (ii) Advanced modelling: The user is interested in building a model of the brain’s role in navigation (<xref ref-type="bibr" rid="bib16">George et al., 2023</xref>), including how behaviour and neural representations mutually interact.</p><p>Below we briefly describe the most important details and features of RatInABox, divided into their respective classes. We leave all mathematical details to the Methods. Additional details (including example scripts and figures) can be found in the supplementary material and on the GitHub repository. The codebase itself is comprehensively documented and can be referenced for additional understanding where necessary.</p></sec><sec id="s1-3"><title>The Environment</title><p>Unlike discretised models, where environments are stored as sets of nodes (‘states’) connected by edges (‘actions’)(<xref ref-type="bibr" rid="bib25">Juliani et al., 2022</xref>), here <monospace>Environment</monospace>s are continuous domains containing walls (1D line segments through which locomotion is not allowed) and objects (which are 0-dimensional and act as visual cues). Boundaries and visual cues are thought to provide an important source of sensory data into the hippocampus (<xref ref-type="bibr" rid="bib34">O’Keefe and Burgess, 1996</xref>; <xref ref-type="bibr" rid="bib19">Hartley et al., 2000</xref>; <xref ref-type="bibr" rid="bib2">Barry et al., 2006</xref>; <xref ref-type="bibr" rid="bib40">Solstad et al., 2008</xref>) and play an important role in determining cell activity during navigation (<xref ref-type="bibr" rid="bib41">Stachenfeld et al., 2017</xref>; <xref ref-type="bibr" rid="bib10">de Cothi and Barry, 2020</xref>). An <monospace>Environment</monospace> can have periodic or solid boundary conditions and can be one- or two-dimensional (<xref ref-type="fig" rid="fig1">Figure 1a, d</xref>).</p></sec><sec id="s1-4"><title>The Agent</title><sec id="s1-4-1"><title>Physically realistic random motion</title><p>Smooth and temporally continuous random motion can be difficult to model. To be smooth (and therefore physically plausible), a trajectory must be continuous in both position <italic>and</italic> velocity. To be temporally continuous, the statistics of the motion must be independent of the integration timestep being used. To be random, position and velocity at one time must not be reliable predictors of position and velocity at another time, provided these times are seperated by a sufficiently long interval. Implementations of random motion models typically fail to satisfy one, or sometimes two, of these principles (<xref ref-type="bibr" rid="bib36">Raudies and Hasselmo, 2012</xref>; <xref ref-type="bibr" rid="bib4">Benna and Fusi, 2021</xref>).</p><p>Ornstein-Uhlenbeck processes, which sit at the heart of the RatInABox random motion model, are continuous-in-time random walks with a tendency to return to a central drift value. The decorrelation timescale can be also be controlled. We use these to update the velocity vector (linear and rotational velocities are updated independently) on each update step. Position is then updated by taking a step along the velocity vector with some additional considerations to avoid walls. This method ensures both position and velocity are continuous, yet evolve ‘randomly’ (<xref ref-type="fig" rid="fig1">Figure 1a, d</xref>), and the statistics of the motion is independent of the size of the discretisation timestep being used.</p><p>Reanalysing rat locomotion data from <xref ref-type="bibr" rid="bib37">Sargolini et al., 2006</xref> (as has been done before, by <xref ref-type="bibr" rid="bib36">Raudies and Hasselmo, 2012</xref>) we found that the histograms of linear speeds are well fit by a Rayleigh distributions whereas rotational velocities are approximately fit by normal distributions (<xref ref-type="fig" rid="fig2">Figure 2a</xref>). Unlike <xref ref-type="bibr" rid="bib36">Raudies and Hasselmo, 2012</xref>, we also extract the decorrelation timescale of these variables and observe that rotational velocity in real locomotion data decorrelates nearly an order of magnitude faster than linear velocity (0.08 s vs. 0.7 s). We set the default parameters of our Ornstein-Uhlenbeck processes (including applying a transform on the linear velocity so its long-run distribution also follows a Rayleigh distribution, see Methods) to those measured from the <xref ref-type="bibr" rid="bib37">Sargolini et al., 2006</xref> dataset (<xref ref-type="fig" rid="fig2">Figure 2b</xref>).</p></sec><sec id="s1-4-2"><title>Motion near walls</title><p>Animals rarely charge head-first into a wall, turn around, then continue in the opposite direction. Instead, they slow down smoothly and turn to avoid a collision. Additionally, during random foraging, rodents are observed to show a bias towards following walls, a behaviour known as thigmotaxis (<xref ref-type="bibr" rid="bib38">Satoh et al., 2011</xref>; <xref ref-type="fig" rid="fig2">Figure 2c</xref>). To replicate these observations, walls in the <monospace>Environment</monospace> lightly repel the <monospace>Agent</monospace> when it is close. Coupled with the finite turning speed this creates (somewhat counter-intuitively) a thigmotactic effect where the agent over-explores walls and corners, matching what is observed in the data (<xref ref-type="fig" rid="fig2">Figure 2e</xref>). A user-defined parameter called ‘<monospace>thigmotaxis</monospace>’ can be used to control the strength of this emergent effect (<xref ref-type="fig" rid="fig2">Figure 2d</xref>).</p></sec><sec id="s1-4-3"><title>Imported trajectories</title><p>RatInABox supports importing trajectory data which can be used instead of the inbuilt random motion model. Imported trajectory data points which may be of low temporal-resolution are interpolated using cubic splines and smoothly upsampled to user-define temporal precision (<xref ref-type="fig" rid="fig3">Figure 3a</xref>). This upsampling is essential if one wishes to use low temporal resolution trajectory data to generate high temporal resolution neural data.</p></sec><sec id="s1-4-4"><title>Trajectory control</title><p>RatInABox supports online velocity control. At each integration step a target drift velocity can be specified, towards which the <monospace>Agent</monospace> accelerates. We anticipate this feature being used to generate complex stereotyped trajectories or to model processes underpinning complex spatial behaviour (as we demonstrate in <xref ref-type="fig" rid="fig3">Figure 3b, e</xref>).</p></sec></sec><sec id="s1-5"><title>Neurons</title><p>RatInABox provides multiple premade <monospace>Neurons</monospace> subclasses chosen to replicate the most popular and influential cell models and state representations across computational neuroscience and machine learning. A selection of these are shown in <xref ref-type="fig" rid="fig1">Figure 1b</xref>. See Methods for mathematical details. These currently include:</p><list list-type="bullet"><list-item><p><monospace>PlaceCells</monospace>: A set of locations is sampled uniformly at random from across the <monospace>Environment</monospace> or provided manually, each defining the centre of a place field. The place cell firing rate is determined by the some function of the distance from the <monospace>Agent</monospace> to the centre of the place field. Provided functions are</p><list list-type="bullet"><list-item><p>Gaussian: A Gaussian centred on the place field centre.</p></list-item><list-item><p>Gaussian threshold: A gaussian cropped and levelled at 1 standard deviation.</p></list-item><list-item><p>Difference of two Gaussians: A wide Gaussian substracted from a narrower Gaussian with zero total volume.</p></list-item><list-item><p>Top hat: Fires uniformly only within a circle of specific radius (similar to tile coding in machine learning).</p></list-item><list-item><p>One hot: Only the closest place cell to a given position will fire. This is useful for replicating tabular state spaces but with continuous motion.</p></list-item><list-item><p><monospace>PhasePrecessingPlaceCells</monospace>: A subclass of <monospace>PlaceCells</monospace> which display phase precession (<xref ref-type="bibr" rid="bib33">O’Keefe and Recce, 1993</xref>) with respect to a background LFP theta-oscillation.</p></list-item></list></list-item><list-item><p><monospace>GridCells</monospace>: Grid cells are modelled using a method proposed by <xref ref-type="bibr" rid="bib8">Burgess et al., 2007</xref>. Receptive fields are given by the thresholded or shifted sum of three cosine waves at 60°.</p></list-item><list-item><p><monospace>VectorCells</monospace>: Each vector cells responds to salient features in the <monospace>Environment</monospace> at a preferred distance and angle according to a model inspired by the double-Gaussian model used by <xref ref-type="bibr" rid="bib19">Hartley et al., 2000</xref>. Vector cells can be ‘allocentric’ (angular preferences are relative to true-North) or ‘egocentric’ (<xref ref-type="bibr" rid="bib9">Byrne et al., 2007</xref>) (angular preferences are relative to the <monospace>Agent</monospace>’s heading). Types include:</p><list list-type="bullet"><list-item><p><monospace>BoundaryVectorCells</monospace>: Respond to walls.</p></list-item><list-item><p><monospace>ObjectVectorCells</monospace>: Respond to objects.</p></list-item><list-item><p><monospace>AgentVectorCells</monospace>: Respond to other <monospace>Agent</monospace>s.</p></list-item><list-item><p><monospace>FieldOfViewBVCs/OVCs/AVCs</monospace>: Egocentric vector cells arranged to tile the <monospace>Agent</monospace>’s field-of-view, further described below.</p></list-item></list></list-item><list-item><p><monospace>HeadDirectionCells</monospace>: Each cell has a preferred direction. The firing rate is given by a von Mises distribution centred on the preferred direction.</p></list-item><list-item><p><monospace>VelocityCells</monospace>: Like <monospace>HeadDirectionCells</monospace> but firing rate scales proportional to speed.</p></list-item><list-item><p><monospace>SpeedCell</monospace>: A single cell fires proportional to the scalar speed of the <monospace>Agent</monospace>.</p></list-item><list-item><p><monospace>RandomSpatialNeurons</monospace>: Each cell has a locally smooth but random spatial receptive field of user-defined lengthscale.</p></list-item></list><p>A dedicated space containing additional cell classes not described here, is made available for community contributions to this list.</p><sec id="s1-5-1"><title>Customizable and trainable neurons</title><p>Any single toolkit cannot contain all possible neural representations of interest. Besides, static cell types (e.g. <monospace>PlaceCells</monospace>, <monospace>GridCells</monospace> etc.) which have fixed receptive fields are limiting if the goal is to study how representations and/or behaviour are learned. RatInABox provides two solutions: Firstly, being open-source, users can write and contribute their own bespoke <monospace>Neurons</monospace> (instructions and examples are provided) with arbitrarily complicated rate functions. Secondly, two types of function-approximator <monospace>Neurons</monospace> are provided which map inputs (the firing rate of other <monospace>Neurons</monospace>) to outputs (their own firing rate) through a parameterised function which can be hand-tuned or trained to represent an endless variety of receptive field functions including those which are mixed selective, non-linear, dynamic, and non-stationary.</p><list list-type="bullet"><list-item><p><monospace>FeedForwardLayer</monospace>: Calculates a weighted linear combination of the input <monospace>Neurons</monospace> with optional bias and non-linear activation function.</p></list-item><list-item><p><monospace>NeuralNetworkNeurons</monospace>: Inputs are passed through a user-provided artificial neural network.</p></list-item></list><p>Naturally, function-approximator <monospace>Neurons</monospace> can be used to model how neural populations in the brain communicate, how neural representations are learned or, in certain cases, neural dynamics. In an online demo, we show how <monospace>GridCells</monospace> and <monospace>HeadDirectionCells</monospace> can be easily combined using a <monospace>FeedForwardLayer</monospace> to create head-direction selective grid cells (aka. conjunctive grid cells <xref ref-type="bibr" rid="bib37">Sargolini et al., 2006</xref>). In <xref ref-type="fig" rid="fig3">Figure 3d</xref> and associated demo <monospace>GridCells</monospace> provide input to a <monospace>NeuralNetworkNeurons</monospace> class which is then trained, on data generated during exploration, to have a highly complex and non-linear receptive field. Function-approximator <monospace>Neurons</monospace> can themselves be used as inputs to other function-approximator <monospace>Neurons</monospace> allowing multi-layer and/or recurrent networks to be constructed and studied.</p></sec><sec id="s1-5-2"><title>Field of view encodings</title><p>Efficiently encoding what an <monospace>Agent</monospace> can ‘see’ in its local vicinity, aka. its field of view, is crucial for many modelling studies. A common approach is to use a convolutional neural network (CNN) to process a rendered image of the nearby environment and extract activations from the final layer. However, this method is computationally expensive and necessitates training the CNN on a large dataset of visual images.</p><p>RatInABox offers a more efficient alternative through the use of <monospace>VectorCells</monospace>. Three variants – <monospace>FieldOfViewBVCs</monospace>, <monospace>FieldOfViewOVCs</monospace>, and <monospace>FieldOfViewAVCs</monospace> – comprise populations of <italic>egocentric</italic> <monospace>Boundary</monospace>-, <monospace>Object</monospace>-, and <monospace>AgentVectorCells</monospace> with angular and distance preferences specifically set to tile the <monospace>Agent</monospace>’s field of view. Being egocentric means that the cells remained fixed in the reference frame of the <monospace>Agent</monospace> as it navigates the <monospace>Environment</monospace>. Users define the range and resolution of this field of view. Plotting functions for visualising the field of view cells, as shown in <xref ref-type="fig" rid="fig3">Figure 3c</xref>, are provided.</p></sec><sec id="s1-5-3"><title>Geometry and boundary conditions</title><p>In RatInABox, <monospace>PlaceCells</monospace> and <monospace>VectorCells</monospace> are sensitive to walls in the <monospace>Environment</monospace>. Three distance geometries are supported: ‘euclidean’ geometry calculates the Euclidean distance to a place field centre and so cell activity will ‘bleed’ through boundaries as if they weren’t there. ‘line_of_sight’ geometry allows a place cell to fire only if there is direct line-of-sight to the place field centre from the current location. Finally ‘geodesic’ geometry (default) calculates distance according to the shortest boundary-avoiding path to the cell centre (notice smooth wrapping of the third place field around the wall in <xref ref-type="fig" rid="fig1">Figure 1b</xref>). The latter two geometries respect the observation that place fields don’t typical pass through walls, an observation which is thought to support efficient generalisation in spatial reinforcement learning (<xref ref-type="bibr" rid="bib17">Gustafson and Daw, 2011</xref>). Boundary conditions can be periodic or solid. In the former case, place fields near the boundaries of the environment will wrap around.</p></sec><sec id="s1-5-4"><title>Rate maps</title><p>RatInABox simplifies the calculation and visualization of rate maps through built-in protocols and plotting functions. Rate maps can be derived explicitly from their known analytic firing functions or implicitly from simulation data. The explicit method computes rate maps by querying neuron firing rates at all positions simultaneously, utilizing ’array programming’ to rapidly compute the rate map. In the implicit approach, rate maps are created by plotting a smoothed histogram of positions visited by the <monospace>Agent</monospace>, weighted by observed firing rates (a continuous equivalent of a smoothed spike raster plot). Additionally, the tool offers the option to visualize spikes through raster plots.</p></sec></sec></sec><sec id="s2" sec-type="results"><title>Results</title><p>The default parameters of the random motion model in RatInABox are matched to observed statistics of rodent locomotion, extracted by reanalysing data from <xref ref-type="bibr" rid="bib37">Sargolini et al., 2006</xref> (data freely available at: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.11582/2017.00019">https://doi.org/10.11582/2017.00019</ext-link>, exact filename used: 8F6BE356-3277-475C-87B1-C7A977632DA7_1/11084–03020501_t2c1.mat). Trajectories and statistics from the real data (<xref ref-type="fig" rid="fig2">Figure 2a</xref>) closely compare to the artificially generated trajectories from RatInABox (<xref ref-type="fig" rid="fig2">Figure 2b</xref>). Further, data (<xref ref-type="bibr" rid="bib38">Satoh et al., 2011</xref>) shows that rodents have a tendency to over-explore walls and corners, a bias often called ‘thigmotaxis’ which is particularly pronounced when the animal is new to the environment (<xref ref-type="fig" rid="fig2">Figure 2c</xref>). This bias is correctly replicated in the artificial trajectories generated by RatInABox - the strength of which can be controlled by a single parameter <monospace>Agent.thigmotaxis</monospace> (<xref ref-type="fig" rid="fig2">Figure 2d, e</xref>).</p><p>RatInABox can import and smoothly interpolate user-provided trajectory data. This is demonstrated in <xref ref-type="fig" rid="fig3">Figure 3a</xref> where a low-resolution trajectory is imported into RatInABox and smoothly upsampled using cubic spline interpolation. The resulting trajectory is a close match to the ground truth. Note that without upsampling, this data (2 Hz) would be far too low in temporal-resolution to usefully simulate neural activity. For convenience, the exact datafile <xref ref-type="bibr" rid="bib37">Sargolini et al., 2006</xref> used in <xref ref-type="fig" rid="fig3">Figures 3a</xref> and <xref ref-type="fig" rid="fig2">2a</xref> is uploaded with permission to the GitHub repository and can be imported using <monospace>Agent.import_trajectory(dataset=&quot;sargolini&quot;)</monospace>. An additional trajectory dataset from a much larger environment is also supplied with permission from <xref ref-type="bibr" rid="bib43">Tanni et al., 2022</xref>.</p><p>RatInABox is computationally efficient. We compare compute times for typical RatInABox operations (<xref ref-type="fig" rid="fig3">Figure 3f</xref>, purple bars) to typical <italic>non-</italic>RatInABox operations representing potential ‘bottlenecking’ operations in a downstream analysis or model-training procedure for which RatInABox is providing data (<xref ref-type="fig" rid="fig3">Figure 3f</xref>, red bars). These were multiplying a matrix by a vector using the numpy (<xref ref-type="bibr" rid="bib18">Harris et al., 2020</xref>) package and a forward and backward pass through a small feedforward artificial neural network using the pytorch package (<xref ref-type="bibr" rid="bib35">Paszke et al., 2019</xref>). <monospace>PlaceCells</monospace>, <monospace>GridCells</monospace> and the random motion model all update faster than these two operations. <monospace>BoundaryVectorCells</monospace> (because they require integrating around a 360° field-of-view) are significantly slower than the other cells but still outpace the feedforward neural network. All vector, matrix, and cell populations were size <inline-formula><mml:math id="inf2"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>100</mml:mn></mml:mstyle></mml:math></inline-formula>, the feed forward network had layer sizes <inline-formula><mml:math id="inf3"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>n</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>100</mml:mn><mml:mo>,</mml:mo><mml:mn>1000</mml:mn><mml:mo>,</mml:mo><mml:mn>1000</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula>, the <monospace>Environment</monospace> was 2D with no additional walls and all operations were calculated on a consumer-grade CPU (MacBook Pro, Apple M1). These results imply that, depending on the details of the use-case, RatInABox will likely not be a significant computational bottleneck.</p><p>Our testing (<xref ref-type="fig" rid="fig3">Figure 3f</xref>, inset) reveals that the combined time for updating the motion model and a population of <monospace>PlaceCells</monospace> scales sublinearly <inline-formula><mml:math id="inf4"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">O</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> for small populations <inline-formula><mml:math id="inf5"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>n</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>1000</mml:mn></mml:mstyle></mml:mrow></mml:mstyle></mml:math></inline-formula> where updating the random motion model dominates compute time, and linearly for large populations <inline-formula><mml:math id="inf6"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>n</mml:mi><mml:mo>&lt;</mml:mo><mml:mn>1000</mml:mn></mml:mstyle></mml:mrow></mml:mstyle></mml:math></inline-formula>. <monospace>PlaceCells</monospace>, <monospace>BoundaryVectorCells</monospace> and the <monospace>Agent</monospace> motion model update times will be additionally affected by the number of walls/barriers in the <monospace>Environment</monospace>. 1D simulations are significantly quicker than 2D simulations due to the reduced computational load of the 1D geometry.</p><sec id="s2-1"><title>Case studies</title><p>We envisage RatInABox being used to support a range of theoretical studies by providing data and, if necessary, infrastructure for building models powered by this data. This ‘Bring-Your-Own-Algorithm’ approach makes the toolkit generally applicable, not specialised to one specific field. Two examplar use-cases are provided in the supplement and are briefly described below. The intention is to demonstrate the capacity of RatInABox for use in varied types of computational studies and to provide tutorials as a tool for learning how to use the package. Many more demonstrations and <ext-link ext-link-type="uri" xlink:href="https://github.com/RatInABox-Lab/RatInABox/tree/main/demos">accompanying notebooks</ext-link> are provide on the <ext-link ext-link-type="uri" xlink:href="https://github.com/RatInABox-Lab/RatInABox">Github repository</ext-link>.</p><p>In our first example, we perform a simple experiment where location is decoded from neural firing rates (<xref ref-type="fig" rid="app1fig1">Appendix 1—figure 1</xref>). Data – the location and firing rate trajectories of an <monospace>Agent</monospace> randomly exploring a 2D <monospace>Environment</monospace> – are generated using RatInABox. Non-parameteric Gaussian process regression is used to predict position from firing rates on a held-out testing dataset. We compare the accuracy of decoding using different cell types; place cells, grid cells and boundary vector cells.</p><p>Next, we demonstrate the application of RatInABox to a simple reinforcement learning (RL) task (<xref ref-type="fig" rid="app1fig2">Appendix 1—figure 2</xref>, summarised in <xref ref-type="fig" rid="fig3">Figure 3e</xref>). A small network capable of model-free RL is constructed and trained using RatInABox. First a neuron calculates and learns – using a continuous variant of temporal difference learning – the value function <inline-formula><mml:math id="inf7"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mi>V</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>π</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mi>w</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mi>F</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>pc</mml:mtext></mml:mrow></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> as a linear combination of place cell basis features. Then a new ‘improved’ policy is defined by setting a drift velocity – which biases the <monospace>Agent</monospace>’s motion – proportional to the gradient of the value function <inline-formula><mml:math id="inf8"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mi>v</mml:mi><mml:mrow><mml:mrow><mml:mtext>drift</mml:mtext></mml:mrow></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>π</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∝</mml:mo><mml:msub><mml:mi mathvariant="normal">∇</mml:mi><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:msup><mml:mi>V</mml:mi><mml:mrow><mml:mi>π</mml:mi></mml:mrow></mml:msup></mml:mstyle></mml:mrow></mml:mstyle></mml:math></inline-formula>. The <monospace>Agent</monospace> is therefore encouraged to move towards regions with high value. Iterating between these stages over many episodes (‘policy iteration’) results in convergence towards near optimal behaviour where the <monospace>Agent</monospace> takes the shortest route to the reward, avoiding the wall (<xref ref-type="fig" rid="fig3">Figure 3e</xref>).</p><p>Additional tutorials, not described here but <ext-link ext-link-type="uri" xlink:href="https://github.com/RatInABox-Lab/RatInABox/blob/main/demos/">available online</ext-link>, demonstrate how RatInABox can be used to model splitter cells, conjunctive grid cells, biologically plausible path integration, successor features, deep actor-critic RL, whisker cells and more. Despite including these examples we stress that they are not exhaustive. RatInABox provides the framework and primitive classes/functions from which highly advanced simulations such as these can be built.</p></sec></sec><sec id="s3" sec-type="discussion"><title>Discussion</title><p>RatInABox is a lightweight, open-source toolkit for generating realistic, standardised trajectory and neural data in continuous environments. It should be particularly useful to those studying spatial navigation and the role of the hippocampal formation. It remains purposefully small in scope - intended primarily as a means for generating data. We do not provide, nor intend to provide, a set of benchmark learning algorithms to use on the data it generates. Its user-friendly API, inbuilt data-plotting functions and general yet modular feature set mean it is well placed to empower a wide variety of users to more rapidly build, train and validate models of hippocampal function (<xref ref-type="bibr" rid="bib27">Lee et al., 2023</xref>) and spatial navigation (<xref ref-type="bibr" rid="bib16">George et al., 2023</xref>), accelerating progress in the field.</p><p>Our package is not the first to model neural data (<xref ref-type="bibr" rid="bib42">Stimberg et al., 2019</xref>; <xref ref-type="bibr" rid="bib21">Hepburn et al., 2012</xref>; <xref ref-type="bibr" rid="bib22">Hines and Carnevale, 1997</xref>) or spatial behaviour (<xref ref-type="bibr" rid="bib45">Todorov et al., 2012</xref>; <xref ref-type="bibr" rid="bib31">Merel et al., 2019</xref>), yet it distinguishes itself by integrating these two aspects within a unified, lightweight framework. The modelling approach employed by RatInABox involves certain assumptions:</p><list list-type="order"><list-item><p>It does not engage in the detailed exploration of biophysical (<xref ref-type="bibr" rid="bib42">Stimberg et al., 2019</xref>; <xref ref-type="bibr" rid="bib22">Hines and Carnevale, 1997</xref>) or biochemical (<xref ref-type="bibr" rid="bib21">Hepburn et al., 2012</xref>) aspects of neural modelling, nor does it delve into the mechanical intricacies of joint and muscle modelling (<xref ref-type="bibr" rid="bib45">Todorov et al., 2012</xref>; <xref ref-type="bibr" rid="bib31">Merel et al., 2019</xref>). While these elements are crucial in specific scenarios, they demand substantial computational resources and become less pertinent in studies focused on higher-level questions about behaviour and neural representations.</p></list-item><list-item><p>A focus of our package is modelling experimental paradigms commonly used to study spatially modulated neural activity and behaviour in rodents. Consequently, environments are currently restricted to being two-dimensional and planar, precluding the exploration of three-dimensional settings. However, in principle, these limitations can be relaxed in the future.</p></list-item><list-item><p>RatInABox avoids the oversimplifications commonly found in discrete modelling, predominant in reinforcement learning (<xref ref-type="bibr" rid="bib29">Maxime et al., 2023</xref>; <xref ref-type="bibr" rid="bib25">Juliani et al., 2022</xref>) which we believe impede its relevance to neuroscience.</p></list-item><list-item><p>Currently, inputs from different sensory modalities, such as vision or olfaction, are not explicitly considered. Instead, sensory input is represented implicitly through efficient allocentric or egocentric representations. If necessary, one could use the RatInABox API in conjunction with a third-party computer graphics engine to circumvent this limitation.</p></list-item><list-item><p>Finally, focus has been given to generating synthetic data from steady-state systems. Hence, by default, <monospace>Agent</monospace>s and <monospace>Neurons</monospace> do not explicitly include learning, plasticity or adaptation. Nevertheless we have shown that a minimal set of features such as parameterised function-approximator neurons and policy control enable time varying behavioural policies and cell responses (<xref ref-type="bibr" rid="bib6">Bostock et al., 1991</xref>; <xref ref-type="bibr" rid="bib3">Barry et al., 2007</xref>) to be modelled within the framework.</p></list-item></list><p>In conclusion, while no single approach can be deemed the best, we believe that RatInABox’s unique positioning makes it highly suitable for normative modelling and NeuroAI. We anticipate that it will complement existing toolkits and represent a significant contribution to the computational neuroscience toolbox.</p></sec><sec id="s4" sec-type="materials|methods"><title>Materials and methods</title><p>The following section describes in mathematical detail the models used within RatInABox. Table 1, below compiles a list of all important parameters along with their default values, allowed ranges and how they can be adjusted. These are up to date as of the time/version of publication but later versions may differ, see the GitHub repository for the most up-to-date list.</p><sec id="s4-1"><title>Motion model</title><sec id="s4-1-1"><title>Temporally continuous random motion</title><p>Our random motion model is based on the Ornstein Uhlenbeck (OU) process, <inline-formula><mml:math id="inf9"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">X</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>λ</mml:mi><mml:mo>,</mml:mo><mml:mi>μ</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula>, a stochastic process satisfying the Langevin differential equation<disp-formula id="equ1"><label>(1)</label><mml:math id="m1"><mml:mtable columnalign="right left right left right left right left right left right left" rowspacing="3pt" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" displaystyle="true"><mml:mtr><mml:mtd><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">X</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>λ</mml:mi><mml:mo>,</mml:mo><mml:mi>μ</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd><mml:mtd><mml:mi/><mml:mo>=</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">X</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>λ</mml:mi><mml:mo>,</mml:mo><mml:mi>μ</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">X</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>λ</mml:mi><mml:mo>,</mml:mo><mml:mi>μ</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>d</mml:mi><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">X</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>λ</mml:mi><mml:mo>,</mml:mo><mml:mi>μ</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd><mml:mtd><mml:mi/><mml:mo>=</mml:mo><mml:mi>θ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">X</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>λ</mml:mi><mml:mo>,</mml:mo><mml:mi>μ</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mi>d</mml:mi><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mi>λ</mml:mi><mml:mi>η</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msqrt><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:msqrt></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p>where <inline-formula><mml:math id="inf10"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>η</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∼</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi class="MJX-tex-caligraphic" mathvariant="script">N</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> is Gaussian white noise and <inline-formula><mml:math id="inf11"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>θ</mml:mi></mml:mstyle></mml:math></inline-formula>, <inline-formula><mml:math id="inf12"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>λ</mml:mi></mml:mstyle></mml:math></inline-formula> and μ are constants. The first term in the update equation drives decay of <inline-formula><mml:math id="inf13"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">X</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>λ</mml:mi><mml:mo>,</mml:mo><mml:mi>μ</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> towards the mean μ. The second term is a stochastic forcing term, driving randomness. These stochastic processes are well studied; their unconditioned covariance across time is<disp-formula id="equ2"><label>(2)</label><mml:math id="m2"><mml:mo fence="false" stretchy="false">⟨</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">X</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>λ</mml:mi><mml:mo>,</mml:mo><mml:mi>μ</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">X</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>λ</mml:mi><mml:mo>,</mml:mo><mml:mi>μ</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi class="MJX-variant" mathvariant="normal">′</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo fence="false" stretchy="false">⟩</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:msup><mml:mi>λ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mn>2</mml:mn><mml:mi>θ</mml:mi></mml:mrow></mml:mfrac><mml:msup><mml:mi>e</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>−</mml:mo><mml:mi>θ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi class="MJX-variant" mathvariant="normal">′</mml:mi></mml:mrow></mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:mrow></mml:msup><mml:mo>.</mml:mo></mml:math></disp-formula></p><p>Thus <inline-formula><mml:math id="inf14"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">X</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>λ</mml:mi><mml:mo>,</mml:mo><mml:mi>μ</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> decorrelates smoothly over a timescale of <inline-formula><mml:math id="inf15"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>τ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>/</mml:mo></mml:mrow><mml:mi>θ</mml:mi></mml:mstyle></mml:math></inline-formula>. Over long periods <inline-formula><mml:math id="inf16"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">X</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>λ</mml:mi><mml:mo>,</mml:mo><mml:mi>μ</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> is stochastic and therefore unpredictable. Its long-run stationary probability distribution is a Gaussian with mean μ and standard deviation <inline-formula><mml:math id="inf17"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>σ</mml:mi><mml:mo>=</mml:mo><mml:msqrt><mml:msup><mml:mi>λ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>/</mml:mo></mml:mrow><mml:mn>2</mml:mn><mml:mi>θ</mml:mi></mml:msqrt></mml:mstyle></mml:math></inline-formula>. We can re-parameterise the Ornstein Uhlenbeck process in terms of these more intuitive parameters (the decoherence timescale <inline-formula><mml:math id="inf18"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>τ</mml:mi></mml:mstyle></mml:math></inline-formula> and the long-run standard deviation <inline-formula><mml:math id="inf19"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>σ</mml:mi></mml:mstyle></mml:math></inline-formula>) using the transformations<disp-formula id="equ3"><label>(3)</label><mml:math id="m3"><mml:mtable columnalign="right left right left right left right left right left right left" rowspacing="3pt" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" displaystyle="true"><mml:mtr><mml:mtd><mml:mi>θ</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>τ</mml:mi></mml:mfrac><mml:mspace width="3mm"/><mml:mo>,</mml:mo><mml:mspace width="3mm"/><mml:mi>λ</mml:mi><mml:mo>=</mml:mo><mml:msqrt><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:msup><mml:mi>σ</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mi>τ</mml:mi></mml:mfrac></mml:msqrt><mml:mo>,</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p>to give<disp-formula id="equ4"><label>(4)</label><mml:math id="m4"><mml:mtable columnalign="right left right left right left right left right left right left" rowspacing="3pt" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" displaystyle="true"><mml:mtr><mml:mtd><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">X</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>τ</mml:mi><mml:mo>,</mml:mo><mml:mi>σ</mml:mi><mml:mo>,</mml:mo><mml:mi>μ</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd><mml:mtd><mml:mi/><mml:mo>=</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">X</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>τ</mml:mi><mml:mo>,</mml:mo><mml:mi>σ</mml:mi><mml:mo>,</mml:mo><mml:mi>μ</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">X</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>τ</mml:mi><mml:mo>,</mml:mo><mml:mi>σ</mml:mi><mml:mo>,</mml:mo><mml:mi>μ</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>d</mml:mi><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">X</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>τ</mml:mi><mml:mo>,</mml:mo><mml:mi>σ</mml:mi><mml:mo>,</mml:mo><mml:mi>μ</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd><mml:mtd><mml:mi/><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>τ</mml:mi></mml:mfrac><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">X</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>τ</mml:mi><mml:mo>,</mml:mo><mml:mi>σ</mml:mi><mml:mo>,</mml:mo><mml:mi>μ</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mi>d</mml:mi><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:msqrt><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:msup><mml:mi>σ</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mi>τ</mml:mi></mml:mfrac></mml:msqrt><mml:mi>η</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msqrt><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:msqrt><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p>Ornstein Uhlenbeck processes have the appealing property that they are temporally continuous (their statistics are independent of <inline-formula><mml:math id="inf20"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mstyle></mml:math></inline-formula>) and allow for easy control of the long-run standard deviation and the decoherence timescale of the stochastic variable. For these reasons, we use use them to model rotational and linear velocities within RatInABox.</p><sec id="s4-1-1-1"><title>2D motion</title><p>For 2D locomotion, we sample the <monospace>Agent</monospace>’s rotational velocity <inline-formula><mml:math id="inf21"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>ω</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mi>θ</mml:mi><mml:mo>˙</mml:mo></mml:mover></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> and linear speed, <inline-formula><mml:math id="inf22"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>2</mml:mn><mml:mi>D</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">v</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo fence="false" stretchy="false">‖</mml:mo></mml:mstyle></mml:math></inline-formula>, from independent OU processes. This is because, as shown in the Results section, they have decoherence timescales differing by an order of magnitude. Rotational velocity is sampled from a standard Ornstein Uhlenbeck process with zero mean. Linear speed is also sampled from an Ornstein Uhlenbeck process with one additional transform applied in order to match the observation that linear speeds have a Rayleigh, not normal, distribution.<disp-formula id="equ5"><label>(5)</label><mml:math id="m5"><mml:mrow><mml:mi>ω</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∼</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">X</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>τ</mml:mi><mml:mrow><mml:mi>ω</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mrow><mml:mi>ω</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula><disp-formula id="equ6"><label>(6)</label><mml:math id="m6"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>D</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mspace width="3mm"/><mml:mrow><mml:mtext>where</mml:mtext></mml:mrow><mml:mspace width="3mm"/><mml:mi>z</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∼</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">X</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>τ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula></p><p>where <inline-formula><mml:math id="inf23"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>R</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>σ</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> is a monotonic transformation which maps a normally distributed random variable <inline-formula><mml:math id="inf24"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>x</mml:mi><mml:mo>∼</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi class="MJX-tex-caligraphic" mathvariant="script">N</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> to one with a Rayleigh distribution of scale parameter <inline-formula><mml:math id="inf25"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>σ</mml:mi></mml:mstyle></mml:mrow></mml:mstyle></mml:math></inline-formula> corresponds to the mode, or <inline-formula><mml:math id="inf26"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mo>≈</mml:mo><mml:mn>0.8</mml:mn></mml:mstyle></mml:math></inline-formula> times the mean, of the Rayleigh distribution.<disp-formula id="equ7"><label>(7)</label><mml:math id="m7"><mml:mtable columnalign="right left right left right left right left right left right left" rowspacing="3pt" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" displaystyle="true"><mml:mtr><mml:mtd><mml:msub><mml:mi>R</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>σ</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>σ</mml:mi><mml:msqrt><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>ln</mml:mi><mml:mo>⁡</mml:mo><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow></mml:mstyle><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="1.623em" minsize="1.623em">[</mml:mo></mml:mrow></mml:mstyle><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>erf</mml:mtext></mml:mrow><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow></mml:mstyle><mml:mfrac><mml:mi>x</mml:mi><mml:msqrt><mml:mn>2</mml:mn></mml:msqrt></mml:mfrac><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow></mml:mstyle><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="1.623em" minsize="1.623em">]</mml:mo></mml:mrow></mml:mstyle><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow></mml:mstyle></mml:msqrt><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p>The parameters <inline-formula><mml:math id="inf27"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mo fence="false" stretchy="false">{</mml:mo><mml:msub><mml:mi>τ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>ω</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>ω</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>τ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo fence="false" stretchy="false">}</mml:mo></mml:mstyle></mml:math></inline-formula> are fitted from real open field 2D locomotion data in <xref ref-type="fig" rid="fig2">Figure 2</xref> or can be set by the user (see Table 1, below).</p><p>Full trajectories are then sampled as follows: First the rotational and linear velocities are updated according to <xref ref-type="disp-formula" rid="equ5 equ6">Equations 5, 6</xref> (and additional considerations for walls, see next section). Next the velocity direction, <inline-formula><mml:math id="inf28"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>θ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> – defined as the angle of the velocity vector measured anticlockwise from the x-direction – is updated according to the rotational velocity, <inline-formula><mml:math id="inf29"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>ω</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula>.<disp-formula id="equ8"><label>(8)</label><mml:math id="m8"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo maxsize="1.2em" minsize="1.2em">(</mml:mo></mml:mrow><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mi>d</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>ω</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>d</mml:mi><mml:mi>t</mml:mi><mml:mrow><mml:mo maxsize="1.2em" minsize="1.2em">)</mml:mo></mml:mrow><mml:mspace width="thinmathspace"/><mml:mrow><mml:mi mathvariant="normal">m</mml:mi><mml:mi mathvariant="normal">o</mml:mi><mml:mi mathvariant="normal">d</mml:mi></mml:mrow><mml:mspace width="thinmathspace"/><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mo>.</mml:mo></mml:mstyle></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>This is combined with the linear speed, <inline-formula><mml:math id="inf30"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>2</mml:mn><mml:mi>D</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> to calculate new total velocity vector, <inline-formula><mml:math id="inf31"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">v</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula>.<disp-formula id="equ9"><label>(9)</label><mml:math id="m9"><mml:mtable columnalign="right left right left right left right left right left right left" rowspacing="3pt" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" displaystyle="true"><mml:mtr><mml:mtd><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">v</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd><mml:mtd><mml:mi/><mml:mo>=</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>2</mml:mn><mml:mi>D</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mtable rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd><mml:mi>cos</mml:mi><mml:mo>⁡</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:msub><mml:mi>θ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>sin</mml:mi><mml:mo>⁡</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:msub><mml:mi>θ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable><mml:mo>]</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p>Finally position, <inline-formula><mml:math id="inf32"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula>, is updated by integrating along the total velocity vector to give a continuous and smooth, but over long time periods random, motion trajectory.<disp-formula id="equ10"><label>(10)</label><mml:math id="m10"><mml:mtable columnalign="right left right left right left right left right left right left" rowspacing="3pt" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" displaystyle="true"><mml:mtr><mml:mtd><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd><mml:mtd><mml:mi/><mml:mo>=</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mi>d</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">v</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>d</mml:mi><mml:mi>t</mml:mi><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p></sec><sec id="s4-1-1-2"><title>1D motion</title><p>Motion in 1D is more simple than motion in 2D. Velocity is also modelled as an Ornstein Uhlenbeck process without the Rayleigh transform. In this case a non-zero mean, <inline-formula><mml:math id="inf33"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>μ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula>, corresponding to directional bias in the motion, can be provided by the user. In summary:<disp-formula id="equ11"><label>(11)</label><mml:math id="m11"><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mn>1</mml:mn><mml:mi>D</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∼</mml:mo><mml:msub><mml:mi mathvariant="normal">X</mml:mi><mml:mrow><mml:msub><mml:mi>τ</mml:mi><mml:mi mathvariant="normal">v</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mi mathvariant="normal">v</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>μ</mml:mi><mml:mi mathvariant="normal">v</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula><disp-formula id="equ12"><label>(12)</label><mml:math id="m12"><mml:mrow><mml:mi>x</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mi>d</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mi>D</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>d</mml:mi><mml:mi>t</mml:mi><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p></sec></sec></sec><sec id="s4-2"><title>External velocity control</title><p>It is possible to provide an external velocity signal controlling the <monospace>Agent</monospace>’s motion. After the random motion update (as described above) is applied, if an external velocity <inline-formula><mml:math id="inf34"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">v</mml:mi></mml:mrow></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>drift</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> is provided by the user, an additional update to the velocity vector is performed<disp-formula id="equ13"><label>(13)</label><mml:math id="m13"><mml:mi>d</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">v</mml:mi></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:msub><mml:mi>τ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>drift</mml:mtext></mml:mrow></mml:mrow></mml:msub></mml:mfrac><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">v</mml:mi></mml:mrow></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>drift</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">v</mml:mi></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mi>d</mml:mi><mml:mi>t</mml:mi><mml:mo>.</mml:mo></mml:math></disp-formula></p><p>In cases where <inline-formula><mml:math id="inf35"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>τ</mml:mi><mml:mrow><mml:mrow><mml:mtext>drift</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo>&gt;&gt;</mml:mo><mml:msub><mml:mi>τ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mstyle></mml:mrow></mml:mstyle></mml:math></inline-formula> the net update to the velocity (random update and drift update) is dominated by the random component. When <inline-formula><mml:math id="inf36"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>τ</mml:mi><mml:mrow><mml:mrow><mml:mtext>drift</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo>&lt;&lt;</mml:mo><mml:msub><mml:mi>τ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mstyle></mml:mrow></mml:mstyle></mml:math></inline-formula> the update is dominated by the drift component. We define <inline-formula><mml:math id="inf37"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>τ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>drift</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo>:=</mml:mo><mml:msub><mml:mi>τ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>/</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:mstyle></mml:math></inline-formula> where <inline-formula><mml:math id="inf38"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>k</mml:mi></mml:mstyle></mml:math></inline-formula> is an argument also provided by the user. To good approximation for large <inline-formula><mml:math id="inf39"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>k</mml:mi><mml:mo>&gt;&gt;</mml:mo><mml:mn>1</mml:mn></mml:mstyle></mml:mrow></mml:mstyle></mml:math></inline-formula> the <monospace>Agent</monospace> velocity closely tracks the drift velocity at all times and is not random whilst for <inline-formula><mml:math id="inf40"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>k</mml:mi><mml:mo>&lt;&lt;</mml:mo><mml:mn>1</mml:mn></mml:mstyle></mml:mrow></mml:mstyle></mml:math></inline-formula> the drift velocity is ignored and the motion is entirely random.</p></sec><sec id="s4-3"><title>Motion near walls in 2D</title><p>An important feature is the ability to generate <monospace>Environment</monospace>s with arbitrary arrangements of walls (aka ‘barriers’ or ‘boundaries’). Walls are meaningful only if they appropriately constrain the motion of the <monospace>Agent</monospace>. For biological agents this means three things:</p><list list-type="order"><list-item><p>The <monospace>Agent</monospace> cannot travel through a wall.</p></list-item><list-item><p>The <monospace>Agent</monospace> slows down upon approaching a wall to avoid a full-speed collision.</p></list-item><list-item><p>There may be a bias called “thigmotaxis” for the <monospace>Agent</monospace> to stay near walls.</p></list-item></list><p>Our motion model replicates these three effects as follows:</p><sec id="s4-3-1"><title>Collision detection</title><p>To avoid travelling through walls, if a collision is detected the velocity is elastically reflected off the wall (normal component is flipped). The speed is then scaled to one half the average motion speed, <inline-formula><mml:math id="inf41"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>2</mml:mn><mml:mi>D</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0.5</mml:mn><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula>.</p></sec><sec id="s4-3-2"><title>Wall repulsion</title><p><bold>Spring-deceleration model.</bold> In order to slow down <italic>before</italic> colliding with a wall the <monospace>Agent</monospace> feels an acceleration, perpendicular to the wall, whenever it is within a small distance, <inline-formula><mml:math id="inf42"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>d</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>wall</mml:mtext></mml:mrow></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula>, of the wall.<disp-formula id="equ14"><label>(14)</label><mml:math id="m14"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">v</mml:mi></mml:mrow><mml:mo>˙</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>k</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mrow><mml:mtext>walls</mml:mtext></mml:mrow><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi mathvariant="bold">n</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>{</mml:mo><mml:mtable rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd><mml:mfrac><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>⋅</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:msubsup><mml:mi>d</mml:mi><mml:mrow><mml:mrow><mml:mtext>wall</mml:mtext></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:mfrac><mml:mo>⋅</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mrow><mml:mtext>wall</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mo>⊥</mml:mo><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mtd><mml:mtd><mml:mtext>if </mml:mtext><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mo>⊥</mml:mo><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mrow><mml:mtext>wall</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mrow><mml:mtext>if </mml:mtext></mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mo>⊥</mml:mo><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&gt;</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mrow><mml:mtext>wall</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable><mml:mo fence="true" stretchy="true" symmetric="true"/></mml:mrow></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p><inline-formula><mml:math id="inf43"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>d</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>⊥</mml:mo><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> is the perpendicular distance from the <monospace>Agent</monospace> to the <inline-formula><mml:math id="inf44"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mi>j</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>th</mml:mtext></mml:mrow></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula> wall, <inline-formula><mml:math id="inf45"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">n</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> is the perpendicular norm of the <inline-formula><mml:math id="inf46"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mi>j</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>th</mml:mtext></mml:mrow></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula> wall (the norm pointing towards the <monospace>Agent</monospace>) and <inline-formula><mml:math id="inf47"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>k</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> &amp; <inline-formula><mml:math id="inf48"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>s</mml:mi></mml:mstyle></mml:math></inline-formula> are constants (explained later). <inline-formula><mml:math id="inf49"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>d</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>wall</mml:mtext></mml:mrow></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> is the distance from the wall at which the <monospace>Agent</monospace> starts to feel the deceleration, defaulting to <inline-formula><mml:math id="inf50"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>d</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>wall</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0.1</mml:mn></mml:mstyle></mml:math></inline-formula> m.</p><p>Note that this acceleration is identical to that of an oscillating spring-mass where the base of the spring is attached a distance <inline-formula><mml:math id="inf51"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>d</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>wall</mml:mtext></mml:mrow></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> from the wall on a perpendicular passing through the <monospace>Agent</monospace>. The spring constant is tuned such that a mass starting with initial velocity towards the wall of <inline-formula><mml:math id="inf52"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mo>−</mml:mo><mml:mi>s</mml:mi><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">n</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> would stop <italic>just</italic> before the wall. In summary, for <inline-formula><mml:math id="inf53"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>k</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mstyle></mml:math></inline-formula>, if the <monospace>Agent</monospace> approaches the wall head-on at speed of <inline-formula><mml:math id="inf54"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>s</mml:mi><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> (<inline-formula><mml:math id="inf55"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>s</mml:mi></mml:mstyle></mml:math></inline-formula> times its mean speed) this deceleration will just be enough to avoid a collision.</p><p><inline-formula><mml:math id="inf56"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>s</mml:mi></mml:mstyle></mml:math></inline-formula> is the unitless wall repel strength parameter (default <inline-formula><mml:math id="inf57"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mstyle></mml:math></inline-formula>). When it is high, walls repel the agent strongly (only fast initial speeds will result in the agent reaching the wall) and when it is low, walls repel weakly (even very slow initial speeds will not be slowed done by the spring dynamics). When <inline-formula><mml:math id="inf58"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mstyle></mml:math></inline-formula> wall repulsion is turned off entirely.</p><p><bold>Conveyor-belt model.</bold> A second (similar, but not exactly equivalent) way to slow down motion near a wall is to consider a hypothetical conveyor belt near the wall. This conveyor belt has a non-uniform velocity pointing away from the wall of<disp-formula id="equ15"><label>(15)</label><mml:math id="m15"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo>˙</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>k</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mrow><mml:mtext>walls</mml:mtext></mml:mrow><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi mathvariant="bold">n</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>{</mml:mo><mml:mtable rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd><mml:mi>s</mml:mi><mml:mo>⋅</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mrow><mml:mo maxsize="2.047em" minsize="2.047em">(</mml:mo></mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msqrt><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mrow><mml:mtext>wall</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mo>⊥</mml:mo><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:msubsup><mml:mi>d</mml:mi><mml:mrow><mml:mrow><mml:mtext>wall</mml:mtext></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:mfrac></mml:msqrt><mml:mrow><mml:mo maxsize="2.047em" minsize="2.047em">)</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mtext>if </mml:mtext><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mo>⊥</mml:mo><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mrow><mml:mtext>wall</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mrow><mml:mtext>if </mml:mtext></mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mo>⊥</mml:mo><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&gt;</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mrow><mml:mtext>wall</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable><mml:mo fence="true" stretchy="true" symmetric="true"/></mml:mrow></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>When the <monospace>Agent</monospace> is close to the wall the hypothetical conveyor-belt moves it backwards on each time step, effectively slowing it down. Note that this velocity is identical to that of a spring-mass attached to the wall with initial velocity <inline-formula><mml:math id="inf59"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>s</mml:mi><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">n</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> away from the wall and spring constant tuned to stop the mass just before it reaches a distance <inline-formula><mml:math id="inf60"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>d</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>wall</mml:mtext></mml:mrow></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula>. In summary, for <inline-formula><mml:math id="inf61"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>k</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mstyle></mml:math></inline-formula>, if the <monospace>Agent</monospace> approaches the wall head-on at speed of <inline-formula><mml:math id="inf62"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>s</mml:mi><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> the conveyor belt will just be fast enough to bring it to a halt at the location of the wall.</p><p><bold>Wall attraction (thigmotaxis).</bold> Although similar, there is an exploitable difference between the ‘spring-deceleration’ and ‘conveyor-belt’ models: the ‘conveyor-belt’ changes the <monospace>Agent</monospace>s position, <inline-formula><mml:math id="inf63"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula>, on each step but not its internal velocity variable <inline-formula><mml:math id="inf64"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">v</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula>. As as result (and as the conveyor-belt intuition suggests) it will slow down the <monospace>Agent</monospace>’s approach towards the wall without causing it to turn around. This creates a ‘lingering’ or ‘thigmotactic’ effect whereby whenever the <monospace>Agent</monospace> heads towards a wall it may carry on doing so, without collision, for some time until the stochastic processes governing its motion (section ‘Temporally continuous random motion’) cause it to turn. Conversely the ‘spring-deceleration’ model has no ‘thigmotactic’ effect since it actively changes the internal velocity variable causing the <monospace>Agent</monospace> to turn around or ‘bounce’ off the walls.</p><p>The relative strengths of these two effects, <inline-formula><mml:math id="inf65"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>k</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> and <inline-formula><mml:math id="inf66"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>k</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula>, are controlled by a single thigmotaxis parameter, <inline-formula><mml:math id="inf67"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>λ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>thig</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula> which governs the trade-off between these two models.<disp-formula id="equ16"><label>(16)</label><mml:math id="m16"><mml:msub><mml:mi>k</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>λ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>thig</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mn>2</mml:mn></mml:msup><mml:mo>,</mml:mo><mml:mspace width="10mm"/><mml:msub><mml:mi>k</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>6</mml:mn><mml:msubsup><mml:mi>λ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>thig</mml:mtext></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mo>.</mml:mo></mml:math></disp-formula></p><p>When <inline-formula><mml:math id="inf68"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>λ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>thig</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mstyle></mml:math></inline-formula> only the conveyor belt model is active giving a strong thigmotactic effects. When <inline-formula><mml:math id="inf69"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>λ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>thig</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mstyle></mml:math></inline-formula> only the spring-deceleration model is active giving no thigmotactic effect. By default <inline-formula><mml:math id="inf70"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>λ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>thig</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0.5</mml:mn></mml:mstyle></mml:math></inline-formula>. The constants 3 and 6 are tuning parameters chosen by hand in order that direct collisions with the walls are rare but not impossible.</p><p>Although this procedure, intended to smoothly slow the <monospace>Agent</monospace> near a wall, may seem complex, it has a two advantages: Firstly, deceleration near walls is smooth, becoming stronger as the <monospace>Agent</monospace> gets nearer and so induces no physically implausible discontinuities in the velocity. Secondly, it provides a tunable way by which to control the amount of thigmotaxis (evidenced in <xref ref-type="fig" rid="fig2">Figure 2c, d</xref>). Recall that these equations only apply to motion very near the wall (<inline-formula><mml:math id="inf71"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mo>&lt;</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mrow><mml:mtext>wall</mml:mtext></mml:mrow></mml:mrow></mml:msub></mml:mstyle></mml:mrow></mml:mstyle></mml:math></inline-formula>) and they can be turned off entirely (<inline-formula><mml:math id="inf72"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mstyle></mml:math></inline-formula>) (see Table 1, below).</p></sec></sec><sec id="s4-4"><title>Importing trajectories</title><p>Users can override the random motion model by importing their own trajectory with <monospace>Agent.import_trajectory(times,positions)</monospace> where times is an array of times (not necessarily evenly spaced) and positions is an array of positions at each time. The trajectory is then interpolated using scipy.interpolate’s interp1d function following which the standard RatInABox <monospace>Agent.update(dt)</monospace> API is called to move the <monospace>Agent</monospace> to a new position a time dt along the imported trajectory.</p><p>When moving along imported trajectories the <monospace>Agent</monospace> will not be subject to the wall repel nor wall collision effects described above.</p></sec><sec id="s4-5"><title>Head direction</title><p>As well as position and velocity <monospace>Agent</monospace>s have a head direction, <inline-formula><mml:math id="inf73"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">h</mml:mi></mml:mrow><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula>. Head direction is used by various cell types to determine firing rate including <monospace>HeadDirectionCells</monospace> and (egocentric) <monospace>VectorCells</monospace>. By default, head direction is just the smoothed-then-normalised velocity vector, updated on each timestep as follows:<disp-formula id="equ17"><label>(17)</label><mml:math id="m17"><mml:mtable columnalign="right left right left right left right left right left right left" rowspacing="3pt" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" displaystyle="true"><mml:mtr><mml:mtd><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">h</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow><mml:msub><mml:mi>τ</mml:mi><mml:mi>h</mml:mi></mml:msub></mml:mfrac><mml:mo>)</mml:mo></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">h</mml:mi></mml:mrow><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow><mml:msub><mml:mi>τ</mml:mi><mml:mi>h</mml:mi></mml:msub></mml:mfrac><mml:mfrac><mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">v</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">v</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo fence="false" stretchy="false">‖</mml:mo></mml:mrow></mml:mfrac></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula><disp-formula id="equ18"><label>(18)</label><mml:math id="m18"><mml:mtable columnalign="right left right left right left right left right left right left" rowspacing="3pt" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" displaystyle="true"><mml:mtr><mml:mtd><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">h</mml:mi></mml:mrow><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">h</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">h</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo fence="false" stretchy="false">‖</mml:mo></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p>By default the amount of smoothing is very small (in 2D <inline-formula><mml:math id="inf74"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>τ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>h</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0.15</mml:mn></mml:mstyle></mml:math></inline-formula>, in 1D there is no smoothing at all) meaning that, to a good approximation, head direction is simply the normalised velocity vector at time <inline-formula><mml:math id="inf75"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>t</mml:mi></mml:mstyle></mml:math></inline-formula>, <inline-formula><mml:math id="inf76"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">h</mml:mi></mml:mrow><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≈</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">v</mml:mi></mml:mrow><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula>. However by storing head direction as an independent variable, we make available the possibility for users to craft their own, potenitally more complex, head direction dynamics if desired.</p><p>We also define the head direction angle <inline-formula><mml:math id="inf77"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>ϕ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>h</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> aka. the angle of head direction vector measured clockwise from the x-axis.</p></sec><sec id="s4-6"><title>Distance measures</title><p>In many of the cell models, it is necessary to calculate the ‘distance’ between two locations in the <monospace>Environment</monospace> (for example to calculate the firing rate of a Gaussian <monospace>PlaceCell</monospace>). This might depend on the type of geometry being used and the arrangement of walls in the <monospace>Environment</monospace>. There are three types of geometry currently supported:<disp-formula id="equ19"><label>(19)</label><mml:math id="m19"><mml:mrow><mml:mrow><mml:mi mathvariant="monospace">e</mml:mi><mml:mi mathvariant="monospace">u</mml:mi><mml:mi mathvariant="monospace">c</mml:mi><mml:mi mathvariant="monospace">l</mml:mi><mml:mi mathvariant="monospace">i</mml:mi><mml:mi mathvariant="monospace">d</mml:mi><mml:mi mathvariant="monospace">e</mml:mi><mml:mi mathvariant="monospace">a</mml:mi><mml:mi mathvariant="monospace">n</mml:mi></mml:mrow><mml:mo>:</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo fence="false" stretchy="false">‖</mml:mo></mml:mrow></mml:math></disp-formula><disp-formula id="equ20"><label>(20)</label><mml:math id="m20"><mml:mrow><mml:mrow><mml:mi mathvariant="monospace">g</mml:mi><mml:mi mathvariant="monospace">e</mml:mi><mml:mi mathvariant="monospace">o</mml:mi><mml:mi mathvariant="monospace">d</mml:mi><mml:mi mathvariant="monospace">e</mml:mi><mml:mi mathvariant="monospace">s</mml:mi><mml:mi mathvariant="monospace">i</mml:mi><mml:mi mathvariant="monospace">c</mml:mi></mml:mrow><mml:mo>:</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mrow><mml:mtext>length of shortest wall-avoiding path between </mml:mtext><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mtext> and </mml:mtext><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula><disp-formula id="equ21"><label>(21)</label><mml:math id="m21"><mml:mrow><mml:mrow><mml:mi mathvariant="monospace">l</mml:mi><mml:mi mathvariant="monospace">i</mml:mi><mml:mi mathvariant="monospace">n</mml:mi><mml:mi mathvariant="monospace">e</mml:mi></mml:mrow><mml:mi mathvariant="normal">_</mml:mi><mml:mrow><mml:mi mathvariant="monospace">o</mml:mi><mml:mi mathvariant="monospace">f</mml:mi></mml:mrow><mml:mi mathvariant="normal">_</mml:mi><mml:mrow><mml:mi mathvariant="monospace">s</mml:mi><mml:mi mathvariant="monospace">i</mml:mi><mml:mi mathvariant="monospace">g</mml:mi><mml:mi mathvariant="monospace">h</mml:mi><mml:mi mathvariant="monospace">t</mml:mi></mml:mrow><mml:mo>:</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mtable columnalign="left left" rowspacing=".2em" columnspacing="1em" displaystyle="false"><mml:mtr><mml:mtd><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mo>,</mml:mo></mml:mtd><mml:mtd><mml:mrow><mml:mtext>if no wall obstructs the straight line between </mml:mtext><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mtext> and </mml:mtext><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi mathvariant="normal">∞</mml:mi><mml:mo>,</mml:mo></mml:mtd><mml:mtd><mml:mrow><mml:mtext>otherwise</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable><mml:mo fence="true" stretchy="true" symmetric="true"/></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>By default RatInABox typically uses geodesic distance, except in <monospace>Environment</monospace>s with more than one additional wall where calculating the shortest path becomes computationally expensive. In these cases, <monospace>line_of_sight</monospace> distance is typically used instead. Furthermore, in <monospace>Environment</monospace>s with periodic boundary conditions these distance measures will respect the periodicity by always using the shortest path between two points, wrapping around boundaries if necessary. These geometry considerations are what allow RatInABox cell classes to interact sensibly with walls (e.g. by default place cells won’t bleed through walls, as observed in the brain). Hereon we refer to this as the ‘environmental-distance’.</p></sec><sec id="s4-7"><title>Cell models</title><p>In the following section, we list mathematical models for some of the default provided <monospace>Neurons</monospace> subclasses, including all those covered in this manuscript. More cell types and documentation can be found on the codebase. Readers will note that, oftentimes, parameters are set randomly at the point of initialisation (e.g. where the place cells are located, the orientation of grid cells, the angular preference of boundary vector cells etc.). Many of these random parameters are all set as class attributes and so can be redefined after initialisation if necessary. For simplicity here we describe default behaviour only – the default values for all parameters and how to change them are given in Table 1, below.</p><p><bold>Maximum and minimum firing rates.</bold> For most cell classes it is also possible to set their maximum and minimum firing rates (<inline-formula><mml:math id="inf78"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>f</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>max</mml:mtext></mml:mrow></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula>, <inline-formula><mml:math id="inf79"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>f</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>min</mml:mtext></mml:mrow></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula>). For simplicity, the formulae provided below are written such that they have a maximum firing rate of 1.0 Hz and minimum firing rate of 0.0 Hz but readers should be aware that after evaluation these firing rates are linearly scaled according to<disp-formula id="equ22"><label>(22)</label><mml:math id="m22"><mml:mi>F</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">←</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>max</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>min</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mi>F</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>min</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:math></disp-formula></p><p><bold>Noise.</bold> By default all <monospace>Neurons</monospace> are noiseless with their firing rates entirely determined by the deterministic mathematical models given below. Smooth Ornstein Uhlenbeck sampled random noise of coherence timescale <inline-formula><mml:math id="inf80"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>τ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>η</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> and magnitude <inline-formula><mml:math id="inf81"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>η</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> can be added:<disp-formula id="equ23"><label>(23)</label><mml:math id="m23"><mml:mtable columnalign="right left right left right left right left right left right left" rowspacing="3pt" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" displaystyle="true"><mml:mtr><mml:mtd><mml:mi>η</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∼</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">X</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:msub><mml:mi>τ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>η</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>η</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula><disp-formula id="equ24"><label>(24)</label><mml:math id="m24"><mml:mtable columnalign="right left right left right left right left right left right left" rowspacing="3pt" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" displaystyle="true"><mml:mtr><mml:mtd><mml:mi>F</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">←</mml:mo><mml:mi>F</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>η</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p><bold>Rates vs. Spikes.</bold> RatInABox <monospace>Neurons</monospace> are fundamentally rate-based. This means that their firing rate is a continuous function of time. Simultaneously, at every time-step, spikes are sampled from this firing rate and saved into the history dataframe in case spiking data is required:<disp-formula id="equ25"><label>(25)</label><mml:math id="m25"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi mathvariant="normal">P</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="monospace">N</mml:mi><mml:mi mathvariant="monospace">e</mml:mi><mml:mi mathvariant="monospace">u</mml:mi><mml:mi mathvariant="monospace">r</mml:mi><mml:mi mathvariant="monospace">o</mml:mi><mml:mi mathvariant="monospace">n</mml:mi></mml:mrow></mml:mrow><mml:mspace width="thinmathspace"/><mml:mi>i</mml:mi><mml:mspace width="thinmathspace"/><mml:mrow><mml:mi mathvariant="normal">s</mml:mi><mml:mi mathvariant="normal">p</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">k</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">s</mml:mi><mml:mspace width="thinmathspace"/><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">n</mml:mi></mml:mrow></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>d</mml:mi><mml:mi>t</mml:mi><mml:mo>.</mml:mo></mml:mstyle></mml:mrow></mml:math></disp-formula></p><sec id="s4-7-1"><title><monospace>PlaceCells</monospace></title><p>A set of locations (the centre of the place fields), <inline-formula><mml:math id="inf82"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mo fence="false" stretchy="false">{</mml:mo><mml:msubsup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>PC</mml:mtext></mml:mrow></mml:mrow></mml:msubsup><mml:mo fence="false" stretchy="false">}</mml:mo></mml:mstyle></mml:math></inline-formula>, is randomly sampled from the <monospace>Environment</monospace>. By default these locations sit on a grid uniformly spanning the <monospace>Environment</monospace> to which a small amount of random jitter, half the scale of the sampled grid, is added. Thus, place cell locations appear ‘random’ but initialising in this way ensures all parts of the <monospace>Environment</monospace> are approximately evenly covered with the same density of place fields.</p><p>The environmental-distance from the <monospace>Agent</monospace> to the place field centres is calculated (<inline-formula><mml:math id="inf83"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mtext>PC</mml:mtext></mml:mrow></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:mrow></mml:mstyle></mml:math></inline-formula>). The firing rate is then determined by one of the following functions (defaulting to <inline-formula><mml:math id="inf84"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mi>F</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>{gaussian}</mml:mtext></mml:mrow></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula>):<disp-formula id="equ26"><label>(26)</label><mml:math id="m26"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mtable columnalign="right left right left right left right left right left right left" rowspacing="3pt" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" displaystyle="true"><mml:mtr><mml:mtd><mml:msubsup><mml:mi>F</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="monospace">g</mml:mi><mml:mi mathvariant="monospace">a</mml:mi><mml:mi mathvariant="monospace">u</mml:mi><mml:mi mathvariant="monospace">s</mml:mi><mml:mi mathvariant="monospace">s</mml:mi><mml:mi mathvariant="monospace">i</mml:mi><mml:mi mathvariant="monospace">a</mml:mi><mml:mi mathvariant="monospace">n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd><mml:mtd><mml:mi/><mml:mo>=</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:msubsup><mml:mi>d</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mn>2</mml:mn><mml:msubsup><mml:mi>w</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:msup></mml:mtd></mml:mtr></mml:mtable></mml:mstyle></mml:mrow></mml:math></disp-formula><disp-formula id="equ27"><label>(27)</label><mml:math id="m27"><mml:mrow><mml:msubsup><mml:mi>F</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="monospace">g</mml:mi><mml:mi mathvariant="monospace">a</mml:mi><mml:mi mathvariant="monospace">u</mml:mi><mml:mi mathvariant="monospace">s</mml:mi><mml:mi mathvariant="monospace">s</mml:mi><mml:mi mathvariant="monospace">i</mml:mi><mml:mi mathvariant="monospace">a</mml:mi><mml:mi mathvariant="monospace">n</mml:mi><mml:mi mathvariant="monospace">_</mml:mi><mml:mi mathvariant="monospace">t</mml:mi><mml:mi mathvariant="monospace">h</mml:mi><mml:mi mathvariant="monospace">r</mml:mi><mml:mi mathvariant="monospace">e</mml:mi><mml:mi mathvariant="monospace">s</mml:mi><mml:mi mathvariant="monospace">h</mml:mi><mml:mi mathvariant="monospace">o</mml:mi><mml:mi mathvariant="monospace">l</mml:mi><mml:mi mathvariant="monospace">d</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow><mml:mrow><mml:mo maxsize="2.047em" minsize="2.047em">(</mml:mo></mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:msubsup><mml:mi>d</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mn>2</mml:mn><mml:msubsup><mml:mi>w</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:msup><mml:mo>−</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfrac><mml:mrow><mml:mo maxsize="2.047em" minsize="2.047em">)</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula><disp-formula id="equ28"><label>(28)</label><mml:math id="m28"><mml:mrow><mml:msubsup><mml:mi>F</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="monospace">d</mml:mi><mml:mi mathvariant="monospace">i</mml:mi><mml:mi mathvariant="monospace">f</mml:mi><mml:mi mathvariant="monospace">f</mml:mi><mml:mi mathvariant="monospace">_</mml:mi><mml:mi mathvariant="monospace">o</mml:mi><mml:mi mathvariant="monospace">f</mml:mi><mml:mi mathvariant="monospace">_</mml:mi><mml:mi mathvariant="monospace">g</mml:mi><mml:mi mathvariant="monospace">a</mml:mi><mml:mi mathvariant="monospace">u</mml:mi><mml:mi mathvariant="monospace">s</mml:mi><mml:mi mathvariant="monospace">s</mml:mi><mml:mi mathvariant="monospace">i</mml:mi><mml:mi mathvariant="monospace">a</mml:mi><mml:mi mathvariant="monospace">n</mml:mi><mml:mi mathvariant="monospace">s</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>;</mml:mo><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:mn>1.5</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:msubsup><mml:mi>d</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mn>2</mml:mn><mml:msubsup><mml:mi>w</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:msup><mml:mo>−</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:msup><mml:mi>r</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:msubsup><mml:mi>d</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mn>2</mml:mn><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:msub><mml:mi>w</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:msup><mml:mi>r</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula><disp-formula id="equ29"><label>(29)</label><mml:math id="m29"><mml:mrow><mml:msubsup><mml:mi>F</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="monospace">t</mml:mi><mml:mi mathvariant="monospace">o</mml:mi><mml:mi mathvariant="monospace">p</mml:mi><mml:mi mathvariant="monospace">_</mml:mi><mml:mi mathvariant="monospace">h</mml:mi><mml:mi mathvariant="monospace">a</mml:mi><mml:mi mathvariant="monospace">t</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mtable columnalign="left left" rowspacing=".2em" columnspacing="1em" displaystyle="false"><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mtext>if </mml:mtext><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mrow><mml:mtext>otherwise</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable><mml:mo fence="true" stretchy="true" symmetric="true"/></mml:mrow></mml:mrow></mml:math></disp-formula><disp-formula id="equ30"><label>(30)</label><mml:math id="m30"><mml:mrow><mml:msubsup><mml:mi>F</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="monospace">o</mml:mi><mml:mi mathvariant="monospace">n</mml:mi><mml:mi mathvariant="monospace">e</mml:mi><mml:mi mathvariant="monospace">_</mml:mi><mml:mi mathvariant="monospace">h</mml:mi><mml:mi mathvariant="monospace">o</mml:mi><mml:mi mathvariant="monospace">t</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>δ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>==</mml:mo><mml:msub><mml:mrow><mml:mtext>argmin</mml:mtext></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p><p>Where used, <inline-formula><mml:math id="inf85"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>w</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> is the user-provided radius (aka. width) of the place cells (defaulting to 0.2 m).</p></sec><sec id="s4-7-2"><title><monospace>GridCells</monospace></title><p>Each grid cell is assigned a random wave direction <inline-formula><mml:math id="inf86"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>θ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>∼</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi class="MJX-tex-caligraphic" mathvariant="script">U</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula>, gridscale <inline-formula><mml:math id="inf87"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>λ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>∼</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi class="MJX-tex-caligraphic" mathvariant="script">U</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo stretchy="false">[</mml:mo><mml:mn>0.5</mml:mn><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext> m</mml:mtext></mml:mrow><mml:mo>,</mml:mo><mml:mn>1.0</mml:mn><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext> m</mml:mtext></mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> and phase offset <inline-formula><mml:math id="inf88"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>ϕ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>∼</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi class="MJX-tex-caligraphic" mathvariant="script">U</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow><mml:mo>[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula>. The firing rate of each grid cell is given by the thresholded sum of three cosines<disp-formula id="equ31"><label>(31)</label><mml:math id="m31"><mml:msub><mml:mi>F</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>3</mml:mn></mml:mfrac><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>max</mml:mtext></mml:mrow><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="2.470em" minsize="2.470em">(</mml:mo></mml:mrow></mml:mstyle><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>cos</mml:mi><mml:mo>⁡</mml:mo><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="2.047em" minsize="2.047em">(</mml:mo></mml:mrow></mml:mstyle><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mfrac><mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⋅</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">e</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:msub><mml:mi>θ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow><mml:msub><mml:mi>λ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mfrac><mml:mo>+</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="2.047em" minsize="2.047em">)</mml:mo></mml:mrow></mml:mstyle><mml:mo>+</mml:mo><mml:mi>cos</mml:mi><mml:mo>⁡</mml:mo><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="2.047em" minsize="2.047em">(</mml:mo></mml:mrow></mml:mstyle><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mfrac><mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⋅</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">e</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:msub><mml:mi>θ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>π</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>/</mml:mo></mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:msub><mml:mi>λ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mfrac><mml:mo>+</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="2.047em" minsize="2.047em">)</mml:mo></mml:mrow></mml:mstyle><mml:mo>+</mml:mo><mml:mi>cos</mml:mi><mml:mo>⁡</mml:mo><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="2.047em" minsize="2.047em">(</mml:mo></mml:mrow></mml:mstyle><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mfrac><mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⋅</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">e</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:msub><mml:mi>θ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>/</mml:mo></mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:msub><mml:mi>λ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mfrac><mml:mo>+</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="2.047em" minsize="2.047em">)</mml:mo></mml:mrow></mml:mstyle><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="2.470em" minsize="2.470em">)</mml:mo></mml:mrow></mml:mstyle><mml:mo>.</mml:mo></mml:math></disp-formula></p><p><inline-formula><mml:math id="inf89"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">e</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>θ</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> is the unit vector pointing in the direction <inline-formula><mml:math id="inf90"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>θ</mml:mi></mml:mstyle></mml:math></inline-formula>. We also provide a shifted (as opposed to rectified) sum of three cosines grid cell resulting in softer grid fields<disp-formula id="equ32"><label>(32)</label><mml:math id="m32"><mml:msub><mml:mi>F</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>2</mml:mn><mml:mn>3</mml:mn></mml:mfrac><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="2.470em" minsize="2.470em">(</mml:mo></mml:mrow></mml:mstyle><mml:mfrac><mml:mn>1</mml:mn><mml:mn>3</mml:mn></mml:mfrac><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="2.047em" minsize="2.047em">(</mml:mo></mml:mrow></mml:mstyle><mml:mi>cos</mml:mi><mml:mo>⁡</mml:mo><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="2.047em" minsize="2.047em">(</mml:mo></mml:mrow></mml:mstyle><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mfrac><mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⋅</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">e</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:msub><mml:mi>θ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow><mml:msub><mml:mi>λ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mfrac><mml:mo>+</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="2.047em" minsize="2.047em">)</mml:mo></mml:mrow></mml:mstyle><mml:mo>+</mml:mo><mml:mi>cos</mml:mi><mml:mo>⁡</mml:mo><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="2.047em" minsize="2.047em">(</mml:mo></mml:mrow></mml:mstyle><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mfrac><mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⋅</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">e</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:msub><mml:mi>θ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>π</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>/</mml:mo></mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:msub><mml:mi>λ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mfrac><mml:mo>+</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="2.047em" minsize="2.047em">)</mml:mo></mml:mrow></mml:mstyle><mml:mo>+</mml:mo><mml:mi>cos</mml:mi><mml:mo>⁡</mml:mo><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="2.047em" minsize="2.047em">(</mml:mo></mml:mrow></mml:mstyle><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mfrac><mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⋅</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">e</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:msub><mml:mi>θ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>/</mml:mo></mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:msub><mml:mi>λ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mfrac><mml:mo>+</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="2.047em" minsize="2.047em">)</mml:mo></mml:mrow></mml:mstyle><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="2.047em" minsize="2.047em">)</mml:mo></mml:mrow></mml:mstyle><mml:mo>+</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="2.470em" minsize="2.470em">)</mml:mo></mml:mrow></mml:mstyle></mml:math></disp-formula></p><p><inline-formula><mml:math id="inf91"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">e</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>θ</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> is the unit vector pointing in the direction <inline-formula><mml:math id="inf92"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>θ</mml:mi></mml:mstyle></mml:math></inline-formula>.</p></sec><sec id="s4-7-3"><title><monospace>VectorCells</monospace> (parent class only)</title><p><monospace>VectorCells</monospace> subclasses include <monospace>BoundaryVectorCells</monospace>, <monospace>ObjectVectorCells</monospace> and <monospace>AgentVectorCells</monospace> as well as <monospace>FieldOfView</monospace> versions of these three classes. The common trait amongst all types of <monospace>VectorCell</monospace> is that each cell is responsive to a <italic>feature</italic> of the environment (boundary segments, objects, other agents) at a preferred distance and angle. The firing rate of each vector cell is given by the product of two functions; a Gaussian radial function and a von Mises angular function. When the agent is a euclidean distance <inline-formula><mml:math id="inf93"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> from the feature, at an angle <inline-formula><mml:math id="inf94"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>ϕ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> the contribution of that feature to the total firing rate is given by<disp-formula id="equ33"><label>(33)</label><mml:math id="m33"><mml:msub><mml:mi>g</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>θ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="2.047em" minsize="2.047em">(</mml:mo></mml:mrow></mml:mstyle><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:msubsup><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>d</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mfrac><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="2.047em" minsize="2.047em">)</mml:mo></mml:mrow></mml:mstyle><mml:mo>⋅</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>VM</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>ϕ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:msub><mml:mi>ϕ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>κ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math></disp-formula></p><p>where <inline-formula><mml:math id="inf95"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>f</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>VM</mml:mtext></mml:mrow></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> is the radial von Mises distribution (a generalisation of a Gaussian for periodic variables)<disp-formula id="equ34"><label>(34)</label><mml:math id="m34"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mrow><mml:mtext>VM</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>ϕ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mo maxsize="1.2em" minsize="1.2em">|</mml:mo></mml:mrow><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>κ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>:=</mml:mo><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>κ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mi>cos</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>ϕ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>Total firing rate is calculated by summing/integrating these contributions over all features in the <monospace>Environment</monospace> as described in the following sections. Distance and angular tuning parameters and defined/sampled as follows:</p><list list-type="bullet"><list-item><p><inline-formula><mml:math id="inf96"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>d</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> is the distance tuning of the vector cell. By default <inline-formula><mml:math id="inf97"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>d</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>∼</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi class="MJX-tex-caligraphic" mathvariant="script">U</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo stretchy="false">[</mml:mo><mml:mn>0.05</mml:mn><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext> m</mml:mtext></mml:mrow><mml:mo>,</mml:mo><mml:mn>0.3</mml:mn><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext> m</mml:mtext></mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula></p></list-item><list-item><p><inline-formula><mml:math id="inf98"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>d</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> is the distance tuning width. By default this increases linearly as a function of <inline-formula><mml:math id="inf99"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>d</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula>: <inline-formula><mml:math id="inf100"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>d</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>/</mml:mo></mml:mrow><mml:mi>β</mml:mi><mml:mo>+</mml:mo><mml:mi>ξ</mml:mi></mml:mstyle></mml:math></inline-formula> for constants <inline-formula><mml:math id="inf101"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>β</mml:mi></mml:mstyle></mml:math></inline-formula> and <inline-formula><mml:math id="inf102"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>ξ</mml:mi></mml:mstyle></mml:math></inline-formula> but can be set otherwise. See Table 1, below for the values which are chosen to match those used by Cothi and Barry (<xref ref-type="bibr" rid="bib10">de Cothi and Barry, 2020</xref>).</p></list-item><list-item><p><inline-formula><mml:math id="inf103"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>ϕ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> is the angular tuning of the vector cell. By default <inline-formula><mml:math id="inf104"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>ϕ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>∼</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi class="MJX-tex-caligraphic" mathvariant="script">U</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mn>0</mml:mn><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>∘</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mn>360</mml:mn><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>∘</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula>.</p></list-item><list-item><p><inline-formula><mml:math id="inf105"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>ϕ</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> (which defines the von Mises concentration measure <inline-formula><mml:math id="inf106"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>κ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>:=</mml:mo><mml:mn>1</mml:mn><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>/</mml:mo></mml:mrow><mml:msqrt><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>ϕ</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:msqrt></mml:mstyle></mml:math></inline-formula>) is the angular tuning width of the vector cell. By default <inline-formula><mml:math id="inf107"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>ϕ</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>∼</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi class="MJX-tex-caligraphic" mathvariant="script">U</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mn>10</mml:mn><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>∘</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mn>30</mml:mn><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>∘</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula>.</p></list-item></list><p>The asymptotic equivalence between a Gaussian and a von Mises distribution (true for small angular tunings whereby von Mises distributions of concentration parameter <inline-formula><mml:math id="inf108"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>κ</mml:mi></mml:mstyle></mml:math></inline-formula> approach Gaussian distributions of variance <inline-formula><mml:math id="inf109"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>/</mml:mo></mml:mrow><mml:mi>κ</mml:mi></mml:mstyle></mml:math></inline-formula>) means this model is effectively identical to the original boundary vector cell model proposed by <xref ref-type="bibr" rid="bib19">Hartley et al., 2000</xref> but with the difference that our vector cells (BVCs included) will not show discontinuities if they have wide angular tunings of order <inline-formula><mml:math id="inf110"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mn>360</mml:mn><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>∘</mml:mo></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula>.</p><p>All vector cells can be either</p><list list-type="bullet"><list-item><p>allocentric (default): <inline-formula><mml:math id="inf111"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>ϕ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> is the angle subtended between the x-direction vector <inline-formula><mml:math id="inf112"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">e</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mstyle></mml:math></inline-formula>, and the line between the <monospace>Agent</monospace> and the feature.</p></list-item><list-item><p>egocentric: <inline-formula><mml:math id="inf113"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>ϕ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> is the angle subtended between the heading direction of the agent <inline-formula><mml:math id="inf114"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">h</mml:mi></mml:mrow><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula>, and the line between the <monospace>Agent</monospace> and the feature.</p></list-item></list></sec><sec id="s4-7-4"><title><monospace>BoundaryVectorCells</monospace></title><p>The environmental features which <monospace>BoundaryVectorCells</monospace> (BVCs) respond to are the boundary segments (walls) of the <monospace>Environment</monospace>. The total firing rate of of each cell is given by integrating (computationally we use a default value of <inline-formula><mml:math id="inf115"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>d</mml:mi><mml:mi>θ</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mn>2</mml:mn><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>∘</mml:mo></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula> to numerically approximate this integral) the contributions from the nearest line-of-sight boundary segments (walls occluded by other walls are not considered) around the full <inline-formula><mml:math id="inf116"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mn>2</mml:mn><mml:mi>π</mml:mi></mml:mstyle></mml:math></inline-formula> field-of-view;<disp-formula id="equ35"><label>(35)</label><mml:math id="m35"><mml:msub><mml:mi>F</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>K</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mo>∫</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>0</mml:mn></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>2</mml:mn><mml:mi>π</mml:mi></mml:mrow></mml:msubsup><mml:msub><mml:mi>g</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo>,</mml:mo><mml:mi>θ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>d</mml:mi><mml:mi>θ</mml:mi><mml:mo>,</mml:mo></mml:math></disp-formula></p><p>(computationally we use a default value of <inline-formula><mml:math id="inf117"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>d</mml:mi><mml:mi>θ</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mn>2</mml:mn><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>∘</mml:mo></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula> to numerically approximate this integral). <inline-formula><mml:math id="inf118"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>K</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>/</mml:mo></mml:mrow><mml:munder><mml:mo movablelimits="true" form="prefix">max</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mrow></mml:munder><mml:msub><mml:mi>F</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> is a normalisation constant calculated empirically at initialisation such that each BVC has a maximum firing rate (before scaling) of 1.0 Hz.</p></sec><sec id="s4-7-5"><title><monospace>ObjectVectorCells</monospace></title><p><monospace>ObjectVectorCells</monospace> (OVCs) respond to objects in the <monospace>Environment</monospace>. Objects are zero-dimensional and can be added anywhere within the <monospace>Environment</monospace>, each object, <inline-formula><mml:math id="inf119"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>j</mml:mi></mml:mstyle></mml:math></inline-formula>, comes with a “type” attribute, <inline-formula><mml:math id="inf120"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>t</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula>. Each object vector cell has a tuning type, <inline-formula><mml:math id="inf121"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>t</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula>, and is only responsive to objects of this type. The total firing rate of of each cell is given by the sum of the contributions from all objects of the correct type in the <monospace>Environment</monospace>;<disp-formula id="equ36"><label>(36)</label><mml:math id="m36"><mml:msub><mml:mi>F</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>objects</mml:mtext></mml:mrow><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext> if </mml:mtext></mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:munder><mml:msub><mml:mi>g</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:math></disp-formula></p><p>Since <xref ref-type="disp-formula" rid="equ33">Equation 33</xref> has a maximum value of 1 by definition the maximum firing rate of an object vector cell is also 1 Hz (unless multiple objects are closeby) and no normalisation is required.</p></sec><sec id="s4-7-6"><title><monospace>AgentVectorCells</monospace></title><p><monospace>AgentVectorCells</monospace> respond to other <monospace>Agent</monospace>s in the <monospace>Environment</monospace>. All cells in a given class are selective to the same <monospace>Agent</monospace>, index <inline-formula><mml:math id="inf122"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>j</mml:mi></mml:mstyle></mml:math></inline-formula>. The firing rate of each cell is then given by;<disp-formula id="equ37"><label>(37)</label><mml:math id="m37"><mml:msub><mml:mi>F</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:math></disp-formula></p></sec><sec id="s4-7-7"><title><monospace>FieldOfViewBVCs</monospace>, <monospace>FieldOfViewOVCs</monospace>, and <monospace>FieldOfViewAVCs</monospace></title><p><monospace>FieldOfViewBVCs/OVCs/AVCs</monospace> are a special case of the above vector cells where the tuning parameters (<inline-formula><mml:math id="inf123"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>d</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula>, <inline-formula><mml:math id="inf124"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>d</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula>, <inline-formula><mml:math id="inf125"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>ϕ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula>, <inline-formula><mml:math id="inf126"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>ϕ</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula>) for a set of <monospace>VectorCells</monospace> are carefully set so that cells tile a predefined ‘field of view’. By default these cells are egocentric and so the field of view (as the name implies) is defined relative to the heading direction of the <monospace>Agent</monospace>; if the <monospace>Agent</monospace> turns the field of view turns with it.</p><p>Users define the angular and radial extent of the field of view as well as the resolution of the cells which tile it. There is some flexiblity for users to construct complex fields of view but baic API simplifies this process, exposing a few key parameters:</p><list list-type="bullet"><list-item><p><inline-formula><mml:math id="inf127"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>r</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>fov</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mi>r</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>fov</mml:mtext></mml:mrow></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>min</mml:mtext></mml:mrow></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mi>r</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>fov</mml:mtext></mml:mrow></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>% max</mml:mtext></mml:mrow></mml:mrow></mml:msubsup><mml:mo stretchy="false">]</mml:mo></mml:mstyle></mml:math></inline-formula> (default [0.02 m, 0.2 m]): the radial extent of the field of view.</p></list-item><list-item><p><inline-formula><mml:math id="inf128"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>θ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>fov</mml:mtext></mml:mrow></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> (default [0°, 75°]): the angular extend of the field of view (measured from the forward heading direction, symmetric left and right).</p></list-item><list-item><p><inline-formula><mml:math id="inf129"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msubsup><mml:mi>δ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>fov</mml:mtext></mml:mrow></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>0</mml:mn></mml:mrow></mml:msubsup></mml:mstyle></mml:math></inline-formula> (default 0.02 m): <monospace>FieldOfView</monospace> <monospace>VectorCells</monospace> all have approximately circular receptive fields (i.e. the radial Gaussian and angular von Mises in <xref ref-type="disp-formula" rid="equ33">Equation 33</xref> have matched variances which depend on their tuning distance; <inline-formula><mml:math id="inf130"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>d</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>⋅</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>ϕ</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>:=</mml:mo><mml:msub><mml:mi>δ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>fov</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula>). <inline-formula><mml:math id="inf131"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msubsup><mml:mi>δ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>fov</mml:mtext></mml:mrow></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>0</mml:mn></mml:mrow></mml:msubsup></mml:mstyle></mml:math></inline-formula> sets the resolution of the inner-most row of cells in the field of view, <inline-formula><mml:math id="inf132"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msubsup><mml:mi>δ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>fov</mml:mtext></mml:mrow></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>0</mml:mn></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mi>δ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>fov</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mi>r</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>fov</mml:mtext></mml:mrow></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>min</mml:mtext></mml:mrow></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula>.</p></list-item><list-item><p>Manifold type: For “diverging” manifolds (default) cells further away from the <monospace>Agent</monospace> have larger receptive fields <inline-formula><mml:math id="inf133"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>δ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>fov</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>ξ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>/</mml:mo></mml:mrow><mml:mi>β</mml:mi></mml:mstyle></mml:math></inline-formula> for user-defined <inline-formula><mml:math id="inf134"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>β</mml:mi></mml:mstyle></mml:math></inline-formula> (default <inline-formula><mml:math id="inf135"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>β</mml:mi><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:mstyle></mml:math></inline-formula>) and <inline-formula><mml:math id="inf136"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>ξ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>:=</mml:mo><mml:msubsup><mml:mi>δ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>fov</mml:mtext></mml:mrow></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>0</mml:mn></mml:mrow></mml:msubsup><mml:mo>−</mml:mo><mml:msubsup><mml:mi>r</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>fov</mml:mtext></mml:mrow></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>min</mml:mtext></mml:mrow></mml:mrow></mml:msubsup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>/</mml:mo></mml:mrow><mml:mi>β</mml:mi></mml:mstyle></mml:math></inline-formula>. For “uniform” manifold all cells have the same sized receptive fields, <inline-formula><mml:math id="inf137"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>δ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>fov</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msubsup><mml:mi>δ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>fov</mml:mtext></mml:mrow></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>0</mml:mn></mml:mrow></mml:msubsup></mml:mstyle></mml:math></inline-formula>.</p></list-item></list><p>More complex field of views can be constructed and a tutorial is provided to show how.</p></sec><sec id="s4-7-8"><title><monospace>HeadDirectionCells</monospace></title><p>In 2D <monospace>Environment</monospace>s each head direction cell has an angular tuning mean <inline-formula><mml:math id="inf138"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>θ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> and width <inline-formula><mml:math id="inf139"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>:=</mml:mo><mml:mn>1</mml:mn><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>/</mml:mo></mml:mrow><mml:msqrt><mml:msub><mml:mi>κ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:msqrt></mml:mstyle></mml:math></inline-formula>. The response function is then a von Mises in the head direction of the <monospace>Agent</monospace>:<disp-formula id="equ38"><label>(38)</label><mml:math id="m38"><mml:mtable columnalign="right left right left right left right left right left right left" rowspacing="3pt" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" displaystyle="true"><mml:mtr><mml:mtd><mml:msub><mml:mi>F</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>κ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mi>cos</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>h</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p>By default all cells have the same angular tuning width of 3° and tuning means even spaced from 0° to <inline-formula><mml:math id="inf140"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mn>360</mml:mn><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>∘</mml:mo></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula>.</p><p>In 1D <monospace>Environment</monospace>s there is always and only exactly <inline-formula><mml:math id="inf141"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:mstyle></mml:math></inline-formula> <monospace>HeadDirectionCells</monospace>; one for leftward motion and one for rightward motion.<disp-formula id="equ39"><label>(39)</label><mml:math id="m39"><mml:mtable columnalign="right left right left right left right left right left right left" rowspacing="3pt" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" displaystyle="true"><mml:mtr><mml:mtd><mml:msub><mml:mi>F</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo movablelimits="true" form="prefix">max</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>sgn</mml:mtext></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>1</mml:mn><mml:mi>D</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mi>F</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo movablelimits="true" form="prefix">max</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>sgn</mml:mtext></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>1</mml:mn><mml:mi>D</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p></sec><sec id="s4-7-9"><title><monospace>VelocityCells</monospace></title><p><monospace>VelocityCells</monospace> are a subclass of <monospace>HeadDirectionCells</monospace> which encode the full velocity vector rather than the (normalised) head direction. In this sense they are similar to <monospace>HeadDirectionCells</monospace> but their firing rate will increase with the speed of the <monospace>Agent</monospace>.</p><p>In 2D their firing rate is given by:<disp-formula id="equ40"><label>(40)</label><mml:math id="m40"><mml:mtable columnalign="right left right left right left right left right left right left" rowspacing="3pt" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" displaystyle="true"><mml:mtr><mml:mtd><mml:msub><mml:mi>F</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>2</mml:mn><mml:mi>D</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mfrac><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>κ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mi>cos</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p>where <inline-formula><mml:math id="inf142"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>θ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> is the angle of the velocity vector <inline-formula><mml:math id="inf143"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">v</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> anticlockwise from the x-direction and <inline-formula><mml:math id="inf144"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> is the likely speed scale of the <monospace>Agent</monospace> moving under random motion (this is chosen so the firing rate of the velocity cell before scaling is approximately <inline-formula><mml:math id="inf145"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">O</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> Hz).</p><p>In 1D environments:<disp-formula id="equ41"><label>(41)</label><mml:math id="m41"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mtable columnalign="left left" rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd><mml:msub><mml:mi>F</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo movablelimits="true" form="prefix">max</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mi>D</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>μ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mi>F</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo movablelimits="true" form="prefix">max</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mi>D</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>μ</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>where the addition of <inline-formula><mml:math id="inf146"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>μ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> accounts for any bias in the motion.</p></sec><sec id="s4-7-10"><title><monospace>SpeedCell</monospace></title><p>A single cell encodes the scaled speed of the <monospace>Agent</monospace><disp-formula id="equ42"><label>(42)</label><mml:math id="m42"><mml:mi>F</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">v</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo fence="false" stretchy="false">‖</mml:mo></mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mfrac></mml:math></disp-formula></p><p>where, same as with the <monospace>VelocityCells</monospace>, <inline-formula><mml:math id="inf147"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> (or <inline-formula><mml:math id="inf148"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>μ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> in 1D) is the typical speed scale of the <monospace>Agent</monospace> moving under random motion giving these cells ad pre-scaled maximum firing rate of <inline-formula><mml:math id="inf149"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">O</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> Hz.</p></sec><sec id="s4-7-11"><title><monospace>PhasePrecessingPlaceCells</monospace></title><p><monospace>PhasePrecessingPlaceCells</monospace> (a subclass of <monospace>PlaceCells</monospace>) display a phenomena known as phase precession with respect to an underlying theta oscillation; within each theta cycle the firing rate of a place cell peaks at a phase dependent on how far through the place field the <monospace>Agent</monospace> has travelled. Specifically, as the <monospace>Agent</monospace> enters the receptive field the firing rate peaks at a late phase in the cycle and as the <monospace>Agent</monospace> leaves the receptive field the firing rate peaks at an early phase in the cycle, hence the name phase <italic>pre</italic>cession. Phase precession is implemented by modulating the spatial firing rate of <monospace>PlaceCells</monospace> with a phase precession factor, <inline-formula><mml:math id="inf150"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msubsup><mml:mi>F</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>θ</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula>,<disp-formula id="equ43"><label>(43)</label><mml:math id="m43"><mml:msub><mml:mi>F</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">←</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⋅</mml:mo><mml:msubsup><mml:mi>F</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>θ</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:math></disp-formula></p><p>which rises and falls each theta cycle, according to:<disp-formula id="equ44"><label>(44)</label><mml:math id="m44"><mml:msubsup><mml:mi>F</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>θ</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:msub><mml:mi>f</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>VM</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="2.047em" minsize="2.047em">(</mml:mo></mml:mrow></mml:mstyle><mml:msub><mml:mi>ϕ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="2.047em" minsize="2.047em">|</mml:mo></mml:mrow></mml:mstyle><mml:msubsup><mml:mi>ϕ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>∗</mml:mo></mml:mrow></mml:msubsup><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="1.2em" minsize="1.2em">(</mml:mo></mml:mrow></mml:mstyle><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo>˙</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="1.2em" minsize="1.2em">)</mml:mo></mml:mrow></mml:mstyle><mml:mo>,</mml:mo><mml:msub><mml:mi>κ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="2.047em" minsize="2.047em">)</mml:mo></mml:mrow></mml:mstyle><mml:mo>.</mml:mo></mml:math></disp-formula></p><p>This is a von Mises factor where <inline-formula><mml:math id="inf151"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>ϕ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:msub><mml:mi>ν</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mi>t</mml:mi><mml:mspace width="1em"/><mml:mi>mod</mml:mi><mml:mspace width="thinmathspace"/><mml:mspace width="thinmathspace"/><mml:mn>2</mml:mn><mml:mi>π</mml:mi></mml:mstyle></mml:math></inline-formula> is the current phase of the <inline-formula><mml:math id="inf152"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>ν</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>θ</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> Hz theta-rhythm and <inline-formula><mml:math id="inf153"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msubsup><mml:mi>ϕ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>∗</mml:mo></mml:mrow></mml:msubsup><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="1.2em" minsize="1.2em">(</mml:mo></mml:mrow></mml:mstyle><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo>˙</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="1.2em" minsize="1.2em">)</mml:mo></mml:mrow></mml:mstyle></mml:mstyle></mml:math></inline-formula> is the current ‘preferred’ theta phase of a cell which is a function of it’s position <inline-formula><mml:math id="inf154"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> and direction of motion <inline-formula><mml:math id="inf155"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo>˙</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula>. This preferred phase is calculated by first establishing how far through a cells spatial receptive field the <monospace>Agent</monospace> has travelled along its current direction of motion;<disp-formula id="equ45"><label>(45)</label><mml:math id="m45"><mml:msub><mml:mi>d</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo>˙</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>⋅</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo>˙</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:math></disp-formula></p><p>and then mapping this to a uniform fraction <inline-formula><mml:math id="inf156"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>β</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>θ</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> of the range <inline-formula><mml:math id="inf157"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mstyle></mml:math></inline-formula>;<disp-formula id="equ46"><label>(46)</label><mml:math id="m46"><mml:msubsup><mml:mi>ϕ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>∗</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>π</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mi>β</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mi>π</mml:mi><mml:mfrac><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mfrac><mml:mo>.</mml:mo></mml:math></disp-formula></p><p><inline-formula><mml:math id="inf158"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> is the width of the cell at its boundary, typically defined as <inline-formula><mml:math id="inf159"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula>, except for <monospace>gaussian</monospace> place cells where the boundary is arbitrarily drawn at two standard deviations <inline-formula><mml:math id="inf160"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:msub><mml:mi>w</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula>.</p><p>The intuition for this formula can be found by considering an <monospace>Agent</monospace> travelling straight through the midline of a circular 2D place field. As the <monospace>Agent</monospace> enters into the receptive field (at which point <inline-formula><mml:math id="inf161"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mo stretchy="false">(</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>⋅</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo>˙</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula>) the firing rate will peak at a theta phase of <inline-formula><mml:math id="inf162"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>π</mml:mi><mml:mo>+</mml:mo><mml:mi>β</mml:mi><mml:mi>π</mml:mi></mml:mstyle></mml:math></inline-formula>. This then precesses backwards as it passes through the field until the moment it leaves (<inline-formula><mml:math id="inf163"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mo stretchy="false">(</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>⋅</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo>˙</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula>) when the firing rate peaks at a phase of <inline-formula><mml:math id="inf164"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>π</mml:mi><mml:mo>−</mml:mo><mml:mi>β</mml:mi><mml:mi>π</mml:mi></mml:mstyle></mml:math></inline-formula>. This generalises to arbitrary curved paths through 2D receptive fields. This model has been used and validated before by <xref ref-type="bibr" rid="bib24">Jeewajee et al., 2014</xref> . <inline-formula><mml:math id="inf165"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>κ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>θ</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> determines the spread of the von Mises, i.e. how far from the preferred phase the cell is likely to fire.</p></sec><sec id="s4-7-12"><title><monospace>RandomSpatialNeurons</monospace></title><p><monospace>RandomSpatialNeurons</monospace> provide spatially ‘tuned’ inputs for use in instances where <monospace>PlaceCells</monospace>, <monospace>GridCells</monospace>, <monospace>BoundaryVectorCells</monospace> etc. These neurons have smooth but, over long distances, random receptive fields (approximately) generated by sampling from a Gaussian process with a radial basis function kernel of lengthscale <inline-formula><mml:math id="inf166"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>l</mml:mi></mml:mstyle></mml:math></inline-formula> (default <inline-formula><mml:math id="inf167"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mn>0.1</mml:mn></mml:mstyle></mml:math></inline-formula> m). The kernel is given by:<disp-formula id="equ47"><label>(47)</label><mml:math id="m47"><mml:mi>k</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo>,</mml:mo><mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi class="MJX-variant" mathvariant="normal">′</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mi>exp</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo>,</mml:mo><mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi class="MJX-variant" mathvariant="normal">′</mml:mi></mml:mrow></mml:msup><mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:msup><mml:mi>l</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:msup></mml:math></disp-formula></p><p>where <inline-formula><mml:math id="inf168"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo>,</mml:mo><mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi class="MJX-variant" mathvariant="normal">′</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> is the environmental-distance between two points in the environment. This distance measure (same as used for <monospace>PlaceCells</monospace>, and <monospace>VectorCells</monospace> etc.) accounts for walls in the environment and so the receptive fields of these neurons are smooth everywhere except across walls (see Section ‘Distance measures’).</p><p>Firing rates are calculated as follows: At initialisation an array of target locations, at least as dense as the lengthscale, is sampled across the environment <inline-formula><mml:math id="inf169"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mo fence="false" stretchy="false">{</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo fence="false" stretchy="false">}</mml:mo></mml:mstyle></mml:math></inline-formula>. For each neuron, <inline-formula><mml:math id="inf170"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>i</mml:mi></mml:mstyle></mml:math></inline-formula>, <inline-formula><mml:math id="inf171"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>j</mml:mi></mml:mstyle></mml:math></inline-formula> target <italic>values</italic>, <inline-formula><mml:math id="inf172"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mi>F</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>:</mml:mo></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula>, is sampled from the multivariate Normal distribution<disp-formula id="equ48"><label>(48)</label><mml:math id="m48"><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mi>F</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>:</mml:mo></mml:mrow></mml:msub><mml:mo>∼</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi class="MJX-tex-caligraphic" mathvariant="script">N</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn mathvariant="bold">0</mml:mn></mml:mrow><mml:mo>,</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">K</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:math></disp-formula></p><p>where <inline-formula><mml:math id="inf173"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">K</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> is the covariance matrix with elements <inline-formula><mml:math id="inf174"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>K</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>l</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula>. This creates a sparse set of locations, <inline-formula><mml:math id="inf175"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mo fence="false" stretchy="false">{</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo fence="false" stretchy="false">}</mml:mo></mml:mstyle></mml:math></inline-formula>, and targets, <inline-formula><mml:math id="inf176"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mi>F</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula>, across the <monospace>Environment</monospace>: locations close to each other are likely to have similar targets (and hence similar firing rates) whereas locations far apart will be uncorrelated.</p><p>At inference time the firing rate at an arbitrary position in the <monospace>Environment</monospace>, <inline-formula><mml:math id="inf177"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> (which will not neccesarily be one of the pre-sampled targets) is estimated by taking the mean of the targets weighted by the kernel function between the position and the target location:<disp-formula id="equ49"><label>(49)</label><mml:math id="m49"><mml:msub><mml:mi>F</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>j</mml:mi></mml:mrow></mml:munder><mml:mi>k</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mi>F</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>j</mml:mi></mml:mrow></mml:munder><mml:mi>k</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac></mml:math></disp-formula></p><p>This weighted average is a cheap and fast approximation to the true Bayesian Gaussian process which would require the inversion of the covariance matrix <inline-formula><mml:math id="inf178"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">K</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> at each time-step and which we find to be numerically unstable around exposed walls.</p></sec><sec id="s4-7-13"><title><monospace>FeedForwardLayer</monospace></title><p><monospace>FeedForwardLayer</monospace> and <monospace>NeuralNetworkNeurons</monospace> are different from other RatInABox classes; their firing rates are not textitexplicitly determined by properties (position, velocity, head direction etc.) of their <monospace>Agent</monospace> but by the firing rates of a set of input layers (other <monospace>ratinabox.Neurons</monospace>). They allow users to create arbitrary and trainable ‘function approximator’ <monospace>Neurons</monospace> with receptive fields depending non-trivially on the states of one or many <monospace>Agent</monospace>(s).</p><p>Each <monospace>FeedForwardLayer</monospace> has a list of inputs <inline-formula><mml:math id="inf179"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mo fence="false" stretchy="false">{</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">L</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>N</mml:mi></mml:mrow></mml:msubsup></mml:mstyle></mml:math></inline-formula> which must be other <monospace>ratinabox.Neurons</monospace> subclasses (e.g. <monospace>PlaceCells</monospace>, <monospace>BoundaryVectorCells</monospace>, <monospace>FeedForwardLayer</monospace>). For input layer <inline-formula><mml:math id="inf180"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>j</mml:mi></mml:mstyle></mml:math></inline-formula> with <inline-formula><mml:math id="inf181"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>n</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> neurons of firing rates <inline-formula><mml:math id="inf182"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msubsup><mml:mi>F</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>k</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">L</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> for <inline-formula><mml:math id="inf183"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mstyle></mml:math></inline-formula>, a weight matrix is initialised by drawing weights randomly <inline-formula><mml:math id="inf184"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msubsup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">w</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">L</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msubsup><mml:mo>∼</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi class="MJX-tex-caligraphic" mathvariant="script">N</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>/</mml:mo></mml:mrow><mml:msqrt><mml:msub><mml:mi>n</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:msqrt><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> (for default weight intialisation scale <inline-formula><mml:math id="inf185"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>g</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mstyle></mml:math></inline-formula>). The firing rate of the <inline-formula><mml:math id="inf186"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mi>i</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>th</mml:mtext></mml:mrow></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula> <monospace>FeedForwardLayer</monospace> neuron is given by weighted summation of the inputs from all layers plus a bias term:<disp-formula id="equ50"><label>(50)</label><mml:math id="m50"><mml:mtable columnalign="right left right left right left right left right left right left" rowspacing="3pt" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" displaystyle="true"><mml:mtr><mml:mtd><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd><mml:mtd><mml:mi/><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>N</mml:mi></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:msub><mml:mi>n</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msubsup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">w</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">L</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:msubsup><mml:mi>F</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>k</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">L</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula><disp-formula id="equ51"><label>(51)</label><mml:math id="m51"><mml:mtable columnalign="right left right left right left right left right left right left" rowspacing="3pt" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" displaystyle="true"><mml:mtr><mml:mtd><mml:msub><mml:mi>F</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd><mml:mtd><mml:mi/><mml:mo>=</mml:mo><mml:mi>ϕ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p>where <inline-formula><mml:math id="inf187"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>ϕ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> is a potentially non-linear activation function defaulting to a linear identity function of unit gain. <inline-formula><mml:math id="inf188"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>b</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> is a constant bias (default zero). A full list of available activations and their defining parameters can be found in the <ext-link ext-link-type="uri" xlink:href="https://github.com/RatInABox-Lab/RatInABox/blob/main/ratinabox/utils.py">utils.py</ext-link> file; these include ReLU, sigmoid, tanh, Retanh, softmax and linear (the default) functions or users can pass their own bespoke activation function.</p><p>Alongside <inline-formula><mml:math id="inf189"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>ϕ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> this layer also calculates and saves <inline-formula><mml:math id="inf190"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mi>ϕ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi class="MJX-variant" mathvariant="normal">′</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> where <inline-formula><mml:math id="inf191"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mi>ϕ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi class="MJX-variant" mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula> is the derivative of the activation function, a necessary quantity for many learning rules and training algorithms.</p></sec><sec id="s4-7-14"><title><monospace>NeuralNetworkNeurons</monospace></title><p><monospace>NeuralNetworkNeurons</monospace> are a generalisation of <monospace>FeedForwardLayer</monospace>. Like <monospace>FeedForwardLayer</monospace> they are initialised with a list of inputs <inline-formula><mml:math id="inf192"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mi>i</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>th</mml:mtext></mml:mrow></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula>. This class also recieves, at the point of initialisation, a neural network, <monospace>NN</monospace>. This can be any <monospace>pytorch.nn.module</monospace>. To calculate teh firing rate this class takes the firing rates of all input layers, concatenates them, and passes them through the neural network. The firing rate of the <monospace>NeuralNetworkNeurons</monospace> neuron is given by the activity of the neuron in the output layer of neural network:<disp-formula id="equ52"><label>(52)</label><mml:math id="m52"><mml:msub><mml:mi>F</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">N</mml:mi><mml:mi mathvariant="sans-serif">N</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:munder><mml:mrow class="MJX-TeXAtom-OP MJX-fixedlimits"><mml:munder><mml:mrow><mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mi>F</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">L</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mi>F</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">L</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo></mml:mrow><mml:mo>⏟</mml:mo></mml:munder></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>inputs</mml:mtext></mml:mrow></mml:mrow></mml:munder><mml:mo>;</mml:mo><mml:munder><mml:mrow class="MJX-TeXAtom-OP MJX-fixedlimits"><mml:munder><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">w</mml:mi></mml:mrow><mml:mo>⏟</mml:mo></mml:munder></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>weights</mml:mtext></mml:mrow></mml:mrow></mml:munder><mml:mo stretchy="false">)</mml:mo></mml:math></disp-formula></p><p>If no neural network is provided by the user a default network with two hidden ReLU layers of size 20 is used.</p><p>In order to be compatible with the rest of the RatInABox API the firing rate returned by this class is a numpy array, however, on each update the output of the <monospace>pytorch</monospace> neural network is additionally saved as a <monospace>torch</monospace> tensor. By accessing this tensor, users can take gradients back through the embedded neural network and train is as we demonstrate in <xref ref-type="fig" rid="fig3">Figure 3e</xref>.</p><p>In <xref ref-type="fig" rid="fig3">Figure 3e</xref> and an associated demo script a <monospace>NeuralNetworkNeurons</monospace> layer is initialised with <inline-formula><mml:math id="inf193"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>N</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mstyle></mml:math></inline-formula> neuron/output. The inputs to the network come from a layer of 200 <monospace>GridCells</monospace>, ranging in grid scale from 0.2 m to 0.5 m. These are passed through a neural network with three hidden ReLU layers of size 100 and a linear readout. As the <monospace>Agent</monospace> randomly explores its <monospace>Environment</monospace> the network is trained with gradient descent to reduce the L2 error between the firing rate of the network and that of a ‘<monospace>target</monospace>’ rate map (a vector image of the letters ‘RIAB’). We use gradient descent with momentum and a learning rate of <inline-formula><mml:math id="inf194"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>η</mml:mi><mml:mo>=</mml:mo><mml:mn>0.002</mml:mn><mml:mo>⋅</mml:mo><mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>dt</mml:mtext></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula> (which makes the total rate of learning time-step independent). Momentum is set to <inline-formula><mml:math id="inf195"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>μ</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow><mml:msub><mml:mi>τ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>et</mml:mtext></mml:mrow></mml:mrow></mml:msub></mml:mfrac><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> where <inline-formula><mml:math id="inf196"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>τ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>et</mml:mtext></mml:mrow></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> is the eligibility trace timescale of 10 s which smoothes the gradient descent, improving convergence. We find learning converges after approximately 2 hr and a good approximation of the target function is achieved.</p></sec></sec><sec id="s4-8"><title>Tutorials and demonstrations</title><p>We provide numerous resources, some of which are listed here, to streamline the process of learning RatInABox. Next to each we describe the key features – which you may be interested in learning – covered by the resource.</p><list list-type="bullet"><list-item><p><ext-link ext-link-type="uri" xlink:href="https://github.com/RatInABox-Lab/RatInABox">Github readme</ext-link>: Installing and importing RatInABox. Descriptions and diagrams of key features.</p></list-item><list-item><p><ext-link ext-link-type="uri" xlink:href="https://github.com/RatInABox-Lab/RatInABox/blob/main/demos/simple_example.ipynb">Simple script</ext-link>: A minimal example of using RatInABox to generate and display data. Code duplicated below for convenience.</p></list-item><list-item><p><ext-link ext-link-type="uri" xlink:href="https://github.com/RatInABox-Lab/RatInABox/blob/main/demos/extensive_example.ipynb">Extensive script</ext-link>: A more detailed tutorial showing advanced data generation, and advanced plotting.</p></list-item><list-item><p><ext-link ext-link-type="uri" xlink:href="https://github.com/RatInABox-Lab/RatInABox/blob/main/demos/decoding_position_example.ipynb">Decoding position example</ext-link>: Data collection. Firing rate to position decoding. Data plotting.</p></list-item><list-item><p><ext-link ext-link-type="uri" xlink:href="https://github.com/RatInABox-Lab/RatInABox/blob/main/demos/conjunctive_gridcells_example.ipynb">Conjunctive grid cells example</ext-link>: <monospace>GridCells</monospace> and <monospace>HeadDirectionCells</monospace> are combined with the function approximator <monospace>FeedForwardLayer</monospace> class to make head direction-selective grid cells (aka. conjunctive grid cells)</p></list-item><list-item><p><ext-link ext-link-type="uri" xlink:href="https://github.com/RatInABox-Lab/RatInABox/blob/main/demos/splitter_cells_example.ipynb">Splitter cells example</ext-link>: Bespoke <monospace>Environment</monospace>, <monospace>Agent</monospace> and <monospace>Neurons</monospace> subclasses are written to make simple model of splitter cells.</p></list-item><list-item><p><ext-link ext-link-type="uri" xlink:href="https://github.com/RatInABox-Lab/RatInABox/blob/main/demos/successor_features_example.ipynb">Successor features example</ext-link>: Loop-shaped <monospace>Environment</monospace> is constructed. Implementation of TD learning.</p></list-item><list-item><p><ext-link ext-link-type="uri" xlink:href="https://github.com/RatInABox-Lab/RatInABox/blob/main/demos/reinforcement_learning_example.ipynb">Reinforcement Learning</ext-link><ext-link ext-link-type="uri" xlink:href="https://github.com/RatInABox-Lab/RatInABox/blob/main/demos/reinforcement_learning_example.ipynb"> Example</ext-link>: A bespoke <monospace>ValueNeuron</monospace> subclass is defined. Implementation of TD learning. External ‘non-random’ control of <monospace>Agent</monospace> velocity.</p></list-item><list-item><p><ext-link ext-link-type="uri" xlink:href="https://github.com/RatInABox-Lab/RatInABox/blob/main/demos/deep_learning_example.ipynb">Deep learning example</ext-link>: Deep <monospace>NeuralNetworkNeurons</monospace> trained to approximate a target function. Bespoke <monospace>Neurons</monospace> subclass encoding a.png is written.</p></list-item><list-item><p><ext-link ext-link-type="uri" xlink:href="https://github.com/RatInABox-Lab/RatInABox/blob/main/demos/actor_critic_example.ipynb">Actor-critic example</ext-link>: Deep <monospace>NeuralNetworkNeurons</monospace> are used to implement the actor-critic algorithm in egocentric and allocentric action/representation spaces.</p></list-item><list-item><p><ext-link ext-link-type="uri" xlink:href="https://github.com/RatInABox-Lab/RatInABox/blob/main/demos/path_integration_example.ipynb">Path Integration Example</ext-link>: Extensive use of <monospace>FeedForwardLayer</monospace> to build a deep multilayer network. Implementation of a local Hebbian learning rule.</p></list-item><list-item><p><ext-link ext-link-type="uri" xlink:href="https://github.com/RatInABox-Lab/RatInABox/blob/main/demos/list_of_plotting_fuctions.md">List of plotting functions</ext-link>: Lists and describes all available plotting functions.</p></list-item></list><p>In addition, scripts reproducing all figures in the <ext-link ext-link-type="uri" xlink:href="https://github.com/RatInABox-Lab/RatInABox/blob/main/demos/readme_figures.ipynb">GitHub readme</ext-link> and <ext-link ext-link-type="uri" xlink:href="https://github.com/RatInABox-Lab/RatInABox/blob/main/demos/paper_figures.ipynb">this paper</ext-link> are provided too. <ext-link ext-link-type="uri" xlink:href="https://github.com/RatInABox-Lab/RatInABox/tree/main/ratinabox">The code</ext-link> comments are nearly comprehensive and can be referenced for additional understanding where needed.</p><sec id="s4-8-1"><title>A simple script</title><p>See the GitHub repository for instructions on how to install RatInABox. The following is a Python script demonstrating a very basic use-case.</p><p>Import RatInABox and necessary classes. Initialise a 2D <monospace>Environment</monospace>. Initialise an <monospace>Agent</monospace> in the <monospace>Environment</monospace>. <monospace>Initialise</monospace> some <monospace>PlaceCells</monospace>. Simulate for 20 s. Print table of times, position and firing rates. Plot the motion trajectory, the firing rate timeseries’ and place cell rate maps.</p><p><code xml:space="preserve"># Import RatInABox 
import ratinabox from ratinabox.Environment import Environment 
from ratinabox.Agent import Agent 
from ratinabox.Neurons import PlaceCells 
import pandas as pd

# Run a very simple simulation 
Env = Environment() 
Ag = Agent(Env) 
PCs = PlaceCells(Ag) 
for i in range(int(20/Ag.dt)): 
Ag.update() 
PCs.update()

# Export data into a dataframe 
pd.DataFrame(Ag.history)

# Plot data 
Ag.plot_trajectory() 
PCs.plot_rate_timeseries() 
PCs.plot_rate_map()</code></p></sec></sec><sec id="s4-9"><title>Table of default parameters</title><p><xref ref-type="table" rid="table1">Table 1</xref> lists the RatInABox parameters and their default values. The ‘Key’ column give the key in a parameters dictionary which can be passed to each class upon initialisation. Any variables not present in the parameters dictionary at initialisation will be taken as default. For example, initialising an <monospace>Environment</monospace> of size 2 m (which is <italic>not</italic> the default size) and adding an <monospace>Agent</monospace> with a mean speed of 0.3ms<sup>-1</sup> (which is <italic>not</italic> the default size) would be done as follows:</p><p><code xml:space="preserve">import ratinaboxfrom ratinabox.Environment import Environment
from ratinabox.Agent import Agent

Env=Environment(params = &quot;scale&quot;:2.0) # initialise non-default Environment
Ag=Agent(Env, params = &quot;speed_mean&quot;:0.3) # initialise non-default Agent</code></p><table-wrap id="table1" position="float"><label>Table 1.</label><caption><title>Default values, keys and allowed ranges for RatInABox parameters.</title><p>* This parameter is passed as a kwarg to <monospace>Agent.update()</monospace> function, not in the input dictionary. ** This parameter is passed as a kwarg to <monospace>FeedForwardLayer.add_input()</monospace> when an input layer is being attached, not in the input dictionary.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left" valign="bottom">Parameter</th><th align="left" valign="bottom">Key</th><th align="left" valign="bottom">Description (unit)</th><th align="left" valign="bottom">Default</th><th align="left" valign="bottom">Acceptable range</th></tr></thead><tbody><tr><td align="center" valign="bottom" colspan="5"><monospace>Environment()</monospace></td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf197"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>D</mml:mi></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>dimensionality</monospace></td><td align="left" valign="bottom">Dimensionality of <monospace>Environment</monospace>.</td><td align="left" valign="bottom">&quot;<monospace>2D</monospace>&quot;</td><td align="left" valign="bottom">[&quot;<monospace>1D</monospace>&quot;,&quot;<monospace>2D</monospace>&quot;]</td></tr><tr><td align="left" valign="bottom">Boundary conditions</td><td align="left" valign="bottom"><monospace>boundary_conditions</monospace></td><td align="left" valign="bottom">Determines behaviour of <monospace>Agent</monospace> and <monospace>PlaceCells</monospace> at the room boundaries.</td><td align="left" valign="bottom">&quot;<monospace>solid</monospace>&quot;</td><td align="left" valign="bottom">[&quot;<monospace>solid</monospace>&quot;, &quot;<monospace>periodic</monospace>&quot;]</td></tr><tr><td align="left" valign="bottom">Scale, <inline-formula><mml:math id="inf198"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>s</mml:mi></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>scale</monospace></td><td align="left" valign="bottom">Size of the environment (m).</td><td align="char" char="." valign="bottom">1.0</td><td align="left" valign="bottom"><inline-formula><mml:math id="inf199"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>+</mml:mo></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula></td></tr><tr><td align="left" valign="bottom">Aspect ratio, <inline-formula><mml:math id="inf200"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>a</mml:mi></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>aspect</monospace></td><td align="left" valign="bottom">Aspect ratio for rectangular 2D <monospace>Environment</monospace>s; width = <inline-formula><mml:math id="inf201"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>s</mml:mi><mml:mi>a</mml:mi></mml:mstyle></mml:math></inline-formula>, height = <inline-formula><mml:math id="inf202"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>s</mml:mi></mml:mstyle></mml:math></inline-formula>.</td><td align="char" char="." valign="bottom">1.0</td><td align="left" valign="bottom"><inline-formula><mml:math id="inf203"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>+</mml:mo></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula></td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf204"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>d</mml:mi><mml:mi>x</mml:mi></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>dx</monospace></td><td align="left" valign="bottom">Discretisation length used for plotting rate maps (m).</td><td align="char" char="." valign="bottom">0.01</td><td align="left" valign="bottom"><inline-formula><mml:math id="inf205"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>+</mml:mo></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula></td></tr><tr><td align="left" valign="bottom">Walls</td><td align="left" valign="bottom"><monospace>walls</monospace></td><td align="left" valign="bottom">A list of internal walls (not the perimeter walls) which will be added inside the <monospace>Environment</monospace>. More typically, walls will instead be added with the <monospace>Env.add_wall()</monospace> API (m).</td><td align="char" char="." valign="bottom">[]</td><td align="char" char="." valign="bottom"><inline-formula><mml:math id="inf206"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>N</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>walls</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:mn>2</mml:mn><mml:mo>×</mml:mo><mml:mn>2</mml:mn></mml:mstyle></mml:math></inline-formula>-array/list</td></tr><tr><td align="left" valign="bottom">Boundary</td><td align="left" valign="bottom"><monospace>boundary</monospace></td><td align="left" valign="bottom">Initialise non-rectangular <monospace>Environment</monospace>s by passing in this list of coordinates bounding the outer perimeter (m).</td><td align="left" valign="bottom"><monospace>None</monospace></td><td align="char" char="." valign="bottom"><inline-formula><mml:math id="inf207"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>N</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>corners</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:mn>2</mml:mn></mml:mstyle></mml:math></inline-formula>-array/list</td></tr><tr><td align="left" valign="bottom">Holes</td><td align="left" valign="bottom"><monospace>holes</monospace></td><td align="left" valign="bottom">Add multiple holes into the <monospace>Environment</monospace> by passing in a list of lists, each internal list contains coordinates (min 3) bounding the hole (m).</td><td align="left" valign="bottom"><monospace>None</monospace></td><td align="char" char="." valign="bottom"><inline-formula><mml:math id="inf208"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>N</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>holes</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:mo>≥</mml:mo><mml:mn>3</mml:mn><mml:mo>×</mml:mo><mml:mn>2</mml:mn></mml:mstyle></mml:math></inline-formula>-array/list</td></tr><tr><td align="left" valign="bottom">Objects</td><td align="left" valign="bottom"><monospace>walls</monospace></td><td align="left" valign="bottom">A list of objects inside the <monospace>Environment</monospace>. More typically, objects will instead be added with the <monospace>Env.add_object()</monospace> API (m).</td><td align="char" char="." valign="bottom">[]</td><td align="char" char="." valign="bottom"><inline-formula><mml:math id="inf209"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>N</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>objects</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:mn>2</mml:mn></mml:mstyle></mml:math></inline-formula>-array/list</td></tr><tr><td align="center" valign="bottom" colspan="5"><monospace>Agent()</monospace></td></tr><tr><td align="left" valign="bottom">dt</td><td align="left" valign="bottom"><monospace>dt</monospace></td><td align="left" valign="bottom">Time discretisation step size (s).</td><td align="char" char="." valign="bottom">0.01</td><td align="left" valign="bottom"><inline-formula><mml:math id="inf210"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>+</mml:mo></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula></td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf211"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>τ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>speed_coherence_time</monospace></td><td align="left" valign="bottom">Timescale over which speed (1D or 2D) decoheres under random motion (s).</td><td align="char" char="." valign="bottom">0.7</td><td align="left" valign="bottom"><inline-formula><mml:math id="inf212"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>+</mml:mo></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula></td></tr><tr><td align="char" char="." valign="bottom"><inline-formula><mml:math id="inf213"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> (2D) <inline-formula><mml:math id="inf214"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>μ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> (1D)</td><td align="left" valign="bottom"><monospace>speed_mean</monospace></td><td align="left" valign="bottom">2D: Scale Rayleigh distribution scale parameter for random motion in 2D. 1D: Normal distribution mean for random motion in 1D (ms<sup>-1</sup>).</td><td align="char" char="." valign="bottom">0.08</td><td align="char" char="." valign="bottom">2D: <inline-formula><mml:math id="inf215"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>+</mml:mo></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula> 1D: <inline-formula><mml:math id="inf216"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula></td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf217"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>speed_std</monospace></td><td align="left" valign="bottom">Normal distribution standard deviation for random motion in 1D (ms<sup>-1</sup>).</td><td align="char" char="." valign="bottom">0.08</td><td align="left" valign="bottom"><inline-formula><mml:math id="inf218"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>+</mml:mo></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula></td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf219"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>τ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>ω</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>rotational_velocity_coherence_time</monospace></td><td align="left" valign="bottom">Rotational velocity decoherence timescale under random motion (s).</td><td align="char" char="." valign="bottom">0.08</td><td align="left" valign="bottom"><inline-formula><mml:math id="inf220"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>+</mml:mo></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula></td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf221"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>ω</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>rotational_velocity_std</monospace></td><td align="left" valign="bottom">Rotational velocity Normal distribution standard deviation (rad s<sup>-1</sup>).</td><td align="left" valign="bottom"><inline-formula><mml:math id="inf222"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>/</mml:mo></mml:mrow><mml:mn>3</mml:mn></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><inline-formula><mml:math id="inf223"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>+</mml:mo></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula></td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf224"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>λ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>thig</mml:mtext></mml:mrow></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>thigmotaxis</monospace></td><td align="left" valign="bottom">Thigmotaxis parameter.</td><td align="char" char="." valign="bottom">0.5</td><td align="left" valign="bottom"><inline-formula><mml:math id="inf225"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mn>0</mml:mn><mml:mo>&lt;</mml:mo><mml:msub><mml:mi>λ</mml:mi><mml:mrow><mml:mrow><mml:mtext>thig</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo>&lt;</mml:mo><mml:mn>1</mml:mn></mml:mstyle></mml:mrow></mml:mstyle></mml:math></inline-formula></td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf226"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>d</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>wall</mml:mtext></mml:mrow></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>wall_repel_distance</monospace></td><td align="left" valign="bottom">Wall range of influence (m).</td><td align="char" char="." valign="bottom">0.1</td><td align="left" valign="bottom"><inline-formula><mml:math id="inf227"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>+</mml:mo></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula></td></tr><tr><td align="left" valign="bottom">s</td><td align="left" valign="bottom"><monospace>walls_repel_strength</monospace></td><td align="left" valign="bottom">How strongth walls repel the <monospace>Agent</monospace>. 0=no wall repulsion.</td><td align="char" char="." valign="bottom">1.0</td><td align="left" valign="bottom"><inline-formula><mml:math id="inf228"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msubsup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>0</mml:mn></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>+</mml:mo></mml:mrow></mml:msubsup></mml:mstyle></mml:math></inline-formula></td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf229"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>k</mml:mi></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>drift_to_random_ strength_ratio</monospace>*</td><td align="left" valign="bottom">How much motion is dominated by the drift velocity (if present) relative to random motion.</td><td align="char" char="." valign="bottom">1.0</td><td align="left" valign="bottom"><inline-formula><mml:math id="inf230"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msubsup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>0</mml:mn></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>+</mml:mo></mml:mrow></mml:msubsup></mml:mstyle></mml:math></inline-formula></td></tr><tr><td align="center" valign="bottom" colspan="5"><monospace>Neurons()</monospace></td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf231"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>n</mml:mi></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>n</monospace></td><td align="left" valign="bottom">Number of neurons.</td><td align="char" char="." valign="bottom">10</td><td align="left" valign="bottom"><inline-formula><mml:math id="inf232"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="double-struck">Z</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>+</mml:mo></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula></td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf233"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>f</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>max</mml:mtext></mml:mrow></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>max_fr</monospace></td><td align="left" valign="bottom">Maximum firing rate, see code for applicable cell types (Hz).</td><td align="char" char="." valign="bottom">1.0</td><td align="left" valign="bottom"><inline-formula><mml:math id="inf234"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula></td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf235"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>f</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>min</mml:mtext></mml:mrow></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>min_fr</monospace></td><td align="left" valign="bottom">Minimum firing rate, see code for applicable cell types (Hz).</td><td align="char" char="." valign="bottom">0.0</td><td align="left" valign="bottom"><inline-formula><mml:math id="inf236"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo>&lt;</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:mrow></mml:msub></mml:mstyle></mml:mrow></mml:mstyle></mml:math></inline-formula></td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf237"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>η</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>noise_std</monospace></td><td align="left" valign="bottom">Standard deviation of OU noise added to firing rates (Hz).</td><td align="char" char="." valign="bottom">0.0</td><td align="left" valign="bottom"><inline-formula><mml:math id="inf238"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>+</mml:mo></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula></td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf239"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>τ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>η</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>noise_coherence_time</monospace></td><td align="left" valign="bottom">Timescale of OU noise added to firing rates (s).</td><td align="char" char="." valign="bottom">0.5</td><td align="left" valign="bottom"><inline-formula><mml:math id="inf240"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>+</mml:mo></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula></td></tr><tr><td align="left" valign="bottom">Name</td><td align="left" valign="bottom"><monospace>name</monospace></td><td align="left" valign="bottom">A name which can be used to identify a <monospace>Neurons</monospace> class.</td><td align="left" valign="bottom">&quot;<monospace>Neurons</monospace>&quot;</td><td align="left" valign="bottom">Any string</td></tr><tr><td align="center" valign="bottom" colspan="5"><monospace>PlaceCells()</monospace></td></tr><tr><td align="left" valign="bottom">Type</td><td align="left" valign="bottom"><monospace>description</monospace></td><td align="left" valign="bottom">Place cell firing function.</td><td align="left" valign="bottom">&quot;<monospace>gaussian</monospace>&quot;</td><td align="left" valign="bottom">[&quot;<monospace>gaussian</monospace>&quot;, &quot;<monospace>gaussian_threshold</monospace>&quot;, &quot;<monospace>diff_of_gaussians</monospace>&quot;, &quot;<monospace>top_hat</monospace>&quot;, &quot;<monospace>one_hot</monospace>&quot;]</td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf241"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>w</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>widths</monospace></td><td align="left" valign="bottom">Place cell width parameter; can be specified by a single number (all cells have same width), or an array (each cell has different width) (m).</td><td align="char" char="." valign="bottom">0.2</td><td align="left" valign="bottom"><inline-formula><mml:math id="inf242"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>+</mml:mo></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula></td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf243"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mo fence="false" stretchy="false">{</mml:mo><mml:msubsup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>PC</mml:mtext></mml:mrow></mml:mrow></mml:msubsup><mml:mo fence="false" stretchy="false">}</mml:mo></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>place_cell_centres</monospace></td><td align="left" valign="bottom">Place cell locations. If <monospace>None</monospace>, place cells are randomly scattered (m).</td><td align="left" valign="bottom"><monospace>None</monospace></td><td align="left" valign="bottom">None or array of positions (length <inline-formula><mml:math id="inf244"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>n</mml:mi></mml:mstyle></mml:math></inline-formula>)</td></tr><tr><td align="left" valign="bottom">Wall geometry</td><td align="left" valign="bottom"><monospace>wall_geometry</monospace></td><td align="left" valign="bottom">How place cells interact with walls.</td><td align="left" valign="bottom">&quot;<monospace>geodesic</monospace>&quot;</td><td align="left" valign="bottom">[&quot;<monospace>geodesic</monospace>&quot;, &quot;<monospace>line_of_sight</monospace>&quot;, &quot;<monospace>euclidean</monospace>&quot;]</td></tr><tr><td align="center" valign="bottom" colspan="5"><monospace>GridCells()</monospace></td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf245"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>λ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>gridscale</monospace></td><td align="left" valign="bottom">Grid scales (m), or parameters for grid scale sampling distribution.</td><td align="char" char="." valign="bottom">(0.5,1)</td><td align="left" valign="bottom">array-like or tuple</td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf246"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>λ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula>-dist</td><td align="left" valign="bottom"><monospace>gridscale_distribution</monospace></td><td align="left" valign="bottom">The distribution from which grid scales are sampled, if they aren’t manually provided as an array/list.</td><td align="left" valign="bottom">&quot;uniform&quot;</td><td align="left" valign="bottom">see <monospace>utils.distribution_sampler()</monospace> for list</td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf247"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>θ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>orientation</monospace></td><td align="left" valign="bottom">Orientations (rad), or parameters for orientation sampling distribution.</td><td align="char" char="." valign="bottom">(0,2π)</td><td align="left" valign="bottom">array-like or tuple</td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf248"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>θ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula>-dist</td><td align="left" valign="bottom"><monospace>orientation_distribution</monospace></td><td align="left" valign="bottom">The distribution from which orientations are sampled, if they aren’t manually provided as an array/list.</td><td align="left" valign="bottom">&quot;<monospace>uniform</monospace>&quot;</td><td align="left" valign="bottom">see <monospace>utils.distribution_sampler()</monospace> for list</td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf249"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>ϕ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>phase_offset</monospace></td><td align="left" valign="bottom">Phase offsets (rad), or parameters for phase offset sampling distribution.</td><td align="char" char="." valign="bottom">(0,2π)</td><td align="left" valign="bottom">array-like or tuple</td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf250"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>ϕ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula>-dist</td><td align="left" valign="bottom"><monospace>phase_offset_distribution</monospace></td><td align="left" valign="bottom">The distribution from which phase offsets are sampled, if they aren’t manually provided as an array/list.</td><td align="left" valign="bottom">&quot;<monospace>uniform</monospace>&quot;</td><td align="left" valign="bottom">see <monospace>utils.distribution_sampler()</monospace> for list</td></tr><tr><td align="left" valign="bottom">Type</td><td align="left" valign="bottom"><monospace>description</monospace></td><td align="left" valign="bottom">Grid cell firing function.</td><td align="left" valign="bottom">&quot;<monospace>three_rectified_cosines</monospace>&quot;</td><td align="left" valign="bottom">[&quot;<monospace>three_rectified_cosines</monospace>&quot;, &quot;<monospace>three_shifted_cosines</monospace>&quot;]</td></tr><tr><td align="center" valign="bottom" colspan="5"><monospace>VectorCells()</monospace></td></tr><tr><td align="left" valign="bottom">Reference frame</td><td align="left" valign="bottom"><monospace>reference_frame</monospace></td><td align="left" valign="bottom">Whether receptive fields are defined in allo- or egocentric coordinate frames</td><td align="left" valign="bottom">&quot;<monospace>allocentric</monospace>&quot;</td><td align="left" valign="bottom">[&quot;<monospace>allocentric</monospace>&quot;, &quot;<monospace>egocentric</monospace>&quot;]</td></tr><tr><td align="left" valign="bottom">Arrangement protocol</td><td align="left" valign="bottom"><monospace>cell_arrangement</monospace></td><td align="left" valign="bottom">How receptive fields are arranged in the environment.</td><td align="left" valign="bottom">&quot;<monospace>random</monospace>&quot;</td><td align="left" valign="bottom">[&quot;<monospace>random</monospace>&quot;, &quot;<monospace>uniform_manifold</monospace>&quot;, &quot;<monospace>diverging_manifold</monospace>&quot;, function()]</td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf251"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>d</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>tuning_distance</monospace></td><td align="left" valign="bottom">Tuning distances (m), or parameters for tuning distance sampling distribution.</td><td align="char" char="." valign="bottom">(0.0,0.3)</td><td align="left" valign="bottom">array-like or tuple</td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf252"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>d</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula>-dist</td><td align="left" valign="bottom"><monospace>tuning_distance_distribution</monospace></td><td align="left" valign="bottom">The distribution from which tuning distances are sampled, if they aren’t manually provided as an array/list.</td><td align="left" valign="bottom">&quot;<monospace>uniform</monospace>&quot;</td><td align="left" valign="bottom">see <monospace>utils.distribution _sampler()</monospace> for list</td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf253"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>d</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>sigma_distance</monospace></td><td align="left" valign="bottom">Distance tuning widths (m), or parameters for distance tuning widths distribution. (By default these give <inline-formula><mml:math id="inf254"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>ξ</mml:mi></mml:mstyle></mml:math></inline-formula> and <inline-formula><mml:math id="inf255"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>β</mml:mi></mml:mstyle></mml:math></inline-formula>)</td><td align="char" char="." valign="bottom">(0.08,12)</td><td align="left" valign="bottom">array-like or tuple</td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf256"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>d</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula>-dist</td><td align="left" valign="bottom"><monospace>sigma_distance_distribution</monospace></td><td align="left" valign="bottom">The distribution from which distance tuning widths are sampled, if they aren’t manually provided as an array/list. &quot;diverging&quot; is an exception where distance tuning widths are an increasing linear function of tuning distance.</td><td align="left" valign="bottom">&quot;diverging&quot;</td><td align="left" valign="bottom">see utils.distribution _sampler() for list</td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf257"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>ϕ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>tuning_angle</monospace></td><td align="left" valign="bottom">Tuning angles (<inline-formula><mml:math id="inf258"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mo>∘</mml:mo></mml:mstyle></mml:math></inline-formula>), or parameters for tuning angle sampling distribution (degrees).</td><td align="char" char="." valign="bottom">(0.0,360.0)</td><td align="left" valign="bottom">array-like or tuple</td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf259"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>ϕ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula>-dist</td><td align="left" valign="bottom"><monospace>tuning_angle_distribution</monospace></td><td align="left" valign="bottom">The distribution from which tuning angles are sampled, if they aren’t manually provided as an array/list.</td><td align="left" valign="bottom">&quot;<monospace>uniform</monospace>&quot;</td><td align="left" valign="bottom">see <monospace>utils.distribution_sampler()</monospace> for list</td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf260"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>ϕ</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>sigma_angle</monospace></td><td align="left" valign="bottom">Angular tuning widths (<inline-formula><mml:math id="inf261"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mo>∘</mml:mo></mml:mstyle></mml:math></inline-formula>), or parameters for angular tuning widths distribution (degrees).</td><td align="char" char="." valign="bottom">(10,30)</td><td align="left" valign="bottom">array-like or tuple</td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf262"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>ϕ</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula>-dist</td><td align="left" valign="bottom"><monospace>sigma_angle_distribution</monospace></td><td align="left" valign="bottom">The distribution from which angular tuning widths are sampled, if they aren’t manually provided as an array/list.</td><td align="left" valign="bottom">&quot;<monospace>uniform</monospace>&quot;</td><td align="left" valign="bottom">see <monospace>utils.distribution_sampler()</monospace> for list</td></tr><tr><td align="center" valign="bottom" colspan="5"><monospace>BoundaryVectorCells()</monospace></td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf263"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>d</mml:mi><mml:mi>θ</mml:mi></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>dtheta</monospace></td><td align="left" valign="bottom">Size of angular integration step (°).</td><td align="char" char="." valign="bottom">2.0</td><td align="left" valign="bottom"><inline-formula><mml:math id="inf264"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mn>0</mml:mn><mml:mo>&lt;</mml:mo><mml:mi>d</mml:mi><mml:mi>θ</mml:mi><mml:mo>&lt;&lt;</mml:mo><mml:mn>360</mml:mn></mml:mstyle></mml:mrow></mml:mstyle></mml:math></inline-formula></td></tr><tr><td align="center" valign="bottom" colspan="5"><monospace>ObjectVectorCells()</monospace></td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf265"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>t</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>object_tuning_type</monospace></td><td align="left" valign="bottom">Tuning type for object vectors, if &quot;<monospace>random</monospace>&quot; each OVC has preference for a random object type present in the environment</td><td align="left" valign="bottom">&quot;<monospace>random</monospace>&quot;</td><td align="left" valign="bottom">&quot;<monospace>random</monospace>&quot; or any-int or arrray-like</td></tr><tr><td align="left" valign="bottom">wall-behaviour</td><td align="left" valign="bottom"><monospace>walls_occlude</monospace></td><td align="left" valign="bottom">Whether walls occlude objects behind them.</td><td align="left" valign="bottom">True</td><td align="left" valign="bottom"><monospace>bool</monospace></td></tr><tr><td align="left" valign="bottom" colspan="5"><monospace>AgentVectorCells()</monospace></td></tr><tr><td align="left" valign="bottom">Other agent, <inline-formula><mml:math id="inf266"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>j</mml:mi></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>Other_Agent</monospace></td><td align="left" valign="bottom">The <monospace>ratinabox.Agent</monospace> which these cells are selective for.</td><td align="left" valign="bottom"><monospace>None</monospace></td><td align="left" valign="bottom"><monospace>ratinabox.Agent</monospace></td></tr><tr><td align="left" valign="bottom">wall-behaviour</td><td align="left" valign="bottom"><monospace>walls_occlude</monospace></td><td align="left" valign="bottom">Whether walls occlude <monospace>Agent</monospace>s behind them.</td><td align="left" valign="bottom">True</td><td align="left" valign="bottom"><monospace>bool</monospace></td></tr><tr><td align="center" valign="bottom" colspan="5"><monospace>FieldOfView[X]s()</monospace> for [<monospace>X</monospace>] <inline-formula><mml:math id="inf267"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mo>∈</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula> [<monospace>BVC</monospace>,<monospace>OVC</monospace>,<monospace>AVC</monospace>]</td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf268"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>r</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>fov</mml:mtext></mml:mrow></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>distance_range</monospace></td><td align="left" valign="bottom">Radial extent of the field-of-view (m).</td><td align="char" char="." valign="bottom">[0.02,0.4]</td><td align="left" valign="bottom">List of two distances</td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf269"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>θ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>fov</mml:mtext></mml:mrow></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>angle_range</monospace></td><td align="left" valign="bottom">Angular range of the field-of-view (°).</td><td align="char" char="." valign="bottom">[0,75]</td><td align="left" valign="bottom">List of two angles</td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf270"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msubsup><mml:mi>δ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>fov</mml:mtext></mml:mrow></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>0</mml:mn></mml:mrow></mml:msubsup></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>spatial_resolution</monospace></td><td align="left" valign="bottom">Resolution of the inner-most row of vector cells (m)</td><td align="char" char="." valign="bottom">0.02</td><td align="left" valign="bottom"/></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf271"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>β</mml:mi></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>beta</monospace></td><td align="left" valign="bottom">Inverse gradient for how quickly receptie fields increase with distance (for &quot;<monospace>diverging_manifold</monospace>&quot; only)</td><td align="char" char="." valign="bottom">5</td><td align="left" valign="bottom"><inline-formula><mml:math id="inf272"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>+</mml:mo></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula></td></tr><tr><td align="left" valign="bottom">Arrangement protocol</td><td align="left" valign="bottom"><monospace>cell_arrangement</monospace></td><td align="left" valign="bottom">How the field-of-view receptive fields are constructed</td><td align="left" valign="bottom">&quot;<monospace>diverging_manifold</monospace>&quot;</td><td align="left" valign="bottom">[&quot;<monospace>diverging_manifold</monospace>&quot;, &quot;<monospace>uniform_manifold</monospace>&quot;]</td></tr><tr><td align="center" valign="bottom" colspan="5"><monospace>FeedForwardLayer()</monospace></td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf273"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mo fence="false" stretchy="false">{</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">L</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>N</mml:mi></mml:mrow></mml:msubsup></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>input_layers</monospace></td><td align="left" valign="bottom">A list of <monospace>Neurons</monospace> classes which are upstream inputs to this layer.</td><td align="char" char="." valign="bottom">[]</td><td align="left" valign="bottom"><inline-formula><mml:math id="inf274"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>N</mml:mi></mml:mstyle></mml:math></inline-formula>-list of <monospace>Neurons</monospace> for <inline-formula><mml:math id="inf275"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>N</mml:mi><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:mstyle></mml:math></inline-formula></td></tr><tr><td align="left" valign="bottom">Activation function</td><td align="left" valign="bottom"><monospace>activation_function</monospace></td><td align="left" valign="bottom">Either a dictionary containing parameters of premade activation functions in <monospace>utils.activate()</monospace> or a user-define python function for bespoke activation function.</td><td align="left" valign="bottom">{&quot;<monospace>activation</monospace>&quot;: &quot;<monospace>linear</monospace>&quot;}</td><td align="left" valign="bottom">See <monospace>utils.activate()</monospace> for full list</td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf276"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>g</mml:mi></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>w_init_scale</monospace>**</td><td align="left" valign="bottom">Scale of random weight initialisation.</td><td align="char" char="." valign="bottom">1.0</td><td align="left" valign="bottom"><inline-formula><mml:math id="inf277"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>+</mml:mo></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula></td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf278"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>b</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>biases</monospace></td><td align="left" valign="bottom">Biases, one per neuron (optional).</td><td align="left" valign="bottom">[0,....,0]</td><td align="left" valign="bottom"><inline-formula><mml:math id="inf279"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula></td></tr><tr><td align="center" valign="bottom" colspan="5"><monospace>NeuralNetworkNeurons()</monospace></td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf280"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mo fence="false" stretchy="false">{</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">L</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>N</mml:mi></mml:mrow></mml:msubsup></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>input_layers</monospace></td><td align="left" valign="bottom">A list of <monospace>Neurons</monospace> classes which are upstream inputs to this layer.</td><td align="char" char="." valign="bottom">[]</td><td align="left" valign="bottom">A list of <monospace>Neurons</monospace></td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf281"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">N</mml:mi><mml:mi mathvariant="sans-serif">N</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>NeuralNetworkModule</monospace></td><td align="left" valign="bottom">The internal neural network function which maps inputs to outputs. If None a default ReLU networ kwith two-hidden layers of size 20 will be used.</td><td align="left" valign="bottom"><monospace>None</monospace></td><td align="left" valign="bottom">Any <monospace>torch.nn.module</monospace></td></tr><tr><td align="center" valign="bottom" colspan="5"><monospace>RandomSpatialNeurons()</monospace></td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf282"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>l</mml:mi></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>lengthscale</monospace></td><td align="left" valign="bottom">Lengthscale of the Gaussian process kernel (m).</td><td align="char" char="." valign="bottom">0.1</td><td align="left" valign="bottom"><inline-formula><mml:math id="inf283"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>+</mml:mo></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula></td></tr><tr><td align="left" valign="bottom">Wall geometry</td><td align="left" valign="bottom"><monospace>wall_geometry</monospace></td><td align="left" valign="bottom">How distances are calculated and therefore how these cells interact with walls.</td><td align="left" valign="bottom">&quot;<monospace>geodesic</monospace>&quot;</td><td align="left" valign="bottom">[&quot;<monospace>geodesic</monospace>&quot;, &quot;<monospace>line_of_sight</monospace>&quot;, &quot;<monospace>euclidean</monospace>&quot;]</td></tr><tr><td align="center" valign="bottom" colspan="5"><monospace>PhasePrecessingPlaceCells()</monospace></td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf284"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>ν</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>θ</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>theta_freq</monospace></td><td align="left" valign="bottom">The theta frequency (Hz).</td><td align="char" char="." valign="bottom">10.0</td><td align="left" valign="bottom"><inline-formula><mml:math id="inf285"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>+</mml:mo></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula></td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf286"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>κ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>θ</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>kappa</monospace></td><td align="left" valign="bottom">The phase precession breadth parameter.</td><td align="char" char="." valign="bottom">1.0</td><td align="left" valign="bottom"><inline-formula><mml:math id="inf287"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>+</mml:mo></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula></td></tr><tr><td align="left" valign="bottom"><inline-formula><mml:math id="inf288"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>β</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>θ</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><monospace>beta</monospace></td><td align="left" valign="bottom">The phase precession fraction.</td><td align="char" char="." valign="bottom">0.5</td><td align="left" valign="bottom"><inline-formula><mml:math id="inf289"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mn>0.0</mml:mn><mml:mo>&lt;</mml:mo><mml:mi>β</mml:mi><mml:mo>&lt;</mml:mo><mml:mn>1.0</mml:mn></mml:mstyle></mml:mrow></mml:mstyle></mml:math></inline-formula></td></tr></tbody></table></table-wrap></sec><sec id="s4-10"><title>License</title><p>RatInABox is currently distributed under an MIT License, meaning users are permitted to use, copy, modify, merge publish, distribute, sublicense and sell copies of the software.</p></sec></sec></body><back><sec sec-type="additional-information" id="s5"><title>Additional information</title><fn-group content-type="competing-interest"><title>Competing interests</title><fn fn-type="COI-statement" id="conf1"><p>No competing interests declared</p></fn></fn-group><fn-group content-type="author-contribution"><title>Author contributions</title><fn fn-type="con" id="con1"><p>Conceptualization, Software, Formal analysis, Validation, Investigation, Visualization, Methodology, Writing – original draft, Writing – review and editing</p></fn><fn fn-type="con" id="con2"><p>Software</p></fn><fn fn-type="con" id="con3"><p>Supervision, Writing – review and editing</p></fn><fn fn-type="con" id="con4"><p>Supervision, Writing – review and editing</p></fn><fn fn-type="con" id="con5"><p>Supervision, Writing – review and editing</p></fn><fn fn-type="con" id="con6"><p>Supervision, Writing – review and editing</p></fn></fn-group></sec><sec sec-type="supplementary-material" id="s6"><title>Additional files</title><supplementary-material id="mdar"><label>MDAR checklist</label><media xlink:href="elife-85274-mdarchecklist1-v2.docx" mimetype="application" mime-subtype="docx"/></supplementary-material></sec><sec sec-type="data-availability" id="s7"><title>Data availability</title><p>Code is provided on the GitHub repository <ext-link ext-link-type="uri" xlink:href="https://github.com/TomGeorge1234/RatInABox">https://github.com/TomGeorge1234/RatInABox</ext-link> (<xref ref-type="bibr" rid="bib14">George, 2022</xref>).</p><p>The following previously published dataset was used:</p><p><element-citation publication-type="data" specific-use="references" id="dataset1"><person-group person-group-type="author"><name><surname>Sargolini</surname><given-names>F</given-names></name></person-group><year iso-8601-date="2006">2006</year><data-title>Grid cell data Sargolini et al 2006</data-title><source>NIRD Research Data Archive</source><pub-id pub-id-type="doi">10.11582/2017.00019</pub-id></element-citation></p></sec><ack id="ack"><title>Acknowledgements</title><p>We thank Tom Burns, Gastón Sivori, Peter Vincent and Colleen Gillon for helpful discussions and comments on the manuscript.</p></ack><ref-list><title>References</title><ref id="bib1"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Banino</surname><given-names>A</given-names></name><name><surname>Barry</surname><given-names>C</given-names></name><name><surname>Uria</surname><given-names>B</given-names></name><name><surname>Blundell</surname><given-names>C</given-names></name><name><surname>Lillicrap</surname><given-names>T</given-names></name><name><surname>Mirowski</surname><given-names>P</given-names></name><name><surname>Pritzel</surname><given-names>A</given-names></name><name><surname>Chadwick</surname><given-names>MJ</given-names></name><name><surname>Degris</surname><given-names>T</given-names></name><name><surname>Modayil</surname><given-names>J</given-names></name><name><surname>Wayne</surname><given-names>G</given-names></name><name><surname>Soyer</surname><given-names>H</given-names></name><name><surname>Viola</surname><given-names>F</given-names></name><name><surname>Zhang</surname><given-names>B</given-names></name><name><surname>Goroshin</surname><given-names>R</given-names></name><name><surname>Rabinowitz</surname><given-names>N</given-names></name><name><surname>Pascanu</surname><given-names>R</given-names></name><name><surname>Beattie</surname><given-names>C</given-names></name><name><surname>Petersen</surname><given-names>S</given-names></name><name><surname>Sadik</surname><given-names>A</given-names></name><name><surname>Gaffney</surname><given-names>S</given-names></name><name><surname>King</surname><given-names>H</given-names></name><name><surname>Kavukcuoglu</surname><given-names>K</given-names></name><name><surname>Hassabis</surname><given-names>D</given-names></name><name><surname>Hadsell</surname><given-names>R</given-names></name><name><surname>Kumaran</surname><given-names>D</given-names></name></person-group><year iso-8601-date="2018">2018</year><article-title>Vector-based navigation using grid-like representations in artificial agents</article-title><source>Nature</source><volume>557</volume><fpage>429</fpage><lpage>433</lpage><pub-id pub-id-type="doi">10.1038/s41586-018-0102-6</pub-id><pub-id pub-id-type="pmid">29743670</pub-id></element-citation></ref><ref id="bib2"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Barry</surname><given-names>C</given-names></name><name><surname>Lever</surname><given-names>C</given-names></name><name><surname>Hayman</surname><given-names>R</given-names></name><name><surname>Hartley</surname><given-names>T</given-names></name><name><surname>Burton</surname><given-names>S</given-names></name><name><surname>O’Keefe</surname><given-names>J</given-names></name><name><surname>Jeffery</surname><given-names>K</given-names></name><name><surname>Burgess</surname><given-names>N</given-names></name></person-group><year iso-8601-date="2006">2006</year><article-title>The boundary vector cell model of place cell firing and spatial memory</article-title><source>Reviews in the Neurosciences</source><volume>17</volume><fpage>71</fpage><lpage>97</lpage><pub-id pub-id-type="doi">10.1515/revneuro.2006.17.1-2.71</pub-id><pub-id pub-id-type="pmid">16703944</pub-id></element-citation></ref><ref id="bib3"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Barry</surname><given-names>C</given-names></name><name><surname>Hayman</surname><given-names>R</given-names></name><name><surname>Burgess</surname><given-names>N</given-names></name><name><surname>Jeffery</surname><given-names>KJ</given-names></name></person-group><year iso-8601-date="2007">2007</year><article-title>Experience-dependent rescaling of entorhinal grids</article-title><source>Nature Neuroscience</source><volume>10</volume><fpage>682</fpage><lpage>684</lpage><pub-id pub-id-type="doi">10.1038/nn1905</pub-id><pub-id pub-id-type="pmid">17486102</pub-id></element-citation></ref><ref id="bib4"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Benna</surname><given-names>MK</given-names></name><name><surname>Fusi</surname><given-names>S</given-names></name></person-group><year iso-8601-date="2021">2021</year><article-title>Place cells may simply be memory cells: Memory compression leads to spatial tuning and history dependence</article-title><source>PNAS</source><volume>118</volume><elocation-id>e2018422118</elocation-id><pub-id pub-id-type="doi">10.1073/pnas.2018422118</pub-id><pub-id pub-id-type="pmid">34916282</pub-id></element-citation></ref><ref id="bib5"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Bono</surname><given-names>J</given-names></name><name><surname>Zannone</surname><given-names>S</given-names></name><name><surname>Pedrosa</surname><given-names>V</given-names></name><name><surname>Clopath</surname><given-names>C</given-names></name></person-group><year iso-8601-date="2023">2023</year><article-title>Learning predictive cognitive maps with spiking neurons during behavior and replays</article-title><source>eLife</source><volume>12</volume><elocation-id>e80671</elocation-id><pub-id pub-id-type="doi">10.7554/eLife.80671</pub-id><pub-id pub-id-type="pmid">36927625</pub-id></element-citation></ref><ref id="bib6"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Bostock</surname><given-names>E</given-names></name><name><surname>Muller</surname><given-names>RU</given-names></name><name><surname>Kubie</surname><given-names>JL</given-names></name></person-group><year iso-8601-date="1991">1991</year><article-title>Experience-dependent modifications of hippocampal place cell firing</article-title><source>Hippocampus</source><volume>1</volume><fpage>193</fpage><lpage>205</lpage><pub-id pub-id-type="doi">10.1002/hipo.450010207</pub-id><pub-id pub-id-type="pmid">1669293</pub-id></element-citation></ref><ref id="bib7"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Burak</surname><given-names>Y</given-names></name><name><surname>Fiete</surname><given-names>IR</given-names></name><name><surname>Sporns</surname><given-names>O</given-names></name></person-group><year iso-8601-date="2009">2009</year><article-title>Accurate path integration in continuous attractor network models of grid cells</article-title><source>PLOS Computational Biology</source><volume>5</volume><elocation-id>e1000291</elocation-id><pub-id pub-id-type="doi">10.1371/journal.pcbi.1000291</pub-id></element-citation></ref><ref id="bib8"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Burgess</surname><given-names>N</given-names></name><name><surname>Barry</surname><given-names>C</given-names></name><name><surname>O’Keefe</surname><given-names>J</given-names></name></person-group><year iso-8601-date="2007">2007</year><article-title>An oscillatory interference model of grid cell firing</article-title><source>Hippocampus</source><volume>17</volume><fpage>801</fpage><lpage>812</lpage><pub-id pub-id-type="doi">10.1002/hipo.20327</pub-id><pub-id pub-id-type="pmid">17598147</pub-id></element-citation></ref><ref id="bib9"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Byrne</surname><given-names>P</given-names></name><name><surname>Becker</surname><given-names>S</given-names></name><name><surname>Burgess</surname><given-names>N</given-names></name></person-group><year iso-8601-date="2007">2007</year><article-title>Remembering the past and imagining the future: A neural model of spatial memory and imagery</article-title><source>Psychological Review</source><volume>114</volume><fpage>340</fpage><lpage>375</lpage><pub-id pub-id-type="doi">10.1037/0033-295X.114.2.340</pub-id><pub-id pub-id-type="pmid">17500630</pub-id></element-citation></ref><ref id="bib10"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>de Cothi</surname><given-names>W</given-names></name><name><surname>Barry</surname><given-names>C</given-names></name></person-group><year iso-8601-date="2020">2020</year><article-title>Neurobiological successor features for spatial navigation</article-title><source>Hippocampus</source><volume>30</volume><fpage>1347</fpage><lpage>1355</lpage><pub-id pub-id-type="doi">10.1002/hipo.23246</pub-id><pub-id pub-id-type="pmid">32584491</pub-id></element-citation></ref><ref id="bib11"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>de Cothi</surname><given-names>W</given-names></name><name><surname>Nyberg</surname><given-names>N</given-names></name><name><surname>Griesbauer</surname><given-names>E-M</given-names></name><name><surname>Ghanamé</surname><given-names>C</given-names></name><name><surname>Zisch</surname><given-names>F</given-names></name><name><surname>Lefort</surname><given-names>JM</given-names></name><name><surname>Fletcher</surname><given-names>L</given-names></name><name><surname>Newton</surname><given-names>C</given-names></name><name><surname>Renaudineau</surname><given-names>S</given-names></name><name><surname>Bendor</surname><given-names>D</given-names></name><name><surname>Grieves</surname><given-names>R</given-names></name><name><surname>Duvelle</surname><given-names>É</given-names></name><name><surname>Barry</surname><given-names>C</given-names></name><name><surname>Spiers</surname><given-names>HJ</given-names></name></person-group><year iso-8601-date="2022">2022</year><article-title>Predictive maps in rats and humans for spatial navigation</article-title><source>Current Biology</source><volume>32</volume><fpage>3676</fpage><lpage>3689</lpage><pub-id pub-id-type="doi">10.1016/j.cub.2022.06.090</pub-id><pub-id pub-id-type="pmid">35863351</pub-id></element-citation></ref><ref id="bib12"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>del Castillo</surname><given-names>J</given-names></name><name><surname>Katz</surname><given-names>B</given-names></name></person-group><year iso-8601-date="1954">1954</year><article-title>Quantal components of the end‐plate potential</article-title><source>The Journal of Physiology</source><volume>124</volume><fpage>560</fpage><lpage>573</lpage><pub-id pub-id-type="doi">10.1113/jphysiol.1954.sp005129</pub-id></element-citation></ref><ref id="bib13"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Doya</surname><given-names>K</given-names></name></person-group><year iso-8601-date="2000">2000</year><article-title>Reinforcement learning in continuous time and space</article-title><source>Neural Computation</source><volume>12</volume><fpage>219</fpage><lpage>245</lpage><pub-id pub-id-type="doi">10.1162/089976600300015961</pub-id><pub-id pub-id-type="pmid">10636940</pub-id></element-citation></ref><ref id="bib14"><element-citation publication-type="software"><person-group person-group-type="author"><name><surname>George</surname><given-names>TM</given-names></name></person-group><year iso-8601-date="2022">2022</year><data-title>Ratinabox</data-title><version designator="v1.11.4">v1.11.4</version><source>Github</source><ext-link ext-link-type="uri" xlink:href="https://github.com/TomGeorge1234/RatInABox">https://github.com/TomGeorge1234/RatInABox</ext-link></element-citation></ref><ref id="bib15"><element-citation publication-type="preprint"><person-group person-group-type="author"><name><surname>George</surname><given-names>TM</given-names></name><name><surname>de Cothi</surname><given-names>W</given-names></name><name><surname>Stachenfeld</surname><given-names>K</given-names></name><name><surname>Barry</surname><given-names>C</given-names></name></person-group><year iso-8601-date="2022">2022</year><article-title>Rapid learning of predictive maps with STDP and theta phase precession</article-title><source>bioRxiv</source><pub-id pub-id-type="doi">10.1101/2022.04.20.488882</pub-id></element-citation></ref><ref id="bib16"><element-citation publication-type="preprint"><person-group person-group-type="author"><name><surname>George</surname><given-names>TM</given-names></name><name><surname>Barry</surname><given-names>C</given-names></name><name><surname>Stachenfeld</surname><given-names>K</given-names></name><name><surname>Clopath</surname><given-names>C</given-names></name><name><surname>Fukai</surname><given-names>T</given-names></name></person-group><year iso-8601-date="2023">2023</year><article-title>A generative model of the hippocampal formation trained with theta driven local learning rules</article-title><source>bioRxiv</source><pub-id pub-id-type="doi">10.1101/2023.12.12.571268v1</pub-id></element-citation></ref><ref id="bib17"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gustafson</surname><given-names>NJ</given-names></name><name><surname>Daw</surname><given-names>ND</given-names></name></person-group><year iso-8601-date="2011">2011</year><article-title>Grid cells, place cells, and geodesic generalization for spatial reinforcement learning</article-title><source>PLOS Computational Biology</source><volume>7</volume><elocation-id>e1002235</elocation-id><pub-id pub-id-type="doi">10.1371/journal.pcbi.1002235</pub-id><pub-id pub-id-type="pmid">22046115</pub-id></element-citation></ref><ref id="bib18"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Harris</surname><given-names>CR</given-names></name><name><surname>Millman</surname><given-names>KJ</given-names></name><name><surname>van der Walt</surname><given-names>SJ</given-names></name><name><surname>Gommers</surname><given-names>R</given-names></name><name><surname>Virtanen</surname><given-names>P</given-names></name><name><surname>Cournapeau</surname><given-names>D</given-names></name><name><surname>Wieser</surname><given-names>E</given-names></name><name><surname>Taylor</surname><given-names>J</given-names></name><name><surname>Berg</surname><given-names>S</given-names></name><name><surname>Smith</surname><given-names>NJ</given-names></name><name><surname>Kern</surname><given-names>R</given-names></name><name><surname>Picus</surname><given-names>M</given-names></name><name><surname>Hoyer</surname><given-names>S</given-names></name><name><surname>van Kerkwijk</surname><given-names>MH</given-names></name><name><surname>Brett</surname><given-names>M</given-names></name><name><surname>Haldane</surname><given-names>A</given-names></name><name><surname>Del Río</surname><given-names>JF</given-names></name><name><surname>Wiebe</surname><given-names>M</given-names></name><name><surname>Peterson</surname><given-names>P</given-names></name><name><surname>Gérard-Marchant</surname><given-names>P</given-names></name><name><surname>Sheppard</surname><given-names>K</given-names></name><name><surname>Reddy</surname><given-names>T</given-names></name><name><surname>Weckesser</surname><given-names>W</given-names></name><name><surname>Abbasi</surname><given-names>H</given-names></name><name><surname>Gohlke</surname><given-names>C</given-names></name><name><surname>Oliphant</surname><given-names>TE</given-names></name></person-group><year iso-8601-date="2020">2020</year><article-title>Array programming with NumPy</article-title><source>Nature</source><volume>585</volume><fpage>357</fpage><lpage>362</lpage><pub-id pub-id-type="doi">10.1038/s41586-020-2649-2</pub-id><pub-id pub-id-type="pmid">32939066</pub-id></element-citation></ref><ref id="bib19"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hartley</surname><given-names>T</given-names></name><name><surname>Burgess</surname><given-names>N</given-names></name><name><surname>Lever</surname><given-names>C</given-names></name><name><surname>Cacucci</surname><given-names>F</given-names></name><name><surname>O’Keefe</surname><given-names>J</given-names></name></person-group><year iso-8601-date="2000">2000</year><article-title>Modeling place fields in terms of the cortical inputs to the hippocampus</article-title><source>Hippocampus</source><volume>10</volume><fpage>369</fpage><lpage>379</lpage><pub-id pub-id-type="doi">10.1002/1098-1063(2000)10:4&lt;369::AID-HIPO3&gt;3.0.CO;2-0</pub-id><pub-id pub-id-type="pmid">10985276</pub-id></element-citation></ref><ref id="bib20"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hartley</surname><given-names>T</given-names></name><name><surname>Trinkler</surname><given-names>I</given-names></name><name><surname>Burgess</surname><given-names>N</given-names></name></person-group><year iso-8601-date="2004">2004</year><article-title>Geometric determinants of human spatial memory</article-title><source>Cognition</source><volume>94</volume><fpage>39</fpage><lpage>75</lpage><pub-id pub-id-type="doi">10.1016/j.cognition.2003.12.001</pub-id></element-citation></ref><ref id="bib21"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hepburn</surname><given-names>I</given-names></name><name><surname>Chen</surname><given-names>W</given-names></name><name><surname>Wils</surname><given-names>S</given-names></name><name><surname>De Schutter</surname><given-names>E</given-names></name></person-group><year iso-8601-date="2012">2012</year><article-title>STEPS: efficient simulation of stochastic reaction-diffusion models in realistic morphologies</article-title><source>BMC Systems Biology</source><volume>6</volume><elocation-id>36</elocation-id><pub-id pub-id-type="doi">10.1186/1752-0509-6-36</pub-id><pub-id pub-id-type="pmid">22574658</pub-id></element-citation></ref><ref id="bib22"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hines</surname><given-names>ML</given-names></name><name><surname>Carnevale</surname><given-names>NT</given-names></name></person-group><year iso-8601-date="1997">1997</year><article-title>The NEURON simulation environment</article-title><source>Neural Computation</source><volume>9</volume><fpage>1179</fpage><lpage>1209</lpage><pub-id pub-id-type="doi">10.1162/neco.1997.9.6.1179</pub-id><pub-id pub-id-type="pmid">9248061</pub-id></element-citation></ref><ref id="bib23"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hodgkin</surname><given-names>AL</given-names></name><name><surname>Huxley</surname><given-names>AF</given-names></name></person-group><year iso-8601-date="1952">1952</year><article-title>A quantitative description of membrane current and its application to conduction and excitation in nerve</article-title><source>The Journal of Physiology</source><volume>117</volume><fpage>500</fpage><lpage>544</lpage><pub-id pub-id-type="doi">10.1113/jphysiol.1952.sp004764</pub-id></element-citation></ref><ref id="bib24"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Jeewajee</surname><given-names>A</given-names></name><name><surname>Barry</surname><given-names>C</given-names></name><name><surname>Douchamps</surname><given-names>V</given-names></name><name><surname>Manson</surname><given-names>D</given-names></name><name><surname>Lever</surname><given-names>C</given-names></name><name><surname>Burgess</surname><given-names>N</given-names></name></person-group><year iso-8601-date="2014">2014</year><article-title>Theta phase precession of grid and place cell firing in open environments</article-title><source>Philosophical Transactions of the Royal Society of London. Series B, Biological Sciences</source><volume>369</volume><elocation-id>20120532</elocation-id><pub-id pub-id-type="doi">10.1098/rstb.2012.0532</pub-id><pub-id pub-id-type="pmid">24366140</pub-id></element-citation></ref><ref id="bib25"><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Juliani</surname><given-names>A</given-names></name><name><surname>Barnett</surname><given-names>S</given-names></name><name><surname>Davis</surname><given-names>B</given-names></name><name><surname>Sereno</surname><given-names>M</given-names></name><name><surname>Momennejad</surname><given-names>I</given-names></name></person-group><year iso-8601-date="2022">2022</year><article-title>Neuro-Nav: a library for neurally-plausible reinforcement learning</article-title><conf-name>2022 Conference on Cognitive Computational Neuroscience</conf-name><conf-loc>San Francisco, California, USA</conf-loc><elocation-id>1.16</elocation-id><pub-id pub-id-type="doi">10.32470/CCN.2022.1212-0</pub-id></element-citation></ref><ref id="bib26"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kropff</surname><given-names>E</given-names></name><name><surname>Carmichael</surname><given-names>JE</given-names></name><name><surname>Moser</surname><given-names>M-B</given-names></name><name><surname>Moser</surname><given-names>EI</given-names></name></person-group><year iso-8601-date="2015">2015</year><article-title>Speed cells in the medial entorhinal cortex</article-title><source>Nature</source><volume>523</volume><fpage>419</fpage><lpage>424</lpage><pub-id pub-id-type="doi">10.1038/nature14622</pub-id><pub-id pub-id-type="pmid">26176924</pub-id></element-citation></ref><ref id="bib27"><element-citation publication-type="preprint"><person-group person-group-type="author"><name><surname>Lee</surname><given-names>JQ</given-names></name><name><surname>Keinath</surname><given-names>AT</given-names></name><name><surname>Cianfarano</surname><given-names>E</given-names></name><name><surname>Brandon</surname><given-names>MP</given-names></name></person-group><year iso-8601-date="2023">2023</year><article-title>Identifying Representational Structure in CA1 to Benchmark Theoretical Models of Cognitive Mapping</article-title><source>bioRxiv</source><pub-id pub-id-type="doi">10.1101/2023.10.08.561112</pub-id></element-citation></ref><ref id="bib28"><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>MacKay</surname><given-names>DJC</given-names></name></person-group><source>Information Theory, Inference, and Learning Algorithms</source><publisher-name>Cambridge University Press</publisher-name><year iso-8601-date="2003">2003</year></element-citation></ref><ref id="bib29"><element-citation publication-type="preprint"><person-group person-group-type="author"><name><surname>Maxime</surname><given-names>C</given-names></name><name><surname>Bolun</surname><given-names>D</given-names></name><name><surname>Mark</surname><given-names>T</given-names></name></person-group><year iso-8601-date="2023">2023</year><article-title>Minigrid &amp; Miniworld: Modular &amp; Customizable Reinforcement Learning Environments for Goal-Oriented Tasks</article-title><source>arXiv</source><pub-id pub-id-type="doi">10.48550/arXiv.2306.13831</pub-id></element-citation></ref><ref id="bib30"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Mehta</surname><given-names>MR</given-names></name><name><surname>Quirk</surname><given-names>MC</given-names></name><name><surname>Wilson</surname><given-names>MA</given-names></name></person-group><year iso-8601-date="2000">2000</year><article-title>Experience-dependent asymmetric shape of hippocampal receptive fields</article-title><source>Neuron</source><volume>25</volume><fpage>707</fpage><lpage>715</lpage><pub-id pub-id-type="doi">10.1016/s0896-6273(00)81072-7</pub-id><pub-id pub-id-type="pmid">10774737</pub-id></element-citation></ref><ref id="bib31"><element-citation publication-type="preprint"><person-group person-group-type="author"><name><surname>Merel</surname><given-names>J</given-names></name><name><surname>Aldarondo</surname><given-names>D</given-names></name><name><surname>Marshall</surname><given-names>J</given-names></name><name><surname>Tassa</surname><given-names>Y</given-names></name><name><surname>Wayne</surname><given-names>G</given-names></name><name><surname>Olveczky</surname><given-names>B</given-names></name></person-group><year iso-8601-date="2019">2019</year><article-title>Deep neuroethology of a virtual rodent</article-title><source>arXiv</source><ext-link ext-link-type="uri" xlink:href="https://arxiv.org/abs/1911.09451">https://arxiv.org/abs/1911.09451</ext-link></element-citation></ref><ref id="bib32"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>O’Keefe</surname><given-names>J</given-names></name><name><surname>Dostrovsky</surname><given-names>J</given-names></name></person-group><year iso-8601-date="1971">1971</year><article-title>The hippocampus as a spatial map. Preliminary evidence from unit activity in the freely-moving rat</article-title><source>Brain Research</source><volume>34</volume><fpage>171</fpage><lpage>175</lpage><pub-id pub-id-type="doi">10.1016/0006-8993(71)90358-1</pub-id><pub-id pub-id-type="pmid">5124915</pub-id></element-citation></ref><ref id="bib33"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>O’Keefe</surname><given-names>J</given-names></name><name><surname>Recce</surname><given-names>ML</given-names></name></person-group><year iso-8601-date="1993">1993</year><article-title>Phase relationship between hippocampal place units and the EEG theta rhythm</article-title><source>Hippocampus</source><volume>3</volume><fpage>317</fpage><lpage>330</lpage><pub-id pub-id-type="doi">10.1002/hipo.450030307</pub-id><pub-id pub-id-type="pmid">8353611</pub-id></element-citation></ref><ref id="bib34"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>O’Keefe</surname><given-names>J</given-names></name><name><surname>Burgess</surname><given-names>N</given-names></name></person-group><year iso-8601-date="1996">1996</year><article-title>Geometric determinants of the place fields of hippocampal neurons</article-title><source>Nature</source><volume>381</volume><fpage>425</fpage><lpage>428</lpage><pub-id pub-id-type="doi">10.1038/381425a0</pub-id><pub-id pub-id-type="pmid">8632799</pub-id></element-citation></ref><ref id="bib35"><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Paszke</surname><given-names>A</given-names></name><name><surname>Gross</surname><given-names>S</given-names></name><name><surname>Massa</surname><given-names>F</given-names></name><name><surname>Lerer</surname><given-names>A</given-names></name><name><surname>Bradbury</surname><given-names>J</given-names></name><name><surname>Chanan</surname><given-names>G</given-names></name><name><surname>Killeen</surname><given-names>T</given-names></name><name><surname>Lin</surname><given-names>Z</given-names></name><name><surname>Gimelshein</surname><given-names>N</given-names></name><name><surname>Antiga</surname><given-names>L</given-names></name><name><surname>Desmaison</surname><given-names>A</given-names></name><name><surname>Kopf</surname><given-names>A</given-names></name><name><surname>Yang</surname><given-names>E</given-names></name><name><surname>DeVito</surname><given-names>Z</given-names></name><name><surname>Raison</surname><given-names>M</given-names></name><name><surname>Tejani</surname><given-names>A</given-names></name><name><surname>Chilamkurthy</surname><given-names>S</given-names></name><name><surname>Steiner</surname><given-names>B</given-names></name><name><surname>Fang</surname><given-names>L</given-names></name><name><surname>Bai</surname><given-names>J</given-names></name><name><surname>Chintala</surname><given-names>S</given-names></name></person-group><year iso-8601-date="2019">2019</year><chapter-title>Pytorch: an imperative style, high-performance deep learning library</chapter-title><source>In Advances in Neural Information Processing Systems 32</source><publisher-name>Curran Associates, Inc</publisher-name><fpage>8024</fpage><lpage>8035</lpage></element-citation></ref><ref id="bib36"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Raudies</surname><given-names>F</given-names></name><name><surname>Hasselmo</surname><given-names>ME</given-names></name></person-group><year iso-8601-date="2012">2012</year><article-title>Modeling boundary vector cell firing given optic flow as a cue</article-title><source>PLOS Computational Biology</source><volume>8</volume><elocation-id>e1002553</elocation-id><pub-id pub-id-type="doi">10.1371/journal.pcbi.1002553</pub-id><pub-id pub-id-type="pmid">22761557</pub-id></element-citation></ref><ref id="bib37"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Sargolini</surname><given-names>F</given-names></name><name><surname>Fyhn</surname><given-names>M</given-names></name><name><surname>Hafting</surname><given-names>T</given-names></name><name><surname>McNaughton</surname><given-names>BL</given-names></name><name><surname>Witter</surname><given-names>MP</given-names></name><name><surname>Moser</surname><given-names>M-B</given-names></name><name><surname>Moser</surname><given-names>EI</given-names></name></person-group><year iso-8601-date="2006">2006</year><article-title>Conjunctive representation of position, direction, and velocity in entorhinal cortex</article-title><source>Science</source><volume>312</volume><fpage>758</fpage><lpage>762</lpage><pub-id pub-id-type="doi">10.1126/science.1125572</pub-id><pub-id pub-id-type="pmid">16675704</pub-id></element-citation></ref><ref id="bib38"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Satoh</surname><given-names>Y</given-names></name><name><surname>Endo</surname><given-names>S</given-names></name><name><surname>Nakata</surname><given-names>T</given-names></name><name><surname>Kobayashi</surname><given-names>Y</given-names></name><name><surname>Yamada</surname><given-names>K</given-names></name><name><surname>Ikeda</surname><given-names>T</given-names></name><name><surname>Takeuchi</surname><given-names>A</given-names></name><name><surname>Hiramoto</surname><given-names>T</given-names></name><name><surname>Watanabe</surname><given-names>Y</given-names></name><name><surname>Kazama</surname><given-names>T</given-names></name></person-group><year iso-8601-date="2011">2011</year><article-title>ERK2 contributes to the control of social behaviors in mice</article-title><source>The Journal of Neuroscience</source><volume>31</volume><fpage>11953</fpage><lpage>11967</lpage><pub-id pub-id-type="doi">10.1523/JNEUROSCI.2349-11.2011</pub-id><pub-id pub-id-type="pmid">21849556</pub-id></element-citation></ref><ref id="bib39"><element-citation publication-type="preprint"><person-group person-group-type="author"><name><surname>Schaeffer</surname><given-names>R</given-names></name><name><surname>Khona</surname><given-names>M</given-names></name><name><surname>Fiete</surname><given-names>IR</given-names></name></person-group><year iso-8601-date="2022">2022</year><article-title>No free lunch from deep learning in neuroscience: a case study through models of the entorhinal-hippocampal circuit</article-title><source>bioRxiv</source><pub-id pub-id-type="doi">10.1101/2022.08.07.503109</pub-id></element-citation></ref><ref id="bib40"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Solstad</surname><given-names>T</given-names></name><name><surname>Boccara</surname><given-names>CN</given-names></name><name><surname>Kropff</surname><given-names>E</given-names></name><name><surname>Moser</surname><given-names>M-B</given-names></name><name><surname>Moser</surname><given-names>EI</given-names></name></person-group><year iso-8601-date="2008">2008</year><article-title>Representation of geometric borders in the entorhinal cortex</article-title><source>Science</source><volume>322</volume><fpage>1865</fpage><lpage>1868</lpage><pub-id pub-id-type="doi">10.1126/science.1166466</pub-id></element-citation></ref><ref id="bib41"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Stachenfeld</surname><given-names>KL</given-names></name><name><surname>Botvinick</surname><given-names>MM</given-names></name><name><surname>Gershman</surname><given-names>SJ</given-names></name></person-group><year iso-8601-date="2017">2017</year><article-title>The hippocampus as a predictive map</article-title><source>Nature Neuroscience</source><volume>20</volume><fpage>1643</fpage><lpage>1653</lpage><pub-id pub-id-type="doi">10.1038/nn.4650</pub-id><pub-id pub-id-type="pmid">28967910</pub-id></element-citation></ref><ref id="bib42"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Stimberg</surname><given-names>M</given-names></name><name><surname>Brette</surname><given-names>R</given-names></name><name><surname>Goodman</surname><given-names>DF</given-names></name></person-group><year iso-8601-date="2019">2019</year><article-title>Brian 2, an intuitive and efficient neural simulator</article-title><source>eLife</source><volume>8</volume><elocation-id>e47314</elocation-id><pub-id pub-id-type="doi">10.7554/eLife.47314</pub-id><pub-id pub-id-type="pmid">31429824</pub-id></element-citation></ref><ref id="bib43"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Tanni</surname><given-names>S</given-names></name><name><surname>de Cothi</surname><given-names>W</given-names></name><name><surname>Barry</surname><given-names>C</given-names></name></person-group><year iso-8601-date="2022">2022</year><article-title>State transitions in the statistically stable place cell population correspond to rate of perceptual change</article-title><source>Current Biology</source><volume>32</volume><fpage>3505</fpage><lpage>3514</lpage><pub-id pub-id-type="doi">10.1016/j.cub.2022.06.046</pub-id><pub-id pub-id-type="pmid">35835121</pub-id></element-citation></ref><ref id="bib44"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Taube</surname><given-names>JS</given-names></name><name><surname>Muller</surname><given-names>RU</given-names></name><name><surname>Ranck</surname><given-names>JB</given-names></name></person-group><year iso-8601-date="1990">1990</year><article-title>Head-direction cells recorded from the postsubiculum in freely moving rats</article-title><source>I. Description and Quantitative Analysis. The Journal of Neuroscience</source><volume>10</volume><elocation-id>ISSN</elocation-id><pub-id pub-id-type="doi">10.1523/JNEUROSCI.10-02-00420.1990</pub-id></element-citation></ref><ref id="bib45"><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Todorov</surname><given-names>E</given-names></name><name><surname>Erez</surname><given-names>T</given-names></name><name><surname>Tassa</surname><given-names>Y</given-names></name></person-group><year iso-8601-date="2012">2012</year><article-title>IEEE/RSJ International Conference on Intelligent Robots and Systems</article-title><conf-name>IEEE</conf-name><conf-loc>Vilamoura-Algarve, Portugal</conf-loc><pub-id pub-id-type="doi">10.1109/IROS.2012.6386109</pub-id></element-citation></ref><ref id="bib46"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Tolman</surname><given-names>EC</given-names></name><name><surname>Honzik</surname><given-names>CH</given-names></name></person-group><year iso-8601-date="1930">1930</year><article-title>Introduction and removal of reward, and maze performance in rats</article-title><source>University of California, Publications in Psychology</source><volume>4</volume><fpage>257</fpage><lpage>275</lpage></element-citation></ref></ref-list><app-group><app id="appendix-1"><title>Appendix 1</title><sec sec-type="appendix" id="s8"><title>1.1 Figure details and parameter settings</title><p>A Jupyter script replicating <xref ref-type="fig" rid="fig1">Figures 1</xref>—<xref ref-type="fig" rid="fig3">3</xref> can be found at <ext-link ext-link-type="uri" xlink:href="https://github.com/RatInABox-Lab/RatInABox/blob/main/demos/paper_figures.ipynb">https://github.com/RatInABox-Lab/RatInABox/blob/main/demos/paper_figures.ipynb</ext-link>. Unless stated below, parameters in all figures take their default values listed in <xref ref-type="table" rid="table1">Table 1</xref>.</p><p><xref ref-type="fig" rid="fig1">Figure 1</xref>: Panel (b): Place cells are of type <monospace>gaussian_threshold</monospace> with widths <inline-formula><mml:math id="inf290"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>w</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0.4</mml:mn></mml:mstyle></mml:math></inline-formula> m. Panel (e) <inline-formula><mml:math id="inf291"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>μ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0.1</mml:mn></mml:mstyle></mml:math></inline-formula> and <inline-formula><mml:math id="inf292"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0.2</mml:mn></mml:mstyle></mml:math></inline-formula>.</p><p><xref ref-type="fig" rid="fig2">Figure 2</xref>: Panel (a): Curve fitting is done using <monospace>scipy.optimize.curve_fit</monospace>. Panel (d): <inline-formula><mml:math id="inf293"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>d</mml:mi><mml:mi>t</mml:mi><mml:mo>=</mml:mo><mml:mn>100</mml:mn></mml:mstyle></mml:math></inline-formula> ms. Panel (e) <monospace>Agent.wall_repel_strength</monospace> = 2. Panel (e) uses <italic>all</italic> available datasets from <xref ref-type="bibr" rid="bib37">Sargolini et al., 2006</xref> to create the historgrams, as opposed to panel (a) which only uses one of the recordings.</p><p><xref ref-type="fig" rid="fig3">Figure 3</xref>: Panel (a): 25 seconds of trajectory data from <xref ref-type="bibr" rid="bib37">Sargolini et al., 2006</xref> is imported, converted into metres, mean centred and then downsampled by 30 x (from 50 Hz to 1.66 Hz) before being imported into a RatInABox <monospace>Agent</monospace>. Panel (c): All populations of vector cells had &quot;<monospace>distance_range</monospace>&quot; = [0.05, 0.30], &quot;<monospace>angle_range</monospace>&quot; = [0,75] and &quot;<monospace>spatial_resolution</monospace>&quot;=0.015. Panel (e): RatInABox for reinforcement learning experiment is described below. Panel (f): The average and standard deviation over 1000 repeats is plotted. For the motion model this is taken for motion updates of a default <monospace>Agent</monospace> in a default <monospace>Environment</monospace> (i.e. 2D with solid boundary conditions and no additional walls). For the <monospace>numpy</monospace> matrix calculations the time taken does not include the time taken to initialise the matrices.</p></sec><sec sec-type="appendix" id="s9"><title>1.2 Supplementary figures</title><p>In this section we demonstrate how RatInABox could be used in two simple experiments: neural decoding and reinforcement learning. The intention is not to present novel scientific results but rather to demonstrate the capability of RatInABox to facilitate novel scientific research in a variety of fields. Additional demos beyond these two are given in the online repository and, as with all figures in this paper, executable Jupyter scripts are provided to replicate all figures shown.</p><sec sec-type="appendix" id="s9-1"><title>1.2.1 <xref ref-type="fig" rid="app1fig1">Appendix 1—figure 1</xref> RatInABox for neural decoding</title><p>Jupyter script: <ext-link ext-link-type="uri" xlink:href="https://github.com/RatInABox-Lab/RatInABox/blob/main/demos/paper_figures.ipynb">https://github.com/RatInABox-Lab/RatInABox/blob/main/demos/paper_figures.ipynb</ext-link>.</p><p>In this demonstration we study, using RatInABox, which type of spatially modulated cell type is best for decoding position.</p><p>First we generate training and testing datasets. A set of <monospace>Neurons</monospace> (<inline-formula><mml:math id="inf294"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>cells</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>20</mml:mn></mml:mstyle></mml:math></inline-formula>) is initialised in a 1 m square <monospace>Environment</monospace> containing a small barrier (<xref ref-type="fig" rid="app1fig1">Appendix 1—figure 1</xref>, top). A six minute trajectory is simulated using the RatInABox random motion model to produce a dataset of inputs <inline-formula><mml:math id="inf295"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mo fence="false" stretchy="false">{</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:msub><mml:mi>N</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>T</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msubsup></mml:mstyle></mml:math></inline-formula> and targets <inline-formula><mml:math id="inf296"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mo fence="false" stretchy="false">{</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">y</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:msub><mml:mi>N</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>T</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msubsup></mml:mstyle></mml:math></inline-formula>:<disp-formula id="equ53"><label>(53)</label><mml:math id="m53"><mml:mtable columnalign="right left right left right left right left right left right left" rowspacing="3pt" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" displaystyle="true"><mml:mtr><mml:mtd><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:mi/><mml:mo>=</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mi>F</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>∼</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi class="MJX-tex-caligraphic" mathvariant="script">X</mml:mi></mml:mrow><mml:mo>⊆</mml:mo><mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:msub><mml:mi>N</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>cells</mml:mtext></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:msup></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula><disp-formula id="equ54"><label>(54)</label><mml:math id="m54"><mml:mtable columnalign="right left right left right left right left right left right left" rowspacing="3pt" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" displaystyle="true"><mml:mtr><mml:mtd><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">y</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:mi/><mml:mo>=</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∼</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi class="MJX-tex-caligraphic" mathvariant="script">Y</mml:mi></mml:mrow><mml:mo>⊆</mml:mo><mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p>where <inline-formula><mml:math id="inf297"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> is the position of the <monospace>Agent</monospace> at time <inline-formula><mml:math id="inf298"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>t</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> and <inline-formula><mml:math id="inf299"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mi>F</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mstyle></mml:math></inline-formula> is the firing rate of the neuronal population. These data are split into training (<inline-formula><mml:math id="inf300"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mn>0</mml:mn><mml:mo>&lt;</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>&lt;</mml:mo><mml:mn>5</mml:mn></mml:mstyle></mml:mrow></mml:mstyle></mml:math></inline-formula> mins, <xref ref-type="fig" rid="app1fig1">Appendix 1—figure 1a</xref> purple) and testing (<inline-formula><mml:math id="inf301"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mn>5</mml:mn><mml:mo>&lt;</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>&lt;</mml:mo><mml:mn>6</mml:mn></mml:mstyle></mml:mrow></mml:mstyle></mml:math></inline-formula> mins, <xref ref-type="fig" rid="app1fig1">Appendix 1—figure 1a</xref> black) fractions. The goal of the decoder is to learn a mapping <inline-formula><mml:math id="inf302"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>G</mml:mi><mml:mo>:</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi class="MJX-tex-caligraphic" mathvariant="script">X</mml:mi></mml:mrow><mml:mo stretchy="false">→</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi class="MJX-tex-caligraphic" mathvariant="script">Y</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula>, from firing rates to positions.</p><p>To do this we use Gaussian Process Regression (GPR). GPR is a form of non-parameteric regression where a prior is placed over the infinite-dimensional function space <inline-formula><mml:math id="inf303"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> in the form of its covariance kernel <inline-formula><mml:math id="inf304"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo>,</mml:mo><mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi class="MJX-variant" mathvariant="normal">′</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> and mean <inline-formula><mml:math id="inf305"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>μ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> (typically zero). This defines a prior on the targets in the training set <inline-formula><mml:math id="inf306"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">Y</mml:mi></mml:mrow><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">y</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">y</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">y</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">T</mml:mi></mml:mrow></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula>,<disp-formula id="equ55"><label>(55)</label><mml:math id="m55"><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">Y</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi class="MJX-tex-caligraphic" mathvariant="script">N</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">Y</mml:mi></mml:mrow><mml:mo>;</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn mathvariant="bold">0</mml:mn></mml:mrow><mml:mo>,</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">C</mml:mi></mml:mrow></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:math></disp-formula></p><p>where <inline-formula><mml:math id="inf307"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">C</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>η</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>δ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> is a covariance matrix established over the data points. The second term accounts for additive noise in the data function. This can be used to make an inference on the posterior of the target for an unseen testing data point, <inline-formula><mml:math id="inf308"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">y</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>test</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mo fence="false" stretchy="false">{</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msup><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>train</mml:mtext></mml:mrow></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">y</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msup><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>train</mml:mtext></mml:mrow></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>test</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> – itself a Gaussian – the mean of which is taken as the “prediction”. A more comprehensive reference/tutorial on Gaussian Process Regression is given by <xref ref-type="bibr" rid="bib28">MacKay, 2003</xref>.</p><p>We use a radial basis function (aka “squared exponential”) kernel with width <inline-formula><mml:math id="inf309"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>l</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:msqrt><mml:msub><mml:mi>N</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>cells</mml:mtext></mml:mrow></mml:mrow></mml:msub></mml:msqrt></mml:mstyle></mml:math></inline-formula> which scales with the expected size of the population vector (<inline-formula><mml:math id="inf310"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mo>∼</mml:mo><mml:msqrt><mml:msub><mml:mi>N</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>cells</mml:mtext></mml:mrow></mml:mrow></mml:msub></mml:msqrt></mml:mstyle></mml:math></inline-formula>, we set <inline-formula><mml:math id="inf311"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>l</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msqrt><mml:mn>20</mml:mn></mml:msqrt></mml:mstyle></mml:math></inline-formula>)<disp-formula id="equ56"><label>(56)</label><mml:math id="m56"><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo>,</mml:mo><mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi class="MJX-variant" mathvariant="normal">′</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo>−</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:msup><mml:mi mathvariant="bold">x</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi class="MJX-variant" mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:msup><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:msup><mml:mi>l</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac><mml:mo>)</mml:mo></mml:mrow></mml:math></disp-formula></p><p>and a small amount of target noise <inline-formula><mml:math id="inf312"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>η</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mi>e</mml:mi><mml:mo>−</mml:mo><mml:mn>10</mml:mn></mml:mstyle></mml:math></inline-formula>. Note that the closest ‘parameterised’ analog to GPR with an RBF kernel is linear regression against Gaussian basis features of length scale <inline-formula><mml:math id="inf313"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>l</mml:mi></mml:mstyle></mml:math></inline-formula>. Since the Gaussian is a non-linear function this means our regression prior is also non-linear function of firing rate (and therefore potential non-biologically plausible). We choose to optimise with the <monospace>sklearn.gaussian_process.GaussianProcessRegressor</monospace> package. Note we do not attempt to optimise the hyperparameters <inline-formula><mml:math id="inf314"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>l</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> or <inline-formula><mml:math id="inf315"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>η</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:math></inline-formula> which one would probably do in a more rigorous experiment. RatInABox parameters are all default with the exception that the place cells are of type <monospace>gaussian_threshold</monospace> and width <inline-formula><mml:math id="inf316"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>w</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0.4</mml:mn></mml:mstyle></mml:math></inline-formula> m and the timestep is set to <inline-formula><mml:math id="inf317"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>d</mml:mi><mml:mi>t</mml:mi><mml:mo>=</mml:mo><mml:mn>50</mml:mn></mml:mstyle></mml:math></inline-formula> ms.</p><p><xref ref-type="fig" rid="app1fig1">Appendix 1—figure 1b</xref> (lower) show the results over comparable sets of <monospace>PlaceCells</monospace>, <monospace>GridCells</monospace> and <monospace>BoundaryVectorCells</monospace>. Coloured dots show the prediction – mean of the posterior – of the GPR model “trained” on all points in the training dataset for that particular cell type. This is plotted on top of the true trajectory, shown in black. <monospace>PlaceCells</monospace> perform best achieving under 1 cm average decoding error, followed by <monospace>BoundaryVectorCells</monospace> then <monospace>GridCells</monospace> where the decoded position is visibly noisy.</p><p>Place cells outperform grid cells which outperform BVCs irrespective of how many cells are using in the basis feature set. More cells gives lower decoding error. Decoding errors in <xref ref-type="fig" rid="app1fig1">Appendix 1—figure 1c</xref> are smaller than would be expected if one decoded from equivalently sized populations of <italic>real</italic> hippocampal neurons. There are likely many reasons for this. Real neurons are noisy, communicate sparsely through spikes rather than rates and, most likely, jointly encode position and many other behaviourally relevant (or irrelevant) variables simultaneously. All of these factors could be straightforwardly incorporated into this analysis using existing RatInABox functionality.</p><fig id="app1fig1" position="float"><label>Appendix 1—figure 1.</label><caption><title>RatInABox used for a simple neural decoding experiment.</title><p>(<bold>a</bold>) Training (5 min) and testing (1 min) trajectories are sampled in a 1 m square environment containing a small barrier. (<bold>b</bold>) The firing rates of a population of <inline-formula><mml:math id="inf318"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>N</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>cells</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>20</mml:mn></mml:mstyle></mml:math></inline-formula> cells, taken over the training trajectory, are used to fit a Gaussian Process regressor model estimating position. This decoder is then used to decode position from firing rates on the the unseen testing dataset. Top row shows receptive field for 4 of the 20 cells, bottom row shows decoding estimate (coloured dots) against ground truth (black dots). The process is carried out independently for populations of place cells (left), grid cells (middle) and boundary vector cells (right). (<bold>c</bold>) Average decoding error against number of cells, note log scale. Error region shows the standard error in the mean over 15 random seeds. A jupyter script demonstrating this experiment is given in the codebase <ext-link ext-link-type="uri" xlink:href="https://github.com/RatInABox-Lab/RatInABox/blob/main/demos/decoding_position_example.ipynb">GitHub repository</ext-link>.</p></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-85274-app1-fig1-v2.tif"/></fig></sec><sec sec-type="appendix" id="s9-2"><title>1.2.2 <xref ref-type="fig" rid="app1fig2">Appendix 1—figure 2</xref> RatInABox for reinforcement learning</title><p>Jupyter script: <ext-link ext-link-type="uri" xlink:href="https://github.com/RatInABox-Lab/RatInABox/blob/main/demos/reinforcement_learning_example.ipynb">https://github.com/RatInABox-Lab/RatInABox/blob/main/demos/reinforcement_learning_example.ipynb</ext-link>.</p><p>In this example we demonstrate how RatInABox can be used in a reinforcement learning (RL) study. The goal is as follows: train an artificial <monospace>Agent</monospace> to explore a 2D <monospace>Environment</monospace> where a reward is hidden behind a wall. The <monospace>Agent</monospace> should become proficient at navigating around the wall and towards the reward from all locations within the <monospace>Environment</monospace>.</p><p>The core of our approach will rest on model-free RL where an <monospace>Agent</monospace> first learns a value function for a policy (a process known as “policy evaluation”) and then uses this value function to define a new, improved policy (“policy improvement”). Iterating between these two procedures (“policy iteration”) can result in convergence towards an optimal or near-optimal policy.</p><p>A core pillar of RatInABox is its continuous approach to modelling time and space. This continuity will require revising typical approaches to how the value function if defined, approximated and then learned, as well as how motion control (aka action selection, in discrete space) is performed. This is not a weakness, in fact we would argue it is one of the strengths. Once we are done, we are left with a formulation of model-free RL which bears much higher resemblance to biological navigation. Furthermore, since most of the complexities of feature encoding and motion control in continuous time and space are handled by RatInABox innately this “upgrade” comes almost for free.</p></sec><sec sec-type="appendix" id="s9-3"><title>Policy evaluation</title><p>The value of a motion policy, <inline-formula><mml:math id="inf319"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>π</mml:mi></mml:mstyle></mml:math></inline-formula>, is defined as the decaying sum (or integral in continuous time) of expected future rewards<disp-formula id="equ57"><label>(57)</label><mml:math id="m57"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mi mathvariant="sans-serif">V</mml:mi><mml:mo mathvariant="sans-serif" stretchy="false">^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≈</mml:mo><mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">V</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>π</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="double-struck">E</mml:mi></mml:mrow><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="2.047em" minsize="2.047em">[</mml:mo></mml:mrow></mml:mstyle><mml:mfrac><mml:mn>1</mml:mn><mml:mi>τ</mml:mi></mml:mfrac><mml:msubsup><mml:mo>∫</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>t</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="normal">∞</mml:mi></mml:mrow></mml:msubsup><mml:msup><mml:mi>e</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi class="MJX-variant" mathvariant="normal">′</mml:mi></mml:mrow></mml:msup><mml:mo>−</mml:mo><mml:mi>t</mml:mi></mml:mrow><mml:mi>τ</mml:mi></mml:mfrac></mml:mrow></mml:msup><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">R</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi class="MJX-variant" mathvariant="normal">′</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mi>d</mml:mi><mml:msup><mml:mi>t</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi class="MJX-variant" mathvariant="normal">′</mml:mi></mml:mrow></mml:msup><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="2.047em" minsize="2.047em">]</mml:mo></mml:mrow></mml:mstyle></mml:math></disp-formula></p><p>where the expectation is taken over any stochasticity present in the current policy (i.e. how the <monospace>Agent</monospace> moves) and <monospace>Environment</monospace>/reward (although in this case both will be deterministic). This definition of value is temporally continuous. The key differences compared to the more common form – where value is written as a discrete sum of rewards over future timesteps – is that it is now a continuous integral over a reward density function and temporal discounting is done by exponentially decaying future reward over a time period <inline-formula><mml:math id="inf320"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>τ</mml:mi></mml:mstyle></mml:math></inline-formula>. The prefactor of <inline-formula><mml:math id="inf321"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mn>1</mml:mn><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>/</mml:mo></mml:mrow><mml:mi>τ</mml:mi></mml:mstyle></mml:math></inline-formula> is an optional constant of normalisation.</p><p>In order to learn the value function we define a new <monospace>ValueNeuron</monospace> class. The <monospace>ValueNeuron</monospace>, which is a subclass of <monospace>FeedForwardLayer</monospace>, recieves feedforward input from a set of features corresponding to <monospace>PlaceCells</monospace> scattered across the <monospace>Environment</monospace> with firing rates <inline-formula><mml:math id="inf322"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mo fence="false" stretchy="false">{</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:msub><mml:mi>N</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>ϕ</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1000</mml:mn></mml:mrow></mml:msubsup></mml:mstyle></mml:math></inline-formula> where <inline-formula><mml:math id="inf323"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>ϕ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> is the firing rate of the <inline-formula><mml:math id="inf324"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mi>i</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>th</mml:mtext></mml:mrow></mml:mrow></mml:msup></mml:mstyle></mml:math></inline-formula> place cell at location <inline-formula><mml:math id="inf325"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula>. This linear approximation to the value function can be written as<disp-formula id="equ58"><label>(58)</label><mml:math id="m58"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mi mathvariant="sans-serif">V</mml:mi><mml:mo mathvariant="sans-serif" stretchy="false">^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">I</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>;</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">w</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>N</mml:mi></mml:mrow></mml:munderover><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">w</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>ϕ</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:math></disp-formula></p><p>We can take the temporal derivative of <xref ref-type="disp-formula" rid="equ57">Equation (57)</xref> and derive a consistency equation (analogous to the Bellman equation) satisfied by this value function. This naturally gives a temporal difference-style update rule which relies on “bootstrapping” (the current estimate of the value function is used in lieu of the true value function) to optimize the weights of the value function approximation. A good reference for continuous RL is <xref ref-type="bibr" rid="bib13">Doya, 2000</xref> if readers wish to know more about deriving this learning rule.<disp-formula id="equ59"><label>(59)</label><mml:math id="m59"><mml:mi>δ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:msub><mml:mi mathvariant="sans-serif">w</mml:mi><mml:mi mathvariant="sans-serif">i</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>η</mml:mi><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="2.047em" minsize="2.047em">(</mml:mo></mml:mrow></mml:mstyle><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">R</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>τ</mml:mi><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mi mathvariant="sans-serif">V</mml:mi><mml:mo mathvariant="sans-serif" stretchy="false">^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mfrac><mml:mo>−</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mi mathvariant="sans-serif">V</mml:mi><mml:mo mathvariant="sans-serif" stretchy="false">^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mstyle scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo maxsize="2.047em" minsize="2.047em">)</mml:mo></mml:mrow></mml:mstyle><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">e</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:math></disp-formula></p><p>For now it suffices to observe that this learning rule is very similar to the temporally discrete TD-update rule. The first term in brackets represents the continuous analog of the temporal difference error (in fact, if you rediscretise using the Euler formula <inline-formula><mml:math id="inf326"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">V</mml:mi></mml:mrow><mml:mo>˙</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">V</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">V</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mfrac></mml:mstyle></mml:math></inline-formula> to replace the derivative, and set <inline-formula><mml:math id="inf327"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>d</mml:mi><mml:mi>t</mml:mi><mml:mo>=</mml:mo></mml:mstyle></mml:math></inline-formula> 1, you will see they are identical). The second term is the ‘eligibility trace’ determining to which state – or basis feature – credit for the TD error should be assigned. Using an eligibility trace is optional, and it could just be replaced with <inline-formula><mml:math id="inf328"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>ϕ</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula>, however doing so aids stability of the learning. It is defined as:<disp-formula id="equ60"><label>(60)</label><mml:math id="m60"><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">e</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:msub><mml:mi>τ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">e</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mfrac><mml:msubsup><mml:mo>∫</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>−</mml:mo><mml:mi mathvariant="normal">∞</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>t</mml:mi></mml:mrow></mml:msubsup><mml:msup><mml:mi>e</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi class="MJX-variant" mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:msub><mml:mi>τ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">e</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mfrac></mml:mrow></mml:msup><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>ϕ</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>t</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi class="MJX-variant" mathvariant="normal">′</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mi>d</mml:mi><mml:msup><mml:mi>t</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi class="MJX-variant" mathvariant="normal">′</mml:mi></mml:mrow></mml:msup><mml:mo>.</mml:mo></mml:math></disp-formula></p><p>In total the newly defined ValueNeuron does three things, schematically laid out in <xref ref-type="fig" rid="app1fig2">Appendix 1—figure 2</xref></p><list list-type="order"><list-item><p>It linearly summates its PlaceCell inputs, <xref ref-type="disp-formula" rid="equ58">Equation (58)</xref>.</p></list-item><list-item><p>It stores and updates the eligibility traces, <xref ref-type="disp-formula" rid="equ60">Equation (60)</xref>.</p></list-item><list-item><p>It implements the learning rule, <xref ref-type="disp-formula" rid="equ59">Equation (59)</xref>, which requires access to the reward density function <inline-formula><mml:math id="inf329"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">R</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula>, the eligibility traces <inline-formula><mml:math id="inf330"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">e</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula>, its firing rate <inline-formula><mml:math id="inf331"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mi mathvariant="sans-serif">V</mml:mi><mml:mo mathvariant="sans-serif" stretchy="false">^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> and the temporal derivative of its firing rate <inline-formula><mml:math id="inf332"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mi mathvariant="sans-serif">V</mml:mi><mml:mo mathvariant="sans-serif" stretchy="false">^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mfrac></mml:mstyle></mml:math></inline-formula>.</p></list-item></list><p>We use a temporal discount horizon of <inline-formula><mml:math id="inf333"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>τ</mml:mi><mml:mo>=</mml:mo><mml:mn>10</mml:mn></mml:mstyle></mml:math></inline-formula> s and an eligibility trace timescale of <inline-formula><mml:math id="inf334"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>τ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">e</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:mstyle></mml:math></inline-formula> s. Input features are a set of <inline-formula><mml:math id="inf335"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>N</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>ϕ</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1000</mml:mn></mml:mstyle></mml:math></inline-formula> <monospace>PlaceCells</monospace> of random widths uniformly sampled from 0.04 m to 0.4 m (<xref ref-type="fig" rid="app1fig2">Appendix 1—figure 2b</xref>). The reward density function is taken to be the firing rate of a single <monospace>PlaceCell</monospace> positioned behind the wall of type top_hat and width 0.2 m (<xref ref-type="fig" rid="app1fig2">Appendix 1—figure 2c</xref>). The learning rate is set to <inline-formula><mml:math id="inf336"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>η</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mi>e</mml:mi><mml:mo>−</mml:mo><mml:mn>4</mml:mn></mml:mstyle></mml:math></inline-formula>.</p></sec><sec sec-type="appendix" id="s9-4"><title>Policy improvement</title><p>Now we have a neuron capable of learning the value function under its current policy (“policy evaluation”). We want to use this to improve the policy (“policy improvement”) towards an optimal one. To do this we will exploit the “drift velocity” feature (see Section ‘External velocity control’). We set the drift velocity to be 3 times the mean velocity in the direction of steepest ascent of the value function.<disp-formula id="equ61"><label>(61)</label><mml:math id="m61"><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">v</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mtext>drift</mml:mtext></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>3</mml:mn><mml:msub><mml:mi>σ</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">v</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mi mathvariant="normal">∇</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mrow class="MJX-TeXAtom-ORD"><mml:mover><mml:mi mathvariant="sans-serif">V</mml:mi><mml:mo mathvariant="sans-serif" stretchy="false">^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:math></disp-formula></p><p>This way the <monospace>Agent</monospace> is encouraged to move towards regions of higher and higher value. Note that calculating this gradient is a local calculation and can be done on-the-fly by the <monospace>Agent</monospace>, as it locomotes. This method of value ascent is essentially a continuous analog of a similar algorithm, “greedy policy optimization”, used in discrete action spaces.</p></sec><sec sec-type="appendix" id="s9-5"><title>Policy iteration</title><p>Learning is done in batches of 8 episodes each. An episode consists of the <monospace>Agent</monospace> being reset to a random location in the <monospace>Environment</monospace> and left to explore. The episode ends when the <monospace>Agent</monospace> gets close to the reward <italic>or</italic> times out (60 seconds). At the start of each batch the current value function is copied and cached - this cached version is used, but not updated, to determine the drift velocity in <xref ref-type="disp-formula" rid="equ61">Equation (61)</xref> for the duration of the next batch. Varying the strength of the drift bias relative to the random motion allows us to control the trade of between exploration and exploitation. Scheduling goes as follows: initially the drift_to_random_strength_ratio is set to <inline-formula><mml:math id="inf337"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>0.1</mml:mn></mml:mstyle></mml:math></inline-formula> (i.e. mostly random exploration). On each successful episode which did not end in a timeout, this is increased by 10% up to a maximum of <inline-formula><mml:math id="inf338"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mstyle></mml:math></inline-formula> (approximately equal contributions of random and drift motions).</p></sec><sec sec-type="appendix" id="s9-6"><title>Results</title><p>Initially the input weights to the <monospace>ValueNeuron</monospace> are drawn randomly <inline-formula><mml:math id="inf339"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi mathvariant="sans-serif">w</mml:mi></mml:mrow><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>∼</mml:mo><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi class="MJX-tex-caligraphic" mathvariant="script">N</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:msqrt><mml:msub><mml:mi>N</mml:mi><mml:mrow class="MJX-TeXAtom-ORD"><mml:mi>ϕ</mml:mi></mml:mrow></mml:msub></mml:msqrt></mml:mfrac><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:math></inline-formula> and therefore the value map (and <monospace>Agent</monospace> motion) is random (<xref ref-type="fig" rid="app1fig2">Appendix 1—figure 2d</xref>, left). After 10 batches (80 episodes) the <monospace>Agent</monospace> has successfully learnt a near-optimal value function showing high-value in and near to the corridor, and low values elsewhere. This allows it to rapidly navigate towards the reward, avoiding the obstructing wall, from all locations in the <monospace>Environment</monospace> (<xref ref-type="fig" rid="app1fig2">Appendix 1—figure 2d</xref>, middle, colourmap) (<xref ref-type="fig" rid="app1fig2">Appendix 1—figure 2d</xref>, middle and <xref ref-type="fig" rid="fig3">Figure 3b</xref>).</p><p>By virtue of using continuous action control in continuous space, the trajectories of the trained <monospace>Agent</monospace> look highly realistic compared to typical gridworld RL. Since <monospace>PlaceCells</monospace> in RatInABox interact adaptively with the <monospace>Environment</monospace>, when a small gap is created at the base of the obstructing wall the receptive fields of <monospace>PlaceCells</monospace> near this gap “spill” through. This causes an instantaneous update to the percieved value function and therefore policy allowing the <monospace>Agent</monospace> to immediately find a short cut to the reward with no additional training, a form of zero-shot learning (<xref ref-type="fig" rid="app1fig2">Appendix 1—figure 2d</xref>, right).</p><fig id="app1fig2" position="float"><label>Appendix 1—figure 2.</label><caption><title>RatInABox used in a simple reinforcement learning project.</title><p>(<bold>a</bold>) A schematic of the 1 layer linear network. Using a simple model-free policy iteration algorithm the <monospace>Agent</monospace>, initially moving under a random motion policy, learns to approach an optimal policy for finding a reward behind a wall. The policy iteration algorithm alternates between (left) calculating the value function using temporally continuous TD learning and (right) using this to define an improved policy by setting the drift velocity of the Agent to be proportional to the gradient of the value function (a roughly continuous analog for the <inline-formula><mml:math id="inf340"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>ϵ</mml:mi></mml:mstyle></mml:math></inline-formula>-greedy algorithm). (<bold>b</bold>) 1000 <monospace>PlaceCell</monospace>s act as a continuous feature basis for learning the value function. (<bold>c</bold>) The reward is also a (top-hat) <monospace>PlaceCell</monospace>, hidden behind the obstructing wall. (<bold>d</bold>) A <monospace>ValueNeuron</monospace> (a bespoke <monospace>Neurons</monospace> subclass defined for this demonstration) estimates the policy value function as a linear combination of the basis features (heatmap) and improves this using TD learning. After learning the <monospace>Agent</monospace> is able to accurately navigate around the wall towards the reward (middle). Because <monospace>PlaceCells</monospace> in RatInABox are continuous and interact adaptively with the <monospace>Environment</monospace> when a small gap is opened in the wall place fields corresponding to place cells near this gap automatically bleed through it, and therefore so does the value function. This allows the <monospace>Agent</monospace> to find a shortcut to the reward with zero additional training. A jupyter script replicating this project is given in the demos folder <ext-link ext-link-type="uri" xlink:href="https://github.com/RatInABox-Lab/RatInABox/blob/main/demos/reinforcement_learning_example.ipynb">GitHub repository</ext-link>.</p></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-85274-app1-fig2-v2.tif"/></fig></sec></sec></app></app-group></back><sub-article article-type="editor-report" id="sa0"><front-stub><article-id pub-id-type="doi">10.7554/eLife.85274.sa0</article-id><title-group><article-title>Editor's evaluation</article-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>Mathis</surname><given-names>Mackenzie W</given-names></name><role specific-use="editor">Reviewing Editor</role><aff><institution-wrap><institution-id institution-id-type="ror">https://ror.org/02s376052</institution-id><institution>École Polytechnique Fédérale de Lausanne</institution></institution-wrap><country>Switzerland</country></aff></contrib></contrib-group><related-object id="sa0ro1" object-id-type="id" object-id="10.1101/2022.08.10.503541" link-type="continued-by" xlink:href="https://sciety.org/articles/activity/10.1101/2022.08.10.503541"/></front-stub><body><p>RatInABox is a new python library for generating synthetic behavioral and neural data (many functional cell types) that is a highly important contribution to computational neuroscience. Critically, the authors have gone beyond the generally accepted practice with their well-written paper, documented and verified code. They show compelling evidence of its utility and usability, and this is sure to be an influential paper with implications for developing new theories and methods for joint neural and behavioral analysis beyond the navigation field.</p></body></sub-article><sub-article article-type="decision-letter" id="sa1"><front-stub><article-id pub-id-type="doi">10.7554/eLife.85274.sa1</article-id><title-group><article-title>Decision letter</article-title></title-group><contrib-group content-type="section"><contrib contrib-type="editor"><name><surname>Mathis</surname><given-names>Mackenzie W</given-names></name><role>Reviewing Editor</role><aff><institution-wrap><institution-id institution-id-type="ror">https://ror.org/02s376052</institution-id><institution>École Polytechnique Fédérale de Lausanne</institution></institution-wrap><country>Switzerland</country></aff></contrib></contrib-group><contrib-group><contrib contrib-type="reviewer"><name><surname>Fernandez-Ruiz</surname><given-names>Antonio</given-names></name><role>Reviewer</role><aff><institution-wrap><institution-id institution-id-type="ror">https://ror.org/05bnh6r87</institution-id><institution>Cornell University</institution></institution-wrap><country>United States</country></aff></contrib></contrib-group></front-stub><body><boxed-text id="sa2-box1"><p>Our editorial process produces two outputs: (i) <ext-link ext-link-type="uri" xlink:href="https://sciety.org/articles/activity/10.1101/2022.08.10.503541">public reviews</ext-link> designed to be posted alongside <ext-link ext-link-type="uri" xlink:href="https://www.biorxiv.org/content/10.1101/2022.08.10.503541v3">the preprint</ext-link> for the benefit of readers; (ii) feedback on the manuscript for the authors, including requests for revisions, shown below. We also include an acceptance summary that explains what the editors found interesting or important about the work.</p></boxed-text><p><bold>Decision letter after peer review:</bold></p><p>Thank you for submitting your article &quot;RatInABox: A toolkit for modelling locomotion and neuronal activity in continuous environments&quot; for consideration by <italic>eLife</italic>. Your article has been reviewed by 3 peer reviewers, one of whom is a member of our Board of Reviewing Editors, and the evaluation has been overseen by Michael Frank as the Senior Editor. The following individual involved in review of your submission has agreed to reveal their identity: Antonio Fernandez-Ruiz (Reviewer #2).</p><p>The reviewers have discussed their reviews with one another, and the Reviewing Editor has drafted this to help you prepare a revised submission.</p><p>Essential revisions:</p><p>Overall the reviewers are positive about this work and have a few suggestions to improve the presentation and some questions. Here are the essential revisions we ask you to consider, and the detailed reviews are below for your reference.</p><p>1) We would like to see a better discussion of limitations in the Discussion, and some more staging of why this is useful in the Introduction. Specifically, please consider these comments:</p><p>R2: The manuscript also lacks a description of the limitations of the approach. The authors should clarify what types of experimental data that can and cannot be modelled here, the limitations of experimental estimates from the models, and more importantly, what testable predictions of yet unknown results can be generated by this model, beyond replicating what is already known. For example, can RatInABox be used to model episodic coding in the hippocampus (e.g., splitter cells), as task states can often be latent and non-Markovian. Can it be used to model the &quot;remapping&quot; of place cells (and other cell types) in response to changes in the environment?</p><p>R1: Presentation: Some discussion of case studies in Introduction might address the above point on impact. It would be useful to have more discussion of how general the software is, and why the current feature set was chosen. For example, how well does RatInABox deal with environments of arbitrary shape? T-mazes? It might help illustrate the tool's generality to move some of the examples in supplementary figure to main text – or just summarize them in a main text figure/panel.</p><p>2) It would be great to address limitations on how the environment and cells can be modelled currently. Namely, how the cells can be modified to study influences of other internal (latent) states, such as reward or abstract coding, and dynamics. And please clarify what types of experimental data that can and cannot be modeled, the limitations of experimental estimates from the models, and importantly, what testable predictions of yet unknown results can be generated by this model, beyond replicating what is already known. Specifically, please consider these comments from:</p><p>R3: Right now the code only supports X,Y movements, but Z is also critical and opens new questions in 3D coding of space (such as grid cells in bats, etc). Many animals effectively navigate in 2D, as a whole, but they certainly make a large number of 3D head movements, and modeling this will become increasingly important and the authors should consider how to support this.</p><p>– What about other environments that are not &quot;Boxes&quot; as in the name – can the environment only be a Box, what about a circular environment? Or Bat flight? This also has implications for the velocity of the agent, etc. What are the parameters for the motion model to simulate a bat, which likely has a higher velocity than a rat?</p><p>– What if a place cell is not encoding place but is influenced by reward or encodes a more abstract concept? Should a PlaceCell class inherit from an AbstractPlaceCell class, which could be used for encoding more conceptual spaces? How could their tool support this?</p><p>R2: The manuscript also lacks a description of the limitations of the approach. The authors should clarify what types of experimental data that can and cannot be modelled here, the limitations of experimental estimates from the models, and more importantly, what testable predictions of yet unknown results can be generated by this model, beyond replicating what is already known. For example, can RatInABox be used to model episodic coding in the hippocampus (e.g., splitter cells), as task states can often be latent and non-Markovian. Can it be used to model the &quot;remapping&quot; of place cells (and other cell types) in response to changes in the environment?</p><p><italic>Reviewer #2 (Recommendations for the authors):</italic></p><p>– With a few exceptions, the manuscripts lacks a comparison between the RatInABox and previous approaches to simulate behavioral and electrophysiological data. Such comparison can be added to the Discussion and will help many readers to appreciate the novelty and capabilities of this toolbox.</p><p>– An important strength of the toolbox is its capability to simulate with ease realistic animal exploratory patterns. In comparison, the simulation of electrophysiological cell responses is more simplistic. It would be useful to better describe the assumptions and limitations taken in the simulations of cell types and briefly compare them with the well-known experimental evidence. For example, place fields are pre-determined by the model's parameters and completely stable. However, it is well known that place fields developed with experience (e.g., change locations and sizes, pop in/out). The paper claims that it can &quot;concurrently simulate neuronal activity data&quot; in &quot;configurable&quot; environments. It should be clarified if this model can capture the developmental part of place cells, or only the &quot;stable&quot; state. As another example, the authors showed that the decoding error of Agent position is almost 0 with &gt;= 20 place cells (Figure S1c), which is significantly less than that using real neural data. At least, there should be some discussion of where this difference may arise. Can noise be added to cell tuning curves? E.g. in the form of out-of-field spikes or trial-by-trial variability.</p><p>– The manuscript also lacks a description of the limitations of the approach. The authors should clarify what types of experimental data that can and cannot be modelled here, the limitations of experimental estimates from the models, and more importantly, what testable predictions of yet unknown results can be generated by this model, beyond replicating what is already known. For example, can RatInABox be used to model episodic coding in the hippocampus (e.g., splitter cells), as task states can often be latent and non-Markovian. Can it be used to model the &quot;remapping&quot; of place cells (and other cell types) in response to changes in the environment?</p></body></sub-article><sub-article article-type="reply" id="sa2"><front-stub><article-id pub-id-type="doi">10.7554/eLife.85274.sa2</article-id><title-group><article-title>Author response</article-title></title-group></front-stub><body><disp-quote content-type="editor-comment"><p>Essential revisions:</p><p>Overall the reviewers are positive about this work and have a few suggestions to improve the presentation and some questions. Here are the essential revisions we ask you to consider, and the detailed reviews are below for your reference.</p><p>1) We would like to see a better discussion of limitations in the Discussion, and some more staging of why this is useful in the Introduction. Specifically, please consider these comments:</p></disp-quote><p>We now openly discuss the limitations of the software package in the Discussion on page 9 in a new section of text as follows:</p><p>“Our package is not the first to model neural data [37,38,39] or spatial behaviour [40,41], yet it distinguishes itself by integrating these two aspects within a unified, lightweight framework. The modelling approach employed by RatInABox involves certain assumptions:</p><p>1. It does not engage in the detailed exploration of biophysical [37,39] or biochemical[38] aspects of neural modelling, nor does it delve into the mechanical intricacies of joint and muscle modelling [40,41]. While these elements are crucial in specific scenarios, they demand substantial computational resources and become less pertinent in studies focused on higher-level questions about behaviour and neural representations.</p><p>2. A focus of our package is modelling experimental paradigms commonly used to study spatially modulated neural activity and behaviour in rodents. Consequently, environments are currently restricted to being two-dimensional and planar, precluding the exploration of three-dimensional settings. However, in principle, these limitations can be relaxed in the future.</p><p>3. RatInABox avoids the oversimplifications commonly found in discrete modelling, predominant in reinforcement learning [22,23], which we believe impede its relevance to neuroscience.</p><p>4. Currently, inputs from different sensory modalities, such as vision or olfaction, are not explicitly considered. Instead, sensory input is represented implicitly through efficient allocentric or egocentric representations. If necessary, one could use the RatInABox API in conjunction with a third-party computer graphics engine to circumvent this limitation.</p><p>5. Finally, focus has been given to generating synthetic data from steady-state systems. Hence, by default, agents and neurons do not explicitly include learning, plasticity or adaptation. Nevertheless we have shown that a minimal set of features such as parameterised function-approximator neurons and policy control enable a variety of experience-driven changes in behaviour the cell responses [42, 43] to be modelled within the framework.”</p><p>And have also added a new opening paragraph to better stage why RatInABox is useful (and computational modelling toolkits in general) to <italic>eLife</italic>’s broad audience:</p><p>“Computational modelling provides a means to understand how neural circuits represent the world and influence behaviour, interfacing between experiment and theory to express and test how information is processed in the brain. Such models have been central to understanding a range of neural mechanisms, from action potentials [1] and synaptic transmission between neurons [2], to how neurons represent space and guide complex behaviour [3,4,5,6,7]. Relative to empirical approaches, models can offer considerable advantages, providing a means to generate large amounts of data quickly with limited physical resources, and are a precise means to test and communicate complex hypotheses. To fully realise these benefits, computational modelling must be accessible and standardised, something which has not always been the case.”</p><disp-quote content-type="editor-comment"><p>R2: The manuscript also lacks a description of the limitations of the approach. The authors should clarify what types of experimental data that can and cannot be modelled here, the limitations of experimental estimates from the models, and more importantly, what testable predictions of yet unknown results can be generated by this model, beyond replicating what is already known.</p></disp-quote><p>In the text described above and added to the discussion, we discuss the assumptions and limitations of RatInABox. Briefly these are: no low-level biophysical, biochemical, joint or muscle-level modelling, no 3D or higher dimensional / abstract environments, no discretised environments, no explicit sensory inputs (e.g. vision or olfaction).</p><p>Most of these limitations are, as we hope to have made clear in the manuscript, features not bugs. They were explicit choices to keep the RatInABox framework lightweight and easy to understand. We wanted to avoid “feature creep” and repeating work done by others. Interfacing RatInABox with other toolkits or exploiting the existing RatInABox API to add new features could overcome these limitations and we will happily consider these contributions as/when they are made.</p><p>Regarding “how the cells can be modified to study influences of other internal (latent) states, such as reward or abstract coding, and dynamics”<italic>:</italic> Briefly (and expanded on in the individual responses below), in a series of new tutorials we demonstrate how RatInABox can be used to model:</p><p>– Splitter cells<sup>[1]</sup> (i.e. where a latent factor determines cell firing dynamics)</p><p>– Conjunctive cells (where multiple primitive cell classes combine to give mixed selective cells e.g. jointly selective to speed and position)</p><p>– Reinforcement learning<sup>[2,3]</sup> (where reward is explicitly encoded and used to “train” representations and guide behaviour)</p><p>– Successor features<sup>[4]</sup> (where cell representations are dependent on statistics of the agents trajectory).</p><p>To name a few. As such, the following text has been modified in the case studies, section 3.1.</p><p>“Additional tutorials, not described here but available online, demonstrate how RatInABox can be used to model splitter cells, conjunctive grid cells, biologically plausible path integration, successor features, deep actor-critic RL, whisker cells and more. Despite including these examples we stress that they are not exhaustive. RatInABox provides the framework and primitive classes/functions from which highly advanced simulations such as these can be built”</p><p>Furthermore, function-approximator neurons (such as the existing FeedForwardLayer, or the new NeuralNetworkNeurons) can be used to model dynamic systems either by (i) setting the input to a neuron layer as itself (a recurrent input) or (ii) setting the function approximator to be dynamic, e.g. a recurrent neural network. The following text has been added to section 2:</p><p>“Naturally, function-approximator Neurons can be used to model how neural populations in the brain communicate, how neural representations are learned or, in certain cases, neural dynamics. In an online demo we show how grid cells and head direction cells can be easily combined using a FeedForwardLayer to create head-direction selective grid cells (aka. conjunctive grid cells [10]). In Figure 3d and associated demo GridCells provide input to a NeuralNetworkNeuron which is then trained, on data generated during exploration, to have a highly complex and non-linear receptive field. Function-approximator Neurons can themselves be used as inputs to other function-approximator Neurons allowing multi-layer and/or recurrent networks to be constructed and studied.”</p><p>Finally, we already know that “testable predictions of yet unknown results can be generated by this model” as a few early citations of the package<sup>[8,9,10]</sup> (which have been added to the manuscript) demonstrate. However, primarily we think of RatInABox as a generator of models rather than a model itself, therefore making testable predictions is not the primary contribution and might seem out of place. We have modified the following sentence in the discussion to clarify this:</p><p>“Its user-friendly API, inbuilt data-plotting functions and general yet modular feature set mean it is well placed empower a wide variety of users to more rapidly build, train and validate models of hippocampal function [25] and spatial navigation [26], accelerating progress in the field.”</p><p>As well as the final paragraph of the discussion which was added to say:</p><p>“In conclusion, while no single approach can be deemed the best, we believe that RatInABox’s unique positioning makes it highly suitable for normative modelling and NeuroAI. We anticipate that it will complement existing toolkits and represent a significant contribution to the computational neuroscience toolbox.”</p><p>To clarify that normative modelling and NeuroAI are two key areas we anticipate RatInABox making contributions.</p><disp-quote content-type="editor-comment"><p>R1: Presentation: Some discussion of case studies in Introduction might address the above point on impact. It would be useful to have more discussion of how general the software is, and why the current feature set was chosen. For example, how well does RatInABox deal with environments of arbitrary shape? T-mazes? It might help illustrate the tool's generality to move some of the examples in supplementary figure to main text – or just summarize them in a main text figure/panel.</p></disp-quote><p>Thank you for this question. Since the initial submission of this manuscript RatInABox has been upgraded and environments have become substantially more “general”. Environments can now be of arbitrary shape (including T-mazes), boundaries can be curved, they can contain holes and can also contain objects (0-dimensional points which act as visual cues). A few examples are showcased in the updated figure 1 panel e.</p><p>To further illustrate the tools generality beyond the structure of the environment we continue to summarise the reinforcement learning example (Figure 3e) and neural decoding example in section 3.1. In addition to this we have added three new panels into figure 3 highlighting new features which, we hope you will agree, make RatInABox significantly more powerful and general and satisfy your suggestion of clarifying utility and generality in the manuscript directly. These include:</p><p>– Figure 3b: Demonstration of this ability to control policy with a general control signal allowing users to generate arbitrarily complex motion trajectories</p><p>– Figure 3c: New cell classes use egocentric boundary-, object- and agent-vector cells to efficiently encode what is in the agents “field of view”.</p><p>– Figure 3d: Whilst most neurons have static receptive fields (e.g. place cells) we also provide two neuron classes whose receptive fields are defined by a parameterized function receiving the firing rate of other RatInABox neurons as inputs. In this example, grid cells are mapped through a feedforward neural network and trained to represent an arbitrary receptive field (the letter “riab”). These classes allow the construction of quite general neurons (a point we endeavour to stress in the manuscript) as well as the ability to study learning processes in the brain.</p><p>On the topic of generality, we wrote the manuscript in such a way as to demonstrate how the rich variety of ways RatInABox can be used without providing an exhaustive list of potential applications. For example, RatInABox <italic>can</italic> be used to study neural decoding and it <italic>can</italic> be used to study reinforcement learning but not because it was purpose built with these use-cases in mind. Rather because it contains a set of core tools designed to support spatial navigation and neural representations in general. For this reason we would rather keep the demonstrative examples as supplements and implement your suggestion of further raising attention to the large array of tutorials and demos provided on the GitHub repository by modifying the final paragraph of section 3.1 to read:</p><p>“Additional tutorials, not described here but available online, demonstrate how RatInABox can be used to model splitter cells, conjunctive grid cells, biologically plausible path integration, successor features, deep actor-critic RL, whisker cells and more. Despite including these examples we stress that they are not exhaustive. RatInABox provides the framework and primitive classes/functions from which highly advanced simulations such as these can be built.”</p><disp-quote content-type="editor-comment"><p>2) It would be great to address limitations on how the environment and cells can be modelled currently. Namely, how the cells can be modified to study influences of other internal (latent) states, such as reward or abstract coding, and dynamics. And please clarify what types of experimental data that can and cannot be modeled, the limitations of experimental estimates from the models, and importantly, what testable predictions of yet unknown results can be generated by this model, beyond replicating what is already known.</p></disp-quote><p>In the text described above and added to the discussion, we discuss the assumptions and limitations of RatInABox. Briefly these are: no low-level biophysical, biochemical, joint or muscle-level modelling, no 3D or higher dimensional / abstract environments, no discretised environments, no explicit sensory inputs (e.g. vision or olfaction).</p><p>Most of these limitations are, as we hope to have made clear in the manuscript, features not bugs. They were explicit choices to keep the RatInABox framework lightweight and easy to understand. We wanted to avoid “feature creep” and repeating work done by others. Interfacing RatInABox with other toolkits or exploiting the existing RatInABox API to add new features could overcome these limitations and we will happily consider these contributions as/when they are made.</p><p>Regarding “how the cells can be modified to study influences of other internal (latent) states, such as reward or abstract coding, and dynamics”<italic>:</italic> Briefly (and expanded on in the individual responses below), in a series of new tutorials we demonstrate how RatInABox can be used to model:</p><p>– Splitter cells<sup>[1]</sup> (i.e. where a latent factor determines cell firing dynamics)</p><p>– Conjunctive cells (where multiple primitive cell classes combine to give mixed selective cells e.g. jointly selective to speed and position)</p><p>– Reinforcement learning<sup>[2,3]</sup> (where reward is explicitly encoded and used to “train” representations and guide behaviour)</p><p>– Successor features<sup>[4]</sup> (where cell representations are dependent on statistics of the agents trajectory).</p><p>To name a few. As such, the following text has been modified in the case studies, section 3.1:</p><p>“Additional tutorials, not described here but available online, demonstrate how RatInABox can be used to model splitter cells, conjunctive grid cells, biologically plausible path integration, successor features, deep actor-critic RL, whisker cells and more. Despite including these examples we stress that they are not exhaustive. RatInABox provides the framework and primitive classes/functions from which highly advanced simulations such as these can be built”</p><p>Furthermore, function-approximator neurons (such as the existing FeedForwardLayer, or the new NeuralNetworkNeurons) can be used to model dynamic systems either by (i) setting the input to a neuron layer as itself (a recurrent input) or (ii) setting the function approximator to be dynamic, e.g. a recurrent neural network. The following text has been added to section 2:</p><p>“Naturally, function-approximator Neurons can be used to model how neural populations in the brain communicate, how neural representations are learned or, in certain cases, neural dynamics. In an online demo we show how grid cells and head direction cells can be easily combined using a FeedForwardLayer to create head-direction selective grid cells (aka. conjunctive grid cells [10]). In Figure 3d and associated demo GridCells provide input to a NeuralNetworkNeuron which is then trained, on data generated during exploration, to have a highly complex and non-linear receptive field. Function-approximator Neurons can themselves be used as inputs to other function-approximator Neurons allowing multi-layer and/or recurrent networks to be constructed and studied.”</p><p>Finally, we already know that “testable predictions of yet unknown results can be generated by this model” as a few early citations of the package<sup>[8,9,10]</sup> (which have been added to the manuscript) demonstrate. However, primarily we think of RatInABox as a generator of models rather than a model itself, therefore making testable predictions is not the primary contribution and might seem out of place. We have modified the following sentence in the discussion to clarify this:</p><p>“Its user-friendly API, inbuilt data-plotting functions and general yet modular feature set mean it is well placed empower a wide variety of users to more rapidly build, train and validate models of hippocampal function [25] and spatial navigation [26], accelerating progress in the field.”</p><p>As well as the final paragraph of the discussion which was added to say:</p><p>“In conclusion, while no single approach can be deemed the best, we believe that RatInABox’s unique positioning makes it highly suitable for normative modelling and NeuroAI. We anticipate that it will complement existing toolkits and represent a significant contribution to the computational neuroscience toolbox.”</p><p>To clarify that normative modelling and NeuroAI are two key areas we anticipate RatInABox making contributions.</p><disp-quote content-type="editor-comment"><p>Specifically, please consider these comments from:</p><p>R3: Right now the code only supports X,Y movements, but Z is also critical and opens new questions in 3D coding of space (such as grid cells in bats, etc). Many animals effectively navigate in 2D, as a whole, but they certainly make a large number of 3D head movements, and modeling this will become increasingly important and the authors should consider how to support this.</p></disp-quote><p>Agents now have a dedicated head direction variable (before head direction was just assumed to be the normalised velocity vector). By default this just smoothes and normalises the velocity but, in theory, could be accessed and used to model more complex head direction dynamics. This is described in the updated methods section.</p><p>In general, we try to tread a careful line. For example we embrace certain aspects of physical and biological realism (e.g. modelling environments as continuous, or fitting motion to real behaviour) and avoid others (such as the biophysics/biochemisty of individual neurons, or the mechanical complexities of joint/muscle modelling). It is hard to decide where to draw but we have a few guiding principles:</p><p>1. RatInABox is most well suited for normative modelling and neuroAI-style probing questions at the level of behaviour and representations. We consciously avoid unnecessary complexities that do not directly contribute to these domains.</p><p>2. Compute: To best accelerate research we think the package should remain fast and lightweight. Certain features are ignored if computational cost outweighs their benefit.</p><p>3. Users: If, and as, users require complexities e.g. 3D head movements, we will consider adding them to the code base.</p><p>For now we believe proper 3D motion is out of scope for RatInABox. Calculating motion near walls is already surprisingly complex and to do this in 3D would be challenging. Furthermore all cell classes would need to be rewritten too. This would be a large undertaking probably requiring rewriting the package from scratch, or making a new package RatInABox3D (BatInABox?) altogether, something which we don’t intend to undertake right now. One option, if users really needed 3D trajectory data they could quite straightforwardly simulate a 2D Environment (X,Y) and a 1D Environment (Z) independently. With this method (X,Y) and (Z) motion would be entirely independent which is of unrealistic but, depending on the use case, may well be sufficient.</p><p>Alternatively, as you said that many agents effectively navigate in 2D but show complex 3D head and other body movements, RatInABox could interface with and feed data downstream to other softwares (for example Mujoco<sup>[11]</sup>) which specialise in joint/muscle modelling. This would be a very legitimate use-case for RatInABox.</p><p>We’ve flagged all of these assumptions and limitations in a new body of text added to the discussion:</p><p>“Our package is not the first to model neural data [37, 38, 39] or spatial behaviour [40, 41], yet it distinguishes itself by integrating these two aspects within a unified, lightweight framework. The modelling approach employed by RatInABox involves certain assumptions:</p><p>1. It does not engage in the detailed exploration of biophysical [37, 39] or biochemical [38] aspects of neural modelling, nor does it delve into the mechanical intricacies of joint and muscle modelling[40, 41]. While these elements are crucial in specific scenarios, they demand substantial computational resources and become less pertinent in studies focused on higher-level questions about behaviour and neural representations.</p><p>2. A focus of our package is modelling experimental paradigms commonly used to study spatially modulated neural activity and behaviour in rodents. Consequently, environments are currently restricted to being two-dimensional and planar, precluding the exploration of three-dimensional settings. However, in principle, these limitations can be relaxed in the future.</p><p>3. RatInABox avoids the oversimplifications commonly found in discrete modelling, predominant in reinforcement learning [22, 23], which we believe impede its relevance to neuroscience.</p><p>4. Currently, inputs from different sensory modalities, such as vision or olfaction, are not explicitly considered. Instead, sensory input is represented implicitly through efficient allocentric or egocentric representations. If necessary, one could use the RatInABox API in conjunction with a third-party computer graphics engine to circumvent this limitation.</p><p>5. Finally, focus has been given to generating synthetic data from steady-state systems. Hence, by default, agents and neurons do not explicitly include learning, plasticity or adaptation. Nevertheless we have shown that a minimal set of features such as parameterised function-approximator neurons and policy control enable a variety of experience-driven changes in behaviour the cell responses [42, 43] to be modelled within the framework.</p><p>In conclusion, while no single approach can be deemed the best, we believe that RatInABox’s unique positioning makes it highly suitable for normative modelling and NeuroAI. We anticipate that it will complement existing toolkits and represent a significant contribution to the computational neuroscience toolbox.”</p><disp-quote content-type="editor-comment"><p>– What about other environments that are not &quot;Boxes&quot; as in the name – can the environment only be a Box, what about a circular environment? Or Bat flight? This also has implications for the velocity of the agent, etc. What are the parameters for the motion model to simulate a bat, which likely has a higher velocity than a rat?</p></disp-quote><p>Thank you for this question. Since the initial submission of this manuscript RatInABox has been upgraded and environments have become substantially more “general”. Environments can now be of arbitrary shape (including circular), boundaries can be curved, they can contain holes and can also contain objects (0-dimensional points which act as visual cues). A few examples are showcased in the updated figure 1 panel e.</p><p>Whilst we don’t know the exact parameters for bat flight users could fairly straightforwardly figure these out themselves and set them using the motion parameters as shown in the table in <xref ref-type="fig" rid="sa2fig1">Author response image 1</xref>. We would guess that bats have a higher average speed (speed_mean) and a longer decoherence time due to increased inertia (speed_coherence_time), so the following code might roughly simulate a bat flying around in a 10 x 10 m environment. The table (6.4 Table of default parameters) shows all Agent parameters which can be set to vary the random motion model.</p><fig id="sa2fig1" position="float"><label>Author response image 1.</label><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-85274-sa2-fig1-v2.tif"/></fig><disp-quote content-type="editor-comment"><p>– What if a place cell is not encoding place but is influenced by reward or encodes a more abstract concept? Should a PlaceCell class inherit from an AbstractPlaceCell class, which could be used for encoding more conceptual spaces? How could their tool support this?</p></disp-quote><p>In fact PlaceCells already inherit from a more abstract class (Neurons) which contains basic infrastructure for initialisation, saving data, and plotting data etc. We prefer the solution that users can write their <italic>own</italic> cell classes which inherit from Neurons (or PlaceCells if they wish). Then, users need only write a new get_state() method which can be as simple or as complicated as they like. Here are two examples we’ve already made which can be found on the GitHub:</p><p>Phase precession: PhasePrecessingPlaceCells(PlaceCells)<sup>[12]</sup> inherit from PlaceCells and modulate their firing rate by multiplying it by a phase dependent factor causing them to “phase precess”.</p><p>Splitter cells: Perhaps users wish to model PlaceCells that are modulated by recent history of the Agent, for example which arm of a figure-8 maze it just came down. This is observed in hippocampal “splitter cell”. In this demo<sup>[1]</sup> SplitterCells(PlaceCells) inherit from PlaceCells and modulate their firing rate according to which arm was last travelled along.</p><disp-quote content-type="editor-comment"><p>R2: – The manuscript also lacks a description of the limitations of the approach. The authors should clarify what types of experimental data that can and cannot be modelled here, the limitations of experimental estimates from the models, and more importantly, what testable predictions of yet unknown results can be generated by this model, beyond replicating what is already known.</p></disp-quote><p>We already know that <italic>“testable predictions of yet unknown results can be generated by this model”</italic> as some early citations of the package<sup>[8,9,10]</sup> (which have been added to the manuscript) demonstrate. However, we think of RatInABox as a generator or models rather than a model itself, therefore making testable predictions is not the primary contribution and might seem out of place. We have modified the following sentence in the discussion to clarify this:</p><p>“Its user-friendly API, inbuilt data-plotting functions and general yet modular feature set mean it is well placed empower a wide variety of users to more rapidly build, train and validate models of hippocampal function [25] and spatial navigation[26], accelerating progress in the field.”</p><p>As well as:</p><p>“In conclusion, while no single approach can be deemed the best, we believe that RatInABox’s unique positioning makes it highly suitable for normative modelling and NeuroAI. We anticipate that it will complement existing toolkits and represent a significant contribution to the computational neuroscience toolbox.”</p><disp-quote content-type="editor-comment"><p>For example, can RatInABox be used to model episodic coding in the hippocampus (e.g., splitter cells), as task states can often be latent and non-Markovian. Can it be used to model the &quot;remapping&quot; of place cells (and other cell types) in response to changes in the environment?</p></disp-quote><p>All this stuff falls well within the scope of RatInABox but we’d rather not go down the rabbit hole of one-by-one including – at the level of user-facing API – all possible biological phenomena of interest. Instead the approach we take with RatInABox (which we think it’s better and more scalable) is to provide a minimal feature set and then <italic>demonstrate</italic> how more complex phenomena can be modelled in case studies, supplementary material and demos.</p><p>As you mentioned splitter cells we went ahead and made a very basic simulation of splitter cells which is now available as a Jupyter demo on the GitHub<sup>[1]</sup>. In this demo, the Agent goes around a figure-of-eight maze and “remembers” the last arm it passed through. A bespoke “SplitterPlaceCell” uses this to determine if a splitter cell will fire or not. Of course this is highly simplistic and doesn’t model the development of splitter cells or their neural underpinnings but the point is not to provide a completely comprehensive exploration of the biological mechanisms of splitter cells, or any other phenomena for that matter, but to demonstrate that this is <italic>within scope</italic> and give users starting point. We also have a new demo for making conjunctive grid cells<sup>[6]</sup> by combining grid cells and head direction cells, and many more. This figure shows a snippet of the splitter cell demo.</p><p>Likewise, remapping could absolutely be modelled with RatInABox. In fact we study this in our own recent paper<sup>[8]</sup> which uses RatInABox. By the way, PlaceCells now contain a naive “remap()” method which shuffles cell locations.</p><p>We repeat here the modified paragraph in section 3.1 pointing users to these teaching materials:</p><p>“Additional tutorials, not described here but available online, demonstrate how RatInABox can be used to model splitter cells, conjunctive grid cells, biologically plausible path integration, successor features, deep actor-critic RL, whisker cells and more. Despite including these examples we stress that they are not exhaustive. RatInABox provides the framework and primitive classes/functions from which highly advanced simulations such as these can be built.”</p><disp-quote content-type="editor-comment"><p>Reviewer #2 (Recommendations for the authors):</p><p>– With a few exceptions, the manuscripts lacks a comparison between the RatInABox and previous approaches to simulate behavioral and electrophysiological data. Such comparison can be added to the Discussion and will help many readers to appreciate the novelty and capabilities of this toolbox.</p></disp-quote><p>We have added the following paragraph to the discussion to contrast RatInABox to previous approaches and highlight assumptions/limitations of the package:</p><p>“Our package is not the first to model neural data [37, 38, 39] or spatial behaviour [40, 41], yet it distinguishes itself by integrating these two aspects within a unified, lightweight framework. The modelling approach employed by RatInABox involves certain assumptions:</p><p>1. It does not engage in the detailed exploration of biophysica l[37, 39] or biochemical[38] aspects of neural modelling, nor does it delve into the mechanical intricacies of joint and muscle modelling[40, 41]. While these elements are crucial in specific scenarios, they demand substantial computational resources and become less pertinent in studies focused on higher-level questions about behaviour and neural representations.</p><p>2. A focus of our package is modelling experimental paradigms commonly used to study spatially modulated neural activity and behaviour in rodents. Consequently, environments are currently restricted to being two-dimensional and planar, precluding the exploration of three-dimensional settings. However, in principle, these limitations can be relaxed in the future.</p><p>3. RatInABox avoids the oversimplifications commonly found in discrete modelling, predominant in reinforcement learning [22, 23], which we believe impede its relevance to neuroscience.</p><p>4. Currently, inputs from different sensory modalities, such as vision or olfaction, are not explicitly considered. Instead, sensory input is represented implicitly through efficient allocentric or egocentric representations. If necessary, one could use the RatInABox API in conjunction with a third-party computer graphics engine to circumvent this limitation.</p><p>5. Finally, focus has been given to generating synthetic data from steady-state systems. Hence, by default, agents and neurons do not explicitly include learning, plasticity or adaptation. Nevertheless we have shown that a minimal set of features such as parameterised function-approximator neurons and policy control enable a variety of experience-driven changes in behaviour the cell responses [42, 43] to be modelled within the framework.</p><p>In conclusion, while no single approach can be deemed the best, we believe that RatInABox’s unique positioning makes it highly suitable for normative modelling and NeuroAI. We anticipate that it will complement existing toolkits and represent a significant contribution to the computational neuroscience toolbox.”</p><disp-quote content-type="editor-comment"><p>– An important strength of the toolbox is its capability to simulate with ease realistic animal exploratory patterns. In comparison, the simulation of electrophysiological cell responses is more simplistic. It would be useful to better describe the assumptions and limitations taken in the simulations of cell types and briefly compare them with the well-known experimental evidence. For example, place fields are pre-determined by the model's parameters and completely stable. However, it is well known that place fields developed with experience (e.g., change locations and sizes, pop in/out). The paper claims that it can &quot;concurrently simulate neuronal activity data&quot; in &quot;configurable&quot; environments. It should be clarified if this model can capture the developmental part of place cells, or only the &quot;stable&quot; state.</p></disp-quote><p>Assumptions and limitations are described now in the discussion as shown in the section above including a statement clarifying that default cells are steady-state but evolving receptive fields can be modelled too.</p><p>RatInABox default cell classes (like PlaceCells, GridCells) are, as you point out, “steady-state”, so don’t by default model adaptation, remapping etc. however these processes can be modelled within the framework quite easily. For example a demo<sup>[4]</sup> is included which shows how to model successor representations (a popular model for place cells) and shows them “evolving” over time. Another demo shows how to build splitter cells<sup>[1]</sup> which fire depend on the agents history. Additionally, PlaceCells now have a “remap()” method (released in v1.6.0) which shuffles their receptive fields. All said, we are confident RatInABox can easily extend to modelling learning processes in the brain and non-static receptive fields even if default cell types don’t include these a priori. Minor text changes throughout the manuscript highlight the generality/extensibility of RatInABox and the features which enable this. Additionally the following paragraph in section 3.1 was modified to clarify this:</p><p>“Additional tutorials, not described here but available online, demonstrate how RatInABox can be used to model splitter cells, conjunctive grid cells, biologically plausible path integration, successor features, deep actor-critic RL, whisker cells and more. Despite including these examples we stress that they are not exhaustive. RatInABox provides the framework and primitive classes/functions from which highly advanced simulations such as these can be built.”</p><p>Finally, RatInABox is open source. This means users can always write their own cell classes which can be arbitrarily complex, time varying etc. This does not merely kick the can down the road. By writing bespoke cells which follow our minimal API they can then immediately benefit from the rest of the RatInABox package functionality (complex Environments, random motion model, plotting functions, multilayer model building etc.). We already know of many users taking this approach of using RatInABox API to construct their own more advanced cell types and we support this.</p><disp-quote content-type="editor-comment"><p>As another example, the authors showed that the decoding error of Agent position is almost 0 with &gt;= 20 place cells (Figure S1c), which is significantly less than that using real neural data. At least, there should be some discussion of where this difference may arise. Can noise be added to cell tuning curves? E.g. in the form of out-of-field spikes or trial-by-trial variability.</p></disp-quote><p>It is absolutely true that this decoding error from our highly simplified analysis is significantly lower than what would be achieved using a comparable number of <italic>real</italic> neurons. There are many reasons for this: real neurons use spikes not rates, real neurons are noisy and neurons may be jointly encoding multiple variables at once, not just position. All of these can be modelled in RatInABox. For example users could extract spikes and train a spike-based decoder. Following your comment noise can now be natively added to all cell types (new as of v1.1.0) as described in a new methods subsection (see 6.3). Mixed selective Neurons can easily be built using function approximator classes as now discussed in the manuscript and demonstrated in a tutorial<sup>[6]</sup>.</p><p>As you recommended, we have added the following sentence to the supplementary section to discuss where these differences arise and how they can be studied within the framework.</p><p>“Decoding errors in Figure S1c are smaller than would be expected if one decoded from equivalently sized populations of real hippocampal neurons. There are likely many reasons for this. Real neurons are noisy, communicate sparsely through spikes rather than rates and, most likely, jointly encode position and many other behaviourally relevant (or irrelevant) variables simultaneously. All of these factors could be straightforwardly incorporated into this analysis using existing RatInABox functionality.”</p><p>On the topic of generality we have been working to make RatInABox more versatile. An illustrative case in point is the new NeuralNetworkNeurons class. These neurons take <italic>other</italic> neurons as inputs and map them through a small (pytorch) neural network embedded within them. Beyond this they follow the standard RatInABox API and can be used exactly as any other cell would be. In a new panel of figure 3 (and an associated demo notebook<sup>[7]</sup>) we demonstrate these by training them to learn a non-linear target function from a set of grid cell inputs. Additionally in a different demo<sup>[3]</sup> we show how they can support deep reinforcement learning. As always, the point here is not the specifics of the example but to show that with this neurons class (and the analogous FeedForwardLayer) users are not restricted to our predefined list but can in principle create or “learn” arbitrary neural classes with their own complex receptive fields and perhaps even dynamics. This is clarified in the following text in modified/added-to section 2:</p><p>Customizable and trainable Neurons: Any single toolkit cannot contain all possible neural representations of interest. Besides, static cell types (e.g. PlaceCells, GridCells etc.) which have fixed receptive fields are limiting if the goal is to study how representations and/or behaviour are learned. RatInABox provides two solutions: Firstly, being open-source, users can write and contribute their own bespoke Neurons (instructions and examples are provided) with arbitrarily complicated rate functions.</p><p>Secondly, two types of function-approximator Neurons are provided which map inputs (the firing rate of other Neurons) to outputs (firing rate) through a parameterised function which can be hand-tuned or trained to represent an endless variety of receptive field functions including those which are mixed selective, non-linear, dynamic and non-stationary.</p><p>– FeedForwardLayer: Calculates a weighted linear combination of the input Neurons with optional bias and non-linear activation function.</p><p>– NeuralNetworkNeurons: Inputs are passed through a user-provided artificial neural network.</p><p>Naturally, function-approximator Neurons can be used to model how neural populations in the brain communicate, how neural representations are learned or, in certain cases, neural dynamics. In an online demo we show how grid cells and head direction cells can be easily combined using a FeedForwardLayer to create head-direction selective grid cells (aka. conjunctive grid cells[10]). In Figure 3d and associated demo GridCells provide input to a NeuralNetworkNeuron which is then trained, on data generated during exploration, to have a highly complex and non-linear receptive field. Function-approximator Neurons can themselves be used as inputs to other function-approximator Neurons allowing multi-layer and/or recurrent networks to be constructed and studied.</p><p>This panel added to figure 3 demonstrate them in action.</p><disp-quote content-type="editor-comment"><p>– The manuscript also lacks a description of the limitations of the approach. The authors should clarify what types of experimental data that can and cannot be modelled here, the limitations of experimental estimates from the models, and more importantly, what testable predictions of yet unknown results can be generated by this model, beyond replicating what is already known.</p></disp-quote><p>We already know that <italic>“testable predictions of yet unknown results can be generated by this model”</italic> as some early citations of the package<sup>[8,9,10]</sup> (which have been added to the manuscript) demonstrate. However, we think of RatInABox as a generator or models rather than a model itself, therefore making testable predictions is not the primary contribution and might seem out of place. We have modified the following sentence in the discussion to clarify this:</p><p>“Its user-friendly API, inbuilt data-plotting functions and general yet modular feature set mean it is well placed empower a wide variety of users to more rapidly build, train and validate models of hippocampal function [25] and spatial navigation[26], accelerating progress in the field.”</p><p>As well as:</p><p>“In conclusion, while no single approach can be deemed the best, we believe that RatInABox’s unique positioning makes it highly suitable for normative modelling and NeuroAI. We anticipate that it will complement existing toolkits and represent a significant contribution to the computational neuroscience toolbox.”</p><disp-quote content-type="editor-comment"><p>For example, can RatInABox be used to model episodic coding in the hippocampus (e.g., splitter cells), as task states can often be latent and non-Markovian. Can it be used to model the &quot;remapping&quot; of place cells (and other cell types) in response to changes in the environment?</p></disp-quote><p>All this stuff falls well within the scope of RatInABox but we’d rather not go down the rabbit hole of one-by-one including – at the level of user-facing API – all possible biological phenomena of interest. Instead the approach we take with RatInABox (which we think it’s better and more scalable) is to provide a minimal feature set and then <italic>demonstrate</italic> how more complex phenomena can be modelled in case studies, supplementary material and demos.</p><p>As you mentioned splitter cells we went ahead and made a very basic simulation of splitter cells which is now available as a Jupyter demo on the GitHub<sup>[1]</sup>. In this demo, the Agent goes around a figure-of-eight maze and “remembers” the last arm it passed through. A bespoke “SplitterPlaceCell” uses this to determine if a splitter cell will fire or not. Of course this is highly simplistic and doesn’t model the development of splitter cells or their neural underpinnings but the point is not to provide a completely comprehensive exploration of the biological mechanisms of splitter cells, or any other phenomena for that matter, but to demonstrate that this is <italic>within scope</italic> and give users starting point. We also have a new demo for making conjunctive grid cells<sup>[6]</sup> by combining grid cells and head direction cells, and many more. This figure shows a snippet of the splitter cell demo.</p><p>Likewise, remapping could absolutely be modelled with RatInABox. In fact we study this in our own recent paper<sup>[8]</sup> which uses RatInABox. By the way, PlaceCells now contain a naive “remap()” method which shuffles cell locations.</p><p>We repeat here the modified paragraph in section 3.1 pointing users to these teaching materials:</p><p>“Additional tutorials, not described here but available online, demonstrate how RatInABox can be used to model splitter cells, conjunctive grid cells, biologically plausible path integration, successor features, deep actor-critic RL, whisker cells and more. Despite including these examples we stress that they are not exhaustive. RatInABox provides the framework and primitive classes/functions from which highly advanced simulations such as these can be built.”</p></body></sub-article></article>