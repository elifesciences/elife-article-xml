<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD with MathML3 v1.3 20210610//EN"  "JATS-archivearticle1-3-mathml3.dtd"><article xmlns:ali="http://www.niso.org/schemas/ali/1.0/" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article" dtd-version="1.3"><front><journal-meta><journal-id journal-id-type="nlm-ta">elife</journal-id><journal-id journal-id-type="publisher-id">eLife</journal-id><journal-title-group><journal-title>eLife</journal-title></journal-title-group><issn publication-format="electronic" pub-type="epub">2050-084X</issn><publisher><publisher-name>eLife Sciences Publications, Ltd</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="publisher-id">89947</article-id><article-id pub-id-type="doi">10.7554/eLife.89947</article-id><article-id pub-id-type="doi" specific-use="version">10.7554/eLife.89947.3</article-id><article-categories><subj-group subj-group-type="display-channel"><subject>Research Article</subject></subj-group><subj-group subj-group-type="heading"><subject>Computational and Systems Biology</subject></subj-group></article-categories><title-group><article-title>Improved clinical data imputation via classical and quantum determinantal point processes</article-title></title-group><contrib-group><contrib contrib-type="author" corresp="yes" id="author-322251"><name><surname>Kazdaghli</surname><given-names>Skander</given-names></name><contrib-id authenticated="true" contrib-id-type="orcid">https://orcid.org/0009-0005-9044-0919</contrib-id><email>skander.kazdaghli@gmail.com</email><xref ref-type="aff" rid="aff1">1</xref><xref ref-type="fn" rid="con1"/><xref ref-type="fn" rid="conf1"/></contrib><contrib contrib-type="author" id="author-322265"><name><surname>Kerenidis</surname><given-names>Iordanis</given-names></name><xref ref-type="aff" rid="aff1">1</xref><xref ref-type="aff" rid="aff2">2</xref><xref ref-type="fn" rid="con2"/><xref ref-type="fn" rid="conf1"/></contrib><contrib contrib-type="author" id="author-322266"><name><surname>Kieckbusch</surname><given-names>Jens</given-names></name><xref ref-type="aff" rid="aff3">3</xref><xref ref-type="fn" rid="con3"/><xref ref-type="fn" rid="conf2"/></contrib><contrib contrib-type="author" id="author-322267"><name><surname>Teare</surname><given-names>Philip</given-names></name><xref ref-type="aff" rid="aff4">4</xref><xref ref-type="fn" rid="con4"/><xref ref-type="fn" rid="conf2"/></contrib><aff id="aff1"><label>1</label><institution>QC Ware</institution><addr-line><named-content content-type="city">Paris</named-content></addr-line><country>France</country></aff><aff id="aff2"><label>2</label><institution-wrap><institution-id institution-id-type="ror">https://ror.org/05f82e368</institution-id><institution>Universite de Paris, CNRS, IRIF</institution></institution-wrap><addr-line><named-content content-type="city">Paris</named-content></addr-line><country>France</country></aff><aff id="aff3"><label>3</label><institution-wrap><institution-id institution-id-type="ror">https://ror.org/04r9x1a08</institution-id><institution>Emerging Innovations Unit, Discovery Sciences, BioPharmaceuticals R&amp;D, AstraZeneca</institution></institution-wrap><addr-line><named-content content-type="city">Cambridge</named-content></addr-line><country>United Kingdom</country></aff><aff id="aff4"><label>4</label><institution-wrap><institution-id institution-id-type="ror">https://ror.org/04r9x1a08</institution-id><institution>Centre for AI, Data Science &amp; AI, BioPharmaceuticals R&amp;D, AstraZeneca</institution></institution-wrap><addr-line><named-content content-type="city">Cambridge</named-content></addr-line><country>United Kingdom</country></aff></contrib-group><contrib-group content-type="section"><contrib contrib-type="editor"><name><surname>Graña</surname><given-names>Martin</given-names></name><role>Reviewing Editor</role><aff><institution-wrap><institution-id institution-id-type="ror">https://ror.org/04dpm2z73</institution-id><institution>Institut Pasteur de Montevideo</institution></institution-wrap><country>Uruguay</country></aff></contrib><contrib contrib-type="senior_editor"><name><surname>Walczak</surname><given-names>Aleksandra M</given-names></name><role>Senior Editor</role><aff><institution-wrap><institution-id institution-id-type="ror">https://ror.org/05a0dhs15</institution-id><institution>École Normale Supérieure - PSL</institution></institution-wrap><country>France</country></aff></contrib></contrib-group><pub-date publication-format="electronic" date-type="publication"><day>09</day><month>05</month><year>2024</year></pub-date><volume>12</volume><elocation-id>RP89947</elocation-id><history><date date-type="sent-for-review" iso-8601-date="2023-06-09"><day>09</day><month>06</month><year>2023</year></date></history><pub-history><event><event-desc>This manuscript was published as a preprint.</event-desc><date date-type="preprint" iso-8601-date="2023-03-31"><day>31</day><month>03</month><year>2023</year></date><self-uri content-type="preprint" xlink:href="https://doi.org/10.48550/arXiv.2303.17893"/></event><event><event-desc>This manuscript was published as a reviewed preprint.</event-desc><date date-type="reviewed-preprint" iso-8601-date="2023-08-23"><day>23</day><month>08</month><year>2023</year></date><self-uri content-type="reviewed-preprint" xlink:href="https://doi.org/10.7554/eLife.89947.1"/></event><event><event-desc>The reviewed preprint was revised.</event-desc><date date-type="reviewed-preprint" iso-8601-date="2024-03-18"><day>18</day><month>03</month><year>2024</year></date><self-uri content-type="reviewed-preprint" xlink:href="https://doi.org/10.7554/eLife.89947.2"/></event></pub-history><permissions><copyright-statement>© 2023, Kazdaghli et al</copyright-statement><copyright-year>2023</copyright-year><copyright-holder>Kazdaghli et al</copyright-holder><ali:free_to_read/><license xlink:href="http://creativecommons.org/licenses/by/4.0/"><ali:license_ref>http://creativecommons.org/licenses/by/4.0/</ali:license_ref><license-p>This article is distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution License</ext-link>, which permits unrestricted use and redistribution provided that the original author and source are credited.</license-p></license></permissions><self-uri content-type="pdf" xlink:href="elife-89947-v1.pdf"/><abstract><p>Imputing data is a critical issue for machine learning practitioners, including in the life sciences domain, where missing clinical data is a typical situation and the reliability of the imputation is of great importance. Currently, there is no canonical approach for imputation of clinical data and widely used algorithms introduce variance in the downstream classification. Here we propose novel imputation methods based on determinantal point processes (DPP) that enhance popular techniques such as the multivariate imputation by chained equations and MissForest. Their advantages are twofold: improving the quality of the imputed data demonstrated by increased accuracy of the downstream classification and providing deterministic and reliable imputations that remove the variance from the classification results. We experimentally demonstrate the advantages of our methods by performing extensive imputations on synthetic and real clinical data. We also perform quantum hardware experiments by applying the quantum circuits for DPP sampling since such quantum algorithms provide a computational advantage with respect to classical ones. We demonstrate competitive results with up to 10 qubits for small-scale imputation tasks on a state-of-the-art IBM quantum processor. Our classical and quantum methods improve the effectiveness and robustness of clinical data prediction modeling by providing better and more reliable data imputations. These improvements can add significant value in settings demanding high precision, such as in pharmaceutical drug trials where our approach can provide higher confidence in the predictions made.</p></abstract><kwd-group kwd-group-type="author-keywords"><kwd>clinical</kwd><kwd>survival</kwd><kwd>critical care unit</kwd></kwd-group><kwd-group kwd-group-type="research-organism"><title>Research organism</title><kwd>Human</kwd></kwd-group><funding-group><funding-statement>No external funding was received for this work.</funding-statement></funding-group><custom-meta-group><custom-meta specific-use="meta-only"><meta-name>Author impact statement</meta-name><meta-value>A new data imputation method that can be implemented quantumly allows for better and more reliable classifications.</meta-value></custom-meta><custom-meta specific-use="meta-only"><meta-name>publishing-route</meta-name><meta-value>prc</meta-value></custom-meta></custom-meta-group></article-meta></front><body><sec id="s1" sec-type="intro"><title>Introduction</title><p>Missing data is a recurring problem in machine learning and in particular for clinical datasets, where it is common that numerous feature values are not present for reasons including incomplete data collection and discrepancies in data formats and data corruption (<xref ref-type="bibr" rid="bib17">Luo, 2022</xref>; <xref ref-type="bibr" rid="bib9">Emmanuel et al., 2021</xref>; <xref ref-type="bibr" rid="bib21">Pedersen et al., 2017</xref>; <xref ref-type="bibr" rid="bib20">Myers, 2000</xref>). Machine learning is routinely used in life science and clinical research for prediction tasks, such as diagnostics (<xref ref-type="bibr" rid="bib22">Qin et al., 2019</xref>) and prognostics (<xref ref-type="bibr" rid="bib3">Booth et al., 2021</xref>), as well as estimation tasks, such as biomarker proxies (<xref ref-type="bibr" rid="bib28">Wang et al., 2017</xref>) and digital biomarkers (<xref ref-type="bibr" rid="bib23">Rendleman et al., 2019</xref>). Beyond the research setting, machine learning is becoming more commonplace as regulated Software as a Medical Device, where machine learning models are influencing – or making – clinical decisions that affect patient care.</p><p>Machine learning algorithms typically require complete datasets and missing values can significantly affect the quality of the machine learning models trained on such data. This is in large part due to the fact that there can be different underlying reasons for the missingness: for example, feature values can be missing completely at random (MCAR), missing at random (MAR), and missing not at random (MNAR), each one with their own characteristics.</p><p>Despite its importance for clinical trials, there is no canonical approach for dealing with missingness and finding appropriate, effective and reproducible methods remains a challenge. A common way to deal with missing clinical data is to exclude subjects that do not have the complete set of feature values present. A drawback of this approach is that excluding subjects can in fact introduce significant biases in the final model. For example, it can result in the model being trained to be more effective for the type of subjects that are likely to have complete data than for those that do not. Moreover, the effectiveness and reliability of clinical trials are reduced when subjects with missing feature values are excluded from the clinical trial.</p><p>Data imputation is an alternative to the complete dataset approach, where subjects with missing feature values are not excluded. Instead, missing values are imputed to create a complete dataset that is then used for a classification task as shown in <xref ref-type="fig" rid="fig1">Figure 1</xref>. There are different ways to achieve this, including ‘filling’ missing values with zeros, or with the mean value of the feature across all subjects that have such a value present. These methods provide consistent imputation results, but there are important caveats for using such simple methods since they ignore possible correlations between features and can make the dataset appear more homogeneous than it really is. More advanced data imputation methods have been proposed in the literature: iterative methods include the multivariate imputation by chained equations (MICE) (<xref ref-type="bibr" rid="bib10">Groothuis-Oudshoorn, 2011</xref>) and MissForest (<xref ref-type="bibr" rid="bib26">Stekhoven and Bühlmann, 2012</xref>) algorithms, and deep learning methods include GAIN (generative adversarial imputation nets) <xref ref-type="bibr" rid="bib29">Yoon and Jordon, 2018</xref> and MIWAE (missing data importance-weighted autoencoder) (<xref ref-type="bibr" rid="bib19">Mattei and Frellsen, 2019</xref>). Recent results <xref ref-type="bibr" rid="bib25">Shadbahr et al., 2022</xref> have shown that for clinical data two iterative imputation methods, MiceRanger, which uses predictive mean matching, and MissForest, which uses Random Forests to predict the missing values of each feature using the other features, provide the best results and have been used here as a baseline.</p><fig id="fig1" position="float"><label>Figure 1.</label><caption><title>Example of overall workflow for patient management through clinical data imputation and downstream classification.</title></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-89947-fig1-v1.tif"/></fig><p>Several metrics are routinely used to quantify the quality of data imputation: point-wise discrepancy measures include root mean square error, mean absolute error, and coefficient of determination (<inline-formula><mml:math id="inf1"><mml:msup><mml:mi>R</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:math></inline-formula>). Feature-wise discrepancy measures include Kullback–Leibler divergence, two-sample Kolmogorov–Smirnov statistic or (2-)Wasserstein distance. Ultimately, the quality and reliability of imputations can be measured by the performance of a downstream predictor, which is usually the area under the receiver operating curve (AUC) for a classification task. In practical terms, the performance of the downstream classifier is usually of highest importance for clinical datasets: for example, in one of our datasets, the classifier denominates a binary outcome of a critical care unit stay (e.g., survival) for each patient. Accordingly, we have used AUC for the classification task here on different holdout sets (see <xref ref-type="fig" rid="fig2">Figure 2</xref>) to assess the performance of our novel methods.</p><fig id="fig2" position="float"><label>Figure 2.</label><caption><title>Imputation and downstream classification procedure to benchmark the imputation method’s performance.</title><p>First, the imputer is trained on the whole observed dataset X as shown in step (a). In step (b), the imputed data is split into three consecutive folds (holdout sets H1, H2, and H3), then a classifier is trained on each combination of two holdout sets (development sets D1, D2, and D3) and the area under the receiver operating curve (AUC) is calculated for each holdout set.</p></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-89947-fig2-v1.tif"/></fig><p>In order to increase the resulting AUC, we combine the MissForest and MiceRanger imputation methods with determinantal sampling, based on determinantal point processes (DPP) (<xref ref-type="bibr" rid="bib7">Dereziński and Mahoney, 2021</xref>; <xref ref-type="bibr" rid="bib15">Kulezsa and Taskar, 2011</xref>), which favors samples that are diverse and thus reduces the variance of the training of each decision tree that in turn provides more accurate models. In essence, determinantal sampling picks subsets of data according to a distribution that gives more weight to subsets of data that contain diverse data points. More precisely, each subset of data points is picked according to the volume encapsulated by these data points. The determinantal distribution increases the attention given to uncommon or out-of-the-ordinary data points rather than biasing the learning process towards the more commonly found data, which can improve the overall prediction accuracy in particular for unbalanced datasets as is often the case for clinical data (Derezińsk and Mahoney). Determinantal sampling for regression and classification tasks with full data has been proposed previously for linear regressors (<xref ref-type="bibr" rid="bib6">Dereziński et al., 2018</xref>) and for Random Forest training for a financial data classification use case where it outperformed the standard Random Forest model (<xref ref-type="bibr" rid="bib27">Thakkar et al., 2023</xref>). However, an inherent feature of standard Random Forest and determinantal sampling algorithms is randomness that produces data imputations that vary from one run of the algorithm to the next. This is often undesirable since the downstream classification performance can also be affected, which motivated us to apply a deterministic version of determinantal sampling (<xref ref-type="bibr" rid="bib24">Schreurs and Suykens, 2021</xref>) within the Random Forests of the imputation methods to provide more robust and reliable imputations.</p><p>Through deterministic determinantal sampling, we address two challenges in data imputation: first, we provide improved data imputation methods that can increase the performance of the downstream classifier; and second, we remove the variance of the common stochastic and multiple imputation methods, thus ensuring reproducibility, easier integration in machine learning workflows, and compliance with healthcare regulations. While these improvements are of particular relevance for clinical data, our algorithms can also be advantageous for other imputation tasks where improving downstream classification and removing variance is of importance.</p><p>In order to demonstrate this improvement, we apply our methods to two classification datasets: a synthetic dataset and a public clinical dataset where the predicted outcome is the survival of the patient.</p><p>In addition, we explore the potential of quantum computing to speed up these novel imputation methods: we provide a quantum circuit implementation of the determinantal sampling algorithm that offers a computational advantage compared to its classical counterpart. The best classical algorithms for determinantal sampling take in practice cubic time in the number of features to provide a sample (<xref ref-type="bibr" rid="bib7">Dereziński and Mahoney, 2021</xref>). In contrast, the quantum algorithm we present here, based on theoretical analysis in <xref ref-type="bibr" rid="bib13">Kerenidis and Prakash, 2022</xref>, has running time that scales linearly with the number of features. We measure running time as the depth of the necessary quantum circuits, given that the quantum processing units that are being developed currently offer the possibility of performing parallel operations on disjoint qubits.</p><p>This suggests that with the advent of next-generation quantum computers with more and better qubits, one could also expect a computational speedup in performing determinantal sampling using a quantum computer. Here, we demonstrate competitive results with up to 10 qubits for small-scale imputation tasks on a state-of-the-art IBM quantum processor.</p><p>This work combines classical (<xref ref-type="bibr" rid="bib7">Dereziński and Mahoney, 2021</xref>) and quantum (<xref ref-type="bibr" rid="bib13">Kerenidis and Prakash, 2022</xref>) DPP algorithms with widely used data imputation methods, resulting in novel data imputation algorithms that can improve performance on classical computers while also having the potential of a quantum speedup in the future.</p></sec><sec id="s2" sec-type="results"><title>Results</title><p>In ‘Methods’, we provide a detailed description of our four imputation methods, DPP-MICE, DPP-MissForest, detDPP-MICE, and detDPP-MissForest. All of them are based on iterative imputation methods that use the observed values of every column to predict the missing values. The model used to fill missing values in each column is the Random Forest classifier. Our imputation methods replace the standard Random Forest used by the original miceRanger and MissForest imputers by the DPP-Random Forest model, for our first two imputers, and the detDPP-Random Forest for the latter two. The DPP-Random Forest model subsamples the data for each decision tree using determinantal sampling instead of uniform sampling, while the detDPP-Random Forest model deterministically picks for each decision tree the subset of data that has the maximum probability according to the determinantal distribution. We also demonstrate a computationally advantageous way to perform the determinantal sampling on quantum computers.</p><p>In order to benchmark the different imputation methods, we used two types of datasets with a categorical outcome variable. First, a synthetic dataset, created using the scikit-learn method <italic>make_classification</italic>. It consists of 2000 rows with 25 informative features. This is useful to study the imputation quality where features have equal importance. Second, the MIMIC-III dataset (<xref ref-type="bibr" rid="bib12">Johnson et al., 2016</xref>): the Medical Information Mart for Intensive Care (MIMIC) dataset, which is a freely available clinical database. It is comprised of data for patients who stayed in critical care units at the Beth Israel Deaconess Medical Center between 2001 and 2012. It contains the data of 7214 patients with 14 features.</p><p>We also applied two types of missingness on these datasets: MCAR, where the missingness distribution is independent of any observed or unobserved variable, and MNAR, where the missingness distribution depends on the outcome variable. We expect similar results to hold for the MAR case as well, but it was not considered in this work.</p><p>We present the numerical results in terms of the AUC of the downstream classification task in <xref ref-type="table" rid="table1">Table 1</xref> and provide graphs of the results in <xref ref-type="table" rid="table2 table3">Tables 2 and 3</xref>. Each experiment was run 10 times with different random seeds to get the variance of the results.</p><table-wrap id="table1" position="float"><label>Table 1.</label><caption><title>AUC results for the SYNTH and MIMIC-III datasets, with MCAR and MNAR missingness, three holdout sets, and six different imputation methods.</title><p>Values are expressed as mean ± SD of 10 values for each experiment. DPP-MICE and detDPP-MICE are in bold when outperforming MICE and the underlined one is the best of the three. DPP-MissForest and detDPP-MissForest are in bold when outperforming MissForest and the underlined one is the best of the three.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left" valign="bottom">Dataset</th><th align="left" valign="bottom">Missingness</th><th align="left" valign="bottom">Set</th><th align="left" valign="bottom">MICE</th><th align="left" valign="bottom">DPP-MICE</th><th align="left" valign="bottom">detDPP-MICE</th><th align="left" valign="bottom">MissForest</th><th align="left" valign="bottom">DPP-MissForest</th><th align="left" valign="bottom">detDPP-MissForest</th></tr></thead><tbody><tr><td align="left" valign="bottom" rowspan="6">SYNTH</td><td align="left" valign="bottom" rowspan="3">MCAR</td><td align="left" valign="bottom">H1</td><td align="char" char="plusmn" valign="bottom">0.8318 ± 0.0113</td><td align="char" char="plusmn" valign="bottom"><bold>0.835 ± 0.0083</bold></td><td align="char" char="." valign="bottom"><bold>0.8352</bold></td><td align="char" char="plusmn" valign="bottom">0.8525 ± 0.0044</td><td align="char" char="plusmn" valign="bottom"><bold>0.8552 ± 0.0049</bold></td><td align="char" char="." valign="bottom"><bold>0.8582</bold></td></tr><tr><td align="left" valign="bottom">H2</td><td align="char" char="plusmn" valign="bottom">0.8316 ± 0.008</td><td align="char" char="plusmn" valign="bottom"><bold>0.8369 ± 0.0128</bold></td><td align="char" char="." valign="bottom"><bold>0.84</bold></td><td align="char" char="plusmn" valign="bottom">0.8465 ± 0.0057</td><td align="char" char="plusmn" valign="bottom"><bold>0.849 ± 0.003</bold></td><td align="char" char="." valign="bottom"><bold>0.8491</bold></td></tr><tr><td align="left" valign="bottom">H3</td><td align="char" char="plusmn" valign="bottom">0.8205 ± 0.0127</td><td align="char" char="plusmn" valign="bottom"><bold>0.8266 ± 0.0096</bold></td><td align="char" char="." valign="bottom"><bold>0.8272</bold></td><td align="char" char="plusmn" valign="bottom">0.8436 ± 0.0031</td><td align="char" char="plusmn" valign="bottom"><bold>0.8452 ± 0.0048</bold></td><td align="char" char="." valign="bottom"><bold>0.855</bold></td></tr><tr><td align="left" valign="bottom" rowspan="3">MNAR</td><td align="left" valign="bottom">H1</td><td align="char" char="plusmn" valign="bottom">0.8903 ± 0.0046</td><td align="char" char="plusmn" valign="bottom"><bold>0.8915 ± 0.007</bold></td><td align="char" char="." valign="bottom"><bold>0.8934</bold></td><td align="char" char="plusmn" valign="bottom">0.7133 ± 0.0063</td><td align="char" char="plusmn" valign="bottom"><bold>0.7171 ± 0.01</bold></td><td align="char" char="." valign="bottom"><bold>0.7185</bold></td></tr><tr><td align="left" valign="bottom">H2</td><td align="char" char="plusmn" valign="bottom">0.8755 ± 0.01</td><td align="char" char="plusmn" valign="bottom">0.8745 ± 0.0072</td><td align="char" char="." valign="bottom"><bold>0.8955</bold></td><td align="char" char="plusmn" valign="bottom">0.7052 ± 0.0036</td><td align="char" char="plusmn" valign="bottom"><bold>0.7124 ± 0.0078</bold></td><td align="char" char="." valign="bottom"><bold>0.7167</bold></td></tr><tr><td align="left" valign="bottom">H3</td><td align="char" char="plusmn" valign="bottom">0.9003 ± 0.0059</td><td align="char" char="plusmn" valign="bottom"><bold>0.9005 ± 0.006</bold></td><td align="char" char="." valign="bottom"><bold>0.9041</bold></td><td align="char" char="plusmn" valign="bottom">0.769 ± 0.0103</td><td align="char" char="plusmn" valign="bottom"><bold>0.7773 ± 0.0129</bold></td><td align="char" char="." valign="bottom"><bold>0.7905</bold></td></tr><tr><td align="left" valign="bottom" rowspan="6">MIMIC</td><td align="left" valign="bottom" rowspan="3">MCAR</td><td align="left" valign="bottom">H1</td><td align="char" char="plusmn" valign="bottom">0.7621 ± 0.0046</td><td align="char" char="plusmn" valign="bottom"><bold>0.7628 ± 0.0049</bold></td><td align="char" char="." valign="bottom"><bold>0.7641</bold></td><td align="char" char="plusmn" valign="bottom">0.7687 ± 0.0012</td><td align="char" char="plusmn" valign="bottom"><bold>0.77 ± 0.0013</bold></td><td align="char" char="." valign="bottom"><bold>0.771</bold></td></tr><tr><td align="left" valign="bottom">H2</td><td align="char" char="plusmn" valign="bottom">0.7541 ± 0.0037</td><td align="char" char="plusmn" valign="bottom">0.7532 ± 0.0047</td><td align="char" char="." valign="bottom"><bold>0.7619</bold></td><td align="char" char="plusmn" valign="bottom">0.7649 ± 0.0019</td><td align="char" char="plusmn" valign="bottom"><bold>0.777 ± 0.0019</bold></td><td align="char" char="." valign="bottom"><bold>0.7707</bold></td></tr><tr><td align="left" valign="bottom">H3</td><td align="char" char="plusmn" valign="bottom">0.7365 ± 0.0055</td><td align="char" char="plusmn" valign="bottom"><bold>0.7394 ± 0.0052</bold></td><td align="char" char="." valign="bottom"><bold>0.7471</bold></td><td align="char" char="plusmn" valign="bottom">0.7485 ± 0.001</td><td align="char" char="plusmn" valign="bottom"><bold>0.7507 ± 0.0017</bold></td><td align="char" char="." valign="bottom"><bold>0.7515</bold></td></tr><tr><td align="left" valign="bottom" rowspan="3">MNAR</td><td align="left" valign="bottom">H1</td><td align="char" char="plusmn" valign="bottom">0.77 ± 0.0026</td><td align="char" char="plusmn" valign="bottom"><bold>0.7717 ± 0.0036</bold></td><td align="char" char="." valign="bottom"><bold>0.7722</bold></td><td align="char" char="plusmn" valign="bottom">0.6616 ± 0.0065</td><td align="char" char="plusmn" valign="bottom"><bold>0.6715 ± 0.07</bold></td><td align="char" char="." valign="bottom"><bold>0.6760</bold></td></tr><tr><td align="left" valign="bottom">H2</td><td align="char" char="plusmn" valign="bottom">0.777 ± 0.0064</td><td align="char" char="plusmn" valign="bottom"><bold>0.7818 ± 0.0029</bold></td><td align="char" char="." valign="bottom"><bold>0.7812</bold></td><td align="char" char="plusmn" valign="bottom">0.6748 ± 0.0045</td><td align="char" char="plusmn" valign="bottom"><bold>0.6778 ± 0.0048</bold></td><td align="char" char="." valign="bottom"><bold>0.6798</bold></td></tr><tr><td align="left" valign="bottom">H3</td><td align="char" char="plusmn" valign="bottom">0.7324 ± 0.0047</td><td align="char" char="plusmn" valign="bottom"><bold>0.7363 ± 0.0031</bold></td><td align="char" char="." valign="bottom"><bold>0.7403</bold></td><td align="char" char="plusmn" valign="bottom">0.6368 ± 0.0034</td><td align="char" char="plusmn" valign="bottom"><bold>0.64 ± 0.004</bold></td><td align="char" char="." valign="bottom"><bold>0.6419</bold></td></tr></tbody></table><table-wrap-foot><fn><p>AUC = area under the receiver operating curve; MCAR = missing completely at random; MNAR = missing not at random.</p></fn></table-wrap-foot></table-wrap><table-wrap id="table2" position="float"><label>Table 2.</label><caption><title>AUC results on the different holdout sets after imputation using MICE, DPP-MICE, and detDPP-MICE.</title><p>In the case of MICE and DPP-MICE, the boxplots correspond to 10 AUC values for 10 iterations of the same imputation and classification algorithms, depicting the lower and upper quartiles as well as the median of these 10 values. The AUC values are the same for every iteration of the detDPP-MICE algorithm.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left" valign="top"/><th align="left" valign="top">MCAR</th><th align="left" valign="top">MNAR</th></tr></thead><tbody><tr><td align="left" valign="top">SYNTH</td><td align="left" valign="top"><inline-graphic mimetype="image" mime-subtype="jpeg" xlink:href="elife-89947-inf001-v1.tif"/></td><td align="left" valign="top"><inline-graphic mimetype="image" mime-subtype="jpeg" xlink:href="elife-89947-inf002-v1.tif"/></td></tr><tr><td align="left" valign="top">MIMIC</td><td align="left" valign="top"><inline-graphic mimetype="image" mime-subtype="jpeg" xlink:href="elife-89947-inf003-v1.tif"/></td><td align="left" valign="top"><inline-graphic mimetype="image" mime-subtype="jpeg" xlink:href="elife-89947-inf004-v1.tif"/></td></tr></tbody></table><table-wrap-foot><fn><p>AUC = area under the receiver operating curve; MCAR = missing completely at random; MNAR = missing not at random.</p></fn></table-wrap-foot></table-wrap><table-wrap id="table3" position="float"><label>Table 3.</label><caption><title>AUC results on the different holdout sets after imputation using MissForest, DPP-MissForest, and detDPP-MissForest.</title><p>In the case of MissForest and DPP-MissForest, the boxplots correspond to 10 AUC values for 10 iterations of the same imputation and classification algorithm, depicting the lower and upper quartiles as well as the median of these 10 values. The AUC values are always the same for every iteration of the detDPP-MissForest algorithm.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left" valign="top"/><th align="left" valign="top">MCAR</th><th align="left" valign="top">MNAR</th></tr></thead><tbody><tr><td align="left" valign="top">SYNTH</td><td align="left" valign="top"><inline-graphic mimetype="image" mime-subtype="jpeg" xlink:href="elife-89947-inf005-v1.tif"/></td><td align="left" valign="top"><inline-graphic mimetype="image" mime-subtype="jpeg" xlink:href="elife-89947-inf006-v1.tif"/></td></tr><tr><td align="left" valign="top">MIMIC</td><td align="left" valign="top"><inline-graphic mimetype="image" mime-subtype="jpeg" xlink:href="elife-89947-inf007-v1.tif"/></td><td align="left" valign="top"><inline-graphic mimetype="image" mime-subtype="jpeg" xlink:href="elife-89947-inf008-v1.tif"/></td></tr></tbody></table><table-wrap-foot><fn><p>AUC = area under the receiver operating curve; MCAR = missing completely at random; MNAR = missing not at random.</p></fn></table-wrap-foot></table-wrap><p>Overall, DPP-MICE and DPP-MissForest provide improved results compared to their classical baseline MICE and MissForest. This is the case for both the synthetic and the MIMIC datasets and for both MCAR and MNAR missingness. Even more interestingly, the detDPP-MICE and detDPP-MissForest collapse the variance of the imputed data to 0 and moreover lead in most cases to even higher AUC than the expectation of the previous methods.</p><sec id="s2-1"><title>DPP-MICE and detDPP-MICE outperform MICE</title><p>We present the performance results of MICE-based methods in terms of the AUC of the downstream classification task using an XGBoost classifier, which has been shown to be the strongest classifier for such datasets (<xref ref-type="bibr" rid="bib25">Shadbahr et al., 2022</xref>). We used the default parameters of the classifier since our focus is comparing the different imputation methods. In each case, the original dataset with induced missing values is imputed using MICE, DPP-MICE, or detDPP-MICE, then it is divided into threefolds of development/holdout sets. The downstream classifier is then trained on each development set and its performance is measured by the AUC for the corresponding holdout set. The results are shown in <xref ref-type="table" rid="table1">Table 1</xref> and in the figures in <xref ref-type="table" rid="table2">Table 2</xref>.</p><p>The imputation procedure is performed for a total of 10 iterations over all the columns and for each column, a (DPP) Random Forest regressor is trained using 10 trees. For each Random Forest training, the dataset is divided into batches of 150 points each and DPPs are used to sample from every batch.</p><p>The results show that across the 12 in total dataset experiments DPP-MICE outperforms MICE on expectation in 10 of them, while detDPP-MICE provides a single deterministic imputation, which outperforms the expected result from MICE in all 12 datasets and from DPP-MICE 11 out of 12 times.</p></sec><sec id="s2-2"><title>DPP-MissForest and detDPP-MissForest outperform MissForest</title><p>Here we present the performance results of MissForest-based methods in terms of the AUC of the downstream classification task using again an XGBoost classifier. In each case, the original dataset with induced missing values is imputed using MissForest, DPP-MissForest, or detDPP-MissForest, then it is divided into threefolds of development/holdout sets. The downstream classifier is again then trained on each development set and its performance is measured by the AUC for the corresponding holdout set. The results are shown in <xref ref-type="table" rid="table1">Table 1</xref> and in the figures in <xref ref-type="table" rid="table3">Table 3</xref>. The specifics of the Random Forest training are the same as in the case of MICE.</p><p>The results show that across all experiments DPP-MissForest outperforms MissForest in all 12 of them, while detDPP-MissForest provides a single deterministic imputation that outperforms the expected result from MissForest in all 12 datasets and from DPP-MissForest in 11 out of 12 times.</p></sec><sec id="s2-3"><title>Quantum hardware implementation of DPP-MissForest results in competitive downstream classification</title><p>As we describe in ‘Methods’, quantum computers can in principle be used to offer a computational advantage in determinantal sampling. In order to better understand the state of the art of current quantum hardware, we used a currently available quantum computer to perform determinantal sampling within a DPP-MissForest imputation method for scaled-down versions of the synthetic and MIMIC datasets.</p><list list-type="bullet"><list-item><p>Reduced synthetic dataset: 100 points and three features, created using the sklearn method <italic>make_classification</italic>.</p></list-item><list-item><p>Reduced MIMIC dataset: 200 points and three features. The three features were chosen from the original dataset features based on low degree of missingness and their predictiveness of the downstream classifier, and they were ‘Oxygen saturation std’, ‘Oxygen saturation mean’, and ‘Diastolic blood pressure mean’.</p></list-item></list><p>For the purposes of our experiments, we used the ‘ibm_hanoi’ 27-qubit quantum processor shown in <xref ref-type="fig" rid="fig3">Figure 3</xref>. We implemented quantum circuits with up to 10 qubits. We also performed quantum simulations using the qiskit noiseless simulator. The decision trees of the DPP-Random Forests used by the imputation models are trained using batches of decreasing sizes (see <xref ref-type="table" rid="table4">Table 4</xref>). For example, for the algorithm with batch size equal to 10, the algorithm first samples 2 out of the 10 data points to use for the first decision tree, then from the remaining 8 data points it picks another 2 for the second tree, then 2 from the remaining 6, and last 2 from the remaining 4. In other words, we train four different trees, and each time we use a quantum circuit with number of qubits equal to 10, 8, 6, and 4, to perform the respective determinantal sampling.</p><fig id="fig3" position="float"><label>Figure 3.</label><caption><title>IBM Hanoi 27-qubit quantum processor.</title></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-89947-fig3-v1.tif"/></fig><table-wrap id="table4" position="float"><label>Table 4.</label><caption><title>Data matrix sizes used by the quantum determinantal point processes (DPP) circuits to train each tree.</title><p>The number of rows corresponds to the number of data points and is equal to the number of qubits of every circuit.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left" valign="bottom">Batch size</th><th align="left" valign="bottom">Tree 1</th><th align="left" valign="bottom">Tree 2</th><th align="left" valign="bottom">Tree 3</th><th align="left" valign="bottom">Tree 4</th></tr></thead><tbody><tr><td align="char" char="." valign="bottom">7</td><td align="char" char="." valign="bottom">(7,2)</td><td align="char" char="." valign="bottom">(5,2)</td><td align="left" valign="bottom">-</td><td align="left" valign="bottom">-</td></tr><tr><td align="char" char="." valign="bottom">8</td><td align="char" char="." valign="bottom">(8,2)</td><td align="char" char="." valign="bottom">(6,2)</td><td align="char" char="." valign="bottom">(4,2)</td><td align="left" valign="bottom">-</td></tr><tr><td align="char" char="." valign="bottom">10</td><td align="char" char="." valign="bottom">(10,2)</td><td align="char" char="." valign="bottom">(8,2)</td><td align="char" char="." valign="bottom">(6,2)</td><td align="char" char="." valign="bottom">(4,2)</td></tr></tbody></table></table-wrap><p>In the figures of <xref ref-type="table" rid="table5">Table 5</xref> and in <xref ref-type="table" rid="table6">Table 6</xref>, we provide for the different dataset experiments the AUC for MissForest, the simulated results of the quantum version of DPP-MissForest, and the actual hardware experimental results of running the quantum version of DPP-MissForest. Even for these very small datasets, when simulating the quantum version of DPP-MissForest, we demonstrate an increase in the AUC compared to the MissForest algorithm. This further highlights the potential advantages of determinantal sampling within imputation methods. Of note, running our algorithms on current hardware introduces variance in the downstream classifier. Importantly, this variance is due to noise in the hardware rather than inherent to the algorithm.</p><table-wrap id="table5" position="float"><label>Table 5.</label><caption><title>Hardware results using the IBM quantum processor, depicting AUC results of the downstream classifier task after imputing missing values using DPP-MissForest.</title><p>In the case of MissForest and the quantum hardware DPP-MissForest implementations, the boxplots correspond to 10 AUC values for 10 iterations of the same imputation and classification algorithm, depicting the lower and upper quartiles as well as the median of these 10 values. The AUC values are the same for every iteration of the quantum DPP-MissForest algorithm using the simulator.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left" valign="top"/><th align="left" valign="top">Batch size: 7Number of trees: 2</th><th align="left" valign="top">Batch size: 8Number of trees: 3</th><th align="left" valign="top">Batch size: 10Number of trees: 4</th></tr></thead><tbody><tr><td align="left" valign="top">MCAR SYNTH</td><td align="left" valign="top"><inline-graphic mimetype="image" mime-subtype="jpeg" xlink:href="elife-89947-inf009-v1.tif"/></td><td align="left" valign="top"><inline-graphic mimetype="image" mime-subtype="jpeg" xlink:href="elife-89947-inf010-v1.tif"/></td><td align="left" valign="top"><inline-graphic mimetype="image" mime-subtype="jpeg" xlink:href="elife-89947-inf011-v1.tif"/></td></tr><tr><td align="left" valign="top">MCAR MIMIC</td><td align="left" valign="top"><inline-graphic mimetype="image" mime-subtype="jpeg" xlink:href="elife-89947-inf012-v1.tif"/></td><td align="left" valign="top"><inline-graphic mimetype="image" mime-subtype="jpeg" xlink:href="elife-89947-inf013-v1.tif"/></td><td align="left" valign="top"><inline-graphic mimetype="image" mime-subtype="jpeg" xlink:href="elife-89947-inf014-v1.tif"/></td></tr><tr><td align="left" valign="top">MNAR SYNTH</td><td align="left" valign="top"><inline-graphic mimetype="image" mime-subtype="jpeg" xlink:href="elife-89947-inf015-v1.tif"/></td><td align="left" valign="top"><inline-graphic mimetype="image" mime-subtype="jpeg" xlink:href="elife-89947-inf016-v1.tif"/></td><td align="left" valign="top"><inline-graphic mimetype="image" mime-subtype="jpeg" xlink:href="elife-89947-inf017-v1.tif"/></td></tr><tr><td align="left" valign="top">MNAR MIMIC</td><td align="left" valign="top"><inline-graphic mimetype="image" mime-subtype="jpeg" xlink:href="elife-89947-inf018-v1.tif"/></td><td align="left" valign="top"><inline-graphic mimetype="image" mime-subtype="jpeg" xlink:href="elife-89947-inf019-v1.tif"/></td><td align="left" valign="top"><inline-graphic mimetype="image" mime-subtype="jpeg" xlink:href="elife-89947-inf020-v1.tif"/></td></tr></tbody></table><table-wrap-foot><fn><p>AUC = area under the receiver operating curve; MCAR = missing completely at random; MNAR = missing not at random.</p></fn></table-wrap-foot></table-wrap><table-wrap id="table6" position="float"><label>Table 6.</label><caption><title>Numerical quantum hardware results showing the AUC results of the downstream classifier task on reduced datasets.</title><p>Values are represented according to mean ± SD format given 10 values for each experiment.</p></caption><table frame="hsides" rules="groups"><thead><tr><th valign="bottom">Dataset</th><th valign="bottom">Missingness</th><th valign="bottom">Batch size</th><th valign="bottom">Trees</th><th valign="bottom">MissForest</th><th valign="bottom">detDPP-MissForest (simulator)</th><th valign="bottom">detDPP-MissForest (hardware)</th></tr></thead><tbody><tr><td align="left" valign="bottom" rowspan="6">SYNTH</td><td align="left" valign="bottom" rowspan="3">MCAR</td><td align="char" char="." valign="bottom">7</td><td align="char" char="." valign="bottom">2</td><td align="char" char="plusmn" valign="bottom">0.868 ± 0.0302</td><td align="char" char="." valign="bottom">0.9026</td><td align="char" char="plusmn" valign="bottom">0.8598 ± 0.021</td></tr><tr><td align="char" char="." valign="bottom">8</td><td align="char" char="." valign="bottom">3</td><td align="char" char="plusmn" valign="bottom">0.8667 ± 0.0342</td><td align="char" char="." valign="bottom">0.9256</td><td align="char" char="plusmn" valign="bottom">0.8923 ± 0.027</td></tr><tr><td align="char" char="." valign="bottom">10</td><td align="char" char="." valign="bottom">4</td><td align="char" char="plusmn" valign="bottom">0.8725 ± 0.0275</td><td align="char" char="." valign="bottom">0.9028</td><td align="char" char="plusmn" valign="bottom">0.8902 ± 0.024</td></tr><tr><td align="left" valign="bottom" rowspan="3">MNAR</td><td align="char" char="." valign="bottom">7</td><td align="char" char="." valign="bottom">2</td><td align="char" char="plusmn" valign="bottom">0.7122 ± 0.0264</td><td align="char" char="." valign="bottom">0.78</td><td align="char" char="plusmn" valign="bottom">0.7149 ± 0.02</td></tr><tr><td align="char" char="." valign="bottom">8</td><td align="char" char="." valign="bottom">3</td><td align="char" char="plusmn" valign="bottom">0.7153 ± 0.022</td><td align="char" char="." valign="bottom">0.729</td><td align="char" char="plusmn" valign="bottom">0.7036 ± 0.0167</td></tr><tr><td align="char" char="." valign="bottom">10</td><td align="char" char="." valign="bottom">4</td><td align="char" char="plusmn" valign="bottom">0.7258 ± 0.0157</td><td align="char" char="." valign="bottom">0.7868</td><td align="char" char="plusmn" valign="bottom">0.7082 ± 0.036</td></tr><tr><td align="left" valign="bottom" rowspan="6">MIMIC</td><td align="left" valign="bottom" rowspan="3">MCAR</td><td align="char" char="." valign="bottom">7</td><td align="char" char="." valign="bottom">2</td><td align="char" char="plusmn" valign="bottom">0.7127 ± 0.038</td><td align="char" char="." valign="bottom">0.7522</td><td align="char" char="plusmn" valign="bottom">0.7117 ± 0.0315</td></tr><tr><td align="char" char="." valign="bottom">8</td><td align="char" char="." valign="bottom">3</td><td align="char" char="plusmn" valign="bottom">0.7136 ± 0.03</td><td align="char" char="." valign="bottom">0.7728</td><td align="char" char="plusmn" valign="bottom">0.7448 ± 0.0258</td></tr><tr><td align="char" char="." valign="bottom">10</td><td align="char" char="." valign="bottom">4</td><td align="char" char="plusmn" valign="bottom">0.6968 ± 0.03</td><td align="char" char="." valign="bottom">0.7327</td><td align="char" char="plusmn" valign="bottom">0.7262 ± 0.0299</td></tr><tr><td align="left" valign="bottom" rowspan="3">MNAR</td><td align="char" char="." valign="bottom">7</td><td align="char" char="." valign="bottom">2</td><td align="char" char="plusmn" valign="bottom">0.7697 ± 0.0133</td><td align="char" char="." valign="bottom">0.7794</td><td align="char" char="plusmn" valign="bottom">0.7742 ± 0.0108</td></tr><tr><td align="char" char="." valign="bottom">8</td><td align="char" char="." valign="bottom">3</td><td align="char" char="plusmn" valign="bottom">0.7713 ± 0.0112</td><td align="char" char="." valign="bottom">0.7943</td><td align="char" char="plusmn" valign="bottom">0.767 ± 0.0125</td></tr><tr><td align="char" char="." valign="bottom">10</td><td align="char" char="." valign="bottom">4</td><td align="char" char="plusmn" valign="bottom">0.7712 ± 0.0116</td><td align="char" char="." valign="bottom">0.7922</td><td align="char" char="plusmn" valign="bottom">0.7675 ± .01545</td></tr></tbody></table><table-wrap-foot><fn><p>AUC = area under the receiver operating curve; MCAR = missing completely at random; MNAR = missing not at random.</p></fn></table-wrap-foot></table-wrap><p>Our quantum hardware results are competitive with standard methods and in many cases close to the values expected from the simulation. In some cases, we observed a clear deterioration of the AUC due to the noise and errors in the quantum hardware. The results are closer to the simulations when using MCAR missingness with larger batch sizes that use more trees both for synthetic and the MIMIC datasets. As explained above, even though the algorithm with batch size 10 means using a quantum circuit with 10 qubits, the fact that we use four trees overall with a decreasing number of data points each time, and thus a decreasing number of qubits (namely, 10, 8, 6, and 4), results in an overall more reliable imputation.</p></sec></sec><sec id="s3" sec-type="discussion"><title>Discussion</title><p>Missing data is a critical issue for machine learning practitioners as complete datasets are usually required for training machine learning algorithms. To achieve complete datasets, missing values are usually imputed. In the case of clinical data, missing values and imputation can be a potential source of bias and can considerably influence the robustness and interpretability of results. Nevertheless, there is no canonical way to deal with missing data, which makes improvements in data imputation methods an attractive and impactful approach to increase the effectiveness and reliability of clinical trials. In this proof-of-concept study, we assessed the downstream consequences of implementing such improvements focussing on MCAR and MNAR to assess the usefulness of our approach. MNAR and MCAR represent two extreme cases of missingness with importance for clinical data imputation applications.</p><p>Determinantal point processing methods increase the diversity of the data picked to train the models, showcasing also that data gathering and preprocessing are important to remove biases related to over-representation of particular data types. This is more important when dealing with unbalanced datasets, as is the case often with clinical data. Determinantal sampling is an important tool not only for Random Forest models, but also for linear regression, where data diversity results in more robust and fair models (<xref ref-type="bibr" rid="bib6">Dereziński et al., 2018</xref>). Moreover, such sampling methods based on DPP are computationally intensive and quantum computers are expected to be useful in this case: quantum computers offer an asymptotic speedup for performing this sampling, and it is expected that next-generation quantum computers will provide a speedup in practice.</p><p>We show that, as expected, the quantum version of detDPP-MissForest does not introduce any variance in the downstream classifier when simulated in the absence of hardware noise. While the AUC improvements achieved in our experiments may seem modest, it is the consistency of improvements we observed in our simulation results coupled with removal of variance that makes our approach attractive for clinical data applications where these characteristics are extremely desirable. When implemented on quantum hardware, we observed variance that is caused by the noise in the hardware itself. More precisely, the output of the quantum circuit is not a sample from the precise determinantal distribution but from a noisy version of it, and this noise depends on the particular quantum circuit implemented and the quality of the hardware. Thus when attempting to compute the highest probability element using samples from the quantum circuit on current hardware, the result is not deterministic. Importantly, unlike for standard MissForest, this variance is not inherent in the algorithm and is expected to reduce considerably with the advent of better quality quantum computers. The quantum circuits needed to efficiently perform determinantal sampling require a number of qubits equal to the batch size used for each decision tree within the Random Forest training and the depth of the quantum circuit is roughly proportional to the number of features. As an example, if we would like to perform the quantum version of the determinantal imputation methods we used for MIMIC-III, then we would need a quantum computer with 150 qubits (the batch size) that can be reliably used to perform a quantum circuit of depth around 400 (the depth is given by <inline-formula><mml:math id="inf2"><mml:mrow><mml:mn>4</mml:mn><mml:mo>⁢</mml:mo><mml:mi>d</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math id="inf3"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>150</mml:mn></mml:mrow></mml:math></inline-formula> is the batch size and <inline-formula><mml:math id="inf4"><mml:mrow><mml:mi>d</mml:mi><mml:mo>=</mml:mo><mml:mn>14</mml:mn></mml:mrow></mml:math></inline-formula> is the number of features; <xref ref-type="bibr" rid="bib13">Kerenidis and Prakash, 2022</xref>). While quantum hardware with a few hundred qubits that can perform computations of a few hundred steps are not available right now, it seems quite possible that they will be available in the not so far future. In the meantime, further optimization could also help reduce the quantum resources needed for such imputation methods.</p><p>While our DPP-based imputation methods can run classically on small datasets such as MIMIC-III, they are computationally intensive and are hard to parallelize due to the sequential nature of the algorithm. This results in less and less efficient imputation for larger datasets where DPP sampling is applied to bigger batches. For example, when a DPP-MICE imputation is run on a dataset of 200 features and batches of size 400, then the training is expected to take multiple hours on a single GPU. The quantum DPP algorithm therefore could provide a way to speed up the hardest part of the imputer using a next-generation quantum computer. For instance, if <inline-formula><mml:math id="inf5"><mml:mrow><mml:mi>d</mml:mi><mml:mo>=</mml:mo><mml:mn>200</mml:mn></mml:mrow></mml:math></inline-formula>, and batch size is 400, the number of qubits will be 400 and the depth of the quantum circuit would be ≈ 6400, whereas it would take <inline-formula><mml:math id="inf6"><mml:mrow><mml:mi/><mml:mo>∼</mml:mo><mml:mrow><mml:mn>8</mml:mn><mml:mo>*</mml:mo><mml:msup><mml:mn>10</mml:mn><mml:mn>6</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> classical steps for DPP sampling. These are of course simply illustrative calculations and will require more detailed analysis as these machines become available and will need to include parameters such as clock speeds and error correction overheads. Only then can it be experimentally proven that this theoretical asymptotic speedup can translate to a practical speedup for this particular algorithm.</p><p>In summary, here we propose novel data imputation methods that, first, improve the widely used iterative imputation methods – MiceRanger and MissForest – as measured by the AUC of a downstream classifier; second, remove the variance of the imputation methods, thus ensuring reproducibility and simpler integration into machine learning workflows; and third, become even more efficient when run on quantum computers. Based on our results, we anticipate an impact of our algorithms on the reliability of models in high-precision value settings, including in pharmaceutical drug trials where they can provide higher confidence in the predictions made by eradicating the stochastic variance due to multiple imputations. In addition, tasks that are currently overwhelmed by the challenges of missingness become more tractable through the approaches introduced here, which is a common problem with real-world-evidence investigations, where detDPP-MICE and detDPP-MissForest can yield improved performance in the face of missingness.</p></sec><sec id="s4" sec-type="methods"><title>Methods</title><sec id="s4-1"><title>Determinantal point processes (DPPs)</title><p>Given a set of items <inline-formula><mml:math id="inf7"><mml:mrow><mml:mi class="ltx_font_mathcaligraphic">𝒴</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="normal">…</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, a point process <inline-formula><mml:math id="inf8"><mml:mi class="ltx_font_mathcaligraphic">𝒫</mml:mi></mml:math></inline-formula> is a probability distribution over all subsets of the set <inline-formula><mml:math id="inf9"><mml:mi class="ltx_font_mathcaligraphic">𝒴</mml:mi></mml:math></inline-formula>. It is called a determinantal point process (DPP) if, for any subset <inline-formula><mml:math id="inf10"><mml:mi>Y</mml:mi></mml:math></inline-formula> drawn from <inline-formula><mml:math id="inf11"><mml:mi class="ltx_font_mathcaligraphic">𝒴</mml:mi></mml:math></inline-formula> according to <inline-formula><mml:math id="inf12"><mml:mi class="ltx_font_mathcaligraphic">𝒫</mml:mi></mml:math></inline-formula>, we have<disp-formula id="equ1"><label>(1)</label><mml:math id="m1"><mml:mrow><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>⊆</mml:mo><mml:mi>Y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>det</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>K</mml:mi><mml:mrow><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula></p><p>where <inline-formula><mml:math id="inf13"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>K</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> is a real symmetric <inline-formula><mml:math id="inf14"><mml:mrow><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula> matrix, and <inline-formula><mml:math id="inf15"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>K</mml:mi><mml:mrow><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> is its submatrix whose rows and columns are indexed by <inline-formula><mml:math id="inf16"><mml:mi>T</mml:mi></mml:math></inline-formula>. The matrix <inline-formula><mml:math id="inf17"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>K</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> is called the marginal kernel of <inline-formula><mml:math id="inf18"><mml:mi>Y</mml:mi></mml:math></inline-formula>.</p><p>For an <inline-formula><mml:math id="inf19"><mml:mrow><mml:mi>n</mml:mi><mml:mo>×</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula> data matrix <inline-formula><mml:math id="inf20"><mml:mi>A</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="inf21"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>L</mml:mi><mml:mo>=</mml:mo><mml:mi>A</mml:mi><mml:msup><mml:mi>A</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mstyle></mml:math></inline-formula>, we define the <inline-formula><mml:math id="inf22"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula>-ensemble <inline-formula><mml:math id="inf23"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">D</mml:mi><mml:mi mathvariant="normal">P</mml:mi><mml:mi mathvariant="normal">P</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi mathvariant="bold">L</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula> as the distribution where the probability of sampling <inline-formula><mml:math id="inf24"><mml:mi>T</mml:mi></mml:math></inline-formula> is<disp-formula id="equ2"><label>(2)</label><mml:math id="m2"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>T</mml:mi><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mtext>det</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mtext>det</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>I</mml:mi><mml:mo>+</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo>∝</mml:mo><mml:msup><mml:mtext>Vol</mml:mtext><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>:</mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi>T</mml:mi><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula></p><p>where <inline-formula><mml:math id="inf25"><mml:mrow><mml:mi>V</mml:mi><mml:mo>⁢</mml:mo><mml:mi>o</mml:mi><mml:mo>⁢</mml:mo><mml:mi>l</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>:</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi>T</mml:mi></mml:mrow><mml:mo stretchy="false">}</mml:mo></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is the volume of the parallelepiped spanned by the rows of <inline-formula><mml:math id="inf26"><mml:mi>A</mml:mi></mml:math></inline-formula> indexed by <inline-formula><mml:math id="inf27"><mml:mi>T</mml:mi></mml:math></inline-formula>.</p><p>According to this distribution, the probability of sampling points that are similar and thus form a smaller volume is reduced in favor of samples that are more diverse.</p><p>An <inline-formula><mml:math id="inf28"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula>-ensemble is a determinantal point process if <inline-formula><mml:math id="inf29"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>K</mml:mi><mml:mo>=</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>I</mml:mi><mml:mo>+</mml:mo><mml:mi>L</mml:mi><mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mstyle></mml:math></inline-formula>.</p><sec id="s4-1-1"><title>Stochastic <inline-formula><mml:math id="inf30"><mml:mi>k</mml:mi></mml:math></inline-formula>-DPPs</title><p>The distribution <inline-formula><mml:math id="inf31"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mtext>DPP</mml:mtext><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula> is defined as an <inline-formula><mml:math id="inf32"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula>-ensemble which is constrained to subsets of size <inline-formula><mml:math id="inf33"><mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>.</p><p>Different algorithms have been proposed in the literature to sample from <inline-formula><mml:math id="inf34"><mml:mrow><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mrow><mml:mtext>DPP</mml:mtext><mml:mo>⁢</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>, namely <xref ref-type="bibr" rid="bib14">Kulesza and Taskar, 2012</xref>, where sampling <inline-formula><mml:math id="inf35"><mml:mi>d</mml:mi></mml:math></inline-formula> rows from an <inline-formula><mml:math id="inf36"><mml:mrow><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula> matrix takes <inline-formula><mml:math id="inf37"><mml:mrow><mml:mi>O</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi>N</mml:mi><mml:mo>⁢</mml:mo><mml:msup><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> time. There have been improvements over this initial proposal as in <xref ref-type="bibr" rid="bib18">Mahoney et al., 2019</xref>, where there is a preprocessing cost of <inline-formula><mml:math id="inf38"><mml:mrow><mml:mi>O</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi>N</mml:mi><mml:mo>⁢</mml:mo><mml:msup><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and each DPP sample requires <inline-formula><mml:math id="inf39"><mml:mrow><mml:mi>O</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>d</mml:mi><mml:mn>3</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> arithmetic operations.</p></sec><sec id="s4-1-2"><title>Deterministic <inline-formula><mml:math id="inf40"><mml:mi>k</mml:mi></mml:math></inline-formula>-DPPs</title><p>Stochastic DPP sampling may be efficient in practice; however, deterministic algorithms are important for different use cases since they are more interpretable, are less prone to errors, and have no failure probability, which is especially relevant for clinical data (<xref ref-type="bibr" rid="bib8">El Shawi et al., 2019</xref>).</p><p>We use a deterministic version of DPP sampling as proposed in <xref ref-type="bibr" rid="bib24">Schreurs and Suykens, 2021</xref> (see Algorithm 1), which is a greedy maximum volume approach. For each deterministic <inline-formula><mml:math id="inf41"><mml:mrow><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mtext>DPP</mml:mtext></mml:mrow></mml:math></inline-formula> sample, elements with the highest probability are added iteratively. The complexity of the algorithm for selecting deterministically <inline-formula><mml:math id="inf42"><mml:mi>d</mml:mi></mml:math></inline-formula> rows from an <inline-formula><mml:math id="inf43"><mml:mrow><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula> matrix is <inline-formula><mml:math id="inf44"><mml:mrow><mml:mi>O</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mi>N</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>⁢</mml:mo><mml:mi>d</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> for the preprocessing step and <inline-formula><mml:math id="inf45"><mml:mrow><mml:mi>O</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi>N</mml:mi><mml:mo>⁢</mml:mo><mml:msup><mml:mi>d</mml:mi><mml:mn>3</mml:mn></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> for the sampling step.</p><table-wrap id="inlinetable1" position="anchor"><table frame="hsides" rules="groups"><thead><tr><th align="left" valign="bottom">Algorithm 1 Deterministic <italic>k</italic>-DPP algorithm</th></tr></thead><tbody><tr><td align="left" valign="bottom"><bold>Input</bold>:<inline-formula><mml:math id="inf46"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mi>N</mml:mi></mml:mstyle></mml:mrow></mml:mstyle></mml:math></inline-formula> Kernel matrix <inline-formula><mml:math id="inf47"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>K</mml:mi><mml:mo>≻</mml:mo><mml:mn>0</mml:mn></mml:mstyle></mml:mrow></mml:mstyle></mml:math></inline-formula>, sample size <inline-formula><mml:math id="inf48"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>k</mml:mi></mml:mstyle></mml:mrow></mml:mstyle></mml:math></inline-formula>.<break/><bold>Initialization:</bold><inline-formula><mml:math id="inf49"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mo stretchy="false">←</mml:mo><mml:mi mathvariant="normal">∅</mml:mi></mml:mstyle></mml:mrow></mml:mstyle></mml:math></inline-formula><break/><inline-formula><mml:math id="inf50"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>V</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>×</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mstyle></mml:math></inline-formula>: first <inline-formula><mml:math id="inf51"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>k</mml:mi></mml:mstyle></mml:mrow></mml:mstyle></mml:math></inline-formula> eigenvectors of <inline-formula><mml:math id="inf52"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>K</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula>.<break/><inline-formula><mml:math id="inf53"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:mi>V</mml:mi><mml:msup><mml:mi>V</mml:mi><mml:mo>⊺</mml:mo></mml:msup></mml:mrow></mml:mstyle></mml:math></inline-formula><break/><inline-formula><mml:math id="inf54"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo symmetric="true">‖</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="normal">V</mml:mi></mml:mrow><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mi>e</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo symmetric="true">‖</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>,</mml:mo><mml:mspace width="1em"/><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula><break/><inline-formula><mml:math id="inf55"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">←</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> and<inline-formula><mml:math id="inf56"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mstyle></mml:math></inline-formula><break/><bold>while</bold>: <inline-formula><mml:math id="inf57"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi></mml:mstyle></mml:mrow></mml:mstyle></mml:math></inline-formula> <bold>do</bold><break/>     <inline-formula><mml:math id="inf58"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mi>arg</mml:mi><mml:mo>⁡</mml:mo><mml:mo movablelimits="true" form="prefix">max</mml:mo><mml:mi>p</mml:mi></mml:mstyle></mml:mrow></mml:mstyle></mml:math></inline-formula><break/>      <inline-formula><mml:math id="inf59"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mo stretchy="false">←</mml:mo><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mo>∪</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle></mml:math></inline-formula><break/>     <inline-formula><mml:math id="inf60"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msubsup><mml:mi>P</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msubsup><mml:msubsup><mml:mi>P</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mo>†</mml:mo></mml:mrow></mml:msubsup><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mspace width="1em"/><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>n</mml:mi></mml:mstyle></mml:mrow></mml:mstyle></mml:math></inline-formula><break/>      <inline-formula><mml:math id="inf61"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>i</mml:mi><mml:mo stretchy="false">←</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mstyle></mml:mrow></mml:mstyle></mml:math></inline-formula><break/><bold>end while</bold><break/><bold>Output:</bold><inline-formula><mml:math id="inf62"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle></mml:math></inline-formula>.</td></tr></tbody></table></table-wrap></sec></sec><sec id="s4-2"><title>DPP-Random Forest and detDPP-Random Forest</title><p>The Random Forest is a widely used ensemble learning model for classification and regression problems. It trains a number of decision trees on different samples from the dataset, and the final prediction of the Random Forest is the average of the decision trees for regression tasks or the class predicted by the most decision trees for classification tasks.</p><p>The samples used to train each tree are drawn uniformly with replacement from the original dataset (bootstrapping). The DPP-Random Forest algorithm (see <xref ref-type="fig" rid="fig4">Figure 4</xref>) replaces the uniform sampling with DPP sampling without replacement.</p><fig id="fig4" position="float"><label>Figure 4.</label><caption><title>The sampling and training procedure for the DPP-Random Forest algorithm: the dataset is divided into batches of similar size, the DPP sampling algorithm is then applied to every batch in parallel, and the subsequent samples are then combined to form larger datasets used to train the decision trees.</title><p>Since the batches are fixed, DPP sampling can be easily parallelized, either classically or quantumly. DPP, determinantal point processes.</p></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-89947-fig4-v1.tif"/></fig><p>The running time of the standard Random Forest training on an <inline-formula><mml:math id="inf63"><mml:mrow><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula> matrix is <inline-formula><mml:math id="inf64"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mover><mml:mi>O</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>N</mml:mi><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula>, whereas the DPP-Random Forest algorithm takes <inline-formula><mml:math id="inf65"><mml:mrow><mml:mover accent="true"><mml:mi>O</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mrow><mml:mi>N</mml:mi><mml:mo>⁢</mml:mo><mml:msup><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo>+</mml:mo><mml:msup><mml:mi>d</mml:mi><mml:mn>3</mml:mn></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> steps to run. This shows that while for small <inline-formula><mml:math id="inf66"><mml:mi>d</mml:mi></mml:math></inline-formula> the classical DPP-enhanced algorithms can still be efficient, they quickly become inefficient for larger feature spaces.</p><p>Determinantal sampling for regression and classification tasks with full data has been proposed previously for linear regressors (Michał Dereziński and Hsu 2018) and for Random Forest training for a financial data classification use case where it outperformed the standard Random Forest model (<xref ref-type="bibr" rid="bib27">Thakkar et al., 2023</xref>).</p><p>We can also use the deterministic version of DPP sampling for the Random Forest algorithm. This requires removing the sample used at each step (which is the one with the highest probability according to the determinantal distribution) in order to create a smaller dataset from which to sample for the next decision tree (see <xref ref-type="fig" rid="fig5">Figure 5</xref>). We call this new model detDPP-Random Forest.</p><fig id="fig5" position="float"><label>Figure 5.</label><caption><title>Deterministic determinantal point processes (DPP) sampling procedure for training decision trees.</title><p>At each step, a decision tree is trained usingthe sample that corresponds to the highest determinantal probability, and which is then removed from the original batch before continuing to the next decision tree.</p></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-89947-fig5-v1.tif"/></fig><p>Let us note that the distributions of the in-bag DPP samples, which are biased toward diversity, and the out-of-bag (OOB) samples, which reflect the original dataset’s distribution, may be different. This could lead to an inaccurate calculation of the OOB error that can be in fact overestimated (<xref ref-type="bibr" rid="bib11">Janitza and Hornung, 2018</xref>). In the DPP-Random Forest case, the batches are stratified and according to the output variable that follows the same distribution as the original dataset. Thus, sampling from different batches could bridge the gap between the in-bag and the OOB distributions. We leave these considerations for future work.</p></sec><sec id="s4-3"><title>Quantum methods for DPPs</title><p>Quantum machine learning has been a rapidly developing field and many applications have been explored, including with biomedical data, both using quantum algorithms to speedup linear algebraic procedures and through quantum neural networks (<xref ref-type="bibr" rid="bib4">Cerezo et al., 2022</xref>; <xref ref-type="bibr" rid="bib2">Biamonte et al., 2017</xref>; <xref ref-type="bibr" rid="bib16">Landman et al., 2022</xref>; <xref ref-type="bibr" rid="bib5">Cherrat et al., 2022</xref>).</p><p>In <xref ref-type="bibr" rid="bib13">Kerenidis and Prakash, 2022</xref>, it was shown that there exist quantum algorithms for performing the determinantal sampling with better computational complexity than the best known classical methods. We describe below the quantum circuits that are needed for performing this quantum algorithm on quantum hardware with different connectivity characteristics and provide a resource analysis for the number of qubits, the number of gates, and the depth of the quantum circuit.</p><p>First, we introduce an important component of the quantum DPP circuit, which is the Clifford loader. Given an input state <inline-formula><mml:math id="inf67"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mi>n</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, it performs the following operation:<disp-formula id="equ3"><mml:math id="m3"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msup><mml:mi>Z</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mi>X</mml:mi><mml:msup><mml:mi>I</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>In other words, it encodes the vector <inline-formula><mml:math id="inf68"><mml:mi>x</mml:mi></mml:math></inline-formula> as a sum of the mutually anti-commuting operators generating the Clifford algebra.</p><p>For implementing this operation with an efficient quantum circuit, we use standard one- and two-qubit gates, such as the <italic>X, Z, CZ</italic> gates as well as a parameterized two-qubit gate called the reconfigurable beam splitter (RBS) gate, which does the following operation:<disp-formula id="equ4"><label>(3)</label><mml:math id="m4"><mml:mrow><mml:mi>R</mml:mi><mml:mi>B</mml:mi><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>θ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mtable columnalign="center center center center" rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mi>cos</mml:mi><mml:mo>⁡</mml:mo><mml:mi>θ</mml:mi></mml:mtd><mml:mtd><mml:mi>sin</mml:mi><mml:mo>⁡</mml:mo><mml:mi>θ</mml:mi></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mo>−</mml:mo><mml:mi>sin</mml:mi><mml:mo>⁡</mml:mo><mml:mi>θ</mml:mi></mml:mtd><mml:mtd><mml:mi>cos</mml:mi><mml:mo>⁡</mml:mo><mml:mi>θ</mml:mi></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>1</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>We provide in <xref ref-type="fig" rid="fig6">Figure 6</xref> three different versions of the Clifford loader that take advantage of the specific connectivity of the quantum hardware, for example, grid connectivity for superconducting qubits or all-to-all connectivity for trapped-ion qubits. These constructions are optimal (up to constant factor) on the number of two-qubit gates. We provide the exact resource analysis in <xref ref-type="table" rid="table7">Table 7</xref>.</p><fig id="fig6" position="float"><label>Figure 6.</label><caption><title>Types of data loaders.</title><p>Each line corresponds to a qubit. Each vertical line connecting two qubits corresponds to a reconfigurable beam splitter (RBS) gate. We also use <inline-formula><mml:math id="inf69"><mml:mrow><mml:mi>X</mml:mi><mml:mo>,</mml:mo><mml:mi>Z</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:mi>C</mml:mi><mml:mo>⁢</mml:mo><mml:mi>Z</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> gates. The depth of the first two loaders is linear, and the last one is logarithmic on the number of qubits.</p></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-89947-fig6-v1.tif"/></fig><table-wrap id="table7" position="float"><label>Table 7.</label><caption><title>Summary of the characteristics of the different quantum determinantal point processes (DPP) circuits.</title><p>NN = nearest neighbor connectivity.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left" valign="bottom">Clifford loader</th><th align="left" valign="bottom">Hardware connectivity</th><th align="left" valign="bottom">Depth</th><th align="left" valign="bottom"># of RBS gates</th></tr></thead><tbody><tr><td align="left" valign="bottom">Diagonal</td><td align="left" valign="bottom">NN</td><td align="char" char="." valign="bottom">2nd</td><td align="char" char="." valign="bottom">2nd</td></tr><tr><td align="left" valign="bottom">Semi-diagonal</td><td align="left" valign="bottom">NN</td><td align="left" valign="bottom">nd</td><td align="char" char="." valign="bottom">2nd</td></tr><tr><td align="left" valign="bottom">Parallel</td><td align="left" valign="bottom">All-to-all</td><td align="char" char="." valign="bottom">4<italic>d</italic> log(<italic>n</italic>)</td><td align="char" char="." valign="bottom">2nd</td></tr></tbody></table></table-wrap><p>We can now use the Clifford loaders described above to perform <inline-formula><mml:math id="inf70"><mml:mrow><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mrow><mml:mi>D</mml:mi><mml:mo>⁢</mml:mo><mml:mi>P</mml:mi><mml:mo>⁢</mml:mo><mml:mi>P</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> sampling, as described (<xref ref-type="bibr" rid="bib13">Kerenidis and Prakash, 2022</xref>).</p><p>Given an orthogonal matrix <inline-formula><mml:math id="inf71"><mml:mrow><mml:mi>A</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msup><mml:mo>,</mml:mo><mml:mi mathvariant="normal">…</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mi>d</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, we can apply the qDPP circuit shown in <xref ref-type="fig" rid="fig7">Figure 7</xref>, which is just a sequential application of <inline-formula><mml:math id="inf72"><mml:mi>d</mml:mi></mml:math></inline-formula> Clifford loaders, one for each column of the matrix, to the <inline-formula><mml:math id="inf73"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mrow><mml:msup><mml:mn>0</mml:mn><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mo fence="false" stretchy="false">⟩</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula> state, and that leads to the following result:<disp-formula id="equ5"><mml:math id="m5"><mml:mrow><mml:mrow><mml:mo fence="true" stretchy="false">|</mml:mo><mml:mi class="ltx_font_mathcaligraphic">𝒜</mml:mi><mml:mo stretchy="false">⟩</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mi class="ltx_font_mathcaligraphic">𝒞</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mi>d</mml:mi></mml:msup><mml:mo>)</mml:mo></mml:mrow><mml:mo>⁢</mml:mo><mml:mi mathvariant="normal">⋯</mml:mi><mml:mo>⁢</mml:mo><mml:mi class="ltx_font_mathcaligraphic">𝒞</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>)</mml:mo></mml:mrow><mml:mo>⁢</mml:mo><mml:mi class="ltx_font_mathcaligraphic">𝒞</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msup><mml:mo>)</mml:mo></mml:mrow><mml:mo>⁢</mml:mo><mml:mrow><mml:mo fence="true">|</mml:mo><mml:msup><mml:mn>0</mml:mn><mml:mi>n</mml:mi></mml:msup><mml:mo>⟩</mml:mo></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:munder><mml:mo largeop="true" movablelimits="false" symmetric="true">∑</mml:mo><mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mrow><mml:mi>det</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>A</mml:mi><mml:mi>S</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>⁢</mml:mo><mml:mrow><mml:mo fence="true">|</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mi>S</mml:mi></mml:msub><mml:mo>⟩</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula></p><fig id="fig7" position="float"><label>Figure 7.</label><caption><title>Quantum determinant sampling circuit for an orthogonal matrix <inline-formula><mml:math id="inf74"><mml:mrow><mml:mi>A</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msup><mml:mo>,</mml:mo><mml:mi mathvariant="normal">…</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mi>d</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>.</title><p>It uses the Clifford loader, which is a unitary quantum operator: <inline-formula><mml:math id="inf75"><mml:mrow><mml:mrow><mml:mrow><mml:mi class="ltx_font_mathcaligraphic">𝒞</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mrow><mml:msubsup><mml:mo largeop="true" symmetric="true">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>⁢</mml:mo><mml:msup><mml:mi>Z</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>⁢</mml:mo><mml:mi>X</mml:mi><mml:mo>⁢</mml:mo><mml:msup><mml:mi>I</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mrow><mml:mo rspace="12.5pt">,</mml:mo><mml:mtext>for</mml:mtext></mml:mrow></mml:mrow><mml:mo mathvariant="italic" separator="true"> </mml:mo><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mi>n</mml:mi></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>.</p></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-89947-fig7-v1.tif"/></fig><p>Directly measuring at the end of the circuit provides a sample from the correct determinantal distribution.</p><p>Both the classical and the quantum algorithms require a preprocessing step with a similar complexity (see <xref ref-type="table" rid="table8">Table 8</xref>), and the improvement using the quantum method achieves a quadratic to cubic speedup in the sampling step. This speedup holds for <inline-formula><mml:math id="inf76"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mi>O</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula>. This is the case for our current implementation of DPP sampling from smaller batches (see <xref ref-type="fig" rid="fig4">Figure 4</xref>). In addition, the quantum DPP algorithm is efficient in terms of the number of measurements required since one measurement is equivalent to generating one DPP sample.</p><table-wrap id="table8" position="float"><label>Table 8.</label><caption><title>Complexity comparison of d-DPP sampling algorithms, both classical (<xref ref-type="bibr" rid="bib18">Mahoney et al., 2019</xref>) and quantum (<xref ref-type="bibr" rid="bib13">Kerenidis and Prakash, 2022</xref>).</title><p>The problem considered is DPP sampling of <inline-formula><mml:math id="inf77"><mml:mi>d</mml:mi></mml:math></inline-formula> rows from an <inline-formula><mml:math id="inf78"><mml:mrow><mml:mi>n</mml:mi><mml:mo>×</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula> matrix, where <inline-formula><mml:math id="inf79"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mi>O</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula>. For the quantum case, we provide both the depth and the size of the circuits.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left" valign="bottom"/><th align="left" valign="bottom">Classical</th><th align="left" valign="bottom">Quantum</th></tr></thead><tbody><tr><td align="left" valign="bottom">Preprocessing</td><td align="left" valign="bottom"><inline-formula><mml:math id="inf80"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>d</mml:mi><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><inline-formula><mml:math id="inf81"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>d</mml:mi><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td></tr><tr><td align="left" valign="bottom">Sampling</td><td align="left" valign="bottom"><inline-formula><mml:math id="inf82"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mover><mml:mi>O</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>d</mml:mi><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom"><inline-formula><mml:math id="inf83"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mtable columnalign="left left" rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd><mml:mrow><mml:mover><mml:mi>O</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mspace width="thinmathspace"/><mml:mrow><mml:mi mathvariant="normal">d</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">p</mml:mi><mml:mi mathvariant="normal">t</mml:mi><mml:mi mathvariant="normal">h</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mover><mml:mi>O</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>d</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mspace width="thinmathspace"/><mml:mrow><mml:mi mathvariant="normal">g</mml:mi><mml:mi mathvariant="normal">a</mml:mi><mml:mi mathvariant="normal">t</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">s</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mstyle></mml:mrow></mml:mstyle></mml:math></inline-formula></td></tr></tbody></table><table-wrap-foot><fn><p>DPP = determinantal point processes.</p></fn></table-wrap-foot></table-wrap><sec id="s4-3-1"><title>Quantum versions of the imputation methods</title><p>It is easy to define now a quantum version of the DPP-MICE and DPP-MissForest algorithms, where we use the quantum circuit described above to sample from the corresponding DPP. We can also define a variant of the deterministic algorithms, though here we need to pay attention to the fact that the quantum circuit enables to sample from the determinantal distribution but does not efficiently give us a classical description of the entire distribution. Hence, one can instead sample many times from the quantum circuit and output the most frequent element. This provides a sample with less variance but it only becomes deterministic in the limit of infinite measurements. In the experiments we performed, we used 1000 shots and the samples from the quantum circuits were indeed most of the time the highest probability elements. Of course in the worst case, there exist distributions where, for example, the highest and second highest elements are exponentially close to each other, in which case the quantum algorithm would need an exponential number of samples to output the highest element with high probability. Note though that the quantum imputation algorithm will still have a good performance even with few samples (any high-probability element provides the needed diversity of the inputs), though it will not be deterministic.</p></sec></sec><sec id="s4-4"><title>Availability of data and code</title><p>The code for the different DPP imputation methods is publicly available at <ext-link ext-link-type="uri" xlink:href="https://github.com/AstraZeneca/dpp_imp/">github.com/AstraZeneca/dpp_imp</ext-link>, (copy archived at <xref ref-type="bibr" rid="bib1">AstraZeneca, 2023</xref>). The synthetic dataset can be generated using the <italic>make_classification</italic> method from scikit-learn. The MIMIC-III dataset (<xref ref-type="bibr" rid="bib12">Johnson et al., 2016</xref>) is also publicly available.</p></sec></sec></body><back><sec sec-type="additional-information" id="s5"><title>Additional information</title><fn-group content-type="competing-interest"><title>Competing interests</title><fn fn-type="COI-statement" id="conf1"><p>No competing interests declared</p></fn><fn fn-type="COI-statement" id="conf2"><p>are employees of AstraZeneca. The authors declares that no other competing interests exist</p></fn></fn-group><fn-group content-type="author-contribution"><title>Author contributions</title><fn fn-type="con" id="con1"><p>Conceptualization, Data curation, Software, Visualization, Methodology, Writing – original draft, Writing – review and editing</p></fn><fn fn-type="con" id="con2"><p>Conceptualization, Supervision, Methodology, Writing – original draft, Project administration, Writing – review and editing</p></fn><fn fn-type="con" id="con3"><p>Supervision, Validation, Writing – original draft, Project administration, Writing – review and editing</p></fn><fn fn-type="con" id="con4"><p>Validation, Visualization, Methodology, Writing – original draft, Project administration, Writing – review and editing</p></fn></fn-group></sec><sec sec-type="supplementary-material" id="s6"><title>Additional files</title><supplementary-material id="mdar"><label>MDAR checklist</label><media xlink:href="elife-89947-mdarchecklist1-v1.docx" mimetype="application" mime-subtype="docx"/></supplementary-material></sec><sec sec-type="data-availability" id="s7"><title>Data availability</title><p>The synthetic dataset can be generated using the make classification method from scikit-learn. The MIMIC-III dataset is publicly available at <ext-link ext-link-type="uri" xlink:href="https://mimic.mit.edu/">https://mimic.mit.edu/</ext-link>.</p></sec><ack id="ack"><title>Acknowledgements</title><p>This work is a collaboration between QC Ware and AstraZeneca. We acknowledge the use of IBM Quantum services for this work. The views expressed are those of the authors and do not reflect the official policy or position of IBM or the IBM Quantum team.</p></ack><ref-list><title>References</title><ref id="bib1"><element-citation publication-type="software"><person-group person-group-type="author"><collab>AstraZeneca</collab></person-group><year iso-8601-date="2023">2023</year><data-title>Dpp_Imp</data-title><version designator="swh:1:rev:baa623a46174c477c9556112340e9fe5db66955b">swh:1:rev:baa623a46174c477c9556112340e9fe5db66955b</version><source>Software Heriatge</source><ext-link ext-link-type="uri" xlink:href="https://archive.softwareheritage.org/swh:1:dir:5031d4e6c0a99b3b9a81d08c78156f845843a0f8;origin=https://github.com/AstraZeneca/dpp_imp;visit=swh:1:snp:a9428e4d43c15096b5339492546ec926513006c4;anchor=swh:1:rev:baa623a46174c477c9556112340e9fe5db66955b">https://archive.softwareheritage.org/swh:1:dir:5031d4e6c0a99b3b9a81d08c78156f845843a0f8;origin=https://github.com/AstraZeneca/dpp_imp;visit=swh:1:snp:a9428e4d43c15096b5339492546ec926513006c4;anchor=swh:1:rev:baa623a46174c477c9556112340e9fe5db66955b</ext-link></element-citation></ref><ref id="bib2"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Biamonte</surname><given-names>J</given-names></name><name><surname>Wittek</surname><given-names>P</given-names></name><name><surname>Pancotti</surname><given-names>N</given-names></name><name><surname>Rebentrost</surname><given-names>P</given-names></name><name><surname>Wiebe</surname><given-names>N</given-names></name><name><surname>Lloyd</surname><given-names>S</given-names></name></person-group><year iso-8601-date="2017">2017</year><article-title>Quantum machine learning</article-title><source>Nature</source><volume>549</volume><fpage>195</fpage><lpage>202</lpage><pub-id pub-id-type="doi">10.1038/nature23474</pub-id><pub-id pub-id-type="pmid">28905917</pub-id></element-citation></ref><ref id="bib3"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Booth</surname><given-names>AL</given-names></name><name><surname>Abels</surname><given-names>E</given-names></name><name><surname>McCaffrey</surname><given-names>P</given-names></name></person-group><year iso-8601-date="2021">2021</year><article-title>Development of a prognostic model for mortality in COVID-19 infection using machine learning</article-title><source>Modern Pathology</source><volume>34</volume><fpage>522</fpage><lpage>531</lpage><pub-id pub-id-type="doi">10.1038/s41379-020-00700-x</pub-id><pub-id pub-id-type="pmid">33067522</pub-id></element-citation></ref><ref id="bib4"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Cerezo</surname><given-names>M</given-names></name><name><surname>Verdon</surname><given-names>G</given-names></name><name><surname>Huang</surname><given-names>H-Y</given-names></name><name><surname>Cincio</surname><given-names>L</given-names></name><name><surname>Coles</surname><given-names>PJ</given-names></name></person-group><year iso-8601-date="2022">2022</year><article-title>Challenges and opportunities in quantum machine learning</article-title><source>Nature Computational Science</source><volume>2</volume><fpage>567</fpage><lpage>576</lpage><pub-id pub-id-type="doi">10.1038/s43588-022-00311-3</pub-id><pub-id pub-id-type="pmid">38177473</pub-id></element-citation></ref><ref id="bib5"><element-citation publication-type="preprint"><person-group person-group-type="author"><name><surname>Cherrat</surname><given-names>EA</given-names></name><name><surname>Kerenidis</surname><given-names>I</given-names></name><name><surname>Mathur</surname><given-names>N</given-names></name><name><surname>Landman</surname><given-names>J</given-names></name><name><surname>Strahm</surname><given-names>M</given-names></name><name><surname>Li</surname><given-names>YY</given-names></name></person-group><year iso-8601-date="2022">2022</year><article-title>Quantum Vision Transformers</article-title><source>arXiv</source><ext-link ext-link-type="uri" xlink:href="https://arxiv.org/abs/2209.08167">https://arxiv.org/abs/2209.08167</ext-link></element-citation></ref><ref id="bib6"><element-citation publication-type="preprint"><person-group person-group-type="author"><name><surname>Dereziński</surname><given-names>M</given-names></name><name><surname>Warmuth</surname><given-names>MK</given-names></name><name><surname>Hsu</surname><given-names>D</given-names></name></person-group><year iso-8601-date="2018">2018</year><article-title>Leveraged Volume Sampling for Linear Regression</article-title><source>arXiv</source><ext-link ext-link-type="uri" xlink:href="https://arxiv.org/abs/1802.06749">https://arxiv.org/abs/1802.06749</ext-link></element-citation></ref><ref id="bib7"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Dereziński</surname><given-names>M</given-names></name><name><surname>Mahoney</surname><given-names>MW</given-names></name></person-group><year iso-8601-date="2021">2021</year><article-title>Determinantal point processes in randomized numerical linear algebra</article-title><source>Notices of the American Mathematical Society</source><volume>68</volume><fpage>34</fpage><lpage>45</lpage><pub-id pub-id-type="doi">10.1090/noti2202</pub-id></element-citation></ref><ref id="bib8"><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>El Shawi</surname><given-names>R</given-names></name><name><surname>Sherif</surname><given-names>Y</given-names></name><name><surname>Al-Mallah</surname><given-names>M</given-names></name><name><surname>Sakr</surname><given-names>S</given-names></name></person-group><year iso-8601-date="2019">2019</year><article-title>Interpretability in HealthCare A Comparative Study of Local Machine Learning Interpretability Techniques</article-title><conf-name>2019 IEEE 32nd International Symposium on Computer-Based Medical Systems (CBMS)</conf-name><pub-id pub-id-type="doi">10.1109/CBMS.2019.00065</pub-id></element-citation></ref><ref id="bib9"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Emmanuel</surname><given-names>T</given-names></name><name><surname>Maupong</surname><given-names>T</given-names></name><name><surname>Mpoeleng</surname><given-names>D</given-names></name><name><surname>Semong</surname><given-names>T</given-names></name><name><surname>Mphago</surname><given-names>B</given-names></name><name><surname>Tabona</surname><given-names>O</given-names></name></person-group><year iso-8601-date="2021">2021</year><article-title>A survey on missing data in machine learning</article-title><source>Journal of Big Data</source><volume>8</volume><elocation-id>140</elocation-id><pub-id pub-id-type="doi">10.1186/s40537-021-00516-9</pub-id><pub-id pub-id-type="pmid">34722113</pub-id></element-citation></ref><ref id="bib10"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Groothuis-Oudshoorn</surname><given-names>K</given-names></name></person-group><year iso-8601-date="2011">2011</year><article-title>Mice: multivariate imputation by chained equations in r</article-title><source>Journal of Statistical Software</source><volume>45</volume><fpage>1</fpage><lpage>67</lpage><pub-id pub-id-type="doi">10.18637/jss.v045.i03</pub-id></element-citation></ref><ref id="bib11"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Janitza</surname><given-names>S</given-names></name><name><surname>Hornung</surname><given-names>R</given-names></name></person-group><year iso-8601-date="2018">2018</year><article-title>On the overestimation of random forest’s out-of-bag error</article-title><source>PLOS ONE</source><volume>13</volume><elocation-id>e0201904</elocation-id><pub-id pub-id-type="doi">10.1371/journal.pone.0201904</pub-id><pub-id pub-id-type="pmid">30080866</pub-id></element-citation></ref><ref id="bib12"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Johnson</surname><given-names>AEW</given-names></name><name><surname>Pollard</surname><given-names>TJ</given-names></name><name><surname>Shen</surname><given-names>L</given-names></name><name><surname>Lehman</surname><given-names>LWH</given-names></name><name><surname>Feng</surname><given-names>M</given-names></name><name><surname>Ghassemi</surname><given-names>M</given-names></name><name><surname>Moody</surname><given-names>B</given-names></name><name><surname>Szolovits</surname><given-names>P</given-names></name><name><surname>Celi</surname><given-names>LA</given-names></name><name><surname>Mark</surname><given-names>RG</given-names></name></person-group><year iso-8601-date="2016">2016</year><article-title>MIMIC-III, a freely accessible critical care database</article-title><source>Scientific Data</source><volume>3</volume><elocation-id>160035</elocation-id><pub-id pub-id-type="doi">10.1038/sdata.2016.35</pub-id><pub-id pub-id-type="pmid">27219127</pub-id></element-citation></ref><ref id="bib13"><element-citation publication-type="preprint"><person-group person-group-type="author"><name><surname>Kerenidis</surname><given-names>I</given-names></name><name><surname>Prakash</surname><given-names>A</given-names></name></person-group><year iso-8601-date="2022">2022</year><article-title>Quantum Machine Learning with Subspace States</article-title><source>arXiv</source><ext-link ext-link-type="uri" xlink:href="https://arxiv.org/abs/2202.00054">https://arxiv.org/abs/2202.00054</ext-link></element-citation></ref><ref id="bib14"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kulesza</surname><given-names>A</given-names></name><name><surname>Taskar</surname><given-names>B</given-names></name></person-group><year iso-8601-date="2012">2012</year><article-title>Determinantal point processes for machine learning</article-title><source>Foundations and Trends in Machine Learning</source><volume>5</volume><fpage>123</fpage><lpage>286</lpage><pub-id pub-id-type="doi">10.1561/2200000044</pub-id></element-citation></ref><ref id="bib15"><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Kulezsa</surname><given-names>A</given-names></name><name><surname>Taskar</surname><given-names>B</given-names></name></person-group><year iso-8601-date="2011">2011</year><article-title>K-dpps: fixed-size determinantal point processes</article-title><conf-name>ICML’11: Proceedings of the 28th International Conference on International Conference on Machine Learning. Cited by: Improved clinical data imputation via classical and quantum determinantal point processes</conf-name></element-citation></ref><ref id="bib16"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Landman</surname><given-names>J</given-names></name><name><surname>Mathur</surname><given-names>N</given-names></name><name><surname>Li</surname><given-names>YY</given-names></name><name><surname>Strahm</surname><given-names>M</given-names></name><name><surname>Kazdaghli</surname><given-names>S</given-names></name><name><surname>Prakash</surname><given-names>A</given-names></name><name><surname>Kerenidis</surname><given-names>I</given-names></name></person-group><year iso-8601-date="2022">2022</year><article-title>Quantum methods for neural networks and application to medical image classification</article-title><source>Quantum</source><volume>6</volume><elocation-id>881</elocation-id><pub-id pub-id-type="doi">10.22331/q-2022-12-22-881</pub-id></element-citation></ref><ref id="bib17"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Luo</surname><given-names>Y</given-names></name></person-group><year iso-8601-date="2022">2022</year><article-title>Evaluating the state of the art in missing data imputation for clinical data</article-title><source>Briefings in Bioinformatics</source><volume>23</volume><elocation-id>bbab489</elocation-id><pub-id pub-id-type="doi">10.1093/bib/bbab489</pub-id><pub-id pub-id-type="pmid">34882223</pub-id></element-citation></ref><ref id="bib18"><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Mahoney</surname><given-names>MW</given-names></name><name><surname>Dereziński</surname><given-names>M</given-names></name><name><surname>Clarkson</surname><given-names>KL</given-names></name><name><surname>Warmuth</surname><given-names>MK</given-names></name></person-group><year iso-8601-date="2019">2019</year><article-title>Minimax experimental design: bridging the gap between statistical and worst-case approaches to least squares regression</article-title><conf-name>Conference on Learning Theory</conf-name></element-citation></ref><ref id="bib19"><element-citation publication-type="preprint"><person-group person-group-type="author"><name><surname>Mattei</surname><given-names>P</given-names></name><name><surname>Frellsen</surname><given-names>J</given-names></name></person-group><year iso-8601-date="2019">2019</year><article-title>MIWAE: Deep Generative Modelling and Imputation of Incomplete Data Sets</article-title><source>arXiv</source><ext-link ext-link-type="uri" xlink:href="https://arxiv.org/abs/1812.02633">https://arxiv.org/abs/1812.02633</ext-link></element-citation></ref><ref id="bib20"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Myers</surname><given-names>WR</given-names></name></person-group><year iso-8601-date="2000">2000</year><article-title>Handling missing data in clinical trials: An overview</article-title><source>Drug Information Journal</source><volume>34</volume><fpage>525</fpage><lpage>533</lpage><pub-id pub-id-type="doi">10.1177/009286150003400221</pub-id></element-citation></ref><ref id="bib21"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Pedersen</surname><given-names>AB</given-names></name><name><surname>Mikkelsen</surname><given-names>EM</given-names></name><name><surname>Cronin-Fenton</surname><given-names>D</given-names></name><name><surname>Kristensen</surname><given-names>NR</given-names></name><name><surname>Pham</surname><given-names>TM</given-names></name><name><surname>Pedersen</surname><given-names>L</given-names></name><name><surname>Petersen</surname><given-names>I</given-names></name></person-group><year iso-8601-date="2017">2017</year><article-title>Missing data and multiple imputation in clinical epidemiological research</article-title><source>Clinical Epidemiology</source><volume>9</volume><fpage>157</fpage><lpage>166</lpage><pub-id pub-id-type="doi">10.2147/CLEP.S129785</pub-id><pub-id pub-id-type="pmid">28352203</pub-id></element-citation></ref><ref id="bib22"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Qin</surname><given-names>J</given-names></name><name><surname>Chen</surname><given-names>L</given-names></name><name><surname>Liu</surname><given-names>Y</given-names></name><name><surname>Liu</surname><given-names>C</given-names></name><name><surname>Feng</surname><given-names>C</given-names></name><name><surname>Chen</surname><given-names>B</given-names></name></person-group><year iso-8601-date="2019">2019</year><article-title>A machine learning methodology for diagnosing chronic kidney disease</article-title><source>IEEE Access</source><volume>8</volume><fpage>20991</fpage><lpage>21002</lpage><pub-id pub-id-type="doi">10.1109/ACCESS.2019.2963053</pub-id></element-citation></ref><ref id="bib23"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rendleman</surname><given-names>MC</given-names></name><name><surname>Buatti</surname><given-names>JM</given-names></name><name><surname>Braun</surname><given-names>TA</given-names></name><name><surname>Smith</surname><given-names>BJ</given-names></name><name><surname>Nwakama</surname><given-names>C</given-names></name><name><surname>Beichel</surname><given-names>RR</given-names></name><name><surname>Brown</surname><given-names>B</given-names></name><name><surname>Casavant</surname><given-names>TL</given-names></name></person-group><year iso-8601-date="2019">2019</year><article-title>Machine learning with the TCGA-HNSC dataset: improving usability by addressing inconsistency, sparsity, and high-dimensionality</article-title><source>BMC Bioinformatics</source><volume>20</volume><elocation-id>339</elocation-id><pub-id pub-id-type="doi">10.1186/s12859-019-2929-8</pub-id><pub-id pub-id-type="pmid">31208324</pub-id></element-citation></ref><ref id="bib24"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Schreurs</surname><given-names>MFJ</given-names></name><name><surname>Suykens</surname><given-names>JAK</given-names></name></person-group><year iso-8601-date="2021">2021</year><article-title>Towards deterministic diverse subset sampling</article-title><source>Artificial Intelligence and Machine Learning</source><fpage>137</fpage><lpage>151</lpage><pub-id pub-id-type="doi">10.1007/978-3-030-65154-1</pub-id></element-citation></ref><ref id="bib25"><element-citation publication-type="preprint"><person-group person-group-type="author"><name><surname>Shadbahr</surname><given-names>T</given-names></name><name><surname>Roberts</surname><given-names>M</given-names></name><name><surname>Stanczuk</surname><given-names>J</given-names></name><name><surname>Gilbey</surname><given-names>J</given-names></name><name><surname>Teare</surname><given-names>P</given-names></name><name><surname>Dittmer</surname><given-names>S</given-names></name><name><surname>Thorpe</surname><given-names>M</given-names></name></person-group><year iso-8601-date="2022">2022</year><article-title>Classification of Datasets with Imputed Missing Values: Does Imputation Quality Matter</article-title><source>arXiv</source><ext-link ext-link-type="uri" xlink:href="https://arxiv.org/abs/2206.08478">https://arxiv.org/abs/2206.08478</ext-link></element-citation></ref><ref id="bib26"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Stekhoven</surname><given-names>DJ</given-names></name><name><surname>Bühlmann</surname><given-names>P</given-names></name></person-group><year iso-8601-date="2012">2012</year><article-title>MissForest--non-parametric missing value imputation for mixed-type data</article-title><source>Bioinformatics</source><volume>28</volume><fpage>112</fpage><lpage>118</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btr597</pub-id><pub-id pub-id-type="pmid">22039212</pub-id></element-citation></ref><ref id="bib27"><element-citation publication-type="preprint"><person-group person-group-type="author"><name><surname>Thakkar</surname><given-names>S</given-names></name><name><surname>Mathur</surname><given-names>N</given-names></name><name><surname>Kazdaghli</surname><given-names>S</given-names></name><name><surname>Kerenidis</surname><given-names>I</given-names></name><name><surname>Martins</surname><given-names>AJF</given-names></name><name><surname>Brito</surname><given-names>SGA</given-names></name></person-group><year iso-8601-date="2023">2023</year><article-title>Improved Financial Forecasting via Quantum Machine Learning</article-title><source>arXiv</source><ext-link ext-link-type="uri" xlink:href="https://arxiv.org/abs/2306.12965">https://arxiv.org/abs/2306.12965</ext-link></element-citation></ref><ref id="bib28"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Wang</surname><given-names>Z</given-names></name><name><surname>Li</surname><given-names>L</given-names></name><name><surname>Glicksberg</surname><given-names>BS</given-names></name><name><surname>Israel</surname><given-names>A</given-names></name><name><surname>Dudley</surname><given-names>JT</given-names></name><name><surname>Ma’ayan</surname><given-names>A</given-names></name></person-group><year iso-8601-date="2017">2017</year><article-title>Predicting age by mining electronic medical records with deep learning characterizes differences between chronological and physiological age</article-title><source>Journal of Biomedical Informatics</source><volume>76</volume><fpage>59</fpage><lpage>68</lpage><pub-id pub-id-type="doi">10.1016/j.jbi.2017.11.003</pub-id><pub-id pub-id-type="pmid">29113935</pub-id></element-citation></ref><ref id="bib29"><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Yoon</surname><given-names>J</given-names></name><name><surname>Jordon</surname><given-names>J</given-names></name></person-group><year iso-8601-date="2018">2018</year><article-title>GAIN: missing data imputation using generative adversarial nets</article-title><conf-name>Proceedings of the 35th International Conference on Machine Learning. Cited by: Improved clinical data imputation via classical and quantum determinantal point processes</conf-name></element-citation></ref></ref-list></back><sub-article article-type="editor-report" id="sa0"><front-stub><article-id pub-id-type="doi">10.7554/eLife.89947.3.sa0</article-id><title-group><article-title>eLife assessment</article-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>Graña</surname><given-names>Martin</given-names></name><role specific-use="editor">Reviewing Editor</role><aff><institution>Institut Pasteur de Montevideo</institution><country>Uruguay</country></aff></contrib></contrib-group><kwd-group kwd-group-type="evidence-strength"><kwd>Incomplete</kwd><kwd>Solid</kwd></kwd-group><kwd-group kwd-group-type="claim-importance"><kwd>Valuable</kwd></kwd-group></front-stub><body><p>The methods presented in this work provide modest yet consistent accuracy improvements for data classification tasks where certain data are missing. The authors also present a way to use quantum computers for this task. The methodology and results for the classical (non-quantum) case are <bold>solid</bold>, although evidence for the practical quantum advantage via their approach in 'next generation' quantum computers remains <bold>incomplete</bold>. The results are <bold>valuable</bold> and should interest data scientists, life scientists and anyone working in quantum computing.</p></body></sub-article><sub-article article-type="referee-report" id="sa1"><front-stub><article-id pub-id-type="doi">10.7554/eLife.89947.3.sa1</article-id><title-group><article-title>Reviewer #1 (Public Review):</article-title></title-group><contrib-group><contrib contrib-type="author"><anonymous/><role specific-use="referee">Reviewer</role></contrib></contrib-group></front-stub><body><p>Summary:</p><p>The article written by Kazdaghli et al. proposes a modification of imputation methods, to better account and exploit the variability of the data. The aim is to reduce the variability of the imputation results.</p><p>The authors propose two methods, one that still includes some imputation variability, but accounts for the distribution of the data points to improve the imputation. The other one proposes a determinantal sampling, that presents no variation in the imputation data, but it seems to be, that they measure the variation in the classification task, instead. As these methods grow easily in computation requirements and time, they also propose an algorithm to run these methods in quantum processors.</p><p>Strengths:</p><p>The sampling method for imputing missing values that account for the variability of the data seems to be accurate.</p><p>Weaknesses:</p><p>The authors state &quot;Ultimately, the quality and reliability of imputations can be measured by the performance of a downstream predictor, which is usually the AUC (area under the receiver operating curve) for a classification task.&quot; but there is no citation of other scientists doing this. I think the authors could have evaluated the imputations directly, as they mention in the introduction, I understand that the final goal in the task is to have a better classification. In a real situation, they would have data that would be used for training the algorithm, and then new data that needs to be imputed and classified. Is there any difference between imputing all the data together and training the algorithm, versus doing the imputation, training a classifier, then imputing new data (for the testing set), and then testing the classification?</p><p>I wonder if there could be some spurious interaction between the imputation and the classification methods, that could bias the data in the sense of having a better classification, but not imputing the real values; in particular when the deterministic DPP is used.</p></body></sub-article></article>