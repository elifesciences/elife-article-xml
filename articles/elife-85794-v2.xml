<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD with MathML3 v1.3 20210610//EN"  "JATS-archivearticle1-3-mathml3.dtd"><article xmlns:ali="http://www.niso.org/schemas/ali/1.0/" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article" dtd-version="1.3"><front><journal-meta><journal-id journal-id-type="nlm-ta">elife</journal-id><journal-id journal-id-type="publisher-id">eLife</journal-id><journal-title-group><journal-title>eLife</journal-title></journal-title-group><issn publication-format="electronic" pub-type="epub">2050-084X</issn><publisher><publisher-name>eLife Sciences Publications, Ltd</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="publisher-id">85794</article-id><article-id pub-id-type="doi">10.7554/eLife.85794</article-id><article-version article-version-type="publication-state">version of record</article-version><article-categories><subj-group subj-group-type="display-channel"><subject>Tools and Resources</subject></subj-group><subj-group subj-group-type="heading"><subject>Computational and Systems Biology</subject></subj-group><subj-group subj-group-type="heading"><subject>Ecology</subject></subj-group></article-categories><title-group><article-title>A rapid phylogeny-based method for accurate community profiling of large-scale metabarcoding datasets</article-title></title-group><contrib-group><contrib contrib-type="author" corresp="yes"><name><surname>Pipes</surname><given-names>Lenore</given-names></name><contrib-id authenticated="true" contrib-id-type="orcid">https://orcid.org/0000-0003-0056-8045</contrib-id><email>lpipes@berkeley.edu</email><xref ref-type="aff" rid="aff1">1</xref><xref ref-type="other" rid="fund1"/><xref ref-type="other" rid="fund2"/><xref ref-type="other" rid="fund3"/><xref ref-type="fn" rid="con1"/><xref ref-type="fn" rid="conf1"/></contrib><contrib contrib-type="author"><name><surname>Nielsen</surname><given-names>Rasmus</given-names></name><xref ref-type="aff" rid="aff1">1</xref><xref ref-type="aff" rid="aff2">2</xref><xref ref-type="other" rid="fund1"/><xref ref-type="other" rid="fund2"/><xref ref-type="other" rid="fund3"/><xref ref-type="fn" rid="con2"/><xref ref-type="fn" rid="conf1"/></contrib><aff id="aff1"><label>1</label><institution-wrap><institution-id institution-id-type="ror">https://ror.org/01an7q238</institution-id><institution>Department of Integrative Biology, University of California, Berkeley</institution></institution-wrap><addr-line><named-content content-type="city">Berkeley</named-content></addr-line><country>United States</country></aff><aff id="aff2"><label>2</label><institution-wrap><institution-id institution-id-type="ror">https://ror.org/035b05819</institution-id><institution>GLOBE Institute, University of Copenhagen</institution></institution-wrap><addr-line><named-content content-type="city">Copenhagen</named-content></addr-line><country>Denmark</country></aff></contrib-group><contrib-group content-type="section"><contrib contrib-type="editor"><name><surname>Moshiri</surname><given-names>Niema</given-names></name><role>Reviewing Editor</role><aff><institution-wrap><institution-id institution-id-type="ror">https://ror.org/0168r3w48</institution-id><institution>University of California, San Diego</institution></institution-wrap><country>United States</country></aff></contrib><contrib contrib-type="senior_editor"><name><surname>Garrett</surname><given-names>Wendy S</given-names></name><role>Senior Editor</role><aff><institution>Harvard T.H. Chan School of Public Health</institution><country>United States</country></aff></contrib></contrib-group><pub-date publication-format="electronic" date-type="publication"><day>15</day><month>08</month><year>2024</year></pub-date><volume>13</volume><elocation-id>e85794</elocation-id><history><date date-type="received" iso-8601-date="2022-12-23"><day>23</day><month>12</month><year>2022</year></date><date date-type="accepted" iso-8601-date="2024-08-14"><day>14</day><month>08</month><year>2024</year></date></history><pub-history><event><event-desc>This manuscript was published as a preprint at .</event-desc><date date-type="preprint" iso-8601-date="2022-12-07"><day>07</day><month>12</month><year>2022</year></date><self-uri content-type="preprint" xlink:href="https://doi.org/10.1101/2022.12.06.519402"/></event></pub-history><permissions><copyright-statement>© 2024, Pipes and Nielsen</copyright-statement><copyright-year>2024</copyright-year><copyright-holder>Pipes and Nielsen</copyright-holder><ali:free_to_read/><license xlink:href="http://creativecommons.org/licenses/by/4.0/"><ali:license_ref>http://creativecommons.org/licenses/by/4.0/</ali:license_ref><license-p>This article is distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution License</ext-link>, which permits unrestricted use and redistribution provided that the original author and source are credited.</license-p></license></permissions><self-uri content-type="pdf" xlink:href="elife-85794-v2.pdf"/><self-uri content-type="figures-pdf" xlink:href="elife-85794-figures-v2.pdf"/><abstract><p>Environmental DNA (eDNA) is becoming an increasingly important tool in diverse scientific fields from ecological biomonitoring to wastewater surveillance of viruses. The fundamental challenge in eDNA analyses has been the bioinformatical assignment of reads to taxonomic groups. It has long been known that full probabilistic methods for phylogenetic assignment are preferable, but unfortunately, such methods are computationally intensive and are typically inapplicable to modern next-generation sequencing data. We present a fast approximate likelihood method for phylogenetic assignment of DNA sequences. Applying the new method to several mock communities and simulated datasets, we show that it identifies more reads at both high and low taxonomic levels more accurately than other leading methods. The advantage of the method is particularly apparent in the presence of polymorphisms and/or sequencing errors and when the true species is not represented in the reference database.</p></abstract><kwd-group kwd-group-type="author-keywords"><kwd>eukaryotes</kwd><kwd>archaea</kwd><kwd>bacteria</kwd><kwd>fungi</kwd></kwd-group><kwd-group kwd-group-type="research-organism"><title>Research organism</title><kwd>Other</kwd></kwd-group><funding-group><award-group id="fund1"><funding-source><institution-wrap><institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/100000057</institution-id><institution>National Institute of General Medical Sciences</institution></institution-wrap></funding-source><award-id>1R01GM138634-01</award-id><principal-award-recipient><name><surname>Pipes</surname><given-names>Lenore</given-names></name><name><surname>Nielsen</surname><given-names>Rasmus</given-names></name></principal-award-recipient></award-group><award-group id="fund2"><funding-source><institution-wrap><institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/100000057</institution-id><institution>National Institute of General Medical Sciences</institution></institution-wrap></funding-source><award-id>1K99GM144747-01</award-id><principal-award-recipient><name><surname>Pipes</surname><given-names>Lenore</given-names></name><name><surname>Nielsen</surname><given-names>Rasmus</given-names></name></principal-award-recipient></award-group><award-group id="fund3"><funding-source><institution-wrap><institution>Pittsburgh Supercomputing Center</institution></institution-wrap></funding-source><award-id>BIO180028</award-id><principal-award-recipient><name><surname>Pipes</surname><given-names>Lenore</given-names></name><name><surname>Nielsen</surname><given-names>Rasmus</given-names></name></principal-award-recipient></award-group><funding-statement>The funders had no role in study design, data collection and interpretation, or the decision to submit the work for publication.</funding-statement></funding-group><custom-meta-group><custom-meta specific-use="meta-only"><meta-name>Author impact statement</meta-name><meta-value>Tronko provides a scalable solution for accurate taxonomic assignment for large-scale metabarcoding datasets by overcoming the speed and memory limitations of previous phylogenetic placement methods.</meta-value></custom-meta></custom-meta-group></article-meta></front><body><sec id="s1" sec-type="intro"><title>Introduction</title><p>In the past 10 years, metabarcoding and metagenomics based on DNA sequencing and subsequent taxonomic assignment have become an important approach for understanding diversity and community organization at many taxonomic levels. This has led to the publication of more than 80 taxonomic classification methods (<xref ref-type="bibr" rid="bib15">Gardner et al., 2019</xref>). There are three major strategies in classification methods: (1) composition-based, which do not align sequences but extract compositional features (e.g., kmers) to build models of probabilistic taxonomic inclusion; (2) alignment-based, which rely on alignments to directly compare query sequences to reference sequences but do not use trees; and (3) phylogenetic-based, which rely on a phylogenetic tree reconstruction method, in addition to alignments, to perform a placement of the query onto the tree. As a trade-off between speed and precision for processing next-generation sequencing (NGS) data, the vast majority of recent classification methods have either relied on alignment-based or composition-based strategies.</p><p>Composition-based tools reduce the reference database by indexing compositional features such as kmers for a rapid search of the database. These methods require an exact match between the kmer in the query sequence and the kmer in the reference database. As a result of hash indexing of kmers, kraken2 (<xref ref-type="bibr" rid="bib48">Wood et al., 2019</xref>), for example, can classify &gt;1 million reads within 1 min using the entire Geengenes or SILVA databases (<xref ref-type="bibr" rid="bib32">Lu and Salzberg, 2020</xref>). Alignment-based tools use a fast local aligner such as BLAST (<xref ref-type="bibr" rid="bib2">Altschul et al., 1990</xref>) to pairwise align queries to the reference database and define a score based on sequence similarity in the alignment between the read and reference sequence. However, alignment-based methods can be many orders of magnitude slower than composition-based tools since datasets with &gt;10 million reads require weeks of BLASTN running time (<xref ref-type="bibr" rid="bib1">Ainsworth et al., 2017</xref>). In both composition-based tools and alignment-based tools, a lowest common ancestor (LCA) algorithm is then typically used to assign at different taxonomic levels (<xref ref-type="fig" rid="fig1">Figure 1A</xref>). LCA works by assigning to the smallest possible clade that include all matches with a similarity less than the specified cut-off.</p><fig-group><fig id="fig1" position="float"><label>Figure 1.</label><caption><title>Species assignment in alignment-based methods (<bold>A</bold>) vs. Tronko (<bold>B</bold>).</title><p>In Tronko, scores are calculated for all nodes in the tree based on the query’s global alignment to the best BWA-MEM hit. The query is assigned to the lowest common ancestor (LCA) of the highest scoring nodes within the cut-off threshold. See <xref ref-type="fig" rid="fig1s1">Figure 1—figure supplement 1</xref> for more details regarding using multiple trees.</p></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-85794-fig1-v2.tif"/></fig><fig id="fig1s1" position="float" specific-use="child-fig"><label>Figure 1—figure supplement 1.</label><caption><title>Workflow of iterative partitioning procedure.</title><p>First, the multiple sequence alignments (MSAs) and corresponding phylogenetic trees are used as input into the algorithm. Then, the sum-of-pairs scores are calculated for each partition. If the sum-of-pairs score is below a heuristic threshold, the tree is used to partition the sequences into three partitions in the cluster based on the node with the smallest variance. Each of the three partitions is realigned and phylogenetic trees are estimated. The algorithm stops for a given partition when the sum-of-pairs score is greater than the heuristic threshold.</p></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-85794-fig1-figsupp1-v2.tif"/></fig><fig id="fig1s2" position="float" specific-use="child-fig"><label>Figure 1—figure supplement 2.</label><caption><title>Comparisons of Tronko with pplacer and APPLES-2 using a database of 200, 400, 600, 800, 1000, 1200, 1400, and 1600 reference sequences.</title><p>(<bold>A</bold>) Assignment rate against the number of reference sequences at the species level. (<bold>B</bold>) Running time against the number of reference sequences. (<bold>C</bold>) Peak memory in gigabytes against number of references. Both methods had a 100% true positive rate for all sizes of databases. Assignment rate is the number of reads assigned at the species level for each method. Reference sequences were chosen randomly from the cytochrome oxidase 1 (COI) reference database.</p></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-85794-fig1-figsupp2-v2.tif"/></fig></fig-group><p>Phylogenetic placement methods place a query sequence onto a phylogenetic tree of reference sequences. This placement requires a full multiple sequence alignment (MSA) of the reference sequences and a subsequent estimation of a phylogenetic tree. However, large datasets with high rates of evolution are hard to align accurately (<xref ref-type="bibr" rid="bib44">Sievers et al., 2011</xref>) and phylogeny estimation methods produce poor trees when MSAs are not of high quality (<xref ref-type="bibr" rid="bib22">Kapli et al., 2020</xref>). Furthermore, phylogenetic placement tends to be computationally demanding as both running time and memory usage scale linearly with the size of the reference database (<xref ref-type="bibr" rid="bib4">Balaban et al., 2020</xref>). Even for reference databases that contain sequences as few as 1600 sequences, assignment for a single query using the most cited phylogenetic placement method, <italic>pplacer</italic> (<xref ref-type="bibr" rid="bib35">Matsen et al., 2010</xref>), takes more than 7 min and requires over 10 GB of RAM (on a Dell PowerEdge server with 32 CPU threads and 512 GB of RAM). At this rate, a reference database that contains a metabarcode such as cytochrome oxidase 1 (COI) that has at least 1.5 million reference sequences, assigning just a single query would require 20.9 hr and 2.37 TB RAM. Scaling the query size to millions of queries would therefore be computationally intractable.</p><p>To address these challenges, the most recent implementations of phylogeny-based methods (<xref ref-type="bibr" rid="bib5">Barbera et al., 2019</xref>) rely on reference database reduction techniques (i.e., using only representative taxa or consensus sequences for a sparse backbone tree) to handle the large amount of data that is routinely produced. Often a single species is selected to represent an entire clade (<xref ref-type="bibr" rid="bib10">Czech et al., 2022</xref>). While this reduces the computational cost, it also reduces the granularity, and potentially the accuracy, of the assignments. As a trade-off between speed and precision, the vast majority of recent classification methods are either alignment-based or composition-based approaches (<xref ref-type="bibr" rid="bib19">Hleap et al., 2020</xref>) since phylogeny-based methods have not scaled to handle the entirety of the rapidly growing reference databases of genome markers and the increasingly large amounts of NGS data.</p><p>Here, we describe a new method for phylogenetic placement, implemented in the program ’Tronko’ (<ext-link ext-link-type="uri" xlink:href="https://github.com/lpipes/tronko">https://github.com/lpipes/tronko</ext-link>, <xref ref-type="bibr" rid="bib33">Mapper and Pipes, 2024</xref>), the first phylogeny-based taxonomic classification method designed to truly enable the use of modern-day reference databases and NGS data. The method is based on approximating the phylogenetic likelihood calculation by (1) only allowing the edge connecting the reference sequence to the tree to join at existing nodes in the tree and then (2) approximating the likelihood using a probabilistically weighted mismatch score based on pre-calculated fractional likelihoods stored in each node (see ‘Methods’). We argue that (2) approximates the full maximized likelihood assignment without requiring any numerical maximization under the approximating assumption that the read joins the tree in an existing node with a zero-length branch. The approximation is equivalent to calculating the expected average mismatch to each node in the phylogeny. The assignment method in Tronko uses the LCA criteria but, unlike composition-based and alignment-based approaches (<xref ref-type="fig" rid="fig1">Figure 1A</xref>), takes advantage of fractional likelihoods stored in all nodes of the tree with a cut-off that can be adjusted from conservative to aggressive (<xref ref-type="fig" rid="fig1">Figure 1B</xref>). In the simplest case, when the reference sequences form a single tree, Tronko uses a pre-calculated MSA, the phylogenetic tree based on the MSA, and pre-calculated posterior probabilities, which are proportional to the fractional likelihoods. However, in more typical cases, when a single tree/MSA is unsuitable for analyses, as the reference sequences encompass increasingly divergent species as well as an increasing volume of sequences, we present a fully customizable divide-and-conquer method for reference database construction that is based on dividing reference sequences into phylogenetic subsets that are realigned and with local trees re-estimated.</p><p>The construction of the database, MSAs, and trees facilitates fast phylogenetic assignment. The assignment algorithm then proceeds by (1) a BWA-MEM (<xref ref-type="bibr" rid="bib28">Li and Durbin, 2009</xref>) search on all sequences in the database, (2) a pairwise sequence alignment between the query and the top hit in each alignment subset containing a BWA-MEM hit using either the Needleman–Wunsch algorithm (<xref ref-type="bibr" rid="bib38">Needleman and Wunsch, 1970</xref>) or the wavefront alignment algorithm (<xref ref-type="bibr" rid="bib34">Marco-Sola et al., 2021</xref>), and (3) a calculation of a score based on the approximate likelihood for each node in subsets with a BWA-MEM hit. An additional LCA assignment for all subsets can then be applied to summarize the results. For full details, see ‘Methods’.</p></sec><sec id="s2" sec-type="results"><title>Results</title><p>To compare the new method (Tronko) to previous methods, we constructed reference databases for COI and 16S for common amplicon primer sets using CRUX (<xref ref-type="bibr" rid="bib8">Curd et al., 2019</xref>; sSee ‘Methods’ for the exact primers used). We first compared Tronko to pplacer and APPLES-2 for reference databases containing a reduced amount of sequences (&lt;1600 sequences) to compare the speed and memory requirements with comparable phylogenetic-based assignment methods. Tronko shows speed-ups &gt;20 times over pplacer, with a vastly reduced memory requirement illustrating the computational advantage of the approximations in Tronko (<xref ref-type="fig" rid="fig1s2">Figure 1—figure supplement 2</xref>). Tronko demonstrates a speed-up &gt;2 times over APPLES-2 with a similar memory footprint. In terms of accuracy, all methods had a 100% true-positive rate at the species level. Additionally, in terms of the species assignment rate (the percentage of queries that were assigned at the species level), Tronko assigns the most queries.</p><p>Next, in addition to pplacer and APPLES-2, we evaluated Tronko’s performance to kmer-based kraken2 (<xref ref-type="bibr" rid="bib48">Wood et al., 2019</xref>), which previously has been argued to have the lowest false-positive rate (<xref ref-type="bibr" rid="bib32">Lu and Salzberg, 2020</xref>), and two other popular alignment-based methods: MEGAN (<xref ref-type="bibr" rid="bib20">Huson et al., 2007</xref>) and metaphlan2 (<xref ref-type="bibr" rid="bib47">Truong et al., 2015</xref>). We used two types of cross-validation tests: leave-one-species-out and leave-one-individual-out analyses. The leave-one-species-out test involves removing an entire species from the reference database, simulating NGS reads from that species, and then attempting to assign those reads with that species missing from the database. The leave-one-individual-out test involves removing a single individual from the reference database, simulating NGS reads from that individual, and then attempting to assign those reads with that individual missing from the database. In both tests, singletons (i.e., cases in which only one species was present in a genera or cases in which only one individual represented a species) were exempt from the tests.</p><p>We performed a leave-one-species-out test comparing Tronko (with LCA cut-offs for the score of 0, 5, 10, 15, and 20 with both Needleman–Wunsch alignment and wavefront alignment) to kraken2, metaphlan2, and MEGAN for 1467 COI sequences from 253 species from the order Charadriiformes using 37,515 (150 bp × 2) paired-end sequences and 768,807 single-end sequences (150 bp and 300 bp in length) using 0, 1, and 2% error/polymorphism (<xref ref-type="fig" rid="fig2">Figure 2</xref>). We use the term ‘error/polymorphism’ to represent a simulated change in nucleotide that can be either an error in sequencing or a polymorphism. We display confusion matrices to display the clades in which each method has an incorrect assignment (<xref ref-type="fig" rid="fig3">Figure 3</xref>). See <xref ref-type="fig" rid="fig2s1">Figure 2—figure supplement 1</xref> for results with the wavefront alignment algorithm (<xref ref-type="bibr" rid="bib34">Marco-Sola et al., 2021</xref>).</p><fig-group><fig id="fig2" position="float"><label>Figure 2.</label><caption><title>Recall vs. misclassification rates using leave-one-species-out analysis of the order Charadriiformes (cytochrome oxidase 1 [COI] metabarcode) with paired-end 150 bp × 2 reads with 0% (<bold>A</bold>), 1% (<bold>B</bold>), and 2% (<bold>C</bold>) error/polymorphism, single-end 150 bp reads with 0% (<bold>D</bold>), 1% (<bold>E</bold>), and 2% (<bold>F</bold>) error/polymorphism, and single-end 300 bp reads with 0% (<bold>G</bold>), 1% (<bold>H</bold>), and 2% (<bold>I</bold>) error/polymorphism using kraken2, metaphlan2, MEGAN, pplacer, and APPLES-2, and Tronko with cut-offs of 0, 5, 10, 15, and 20 using the Needleman–Wunsch alignment (solid line).</title><p>See <xref ref-type="fig" rid="fig2s2">Figure 2—figure supplement 2</xref> for results using different combinations of aligners and tree estimation methods.</p></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-85794-fig2-v2.tif"/></fig><fig id="fig2s1" position="float" specific-use="child-fig"><label>Figure 2—figure supplement 1.</label><caption><title>Recall vs. misclassification rates using leave-one-species-out analysis for the order Charadriiformes (cytochrome oxidase 1 [COI] metabarcode) with paired-end 150 bp × 2 reads with 0% (<bold>A</bold>), 1% (<bold>B</bold>), and 2% (<bold>C</bold>) error/polymorphism, single-end 150 bp reads with 0% (<bold>D</bold>), 1% (<bold>E</bold>), and 2% (<bold>F</bold>) error/polymorphism, and single-end 300 bp reads with 0% (<bold>G</bold>), 1% (<bold>H</bold>), and 2% (<bold>I</bold>) error/polymorphism using kraken2, metaphlan2, MEGAN, pplacer, APPLES-2, and Tronko with cut-offs of 0, 5, 10, 15, and 20 using the Needleman–Wunsch alignment (solid line) and wavefront alignment (dashed line).</title></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-85794-fig2-figsupp1-v2.tif"/></fig><fig id="fig2s2" position="float" specific-use="child-fig"><label>Figure 2—figure supplement 2.</label><caption><title>Recall vs. misclassification rates using leave-one-species-out analysis for the order Charadriiformes (cytochrome oxidase 1 [COI] metabarcode) with paired-end 150 bp × 2 reads with 2% error/polymorphism using Tronko with cut-offs of 0, 5, 10, 15, and 20 and different combinations of tree estimation methods and aligners.</title><p>For tree estimation, we used RAxML and IQ-TREE2. For multiple sequence aligners, we used FAMSA and MAFFT. For global alignment methods, we used Needleman–Wunsch (NW) and wavefront alignment (WFA). This is the same dataset as used in <xref ref-type="fig" rid="fig2">Figure 2</xref>. Colors represent different combinations of methods.</p></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-85794-fig2-figsupp2-v2.tif"/></fig></fig-group><fig id="fig3" position="float"><label>Figure 3.</label><caption><title>Confusion matrices at the genus level of the order Charadriiformes (cytochrome oxidase 1 [COI] metabarcode) using the leave-one-species-out analysis with paired-end 150 bp × 2 reads with 2% error/polymorphism using kraken2 (<bold>A</bold>), metaphlan2 (<bold>B</bold>), pplacer (<bold>C</bold>), APPLES-2 (<bold>D</bold>), MEGAN (<bold>E</bold>), and Tronko using the Needleman–Wunsch alignment (NW) for cut-offs 0 (<bold>F</bold>), 5 (<bold>G</bold>), 10 (<bold>H</bold>), 15 (<bold>I</bold>), and (<bold>J</bold>) 20.</title><p>Unassigned column contains both unassigned queries and queries assigned to a lower taxonomic level. Phylogenetic tree represents ancestral sequences at the genus level.</p></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-85794-fig3-v2.tif"/></fig><p>Using leave-one-species-out and simulating reads (both paired-end and single-end) with a 0–2% error (or polymorphism), Tronko detected the correct genus more accurately than the other methods even when using an aggressive cut-off (i.e., when cut-off <inline-formula><mml:math id="inf1"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mo>=</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula> 0) (<xref ref-type="fig" rid="fig3">Figure 3F</xref>). Using 150 bp paired-end reads with 1% error, Tronko had a misclassification rate of only 9.8% with a recall rate of 70.1% at the genus level using a cut-off set to 15 while kraken2, MEGAN, and metaphlan2 had misclassification rates of 33.5, 10.0, and 27.7%, respectively, with recall rates of 90.6, 52.1, and 95.0% (see <xref ref-type="fig" rid="fig2">Figure 2B</xref>). Tronko had a lower misclassification rate relative to the recall rate out of all methods for 150 bp × 2 paired-end reads with 0% error/polymorphism (<xref ref-type="fig" rid="fig2">Figure 2A</xref>), 1% error/polymorphism (<xref ref-type="fig" rid="fig2">Figure 2B</xref>), and 2% error/polymorphism (<xref ref-type="fig" rid="fig2">Figure 2</xref> and <xref ref-type="fig" rid="fig3">Figure 3D–I</xref>), for 150 bp reads with 0% error/polymorphism (<xref ref-type="fig" rid="fig2">Figure 2D</xref>), 1% error/polymorphism (<xref ref-type="fig" rid="fig2">Figure 2E</xref>), and 2% error/polymorphism (<xref ref-type="fig" rid="fig2">Figure 2F</xref>), and for 300 bp reads with 0% error/polymorphism (<xref ref-type="fig" rid="fig2">Figure 2G</xref>), 1% error/polymorphism (<xref ref-type="fig" rid="fig2">Figure 2H</xref>), and 2% error/polymorphism (<xref ref-type="fig" rid="fig2">Figure 2I</xref>). See ‘Methods’ for definitions of recall and misclassification rates. Tronko also accurately assigned genera from the Scolopacidae family (top left of matrices in <xref ref-type="fig" rid="fig3">Figure 3</xref>) using Needleman–Wunsch with a cut-off of 10 compared to kraken2, metaphlan2, and pplacer.</p><p>Next, we performed a leave-one-individual-out test for the same COI reference sequences using 746,352 single-end reads and 36,390 paired-end reads (<xref ref-type="fig" rid="fig4">Figure 4</xref>, <xref ref-type="fig" rid="fig4s1">Figure 4—figure supplement 1F–J</xref>). See <xref ref-type="fig" rid="fig4s2">Figure 4—figure supplement 2</xref> for results with wavefront alignment algorithm (<xref ref-type="bibr" rid="bib34">Marco-Sola et al., 2021</xref>). Using single-end reads of lengths 150 bp and 300 bp, Tronko has a lower misclassification rate and higher recall rate than kraken2, metaphlan2, and MEGAN. Using 150 bp paired-end reads with 0% error (<xref ref-type="fig" rid="fig4">Figure 4D</xref>), Tronko had a misclassification rate at only 0.1% with a recall rate of 58.6% at the species level using a cut-off set to 10 while kraken2, MEGAN, and metaphlan2 had misclassification rates of 1.5, 0.1, and 11.0%, respectively, with recall rates of 85.4, 60.7, and 98.14%. Both metaphlan and kraken2 have a number of mis-assignments within the family of Laridae (see blue points across the diagonal in <xref ref-type="fig" rid="fig4s1">Figure 4—figure supplement 1A and B</xref>) and Tronko is able to accurately assign species within this family or assign at the genus or family level. We also observe that for increasing error rates, kraken2 and metaphlan2 have a substantial increase in misclassification rate. We believe it would be slightly misleading to display results for pplacer and APPLES-2 here due to the lack of an implementation to calculate the LCA on similar likelihoods. See <xref ref-type="fig" rid="fig4s2">Figure 4—figure supplement 2</xref> for results for pplacer and APPLES-2 along with wavefront alignment algorithm.</p><fig-group><fig id="fig4" position="float"><label>Figure 4.</label><caption><title>Recall vs. misclassification rates using leave-one-individual-out analysis for the order Charadriiformes (cytochrome oxidase 1 [COI] metabarcode) with paired-end 150 bp × 2 reads with 0% (<bold>A</bold>), 1% (<bold>B</bold>), and 2% (<bold>C</bold>) error/polymorphism, single-end 150 bp reads with 0% (<bold>D</bold>), 1% (<bold>E</bold>), and 2% (<bold>F</bold>) error/polymorphism, and single-end 300 bp reads with 0% (<bold>G</bold>), 1% (<bold>H</bold>), and 2% (<bold>I</bold>) error/polymorphism using kraken2, metaphlan2, MEGAN, pplacer, APPLES-2, and Tronko with cut-offs of 0, 5, 10, 15, and 20 using the Needleman–Wunsch alignment (solid line).</title></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-85794-fig4-v2.tif"/></fig><fig id="fig4s1" position="float" specific-use="child-fig"><label>Figure 4—figure supplement 1.</label><caption><title>Confusion matrices at the species level of the order Charadriiformes using the leave-one-individual-out analysis with paired-end 150 bp × 2 reads with 2% error/polymorphism using kraken2 (<bold>A</bold>), metaphlan2 (<bold>B</bold>), pplacer (<bold>C</bold>), APPLES-2 (<bold>D</bold>), MEGAN (<bold>E</bold>), and Tronko using the Needleman–Wunsch alignment (NW) for cut-offs 0 (<bold>F</bold>), 5 (<bold>G</bold>), 10 (<bold>H</bold>), 15 (<bold>I</bold>), and (<bold>J</bold>) 20.</title><p>Unassigned column contains both unassigned queries and queries assigned to a lower taxonomic level. Phylogenetic tree represents ancestral sequences at the species level.</p></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-85794-fig4-figsupp1-v2.tif"/></fig><fig id="fig4s2" position="float" specific-use="child-fig"><label>Figure 4—figure supplement 2.</label><caption><title>Recall vs. misclassification rates using leave-one-individual-out analysis for the order Charadriiformes (cytochrome oxidase 1 [COI] metabarcode) with paired-end 150 bp × 2 reads with 0% (<bold>A</bold>), 1% (<bold>B</bold>), and 2% (<bold>C</bold>) error/polymorphism, single-end 150 bp reads with 0% (<bold>D</bold>), 1% (<bold>E</bold>), and 2% (<bold>F</bold>) error/polymorphism, and single-end 300 bp reads with 0% (<bold>G</bold>), 1% (<bold>H</bold>), and 2% (<bold>I</bold>) error/polymorphism using kraken2, metaphlan2, MEGAN, pplacer, APPLES-2, and Tronko with cut-offs of 0, 5, 10, 15, and 20 using the Needleman–Wunsch alignment (solid line) and wavefront alignment (dashed line).</title></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-85794-fig4-figsupp2-v2.tif"/></fig></fig-group><p>In order to replicate real-world scenarios, we added a leave-one-species-out test using 16S from 2323 bacterial species and 5000 individual sequences (<xref ref-type="fig" rid="fig5">Figure 5</xref>). We selected the sequences for the 16S dataset by grouping the sequences by the class level in a random order, rotating that order, and randomly selecting an individual sequence from each group. We then simulated sequencing reads from the dataset simulating 21,947,613 single-end reads (150 bp and 300 bp in length) as well as 21,478,738 paired-end 150 bp × 2 reads. In all simulations at both the genus and family levels, Tronko had a higher recall and a lower misclassification rate than all other methods. The simulations for 300 bp single-end reads are not directly comparable to the 150 bp single-end or paired-end reads because only 105 missing-out tests out of 2310 were able to be performed because most reference sequences were &lt;300 bp in length. We only display the results for 300 bp single-end reads for APPLES-2 in the supplement as we believe the results are not a good representation of the method. See <xref ref-type="fig" rid="fig5s1">Figure 5—figure supplement 1</xref> for results for APPLES-2 using 300 bp single-end reads, along with results using the wavefront alignment algorithm. Additionally, we tested the use of hmmer or MAFFT for alignments with APPLES-2 and pplacer (<xref ref-type="fig" rid="fig5s2">Figure 5—figure supplement 2</xref>), and we did not observe any substantial difference with the choice of alignment.</p><fig-group><fig id="fig5" position="float"><label>Figure 5.</label><caption><title>Recall vs. misclassification rates using leave-one-species-out analysis with bacteria species (16S metabarcode) with paired-end 150 bp × 2 reads with 0% (<bold>A</bold>), 1% (<bold>B</bold>), and 2% (<bold>C</bold>) error/polymorphism, single-end 150 bp reads with 0% (<bold>D</bold>), 1% (<bold>E</bold>), and 2% (<bold>F</bold>) error/polymorphism, and single-end 300 bp reads with 0% (<bold>G</bold>), 1% (<bold>H</bold>), and 2% (<bold>I</bold>) error/polymorphism using kraken2, metaphlan2, MEGAN, pplacer, APPLES-2 and Tronko with cut-offs of 0, 5, 10, 15, and 20 using the Needleman–Wunsch alignment (solid line).</title></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-85794-fig5-v2.tif"/></fig><fig id="fig5s1" position="float" specific-use="child-fig"><label>Figure 5—figure supplement 1.</label><caption><title>Recall vs. misclassification rates using leave-one-species-out analysis with bacteria species (16S metabarcode) with paired-end 150 bp × 2 reads with 0% (<bold>A</bold>), 1% (<bold>B</bold>), and 2% (<bold>C</bold>) error/polymorphism, single-end 150bp reads with 0% (<bold>D</bold>), 1% (<bold>E</bold>), and 2% (<bold>F</bold>) error/polymorphism, and single-end 300bp reads with 0% (<bold>G</bold>), 1% (<bold>H</bold>), and 2% (<bold>I</bold>) error/polymorphism using kraken2, metaphlan2, MEGAN, pplacer, APPLES-2, and Tronko with cut-offs of 0, 5, 10, 15, and 20 using the Needleman–Wunsch alignment (solid line) and wavefront alignment (dashed line).</title></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-85794-fig5-figsupp1-v2.tif"/></fig><fig id="fig5s2" position="float" specific-use="child-fig"><label>Figure 5—figure supplement 2.</label><caption><title>Recall vs. misclassification rates using leave-one-individual-out analysis for bacterial species (16S metabarcode) with paired-end 150 bp × 2 reads with 0% (<bold>A</bold>), 1% (<bold>B</bold>), and 2% (<bold>C</bold>) error/polymorphism using kraken2, metaphlan2, MEGAN, pplacer + hmmer, pplacer + mafft, APPLES-2 + hmmer, APPLES-2 + mafft, and Tronko with cut-offs of 0, 5, 10, 15, and 20 using the Needleman–Wunsch alignment (solid line).</title></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-85794-fig5-figsupp2-v2.tif"/></fig></fig-group><p>We then compared Tronko’s performance to kraken2, MEGAN, and metaphlan2 using mock communities for both 16S (<xref ref-type="bibr" rid="bib41">Schirmer et al., 2015</xref>; <xref ref-type="bibr" rid="bib17">Gohl et al., 2016</xref>) and COI markers (<xref ref-type="bibr" rid="bib6">Braukmann et al., 2019</xref>; <xref ref-type="fig" rid="fig6">Figure 6</xref>). We did not compare mock community data to pplacer and APPLES-2 because we were unsuccessful in building a full MSA for our 16S and COI reference databases. Tronko also relies on sequence alignments, but as described in ‘Methods’, they can be handled by dividing sequences into clusters in the Tronko pipeline. For 16S, we used three different mock community datasets. We used 1,054,868 2 × 300 bp Illumina MiSeq sequencing data from a mock community consisting of 49 bacteria and 10 archaea species from <xref ref-type="bibr" rid="bib41">Schirmer et al., 2015</xref>, 54,930 2× 300 bp Illumina MiSeq sequencing data from a mock community consisting of 14 bacteria species from <xref ref-type="bibr" rid="bib31">Lluch et al., 2015</xref>, and 206,696 2 × 300 bp Illumina MiSeq sequencing data from a mock community of 20 evenly distributed bacterial species from <xref ref-type="bibr" rid="bib17">Gohl et al., 2016</xref>. For the data from <xref ref-type="bibr" rid="bib41">Schirmer et al., 2015</xref>, at the species level, Tronko had a &lt;0.6% misclassification rate at every cut-off with a recall rate of 11.0% at cut-off 0 (<xref ref-type="fig" rid="fig6">Figure 6A</xref>; see <xref ref-type="fig" rid="fig6s1">Figure 6—figure supplement 1</xref> for plot without outliers). kraken2 had a misclassification rate of 1.2% with a recall rate of 10.6% when using its default database, and a misclassification rate of 3.5% and a recall rate of 35.1% when using the same reference sequences as Tronko. metaphlan2 did not have any assignments at the species, genus, or family level using the default database, and it had an 8.3% misclassification and 8.9% recall rate at the species level when using the same reference sequences as Tronko. MEGAN had a recall rate of 0.2% and a misclassification rate of 0% at the species level.</p><fig-group><fig id="fig6" position="float"><label>Figure 6.</label><caption><title>Recall vs. misclassification rates using mock communities from <xref ref-type="bibr" rid="bib41">Schirmer et al., 2015</xref> (<bold>A</bold>), <xref ref-type="bibr" rid="bib31">Lluch et al., 2015</xref> (<bold>B</bold>), <xref ref-type="bibr" rid="bib17">Gohl et al., 2016</xref> (<bold>C</bold>), and <xref ref-type="bibr" rid="bib6">Braukmann et al., 2019</xref> (<bold>D</bold>) using both Needleman–Wunsch and wavefront alignment algorithms.</title><p>Figures with smaller misclassification rates on the x-axis are available for <xref ref-type="bibr" rid="bib41">Schirmer et al., 2015</xref>, <xref ref-type="bibr" rid="bib31">Lluch et al., 2015</xref>, <xref ref-type="bibr" rid="bib17">Gohl et al., 2016</xref>, <xref ref-type="bibr" rid="bib6">Braukmann et al., 2019</xref> in <xref ref-type="fig" rid="fig6s1 fig6s2">Figure 6—figure supplements 1, 2</xref>, and <xref ref-type="fig" rid="fig6s4">4</xref>, respectively.</p></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-85794-fig6-v2.tif"/></fig><fig id="fig6s1" position="float" specific-use="child-fig"><label>Figure 6—figure supplement 1.</label><caption><title>Close-up of <xref ref-type="fig" rid="fig6">Figure 6A</xref>.</title></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-85794-fig6-figsupp1-v2.tif"/></fig><fig id="fig6s2" position="float" specific-use="child-fig"><label>Figure 6—figure supplement 2.</label><caption><title>Close-up of <xref ref-type="fig" rid="fig6">Figure 6A</xref>.</title></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-85794-fig6-figsupp2-v2.tif"/></fig><fig id="fig6s3" position="float" specific-use="child-fig"><label>Figure 6—figure supplement 3.</label><caption><title>Close-up of <xref ref-type="fig" rid="fig6">Figure 6B</xref>.</title></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-85794-fig6-figsupp3-v2.tif"/></fig><fig id="fig6s4" position="float" specific-use="child-fig"><label>Figure 6—figure supplement 4.</label><caption><title>Close-up of <xref ref-type="fig" rid="fig6">Figure 6C</xref>.</title></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-85794-fig6-figsupp4-v2.tif"/></fig></fig-group><p>For the data from <xref ref-type="bibr" rid="bib31">Lluch et al., 2015</xref>, at the genus level, Tronko had a misclassification rate of 0.6% and a recall rate of 22.3% using a cut-off of 0, while all other methods had a misclassification rate of &gt;8% (see <xref ref-type="fig" rid="fig6s2">Figure 6—figure supplement 2</xref> for a close-up of the rates).</p><p>For the data from <xref ref-type="bibr" rid="bib17">Gohl et al., 2016</xref>, at the species level, Tronko had a &lt;2.6% misclassification rate at every cut-off with a recall rate of 12.8% at cut-off 0 (<xref ref-type="fig" rid="fig6">Figure 6C</xref>; see <xref ref-type="fig" rid="fig6s3">Figure 6—figure supplement 3</xref> for plot without outliers). kraken2 had a misclassification rate of 26.8% and recall rate of 33.7% when using its default database, and a misclassification rate of 21.4% and recall rate of 25.4% when using the same reference sequences as Tronko. metaphlan2 did not have any assignments at the species, genus, or family level using the default database, and it had an 8.5% misclassification and 2.1% recall rate at the species level when using the same reference sequences as Tronko. MEGAN had a misclassification rate of 0% and a recall rate of 4.4% at the species level.</p><p>For COI, we used a dataset from <xref ref-type="bibr" rid="bib6">Braukmann et al., 2019</xref> which consists of 646,997 2 × 300 bp Illumina MiSeq sequencing data from 374 species of terrestrial arthropods, which is the most expansive mock community dataset that we used. At the genus level, Tronko had a misclassification rate of &lt;0.5% with a recall rate of 78.3% at the cut-off of 0 (<xref ref-type="fig" rid="fig6">Figure 6D</xref>; see <xref ref-type="fig" rid="fig6s4">Figure 6—figure supplement 4</xref> for plot without outliers). With the default database, kraken2 had a misclassification rate of 40.5% with a recall rate of 6.5%. With the same reference sequences as Tronko, kraken2 still had a misclassification of 14.0% with a recall rate of 83.1%. metaphlan2 had a misclassification rate of 3.5% with a recall of 86.4% with the same reference sequences as Tronko while the default database failed to assign any reads. MEGAN had a 15.0% recall and 0% misclassification rate at the species level and a 49.9% recall and 0.5% misclassfication rate at the genus level.</p><p>We compared Tronko with kraken2, metaphlan2, and MEGAN (using BLAST as the aligner) for running time (<xref ref-type="fig" rid="fig7">Figure 7A</xref>) and peak memory (<xref ref-type="fig" rid="fig7">Figure 7B</xref>) using 100, 1000, 10,000, 100,000, and 1,000,000 sequences using the COI reference database. Unsurprisingly, kraken2 had the fastest running time followed by metaphlan2, but MEGAN had a substantially slower running time than all methods. Tronko was able to assign 1,000,000 queries in ∼8 hr with the choice of aligner being negligible. Tronko had the highest peak memory (∼50 GBs) as it stores all reference sequences, their trees, and their posterior probabilities in memory. We note that for very large databases, the memory requirements can, in theory, be reduced by processing different alignment subsets sequentially.</p><fig id="fig7" position="float"><label>Figure 7.</label><caption><title>Comparisons of running time (<bold>A</bold>) and peak memory (<bold>B</bold>) using 100, 1000, 10,000, 100,000, and 1,000,000 queries for Tronko, blastn + MEGAN, kraken2, and metaphlan2 using the cytochrome oxidase 1 (COI) reference database.</title><p>NW: Needleman–Wunsch; WFA: wavefront alignment.</p></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-85794-fig7-v2.tif"/></fig></sec><sec id="s3" sec-type="discussion"><title>Discussion</title><p>Both leave-one-species-out and leave-one-individual-out simulations show that Tronko recovers the correct taxonomy with higher probability than competing methods and represents a substantial improvement over current assignment methods. The advantage of Tronko comes from the use of limited full-sequence alignments and the use of phylogenetic assignment based on a fast approximation to the likelihood.</p><p>We evaluate Tronko using different cut-offs representing different trade-offs between recall and misclassification rate, thereby providing some guidance to users for choice of cut-off. We note that in most cases the other methods evaluated here fall within the convex hull of Tronko, showing that Tronko dominates those methods, and in no cases do other methods fall above the convex hull of Tronko. However, in some cases, other methods are so conservative, or anti-conservative, that a direct comparison is difficult. For example, when using single-end 300 bp reads (<xref ref-type="fig" rid="fig4">Figure 4G–I</xref>), MEGAN has assignment rates that are so low that a direct comparison is difficult.</p><p>Among the methods compared here, kraken2 is clearly the fastest (<xref ref-type="fig" rid="fig7">Figure 7A</xref>). However, it generally also has the worst performance with a higher misclassification rate than other methods, especially in the leave-one-species-out simulations (<xref ref-type="fig" rid="fig2">Figure 2</xref>).</p><p>Both metaphlan2 and MEGAN tend to fall within the convex hull of Tronko. Typically, metaphlan2 assigns much more aggressively, and therefore, has both a recall and misclassification rate that is much higher than MEGAN, which assigns very conservatively. We also note that the computational speed of MEGAN is so low that it, in some applications, may be prohibitive (<xref ref-type="fig" rid="fig7">Figure 7A</xref>).</p><p>We evaluated Tronko using two different alignment methods: Needleman–Wunsch and wavefront alignment. In many cases, the two alignment algorithms perform similarly. However, in the case, where short, single-end reads are used (i.e., 150 bp single-end reads), the wavefront alignment performs worse than the Needleman–Wunsch alignment (see <xref ref-type="fig" rid="fig2s2">Figure 2—figure supplement 2D–F</xref> and <xref ref-type="fig" rid="fig4s2">Figure 4—figure supplement 2D–F</xref>). The wavefront alignment algorithm implements heuristic modes to accelerate the alignment, which performs similarly to Needleman–Wunsch when the two sequences being aligned are similar in length. However, when there is a large difference between the two sequences being aligned, we notice that the wavefront alignment forces an end-to-end alignment which contains large gaps at the beginning and end of the alignment. Hence, based on current implementations, we cannot recommend the use of the wavefront alignment for assignment purposes of short reads, although this conclusion could change with future improvements in the implementation of the wavefront alignment algorithm.</p><p>Tronko is currently not applicable to eukaryotic genomic data as it requires well-curated alignments of markers and associated phylogenetic trees, although we note that whole-genome phylogenetic reference databases for such data could potentially be constructed. Such extensions of the use of Tronko would require heuristics for addressing the memory requirements. Tronko currently has larger memory requirements than methods that are not phylogeny-based. Nonetheless, for assignment to viruses, amplicon sequencing, and other forms of non-genomic barcoding, Tronko provides a substantial improvement over existing assignment methods and is the first full phylogenetic assignment method applicable to modern large datasets generated using NGS.</p><p>The methods presented in this article are implemented in the Tronko software package that includes Tronko-build and Tronko-assign for reference database building and species assignment, respectfully. Tronko can be downloaded at <ext-link ext-link-type="uri" xlink:href="https://github.com/lpipes/tronko">https://github.com/lpipes/tronko</ext-link> and is available under an open-software license (<xref ref-type="bibr" rid="bib33">Mapper and Pipes, 2024</xref>).</p></sec><sec id="s4" sec-type="methods"><title>Methods</title><sec id="s4-1"><title>Tronko-build reference database construction with a single tree</title><p>The algorithm used for assignment takes advantage of pre-calculated posterior probabilities of nucleotides at internal nodes of a phylogeny. We first estimate the topology and branch lengths of the tree using RAxML (<xref ref-type="bibr" rid="bib45">Stamatakis, 2014</xref>), although users of the method could use any tree estimation algorithm. We then calculate and store the posterior probabilities of each nucleotide in each node of the tree. For computational efficiency, this is done under a <xref ref-type="bibr" rid="bib21">Jukes and Cantor, 1969</xref> model, but the method can easily be extended to other models of molecular evolution. The calculations are achieved using an algorithm that traverses the tree only twice to calculate posterior probabilities simultaneously for all nodes in the tree. In brief, fractional likelihoods are first calculated in each node using a standard postorder traversal (e.g., <xref ref-type="bibr" rid="bib14">Felsenstein, 1981</xref>). This directly provides the posterior probabilities in the root after appropriate standardization. An preorder traversal of the tree is then used to pull fractional likelihoods from the root down the tree to calculate posterior probabilities. While naive application of standard algorithms for calculating posterior probabilities in a node, to all nodes of a tree, has computational complexity that is quadratic in the number of nodes, the algorithm used here is linear in the number of nodes as it calculates posterior probabilities for all nodes using a single postorder and a single preorder traversal without having to repeat the calculation for each node in the tree. For a single site, let the fractional likelihood of nucleotide <inline-formula><mml:math id="inf2"><mml:mrow><mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> in node <inline-formula><mml:math id="inf3"><mml:mi>j</mml:mi></mml:math></inline-formula> be <inline-formula><mml:math id="inf4"><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, that is, <inline-formula><mml:math id="inf5"><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is the probability the observed data in the site for all descendants of node <inline-formula><mml:math id="inf6"><mml:mi>j</mml:mi></mml:math></inline-formula> given nucleotide <inline-formula><mml:math id="inf7"><mml:mi>a</mml:mi></mml:math></inline-formula> in node <inline-formula><mml:math id="inf8"><mml:mi>j</mml:mi></mml:math></inline-formula>. Let <inline-formula><mml:math id="inf9"><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> be the probability of the data in the subtree containing all leaf nodes that are not descendants of node <inline-formula><mml:math id="inf10"><mml:mi>j</mml:mi></mml:math></inline-formula>, given nucleotide <inline-formula><mml:math id="inf11"><mml:mi>a</mml:mi></mml:math></inline-formula> in node <inline-formula><mml:math id="inf12"><mml:mi>j</mml:mi></mml:math></inline-formula>, then the posterior probability of nucleotide <inline-formula><mml:math id="inf13"><mml:mi>a</mml:mi></mml:math></inline-formula> is (<xref ref-type="bibr" rid="bib49">Yang et al., 1995</xref>)<disp-formula id="equ1"><label>(1)</label><mml:math id="m1"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>h</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>π</mml:mi><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo fence="false" stretchy="false">}</mml:mo></mml:mrow></mml:munder><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>h</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>π</mml:mi><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>where <inline-formula><mml:math id="inf14"><mml:msub><mml:mi>π</mml:mi><mml:mi>a</mml:mi></mml:msub></mml:math></inline-formula> is the stationary probability of nucleotide <inline-formula><mml:math id="inf15"><mml:mi>a</mml:mi></mml:math></inline-formula>. The algorithm here proceeds by first calculating and storing <inline-formula><mml:math id="inf16"><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> for all values of <inline-formula><mml:math id="inf17"><mml:mi>j</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="inf18"><mml:mi>a</mml:mi></mml:math></inline-formula> using a postorder traversal. It then recursively calculates <inline-formula><mml:math id="inf19"><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> assuming time-reversibility using a preorder traversal as<disp-formula id="equ2"><label>(2)</label><mml:math id="m2"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>h</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo fence="false" stretchy="false">}</mml:mo></mml:mrow></mml:munder><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>h</mml:mi><mml:mrow><mml:mi>A</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo fence="false" stretchy="false">}</mml:mo></mml:mrow></mml:munder><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>b</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>where <inline-formula><mml:math id="inf20"><mml:msub><mml:mi>t</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:math></inline-formula> is the branch length of the edge from node <inline-formula><mml:math id="inf21"><mml:mi>j</mml:mi></mml:math></inline-formula> to its parent, <inline-formula><mml:math id="inf22"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mo>⁢</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is the time-dependent transition probability of a transition from nucleotide <inline-formula><mml:math id="inf23"><mml:mi>a</mml:mi></mml:math></inline-formula> to nucleotide <inline-formula><mml:math id="inf24"><mml:mi>b</mml:mi></mml:math></inline-formula> in time <inline-formula><mml:math id="inf25"><mml:mi>t</mml:mi></mml:math></inline-formula>, <inline-formula><mml:math id="inf26"><mml:mrow><mml:mi>A</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is the parent node of node <inline-formula><mml:math id="inf27"><mml:mi>j</mml:mi></mml:math></inline-formula>, and <inline-formula><mml:math id="inf28"><mml:mrow><mml:mi>S</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is the sister node of node <inline-formula><mml:math id="inf29"><mml:mi>j</mml:mi></mml:math></inline-formula> in the binary tree. The algorithm starts at the root with <inline-formula><mml:math id="inf30"><mml:mrow><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mrow><mml:mi>r</mml:mi><mml:mo>⁢</mml:mo><mml:mi>o</mml:mi><mml:mo>⁢</mml:mo><mml:mi>o</mml:mi><mml:mo>⁢</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>∀</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> This algorithm is implemented in the program ’Tronko-build’.</p><p>Each node in the tree is subsequently provided a taxonomy assignment. This is done by first making taxonomic assignments of the leaf nodes using the taxonomy provided by the taxid of the associated NCBI accession. We then make taxonomic assignments for internal nodes, at all taxonomic levels (species, genus, etc.), using a postorder traversal of the tree that assigns a taxonomic descriptor to node <inline-formula><mml:math id="inf31"><mml:mi>i</mml:mi></mml:math></inline-formula> if both children of node <inline-formula><mml:math id="inf32"><mml:mi>i</mml:mi></mml:math></inline-formula> have the same taxonomic assignment. Otherwise, node <inline-formula><mml:math id="inf33"><mml:mi>i</mml:mi></mml:math></inline-formula> does not have a taxonomic assignment at this taxonomic level and node <inline-formula><mml:math id="inf34"><mml:mi>i</mml:mi></mml:math></inline-formula> is given the next closest upward taxonomic level where its children have the same taxonomic assignment. In other words, node <inline-formula><mml:math id="inf35"><mml:mi>i</mml:mi></mml:math></inline-formula> only gets a taxonomic assignment if the taxonomic assignments of both child nodes agree.</p></sec><sec id="s4-2"><title>Tronko-build reference database construction with multiple trees</title><p>MSAs for a large number of sequences can become unreliable and computationally challenging to work with due to the large number of insertions and deletions. For that reason, we devise an algorithm for partitioning of sequence sets into smaller subsets based on the accuracy of the alignment and using the inferred phylogenetic tree to guide the partitioning (<xref ref-type="fig" rid="fig1s1">Figure 1—figure supplement 1</xref>).</p><p>To measure the integrity of the MSA, we calculate an average quality score, sum-of-pairs, <inline-formula><mml:math id="inf36"><mml:mrow><mml:mi>A</mml:mi><mml:mo>⁢</mml:mo><mml:mi>S</mml:mi><mml:mo>⁢</mml:mo><mml:mi>P</mml:mi></mml:mrow></mml:math></inline-formula>, which is a sum of pairwise alignment scores in the MSA. Assume an MSA of length <inline-formula><mml:math id="inf37"><mml:mi>l</mml:mi></mml:math></inline-formula> with <inline-formula><mml:math id="inf38"><mml:mi>K</mml:mi></mml:math></inline-formula> sequences, <inline-formula><mml:math id="inf39"><mml:mrow><mml:mi>A</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math id="inf40"><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> is the <italic>j</italic>th nucleotide in sequence <inline-formula><mml:math id="inf41"><mml:mi>i</mml:mi></mml:math></inline-formula>, <inline-formula><mml:math id="inf42"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="inf43"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>≤</mml:mo><mml:mi>l</mml:mi></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="inf44"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mi>M</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mo>-</mml:mo><mml:mo>,</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>N</mml:mi><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. Define the penalty function, <inline-formula><mml:math id="inf45"><mml:mi>p</mml:mi></mml:math></inline-formula>:<disp-formula id="equ3"><label>(3)</label><mml:math id="m3"><mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>I</mml:mi><mml:mo>,</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mtable columnspacing="5pt" displaystyle="true" rowspacing="0pt"><mml:mtr><mml:mtd columnalign="left"><mml:mn>3</mml:mn></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext>if </mml:mtext><mml:mrow><mml:mi>I</mml:mi><mml:mo>=</mml:mo><mml:mi>V</mml:mi></mml:mrow><mml:mtext> and </mml:mtext><mml:mrow><mml:mi>I</mml:mi><mml:mo>≠</mml:mo><mml:mo>-</mml:mo></mml:mrow><mml:mtext> (match)</mml:mtext></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:mo>-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext>if </mml:mtext><mml:mrow><mml:mi>I</mml:mi><mml:mo>≠</mml:mo><mml:mi>V</mml:mi></mml:mrow><mml:mtext>, </mml:mtext><mml:mrow><mml:mrow><mml:mi>I</mml:mi><mml:mo>,</mml:mo><mml:mi>V</mml:mi></mml:mrow><mml:mo>∉</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mi>N</mml:mi><mml:mo>,</mml:mo><mml:mo>-</mml:mo><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:mrow><mml:mtext> (mismatch)</mml:mtext></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mtext>otherwise</mml:mtext></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>where <inline-formula><mml:math id="inf46"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>I</mml:mi><mml:mo>,</mml:mo><mml:mi>V</mml:mi><mml:mo>∈</mml:mo><mml:mi>M</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula>. <italic>ASP</italic> is then calculated as<disp-formula id="equ4"><label>(4)</label><mml:math id="m4"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>A</mml:mi><mml:mi>S</mml:mi><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:munderover><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:munderover><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>K</mml:mi></mml:mrow></mml:munderover><mml:munderover><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>K</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:mo maxsize="1.2em" minsize="1.2em">(</mml:mo></mml:mrow><mml:mfrac linethickness="0pt"><mml:mi>K</mml:mi><mml:mn>2</mml:mn></mml:mfrac><mml:mrow><mml:mo maxsize="1.2em" minsize="1.2em">)</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>If the <inline-formula><mml:math id="inf47"><mml:mrow><mml:mi>A</mml:mi><mml:mo>⁢</mml:mo><mml:mi>S</mml:mi><mml:mo>⁢</mml:mo><mml:mi>P</mml:mi></mml:mrow></mml:math></inline-formula> is lower than the <inline-formula><mml:math id="inf48"><mml:mrow><mml:mi>A</mml:mi><mml:mo>⁢</mml:mo><mml:mi>S</mml:mi><mml:mo>⁢</mml:mo><mml:mi>P</mml:mi></mml:mrow></mml:math></inline-formula> threshold (a threshold of 0.1 was used in our analyses in this article), the corresponding tree is split in three partitions at the node with the minimum variance, calculated as<disp-formula id="equ5"><label>(5)</label><mml:math id="m5"><mml:mrow><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:munder><mml:mo lspace="0" rspace="0" movablelimits="true">argmin</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:munder><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="1.2em" minsize="1.2em">{</mml:mo></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>K</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mn>3</mml:mn><mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>K</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mn>3</mml:mn><mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>K</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>K</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mn>3</mml:mn><mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mrow><mml:mo maxsize="1.2em" minsize="1.2em">}</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>where <inline-formula><mml:math id="inf49"><mml:mi>T</mml:mi></mml:math></inline-formula> is a tree, that is, a set of nodes, <inline-formula><mml:math id="inf50"><mml:mrow><mml:msub><mml:mi>L</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="inf51"><mml:mrow><mml:msub><mml:mi>L</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is the number of leaf nodes descending from the left and right child node, respectively, of node <inline-formula><mml:math id="inf52"><mml:mi>i</mml:mi></mml:math></inline-formula>, and <inline-formula><mml:math id="inf53"><mml:mi>K</mml:mi></mml:math></inline-formula> is the total number of leaf nodes in the tree. We then split the tree into three subtrees by eliminating node <inline-formula><mml:math id="inf54"><mml:mi>v</mml:mi></mml:math></inline-formula>. Each partition is realigned with <monospace>FAMSA</monospace> (<xref ref-type="bibr" rid="bib12">Deorowicz et al., 2016</xref>) and new trees are constructed using <monospace>RAxML</monospace> (<xref ref-type="bibr" rid="bib45">Stamatakis, 2014</xref>) using default parameters and the GTR + Gamma model. <monospace>FAMSA</monospace> is used to optimize for speed since it is 1–2 orders of magnitude faster than Clustal (<xref ref-type="bibr" rid="bib18">Higgins and Sharp, 1988</xref>) or MAFFT (<xref ref-type="bibr" rid="bib23">Katoh et al., 2002</xref>) with similar quality (see <xref ref-type="bibr" rid="bib12">Deorowicz et al., 2016</xref>). We explored different combinations of tree estimation methods (including IQ-TREE2 <xref ref-type="bibr" rid="bib36">Minh et al., 2020</xref>), multiple sequence aligners, and global aligners (<xref ref-type="fig" rid="fig2s2">Figure 2—figure supplement 2</xref>). While most combinations of methods were quite similar (especially for the genus level), the use of FAMSA + RAxML + NW was optimal with regard to speed and accuracy. We ran IQ-TREE2 with the default settings using options <monospace>-m GTR+G –nt 4</monospace> to be consistent with similar RAxML settings. The sequences are recursively partitioned until the <inline-formula><mml:math id="inf55"><mml:mrow><mml:mi>A</mml:mi><mml:mo>⁢</mml:mo><mml:mi>S</mml:mi><mml:mo>⁢</mml:mo><mml:mi>P</mml:mi></mml:mrow></mml:math></inline-formula> score is above the threshold. Finally, the trees, MSAs, taxonomic information, and posterior probabilities are written to one reference file which can be loaded for subsequent assignment of reads. Note that the procedure for phylogeny estimating and calculation of posterior probabilities only has to be done once for a marker and then can be used repeatedly for assignment using different datasets of query sequences.</p></sec><sec id="s4-3"><title>Simulation of query sequences</title><p>To simulate single-end reads from a reference sequence, a starting point is selected uniformly at random and extends for <inline-formula><mml:math id="inf56"><mml:msub><mml:mi>m</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:math></inline-formula> base pairs, where <inline-formula><mml:math id="inf57"><mml:msub><mml:mi>m</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:math></inline-formula> represents the read length. For paired-end reads, a similar random selection of a starting point occurs, extending <inline-formula><mml:math id="inf58"><mml:msub><mml:mi>m</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:math></inline-formula> base pairs. From the end of this read, if the insert size <inline-formula><mml:math id="inf59"><mml:msub><mml:mi>m</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> is positive, the reverse read begins <inline-formula><mml:math id="inf60"><mml:msub><mml:mi>m</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> base pairs forward with a length of <inline-formula><mml:math id="inf61"><mml:msub><mml:mi>m</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:math></inline-formula>. If <inline-formula><mml:math id="inf62"><mml:msub><mml:mi>m</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> is negative, the reverse read starts <inline-formula><mml:math id="inf63"><mml:msub><mml:mi>m</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> base pairs backward. Sequencing errors are then added independently with different probabilities <inline-formula><mml:math id="inf64"><mml:mrow><mml:mi>α</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="inf65"><mml:mrow><mml:mi>α</mml:mi><mml:mo>=</mml:mo><mml:mn>0.01</mml:mn></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math id="inf66"><mml:mrow><mml:mi>α</mml:mi><mml:mo>=</mml:mo><mml:mn>0.02</mml:mn></mml:mrow></mml:math></inline-formula> at each site. These errors are induced by changing the nucleotide to any of the other three possible nucleotides, following the probabilities used by <xref ref-type="bibr" rid="bib46">Stephens et al., 2016</xref>:<disp-formula id="equ6"><mml:math id="m6"><mml:mrow><mml:mtable columnalign="left left left" rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd><mml:mtable columnalign="left left" rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd><mml:mspace width="2em"/><mml:mtable rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd><mml:mspace width="1em"/><mml:mi>A</mml:mi></mml:mtd><mml:mtd><mml:mspace width="2em"/><mml:mi>C</mml:mi></mml:mtd><mml:mtd><mml:mspace width="1em"/><mml:mspace width="1em"/><mml:mi>G</mml:mi></mml:mtd><mml:mtd><mml:mspace width="2em"/><mml:mi>T</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtable rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd><mml:mi>A</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>C</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>G</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>7</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mrow><mml:mo>[</mml:mo><mml:mtable rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0.4918</mml:mn></mml:mtd><mml:mtd><mml:mn>0.3377</mml:mn></mml:mtd><mml:mtd><mml:mn>0.1705</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0.5238</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0.2661</mml:mn></mml:mtd><mml:mtd><mml:mn>0.2101</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0.3754</mml:mn></mml:mtd><mml:mtd><mml:mn>0.2355</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0.3890</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0.2505</mml:mn></mml:mtd><mml:mtd><mml:mn>0.2552</mml:mn></mml:mtd><mml:mtd><mml:mn>0.4942</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>]</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p></sec><sec id="s4-4"><title>Taxonomic classification of query sequences</title><p>First, <monospace>BWA-MEM</monospace> (<xref ref-type="bibr" rid="bib29">Li, 2013</xref>) is used with default options to align the query sequences to the reference sequences, thereby identifying a list of the highest scoring reference sequences (which we designate as BWA-MEM hits) from the reference database. We use <monospace>BWA-MEM</monospace> as the original Minimap2 manuscript (<xref ref-type="bibr" rid="bib30">Li, 2018</xref>) demonstrated that <monospace>BWA-MEM</monospace> had the lowest error rate for the same amount of fractional mapped reads compared to Minimap2, SNAP (<xref ref-type="bibr" rid="bib50">Zaharia et al., 2011</xref>), and bowtie2 (<xref ref-type="bibr" rid="bib24">Langdon, 2015</xref>). Second, a global alignment, either using the Needleman–Wunsch algorithm (<xref ref-type="bibr" rid="bib38">Needleman and Wunsch, 1970</xref>) or the wavefront alignment algorithm (<xref ref-type="bibr" rid="bib34">Marco-Sola et al., 2021</xref>), is performed only on the sequence with the highest score from each subtree (reference sequence set) identified using the previously described partitioning algorithm.</p><p>Once aligned to the reference sequence, a score, <inline-formula><mml:math id="inf67"><mml:mrow><mml:mi>S</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, is calculated for all nodes, <inline-formula><mml:math id="inf68"><mml:mi>i</mml:mi></mml:math></inline-formula>, in the tree(s) that the reference sequence is located to. For a given read, let <inline-formula><mml:math id="inf69"><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:math></inline-formula> be the observed nucleotide in the position of the read mapping to position <inline-formula><mml:math id="inf70"><mml:mi>j</mml:mi></mml:math></inline-formula> in the alignment. We also assume an error rate, <inline-formula><mml:math id="inf71"><mml:mi>c</mml:mi></mml:math></inline-formula>. For example, if the true base is G and the error rate is <inline-formula><mml:math id="inf72"><mml:mi>c</mml:mi></mml:math></inline-formula>, then the probability of observing A in the read is <inline-formula><mml:math id="inf73"><mml:mrow><mml:mi>c</mml:mi><mml:mo>/</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula>. We note that this error rate can be consider to include both true sequencing errors and polymorphisms/sequence divergence. In an ungapped alignment, the score for site <inline-formula><mml:math id="inf74"><mml:mi>j</mml:mi></mml:math></inline-formula> in node <inline-formula><mml:math id="inf75"><mml:mi>i</mml:mi></mml:math></inline-formula> is then the negative log of a function that depends on the posterior probability of the observed nucleotide in the query sequence, <inline-formula><mml:math id="inf76"><mml:mrow><mml:msub><mml:mtext>IP</mml:mtext><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, and the error rate:<disp-formula id="equ7"><label>(6)</label><mml:math id="m7"><mml:mrow><mml:mo>−</mml:mo><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>c</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mn>3</mml:mn><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mn>4</mml:mn><mml:mi>c</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mn>3</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mtext>P</mml:mtext><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula></p><p>Assuming symmetric error rates, the probability of observing the base by error is <inline-formula><mml:math id="inf77"><mml:mrow><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:mrow><mml:msub><mml:mtext>IP</mml:mtext><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>⁢</mml:mo><mml:mi>c</mml:mi></mml:mrow><mml:mo>/</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula> and the probability of observing the base with no error is <inline-formula><mml:math id="inf78"><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:mi>c</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>⁢</mml:mo><mml:msub><mml:mtext>IP</mml:mtext><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. The sum of these two expressions equals the expression in the logarithm above. The score for all <inline-formula><mml:math id="inf79"><mml:mi>s</mml:mi></mml:math></inline-formula> sites in the read is defined as <inline-formula><mml:math id="inf80"><mml:mrow><mml:mo>-</mml:mo><mml:mrow><mml:msubsup><mml:mo largeop="true" symmetric="true">∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>s</mml:mi></mml:msubsup><mml:mrow><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mrow><mml:mi>c</mml:mi><mml:mo>/</mml:mo><mml:mn>3</mml:mn></mml:mrow><mml:mo>+</mml:mo><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:mrow><mml:mrow><mml:mn>4</mml:mn><mml:mo>⁢</mml:mo><mml:mi>c</mml:mi></mml:mrow><mml:mo>/</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>⁢</mml:mo><mml:msub><mml:mtext>IP</mml:mtext><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula>.</p><p>Note that the full phylogenetic likelihood for the entire tree, under standard models of molecular evolution (<xref ref-type="bibr" rid="bib49">Yang et al., 1995</xref>) with equal base frequencies and not accounting for errors, and assuming time reversibility, is<disp-formula id="equ8"><label>(7)</label><mml:math id="m8"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:munderover><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mo fence="false" stretchy="false">}</mml:mo></mml:mrow></mml:munder><mml:msub><mml:mtext>P</mml:mtext><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>v</mml:mi><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>where <inline-formula><mml:math id="inf81"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>v</mml:mi><mml:mo>⁢</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is the time-dependent transition probability from base <inline-formula><mml:math id="inf82"><mml:mi>v</mml:mi></mml:math></inline-formula> to base <inline-formula><mml:math id="inf83"><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:math></inline-formula> in time <inline-formula><mml:math id="inf84"><mml:mi>t</mml:mi></mml:math></inline-formula>. This statement takes advantage of the fact that, under time-reversibility, the posterior for a base in an node is proportional to the fractional likelihood of that base in the node, if the tree is rooted in the node. For small values of <inline-formula><mml:math id="inf85"><mml:mi>t</mml:mi></mml:math></inline-formula>, <inline-formula><mml:math id="inf86"><mml:mi mathvariant="normal">ℓ</mml:mi></mml:math></inline-formula> converges to <inline-formula><mml:math id="inf87"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mtext>I\kern-1.5ptP</mml:mtext><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula>. Minimizing the score function, therefore, corresponds to maximizing the full phylogenetic likelihood function assuming that the branch leading to the query sequence is infinitesimally short and connects with the tree in an existing node. An alternative interpretation is that the score maximizes the probability of observing the query sequence if it is placed exactly in a node or, equivalently, minimizes the expected mismatch between the query and a predicted sequence sampled form the node.</p><p>To address insertions and deletions, we define scores of <inline-formula><mml:math id="inf88"><mml:mi>γ</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="inf89"><mml:mi>λ</mml:mi></mml:math></inline-formula> for a gap or insertion, respectively, in the query sequence relative to the reference sequence. We also entertain the possibility of a gap in the reference sequence in node <inline-formula><mml:math id="inf90"><mml:mi>i</mml:mi></mml:math></inline-formula> in read position <inline-formula><mml:math id="inf91"><mml:mi>j</mml:mi></mml:math></inline-formula>, <inline-formula><mml:math id="inf92"><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>, which occurs when the reference is a leaf node with a gap in the position or if it is an internal node with all descendent nodes having gaps in the position. We use the notation <inline-formula><mml:math id="inf93"><mml:mrow><mml:msub><mml:mi>M</mml:mi><mml:mi>g</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mo>-</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> for gaps and <inline-formula><mml:math id="inf94"><mml:mrow><mml:msub><mml:mi>M</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> for nucleotides (no gap). Then, the score for node <italic>i</italic> in site <inline-formula><mml:math id="inf95"><mml:mi>j</mml:mi></mml:math></inline-formula> of the read, with observed base <inline-formula><mml:math id="inf96"><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:math></inline-formula>, is<disp-formula id="equ9"><label>(8)</label><mml:math id="m9"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mtable columnalign="left left" rowspacing=".2em" columnspacing="1em" displaystyle="false"><mml:mtr><mml:mtd><mml:mi>c</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mn>3</mml:mn><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mn>4</mml:mn><mml:mi>c</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mn>3</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mtext>P</mml:mtext><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mtd><mml:mtd><mml:mtext>if </mml:mtext><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mtext> and </mml:mtext><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>γ</mml:mi></mml:mtd><mml:mtd><mml:mtext>if </mml:mtext><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>g</mml:mi></mml:mrow></mml:msub><mml:mtext> and </mml:mtext><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mtext>if </mml:mtext><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>g</mml:mi></mml:mrow></mml:msub><mml:mtext> and </mml:mtext><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>g</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>λ</mml:mi></mml:mtd><mml:mtd><mml:mtext>if </mml:mtext><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mtext> and </mml:mtext><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>g</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable><mml:mo fence="true" stretchy="true" symmetric="true"/></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>The total score for the entire read is<disp-formula id="equ10"><label>(9)</label><mml:math id="m10"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:munderover><mml:mo largeop="true" movablelimits="false" symmetric="true">∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>l</mml:mi></mml:munderover><mml:mrow><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>For paired reads, the scores for each node in the tree are calculated as the sum of the scores for the forward read and the scores for the reverse read. Scores are calculated for all nodes in each tree that contain a best hits from the bwa mem alignment. For all analyses in this article, we use values of <inline-formula><mml:math id="inf97"><mml:mrow><mml:mi>c</mml:mi><mml:mo>=</mml:mo><mml:mn>0.01</mml:mn></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="inf98"><mml:mrow><mml:mi>λ</mml:mi><mml:mo>=</mml:mo><mml:mn>0.01</mml:mn></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math id="inf99"><mml:mrow><mml:mi>γ</mml:mi><mml:mo>=</mml:mo><mml:mn>0.25</mml:mn></mml:mrow></mml:math></inline-formula>.</p><p>After calculation of scores, the LCA of all of the lowest scoring nodes, using a user-defined cut-off parameter, is calculated. For example, if the cut-off parameter is 0, only the highest scoring node (or nodes with the same score as the highest scoring node) is used to calculate the LCA. If the cut-off parameter is 5, the highest scoring node, along with all other nodes within a score of 5 of the highest scoring node, are used to calculate the LCA. Once the LCA node is identified, the classification of the single read (or paired-reads) will be assigned to the taxonomy assigned to that node. The classification of query sequences is parallelized.</p></sec><sec id="s4-5"><title>Taxonomic assignment using pplacer</title><p>To generate phylogenetic placements using pplacer, we first aligned sequencing reads to the reference sequences using hmmer3 (<xref ref-type="bibr" rid="bib37">Mistry et al., 2013</xref>). We then ran pplacer, rppr prep_db, and guppy classify all using the default parameters in that order. Next, to obtain taxonomic assignments, we used the R package BoSSA (<xref ref-type="bibr" rid="bib25">Lefeuvre, 2018</xref>) to merge the multiclass element (which is a data frame with the taxonomic assignments of each placement) and the placement table of pplace object (the output of pplacer) and only kept the ‘best’ type of placement for each read. For paired-end sequences, we assigned the taxonomy by the LCA of both pairs of reads.</p></sec><sec id="s4-6"><title>Taxonomic assignment using APPLES-2</title><p>To generate phylogenetic placements using APPLES-2, we first aligned sequencing reads to the reference sequences using hmmer3 (<xref ref-type="bibr" rid="bib37">Mistry et al., 2013</xref>). We then converted the alignment output from Stockholm to FASTA format and then separated the reference sequences from the sequencing reads (an input requirement for APPLES-2) using in-house scripts. We then ran <monospace>run_apples.py</monospace> with the default parameters. In order to ensure that the tree that was output from APPLES-2 was strictly binary (a requirement to assign taxonomy), we extracted the tree from the jplace output and resolved polytomies using the <monospace>multi2di</monospace> function from the R package ape (<xref ref-type="bibr" rid="bib39">Paradis and Schliep, 2019</xref>). Next, we ran <monospace>run_apples.py</monospace> again using the output tree from ape (with option <monospace>--tree=</monospace>) and disabled reestimation of branch lengths (in order to keep the tree as strictly binary) by using the option <monospace>--disable-reestimation</monospace>. To assign taxonomy we ran <monospace>gappa</monospace> <monospace>examine assign</monospace> from the Gappa toolkit (<xref ref-type="bibr" rid="bib9">Czech et al., 2020</xref>) using the options <monospace>--per-query-results</monospace> and <monospace>--best-hit</monospace>.</p></sec><sec id="s4-7"><title>Classification metrics used for accuracy evaluations</title><p>We used the taxonomic identification metrics from <xref ref-type="bibr" rid="bib43">Siegwald et al., 2017</xref> and <xref ref-type="bibr" rid="bib42">Sczyrba et al., 2017</xref>. A true-positive (TP) read at a certain taxonomic rank has the same taxonomy as the sequence it was simulated from. A misclassification (FP) read at a certain taxonomic rank has a taxonomy different from the sequence it was simulated from. A false-negative (FN) read, at a certain taxonomic rank, is defined as a read that received no assignment at that rank. For accuracy, we use the following measures for recall and misclassification rate.<disp-formula id="equ11"><label>(10)</label><mml:math id="m11"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mtext>Recall</mml:mtext><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>T</mml:mi><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>P</mml:mi><mml:mo>+</mml:mo><mml:mi>F</mml:mi><mml:mi>N</mml:mi></mml:mrow></mml:mfrac></mml:mstyle></mml:mrow></mml:math></disp-formula><disp-formula id="equ12"><label>(11)</label><mml:math id="m12"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mtext>Misclassification rate</mml:mtext><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>F</mml:mi><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>P</mml:mi><mml:mo>+</mml:mo><mml:mi>F</mml:mi><mml:mi>P</mml:mi><mml:mo>+</mml:mo><mml:mi>F</mml:mi><mml:mi>N</mml:mi></mml:mrow></mml:mfrac></mml:mstyle></mml:mrow></mml:math></disp-formula></p></sec><sec id="s4-8"><title>Classification of mock community reads</title><p>For <xref ref-type="bibr" rid="bib41">Schirmer et al., 2015</xref>, we used the ERR777705 sample, for <xref ref-type="bibr" rid="bib17">Gohl et al., 2016</xref> we used the SRR3163887 sample, and for <xref ref-type="bibr" rid="bib6">Braukmann et al., 2019</xref> we used the SRR8082172 sample. For <xref ref-type="bibr" rid="bib31">Lluch et al., 2015</xref>, we used the ERR1049842 sample. All sample raw reads used for assignment were first filtered through the Anacapa Quality Control pipeline (<xref ref-type="bibr" rid="bib8">Curd et al., 2019</xref>) with default parameters up until before the amplicon sequence variant (ASV) construction step. Only paired reads were retained for assignment. For mock datasets where the true species were only defined with ‘sp.’, species assignment were excluded for all methods. After Tronko assignments, we filtered results using a script to check the number of mismatches in the forward vs. reverse reads, and used a <inline-formula><mml:math id="inf100"><mml:msup><mml:mi>χ</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:math></inline-formula> distribution to filter out assignments that have a discrepancy in mismatches.</p></sec><sec id="s4-9"><title>Leave-species-out and leave-one-individual-out analyses</title><p>We used two datasets (Charadriiformes and Bacteria) for leave-species-out and leave-one-individual-out analyses. For one dataset, we used 1467 COI reference sequences from 253 species from the order Charadriiformes. For the leave-species-out analyses with Charadriiformes, we removed each of the species one at a time (excluding singletons, i.e., species only represented by a single sequence), yielding 252 different reference databases. For the leave-species-out analyses with Bacteria, we randomly selected 5000 taxonomically divergent bacteria species from the 16S reference database built through CRUX. For the leave-species-out analyses with Bacteria, we removed each of the species, one at a time (excluding singletons), yielding 2323 different reference databases. For each database, we then simulated reads from the species that had been removed with different error rates, and assigned to taxonomy using all methods tested (Tronko, kraken2, metaphlan2, MEGAN, pplacer, and APPLES-2), using the same reference databases and same simulated reads for all methods. For the leave-individual-out analysis with Charadriiformes, we removed a single individual from each species (excluding singletons) yielding 1423 different reference databases. Assignments for all method were performed with default parameters and where a paired read mode was applicable, that mode was used when analyzing paired reads. For paired-end read assignments with MEGAN, the assignment is the LCA of the forward and reverse read assignments as described in the MEGAN manual v6.12.3. For metaphlan, the results from the forward reads and reverse reads were combined.</p></sec><sec id="s4-10"><title>Custom 16S and COI Tronko-build reference database construction</title><p>For the construction of the reference databases in this article, we use custom-built reference sequences that were generated using common primers (<xref ref-type="bibr" rid="bib7">Caporaso et al., 2012</xref>; <xref ref-type="bibr" rid="bib26">Leray et al., 2013</xref>; <xref ref-type="bibr" rid="bib16">Geller et al., 2013</xref>; <xref ref-type="bibr" rid="bib3">Amaral-Zettler et al., 2009</xref>) for 16S and COI amplicons that have been used in previous studies (<xref ref-type="bibr" rid="bib13">de Vargas et al., 2015</xref>; <xref ref-type="bibr" rid="bib27">Leray and Knowlton, 2015</xref>; <xref ref-type="bibr" rid="bib11">David et al., 2014</xref>) using the CRUX module of the Anacapa Toolkit (<xref ref-type="bibr" rid="bib8">Curd et al., 2019</xref>). For the COI reference database, we use the following forward primer: GGWACWGGWTGAACWGTWTAYCCYCC, and reverse primer: TANACYTCnGGRTGNCCRAARAAYCA from <xref ref-type="bibr" rid="bib26">Leray et al., 2013</xref> and <xref ref-type="bibr" rid="bib16">Geller et al., 2013</xref>, respectively, as input into the CRUX pipeline (<xref ref-type="bibr" rid="bib8">Curd et al., 2019</xref>) to obtain a fasta and taxonomy file of reference sequences. For the 16S database, we use forward primer GTGCCAGCMGCCGCGGTAA and reverse primer GACTACHVGGGTATCTAATCC from <xref ref-type="bibr" rid="bib7">Caporaso et al., 2012</xref>. We set the length of the minimum amplicon expected to 0 bp, the length of the maximum amplicon expected to 2000 bp, and the maximum number of primer mismatches to 3 (parameters <monospace>-s 0, -m 2000, -e 3</monospace>, respectively). Since all of the custom-built libraries contain ≥500,000 reference sequences and MSAs, we first used Ancestralclust (<xref ref-type="bibr" rid="bib40">Pipes and Nielsen, 2022</xref>) to do an initial partition of the data, using parameters of 1000 seed sequences in 30 initial clusters (parameters <monospace>-r 1000</monospace> and <monospace>-b 30</monospace>, respectively). For the COI database, we obtain 76 clusters and for the 16S database we obtain 228 clusters. For each cluster, we use FAMSA (<xref ref-type="bibr" rid="bib12">Deorowicz et al., 2016</xref>) with default parameters to construct the MSAs and RAxML (<xref ref-type="bibr" rid="bib45">Stamatakis, 2014</xref>) with the model GTR+Γ of nucleotide substitution to obtain the starting trees for Tronko-build.</p></sec><sec id="s4-11"><title>Inclusion and diversity</title><p>We support inclusive, diverse, and equitable conduct of research.</p></sec></sec></body><back><sec sec-type="additional-information" id="s5"><title>Additional information</title><fn-group content-type="competing-interest"><title>Competing interests</title><fn fn-type="COI-statement" id="conf1"><p>No competing interests declared</p></fn></fn-group><fn-group content-type="author-contribution"><title>Author contributions</title><fn fn-type="con" id="con1"><p>Conceptualization, Software, Formal analysis, Funding acquisition, Validation, Visualization, Methodology, Writing - original draft, Writing - review and editing</p></fn><fn fn-type="con" id="con2"><p>Conceptualization, Software, Supervision, Funding acquisition, Methodology, Writing - original draft, Writing - review and editing</p></fn></fn-group></sec><sec sec-type="supplementary-material" id="s6"><title>Additional files</title><supplementary-material id="mdar"><label>MDAR checklist</label><media xlink:href="elife-85794-mdarchecklist1-v2.pdf" mimetype="application" mime-subtype="pdf"/></supplementary-material></sec><sec sec-type="data-availability" id="s7"><title>Data availability</title><p>The identified reference databases, MSAs, phylogenetic trees, and posterior probabilities of nucleotides in nodes for COI and 16S are available for download at <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.5281/zenodo.13182507">https://doi.org/10.5281/zenodo.13182507</ext-link>.</p><p>The following dataset was generated:</p><p><element-citation publication-type="data" specific-use="isSupplementedBy" id="dataset1"><person-group person-group-type="author"><name><surname>Pipes</surname><given-names>L</given-names></name><name><surname>Nielsen</surname><given-names>R</given-names></name></person-group><year iso-8601-date="2024">2024</year><data-title>A rapid phylogeny-based method for accurate community profiling of large-scale metabaroding datasets</data-title><source>Zenodo</source><pub-id pub-id-type="doi">10.5281/zenodo.13182507</pub-id></element-citation></p><p>The following previously published datasets were used:</p><p><element-citation publication-type="data" specific-use="references" id="dataset2"><person-group person-group-type="author"><name><surname>Schirmer</surname><given-names>M</given-names></name><name><surname>Ijaz</surname><given-names>UZ</given-names></name><name><surname>D'Amore</surname><given-names>R</given-names></name><name><surname>Hall</surname><given-names>N</given-names></name><name><surname>Sloan</surname><given-names>WT</given-names></name><name><surname>Quince</surname><given-names>C</given-names></name></person-group><year iso-8601-date="2015">2015</year><data-title>Mock community sequencing</data-title><source>NCBI Sequence Read Archive</source><pub-id pub-id-type="accession" xlink:href="https://trace.ncbi.nlm.nih.gov/Traces/?view=run_browser&amp;acc=ERR777705&amp;display=metadata">ERR777705</pub-id></element-citation></p><p><element-citation publication-type="data" specific-use="references" id="dataset3"><person-group person-group-type="author"><name><surname>Gohl</surname><given-names>DM</given-names></name><name><surname>Vangay</surname><given-names>P</given-names></name><name><surname>Garbe</surname><given-names>J</given-names></name><name><surname>MacLean</surname><given-names>A</given-names></name><name><surname>Hauge</surname><given-names>A</given-names></name><name><surname>Becker</surname><given-names>A</given-names></name><name><surname>Gould</surname><given-names>TJ</given-names></name><name><surname>Clayton</surname><given-names>JB</given-names></name><name><surname>Johnson</surname><given-names>TJ</given-names></name><name><surname>Hunter</surname><given-names>R</given-names></name><name><surname>Knights</surname><given-names>D</given-names></name><name><surname>Beckman</surname><given-names>KB</given-names></name></person-group><year iso-8601-date="2016">2016</year><data-title>16S Methods Comparison, raw sequence reads</data-title><source>NCBI Sequence Read Archive</source><pub-id pub-id-type="accession" xlink:href="https://trace.ncbi.nlm.nih.gov/Traces/?view=run_browser&amp;acc=SRR3163887&amp;display=metadata">SRR3163887</pub-id></element-citation></p><p><element-citation publication-type="data" specific-use="references" id="dataset4"><person-group person-group-type="author"><name><surname>Braukmann</surname><given-names>TWA</given-names></name><name><surname>Ivanova</surname><given-names>NV</given-names></name><name><surname>Prosser</surname><given-names>SWJ</given-names></name><name><surname>Elbrecht</surname><given-names>V</given-names></name><name><surname>Steinke</surname><given-names>D</given-names></name><name><surname>Ratnasingham</surname><given-names>S</given-names></name><name><surname>de Waard</surname><given-names>JR</given-names></name><name><surname>Sones</surname><given-names>JE</given-names></name><name><surname>Zakharov</surname><given-names>EV</given-names></name><name><surname>Hebert</surname><given-names>PDN</given-names></name></person-group><year iso-8601-date="2019">2019</year><data-title>Revealing the Complexities of Metabarcoding with a Diverse Arthropod Mock Community</data-title><source>NCBI Sequence Read Archive</source><pub-id pub-id-type="accession" xlink:href="https://trace.ncbi.nlm.nih.gov/Traces/?view=run_browser&amp;acc=SRR8082172&amp;display=metadata">SRR8082172</pub-id></element-citation></p><p><element-citation publication-type="data" specific-use="references" id="dataset5"><person-group person-group-type="author"><name><surname>Lluch</surname><given-names>J</given-names></name><name><surname>Servant</surname><given-names>F</given-names></name><name><surname>Paisse</surname><given-names>S</given-names></name><name><surname>Valle</surname><given-names>C</given-names></name><name><surname>Valiere</surname><given-names>S</given-names></name><name><surname>Kuchly</surname><given-names>C</given-names></name><name><surname>Vilchez</surname><given-names>G</given-names></name><name><surname>Donnadieu</surname><given-names>C</given-names></name><name><surname>Courtney</surname><given-names>M</given-names></name><name><surname>Burcelin</surname><given-names>R</given-names></name></person-group><year iso-8601-date="2015">2015</year><data-title>The characterization of novel tissue microbiota using an optimized 16S metagenomic sequencing pipeline</data-title><source>NCBI Sequence Read Archive</source><pub-id pub-id-type="accession" xlink:href="https://trace.ncbi.nlm.nih.gov/Traces/?view=run_browser&amp;acc=ERR1049842&amp;display=metadata">ERR1049842</pub-id></element-citation></p></sec><ack id="ack"><title>Acknowledgements</title><p>We thank Rachel Meyer and CALeDNA for their support in this project. We acknowledge Thorfinn Sand Korneliussen for advice on parallelization of the method. This work used the Advanced Cyberinfrastructure Coordination Ecosystem: Services &amp; Support (ACCESS) Bridges system at the Pittsburgh Supercomputing Center through allocation BIO180028 and was supported by NIH grants 1R01GM138634-01 and 1K99GM144747-01.</p></ack><ref-list><title>References</title><ref id="bib1"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Ainsworth</surname><given-names>D</given-names></name><name><surname>Sternberg</surname><given-names>MJE</given-names></name><name><surname>Raczy</surname><given-names>C</given-names></name><name><surname>Butcher</surname><given-names>SA</given-names></name></person-group><year iso-8601-date="2017">2017</year><article-title>k-SLAM: accurate and ultra-fast taxonomic classification and gene identification for large metagenomic data sets</article-title><source>Nucleic Acids Research</source><volume>45</volume><fpage>1649</fpage><lpage>1656</lpage><pub-id pub-id-type="doi">10.1093/nar/gkw1248</pub-id><pub-id pub-id-type="pmid">27965413</pub-id></element-citation></ref><ref id="bib2"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Altschul</surname><given-names>SF</given-names></name><name><surname>Gish</surname><given-names>W</given-names></name><name><surname>Miller</surname><given-names>W</given-names></name><name><surname>Myers</surname><given-names>EW</given-names></name><name><surname>Lipman</surname><given-names>DJ</given-names></name></person-group><year iso-8601-date="1990">1990</year><article-title>Basic local alignment search tool</article-title><source>Journal of Molecular Biology</source><volume>215</volume><fpage>403</fpage><lpage>410</lpage><pub-id pub-id-type="doi">10.1016/S0022-2836(05)80360-2</pub-id><pub-id pub-id-type="pmid">2231712</pub-id></element-citation></ref><ref id="bib3"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Amaral-Zettler</surname><given-names>LA</given-names></name><name><surname>McCliment</surname><given-names>EA</given-names></name><name><surname>Ducklow</surname><given-names>HW</given-names></name><name><surname>Huse</surname><given-names>SM</given-names></name></person-group><year iso-8601-date="2009">2009</year><article-title>A method for studying protistan diversity using massively parallel sequencing of V9 hypervariable regions of small-subunit ribosomal RNA genes</article-title><source>PLOS ONE</source><volume>4</volume><elocation-id>e6372</elocation-id><pub-id pub-id-type="doi">10.1371/journal.pone.0006372</pub-id><pub-id pub-id-type="pmid">19633714</pub-id></element-citation></ref><ref id="bib4"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Balaban</surname><given-names>M</given-names></name><name><surname>Sarmashghi</surname><given-names>S</given-names></name><name><surname>Mirarab</surname><given-names>SA</given-names></name></person-group><year iso-8601-date="2020">2020</year><article-title>APPLES: Scalable distance-based phylogenetic placement with or without alignments</article-title><source>Systematic Biology</source><volume>69</volume><fpage>566</fpage><lpage>578</lpage><pub-id pub-id-type="doi">10.1093/sysbio/syz063</pub-id><pub-id pub-id-type="pmid">31545363</pub-id></element-citation></ref><ref id="bib5"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Barbera</surname><given-names>P</given-names></name><name><surname>Kozlov</surname><given-names>AM</given-names></name><name><surname>Czech</surname><given-names>L</given-names></name><name><surname>Morel</surname><given-names>B</given-names></name><name><surname>Darriba</surname><given-names>D</given-names></name><name><surname>Flouri</surname><given-names>T</given-names></name><name><surname>Stamatakis</surname><given-names>A</given-names></name></person-group><year iso-8601-date="2019">2019</year><article-title>EPA-ng: Massively parallel evolutionary placement of genetic sequences</article-title><source>Systematic Biology</source><volume>68</volume><fpage>365</fpage><lpage>369</lpage><pub-id pub-id-type="doi">10.1093/sysbio/syy054</pub-id><pub-id pub-id-type="pmid">30165689</pub-id></element-citation></ref><ref id="bib6"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Braukmann</surname><given-names>TWA</given-names></name><name><surname>Ivanova</surname><given-names>NV</given-names></name><name><surname>Prosser</surname><given-names>SWJ</given-names></name><name><surname>Elbrecht</surname><given-names>V</given-names></name><name><surname>Steinke</surname><given-names>D</given-names></name><name><surname>Ratnasingham</surname><given-names>S</given-names></name><name><surname>de Waard</surname><given-names>JR</given-names></name><name><surname>Sones</surname><given-names>JE</given-names></name><name><surname>Zakharov</surname><given-names>EV</given-names></name><name><surname>Hebert</surname><given-names>PDN</given-names></name></person-group><year iso-8601-date="2019">2019</year><article-title>Metabarcoding a diverse arthropod mock community</article-title><source>Molecular Ecology Resources</source><volume>19</volume><fpage>711</fpage><lpage>727</lpage><pub-id pub-id-type="doi">10.1111/1755-0998.13008</pub-id><pub-id pub-id-type="pmid">30779309</pub-id></element-citation></ref><ref id="bib7"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Caporaso</surname><given-names>JG</given-names></name><name><surname>Lauber</surname><given-names>CL</given-names></name><name><surname>Walters</surname><given-names>WA</given-names></name><name><surname>Berg-Lyons</surname><given-names>D</given-names></name><name><surname>Huntley</surname><given-names>J</given-names></name><name><surname>Fierer</surname><given-names>N</given-names></name><name><surname>Owens</surname><given-names>SM</given-names></name><name><surname>Betley</surname><given-names>J</given-names></name><name><surname>Fraser</surname><given-names>L</given-names></name><name><surname>Bauer</surname><given-names>M</given-names></name><name><surname>Gormley</surname><given-names>N</given-names></name><name><surname>Gilbert</surname><given-names>JA</given-names></name><name><surname>Smith</surname><given-names>G</given-names></name><name><surname>Knight</surname><given-names>R</given-names></name></person-group><year iso-8601-date="2012">2012</year><article-title>Ultra-high-throughput microbial community analysis on the Illumina HiSeq and MiSeq platforms</article-title><source>The ISME Journal</source><volume>6</volume><fpage>1621</fpage><lpage>1624</lpage><pub-id pub-id-type="doi">10.1038/ismej.2012.8</pub-id><pub-id pub-id-type="pmid">22402401</pub-id></element-citation></ref><ref id="bib8"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Curd</surname><given-names>EE</given-names></name><name><surname>Gold</surname><given-names>Z</given-names></name><name><surname>Kandlikar</surname><given-names>GS</given-names></name><name><surname>Gomer</surname><given-names>J</given-names></name><name><surname>Ogden</surname><given-names>M</given-names></name><name><surname>O’Connell</surname><given-names>T</given-names></name><name><surname>Pipes</surname><given-names>L</given-names></name><name><surname>Schweizer</surname><given-names>TM</given-names></name><name><surname>Rabichow</surname><given-names>L</given-names></name><name><surname>Lin</surname><given-names>M</given-names></name><name><surname>Shi</surname><given-names>B</given-names></name><name><surname>Barber</surname><given-names>PH</given-names></name><name><surname>Kraft</surname><given-names>N</given-names></name><name><surname>Wayne</surname><given-names>R</given-names></name><name><surname>Meyer</surname><given-names>RS</given-names></name></person-group><year iso-8601-date="2019">2019</year><article-title><italic>Anacapa Toolkit</italic>: An environmental DNA toolkit for processing multilocus metabarcode datasets</article-title><source>Methods in Ecology and Evolution</source><volume>10</volume><fpage>1469</fpage><lpage>1475</lpage><pub-id pub-id-type="doi">10.1111/2041-210X.13214</pub-id></element-citation></ref><ref id="bib9"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Czech</surname><given-names>L</given-names></name><name><surname>Barbera</surname><given-names>P</given-names></name><name><surname>Stamatakis</surname><given-names>A</given-names></name></person-group><year iso-8601-date="2020">2020</year><article-title>Genesis and Gappa: processing, analyzing and visualizing phylogenetic (placement) data</article-title><source>Bioinformatics</source><volume>36</volume><fpage>3263</fpage><lpage>3265</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btaa070</pub-id><pub-id pub-id-type="pmid">32016344</pub-id></element-citation></ref><ref id="bib10"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Czech</surname><given-names>L</given-names></name><name><surname>Stamatakis</surname><given-names>A</given-names></name><name><surname>Dunthorn</surname><given-names>M</given-names></name><name><surname>Barbera</surname><given-names>P</given-names></name></person-group><year iso-8601-date="2022">2022</year><article-title>Metagenomic analysis using phylogenetic placement-a review of the first decade</article-title><source>Frontiers in Bioinformatics</source><volume>2</volume><elocation-id>871393</elocation-id><pub-id pub-id-type="doi">10.3389/fbinf.2022.871393</pub-id><pub-id pub-id-type="pmid">36304302</pub-id></element-citation></ref><ref id="bib11"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>David</surname><given-names>LA</given-names></name><name><surname>Maurice</surname><given-names>CF</given-names></name><name><surname>Carmody</surname><given-names>RN</given-names></name><name><surname>Gootenberg</surname><given-names>DB</given-names></name><name><surname>Button</surname><given-names>JE</given-names></name><name><surname>Wolfe</surname><given-names>BE</given-names></name><name><surname>Ling</surname><given-names>AV</given-names></name><name><surname>Devlin</surname><given-names>AS</given-names></name><name><surname>Varma</surname><given-names>Y</given-names></name><name><surname>Fischbach</surname><given-names>MA</given-names></name><name><surname>Biddinger</surname><given-names>SB</given-names></name><name><surname>Dutton</surname><given-names>RJ</given-names></name><name><surname>Turnbaugh</surname><given-names>PJ</given-names></name></person-group><year iso-8601-date="2014">2014</year><article-title>Diet rapidly and reproducibly alters the human gut microbiome</article-title><source>Nature</source><volume>505</volume><fpage>559</fpage><lpage>563</lpage><pub-id pub-id-type="doi">10.1038/nature12820</pub-id><pub-id pub-id-type="pmid">24336217</pub-id></element-citation></ref><ref id="bib12"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Deorowicz</surname><given-names>S</given-names></name><name><surname>Debudaj-Grabysz</surname><given-names>A</given-names></name><name><surname>Gudyś</surname><given-names>A</given-names></name></person-group><year iso-8601-date="2016">2016</year><article-title>FAMSA: Fast and accurate multiple sequence alignment of huge protein families</article-title><source>Scientific Reports</source><volume>6</volume><elocation-id>33964</elocation-id><pub-id pub-id-type="doi">10.1038/srep33964</pub-id><pub-id pub-id-type="pmid">27670777</pub-id></element-citation></ref><ref id="bib13"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>de Vargas</surname><given-names>C</given-names></name><name><surname>Audic</surname><given-names>S</given-names></name><name><surname>Henry</surname><given-names>N</given-names></name><name><surname>Decelle</surname><given-names>J</given-names></name><name><surname>Mahé</surname><given-names>F</given-names></name><name><surname>Logares</surname><given-names>R</given-names></name><name><surname>Lara</surname><given-names>E</given-names></name><name><surname>Berney</surname><given-names>C</given-names></name><name><surname>Le Bescot</surname><given-names>N</given-names></name><name><surname>Probert</surname><given-names>I</given-names></name><name><surname>Carmichael</surname><given-names>M</given-names></name><name><surname>Poulain</surname><given-names>J</given-names></name><name><surname>Romac</surname><given-names>S</given-names></name><name><surname>Colin</surname><given-names>S</given-names></name><name><surname>Aury</surname><given-names>JM</given-names></name><name><surname>Bittner</surname><given-names>L</given-names></name><name><surname>Chaffron</surname><given-names>S</given-names></name><name><surname>Dunthorn</surname><given-names>M</given-names></name><name><surname>Engelen</surname><given-names>S</given-names></name><name><surname>Flegontova</surname><given-names>O</given-names></name><name><surname>Guidi</surname><given-names>L</given-names></name><name><surname>Horák</surname><given-names>A</given-names></name><name><surname>Jaillon</surname><given-names>O</given-names></name><name><surname>Lima-Mendez</surname><given-names>G</given-names></name><name><surname>Lukeš</surname><given-names>J</given-names></name><name><surname>Malviya</surname><given-names>S</given-names></name><name><surname>Morard</surname><given-names>R</given-names></name><name><surname>Mulot</surname><given-names>M</given-names></name><name><surname>Scalco</surname><given-names>E</given-names></name><name><surname>Siano</surname><given-names>R</given-names></name><name><surname>Vincent</surname><given-names>F</given-names></name><name><surname>Zingone</surname><given-names>A</given-names></name><name><surname>Dimier</surname><given-names>C</given-names></name><name><surname>Picheral</surname><given-names>M</given-names></name><name><surname>Searson</surname><given-names>S</given-names></name><name><surname>Kandels-Lewis</surname><given-names>S</given-names></name><collab>Tara Oceans Coordinators</collab><name><surname>Acinas</surname><given-names>SG</given-names></name><name><surname>Bork</surname><given-names>P</given-names></name><name><surname>Bowler</surname><given-names>C</given-names></name><name><surname>Gorsky</surname><given-names>G</given-names></name><name><surname>Grimsley</surname><given-names>N</given-names></name><name><surname>Hingamp</surname><given-names>P</given-names></name><name><surname>Iudicone</surname><given-names>D</given-names></name><name><surname>Not</surname><given-names>F</given-names></name><name><surname>Ogata</surname><given-names>H</given-names></name><name><surname>Pesant</surname><given-names>S</given-names></name><name><surname>Raes</surname><given-names>J</given-names></name><name><surname>Sieracki</surname><given-names>ME</given-names></name><name><surname>Speich</surname><given-names>S</given-names></name><name><surname>Stemmann</surname><given-names>L</given-names></name><name><surname>Sunagawa</surname><given-names>S</given-names></name><name><surname>Weissenbach</surname><given-names>J</given-names></name><name><surname>Wincker</surname><given-names>P</given-names></name><name><surname>Karsenti</surname><given-names>E</given-names></name></person-group><year iso-8601-date="2015">2015</year><article-title>Ocean plankton. Eukaryotic plankton diversity in the sunlit ocean</article-title><source>Science</source><volume>348</volume><elocation-id>1261605</elocation-id><pub-id pub-id-type="doi">10.1126/science.1261605</pub-id><pub-id pub-id-type="pmid">25999516</pub-id></element-citation></ref><ref id="bib14"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Felsenstein</surname><given-names>J</given-names></name></person-group><year iso-8601-date="1981">1981</year><article-title>Evolutionary trees from DNA sequences: a maximum likelihood approach</article-title><source>Journal of Molecular Evolution</source><volume>17</volume><fpage>368</fpage><lpage>376</lpage><pub-id pub-id-type="doi">10.1007/BF01734359</pub-id><pub-id pub-id-type="pmid">7288891</pub-id></element-citation></ref><ref id="bib15"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gardner</surname><given-names>PP</given-names></name><name><surname>Watson</surname><given-names>RJ</given-names></name><name><surname>Morgan</surname><given-names>XC</given-names></name><name><surname>Draper</surname><given-names>JL</given-names></name><name><surname>Finn</surname><given-names>RD</given-names></name><name><surname>Morales</surname><given-names>SE</given-names></name><name><surname>Stott</surname><given-names>MB</given-names></name></person-group><year iso-8601-date="2019">2019</year><article-title>Identifying accurate metagenome and amplicon software via a meta-analysis of sequence to taxonomy benchmarking studies</article-title><source>PeerJ</source><volume>7</volume><elocation-id>e6160</elocation-id><pub-id pub-id-type="doi">10.7717/peerj.6160</pub-id><pub-id pub-id-type="pmid">30631651</pub-id></element-citation></ref><ref id="bib16"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Geller</surname><given-names>J</given-names></name><name><surname>Meyer</surname><given-names>C</given-names></name><name><surname>Parker</surname><given-names>M</given-names></name><name><surname>Hawk</surname><given-names>H</given-names></name></person-group><year iso-8601-date="2013">2013</year><article-title>Redesign of PCR primers for mitochondrial cytochrome c oxidase subunit I for marine invertebrates and application in all-taxa biotic surveys</article-title><source>Molecular Ecology Resources</source><volume>13</volume><fpage>851</fpage><lpage>861</lpage><pub-id pub-id-type="doi">10.1111/1755-0998.12138</pub-id><pub-id pub-id-type="pmid">23848937</pub-id></element-citation></ref><ref id="bib17"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gohl</surname><given-names>DM</given-names></name><name><surname>Vangay</surname><given-names>P</given-names></name><name><surname>Garbe</surname><given-names>J</given-names></name><name><surname>MacLean</surname><given-names>A</given-names></name><name><surname>Hauge</surname><given-names>A</given-names></name><name><surname>Becker</surname><given-names>A</given-names></name><name><surname>Gould</surname><given-names>TJ</given-names></name><name><surname>Clayton</surname><given-names>JB</given-names></name><name><surname>Johnson</surname><given-names>TJ</given-names></name><name><surname>Hunter</surname><given-names>R</given-names></name><name><surname>Knights</surname><given-names>D</given-names></name><name><surname>Beckman</surname><given-names>KB</given-names></name></person-group><year iso-8601-date="2016">2016</year><article-title>Systematic improvement of amplicon marker gene methods for increased accuracy in microbiome studies</article-title><source>Nature Biotechnology</source><volume>34</volume><fpage>942</fpage><lpage>949</lpage><pub-id pub-id-type="doi">10.1038/nbt.3601</pub-id><pub-id pub-id-type="pmid">27454739</pub-id></element-citation></ref><ref id="bib18"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Higgins</surname><given-names>DG</given-names></name><name><surname>Sharp</surname><given-names>PM</given-names></name></person-group><year iso-8601-date="1988">1988</year><article-title>CLUSTAL: a package for performing multiple sequence alignment on a microcomputer</article-title><source>Gene</source><volume>73</volume><fpage>237</fpage><lpage>244</lpage><pub-id pub-id-type="doi">10.1016/0378-1119(88)90330-7</pub-id><pub-id pub-id-type="pmid">3243435</pub-id></element-citation></ref><ref id="bib19"><element-citation publication-type="preprint"><person-group person-group-type="author"><name><surname>Hleap</surname><given-names>JS</given-names></name><name><surname>Littlefair</surname><given-names>JE</given-names></name><name><surname>Steinke</surname><given-names>D</given-names></name><name><surname>Hebert</surname><given-names>PDN</given-names></name><name><surname>Cristescu</surname><given-names>ME</given-names></name></person-group><year iso-8601-date="2020">2020</year><article-title>Assessment of Current Taxonomic Assignment Strategies for Metabarcoding Eukaryotes</article-title><source>bioRxiv</source><pub-id pub-id-type="doi">10.1101/2020.07.21.214270</pub-id></element-citation></ref><ref id="bib20"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Huson</surname><given-names>DH</given-names></name><name><surname>Auch</surname><given-names>AF</given-names></name><name><surname>Qi</surname><given-names>J</given-names></name><name><surname>Schuster</surname><given-names>SC</given-names></name></person-group><year iso-8601-date="2007">2007</year><article-title>MEGAN analysis of metagenomic data</article-title><source>Genome Research</source><volume>17</volume><fpage>377</fpage><lpage>386</lpage><pub-id pub-id-type="doi">10.1101/gr.5969107</pub-id><pub-id pub-id-type="pmid">17255551</pub-id></element-citation></ref><ref id="bib21"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Jukes</surname><given-names>TH</given-names></name><name><surname>Cantor</surname><given-names>CR</given-names></name></person-group><year iso-8601-date="1969">1969</year><article-title>Evolution of protein molecules</article-title><source>Mammalian Protein Metabolism</source><volume>3</volume><fpage>21</fpage><lpage>132</lpage><pub-id pub-id-type="doi">10.1016/B978-1-4832-3211-9.50009-7</pub-id></element-citation></ref><ref id="bib22"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kapli</surname><given-names>P</given-names></name><name><surname>Yang</surname><given-names>Z</given-names></name><name><surname>Telford</surname><given-names>MJ</given-names></name></person-group><year iso-8601-date="2020">2020</year><article-title>Phylogenetic tree building in the genomic age</article-title><source>Nature Reviews. Genetics</source><volume>21</volume><fpage>428</fpage><lpage>444</lpage><pub-id pub-id-type="doi">10.1038/s41576-020-0233-0</pub-id><pub-id pub-id-type="pmid">32424311</pub-id></element-citation></ref><ref id="bib23"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Katoh</surname><given-names>K</given-names></name><name><surname>Misawa</surname><given-names>K</given-names></name><name><surname>Kuma</surname><given-names>K</given-names></name><name><surname>Miyata</surname><given-names>T</given-names></name></person-group><year iso-8601-date="2002">2002</year><article-title>MAFFT: a novel method for rapid multiple sequence alignment based on fast Fourier transform</article-title><source>Nucleic Acids Research</source><volume>30</volume><fpage>3059</fpage><lpage>3066</lpage><pub-id pub-id-type="doi">10.1093/nar/gkf436</pub-id><pub-id pub-id-type="pmid">12136088</pub-id></element-citation></ref><ref id="bib24"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Langdon</surname><given-names>WB</given-names></name></person-group><year iso-8601-date="2015">2015</year><article-title>Performance of genetic programming optimised Bowtie2 on genome comparison and analytic testing (GCAT) benchmarks</article-title><source>BioData Mining</source><volume>8</volume><elocation-id>1</elocation-id><pub-id pub-id-type="doi">10.1186/s13040-014-0034-0</pub-id><pub-id pub-id-type="pmid">25621011</pub-id></element-citation></ref><ref id="bib25"><element-citation publication-type="software"><person-group person-group-type="author"><name><surname>Lefeuvre</surname><given-names>P</given-names></name></person-group><year iso-8601-date="2018">2018</year><data-title>Bossa: a bunch of structure and sequence analysis</data-title><version designator="version 1">version 1</version><source>R Package</source></element-citation></ref><ref id="bib26"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Leray</surname><given-names>M</given-names></name><name><surname>Yang</surname><given-names>JY</given-names></name><name><surname>Meyer</surname><given-names>CP</given-names></name><name><surname>Mills</surname><given-names>SC</given-names></name><name><surname>Agudelo</surname><given-names>N</given-names></name><name><surname>Ranwez</surname><given-names>V</given-names></name><name><surname>Boehm</surname><given-names>JT</given-names></name><name><surname>Machida</surname><given-names>RJ</given-names></name></person-group><year iso-8601-date="2013">2013</year><article-title>A new versatile primer set targeting A short fragment of the mitochondrial COI region for metabarcoding metazoan diversity: application for characterizing coral reef fish gut contents</article-title><source>Frontiers in Zoology</source><volume>10</volume><elocation-id>34</elocation-id><pub-id pub-id-type="doi">10.1186/1742-9994-10-34</pub-id><pub-id pub-id-type="pmid">23767809</pub-id></element-citation></ref><ref id="bib27"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Leray</surname><given-names>M</given-names></name><name><surname>Knowlton</surname><given-names>N</given-names></name></person-group><year iso-8601-date="2015">2015</year><article-title>DNA barcoding and metabarcoding of standardized samples reveal patterns of marine benthic diversity</article-title><source>PNAS</source><volume>112</volume><fpage>2076</fpage><lpage>2081</lpage><pub-id pub-id-type="doi">10.1073/pnas.1424997112</pub-id><pub-id pub-id-type="pmid">25646458</pub-id></element-citation></ref><ref id="bib28"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>H</given-names></name><name><surname>Durbin</surname><given-names>R</given-names></name></person-group><year iso-8601-date="2009">2009</year><article-title>Fast and accurate short read alignment with Burrows–Wheeler transform</article-title><source>Bioinformatics</source><volume>25</volume><fpage>1754</fpage><lpage>1760</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btp324</pub-id></element-citation></ref><ref id="bib29"><element-citation publication-type="preprint"><person-group person-group-type="author"><name><surname>Li</surname><given-names>H</given-names></name></person-group><year iso-8601-date="2013">2013</year><article-title>Aligning Sequence Reads, Clone Sequences and Assembly Contigs with Bwa-Mem</article-title><source>arXiv</source><ext-link ext-link-type="uri" xlink:href="https://arxiv.org/abs/1303.3997">https://arxiv.org/abs/1303.3997</ext-link></element-citation></ref><ref id="bib30"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>H</given-names></name></person-group><year iso-8601-date="2018">2018</year><article-title>Minimap2: pairwise alignment for nucleotide sequences</article-title><source>Bioinformatics</source><volume>34</volume><fpage>3094</fpage><lpage>3100</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/bty191</pub-id><pub-id pub-id-type="pmid">29750242</pub-id></element-citation></ref><ref id="bib31"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Lluch</surname><given-names>J</given-names></name><name><surname>Servant</surname><given-names>F</given-names></name><name><surname>Païssé</surname><given-names>S</given-names></name><name><surname>Valle</surname><given-names>C</given-names></name><name><surname>Valière</surname><given-names>S</given-names></name><name><surname>Kuchly</surname><given-names>C</given-names></name><name><surname>Vilchez</surname><given-names>G</given-names></name><name><surname>Donnadieu</surname><given-names>C</given-names></name><name><surname>Courtney</surname><given-names>M</given-names></name><name><surname>Burcelin</surname><given-names>R</given-names></name><name><surname>Amar</surname><given-names>J</given-names></name><name><surname>Bouchez</surname><given-names>O</given-names></name><name><surname>Lelouvier</surname><given-names>B</given-names></name></person-group><year iso-8601-date="2015">2015</year><article-title>The characterization of novel tissue microbiota using an optimized 16s metagenomic sequencing pipeline</article-title><source>PLOS ONE</source><volume>10</volume><elocation-id>e0142334</elocation-id><pub-id pub-id-type="doi">10.1371/journal.pone.0142334</pub-id><pub-id pub-id-type="pmid">26544955</pub-id></element-citation></ref><ref id="bib32"><element-citation publication-type="preprint"><person-group person-group-type="author"><name><surname>Lu</surname><given-names>J</given-names></name><name><surname>Salzberg</surname><given-names>SL</given-names></name></person-group><year iso-8601-date="2020">2020</year><article-title>Ultrafast and Accurate 16S Microbial Community Analysis Using Kraken 2</article-title><source>bioRxiv</source><pub-id pub-id-type="doi">10.1101/2020.03.27.012047</pub-id></element-citation></ref><ref id="bib33"><element-citation publication-type="software"><person-group person-group-type="author"><name><surname>Mapper</surname><given-names>M</given-names></name><name><surname>Pipes</surname><given-names>L</given-names></name></person-group><year iso-8601-date="2024">2024</year><data-title>Tronko</data-title><version designator="de10693">de10693</version><source>GitHub</source><ext-link ext-link-type="uri" xlink:href="https://github.com/lpipes/tronko">https://github.com/lpipes/tronko</ext-link></element-citation></ref><ref id="bib34"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Marco-Sola</surname><given-names>S</given-names></name><name><surname>Moure</surname><given-names>JC</given-names></name><name><surname>Moreto</surname><given-names>M</given-names></name><name><surname>Espinosa</surname><given-names>A</given-names></name></person-group><year iso-8601-date="2021">2021</year><article-title>Fast gap-affine pairwise alignment using the wavefront algorithm</article-title><source>Bioinformatics</source><volume>37</volume><fpage>456</fpage><lpage>463</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btaa777</pub-id><pub-id pub-id-type="pmid">32915952</pub-id></element-citation></ref><ref id="bib35"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Matsen</surname><given-names>FA</given-names></name><name><surname>Kodner</surname><given-names>RB</given-names></name><name><surname>Armbrust</surname><given-names>EV</given-names></name></person-group><year iso-8601-date="2010">2010</year><article-title>pplacer: linear time maximum-likelihood and Bayesian phylogenetic placement of sequences onto a fixed reference tree</article-title><source>BMC Bioinformatics</source><volume>11</volume><elocation-id>538</elocation-id><pub-id pub-id-type="doi">10.1186/1471-2105-11-538</pub-id><pub-id pub-id-type="pmid">21034504</pub-id></element-citation></ref><ref id="bib36"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Minh</surname><given-names>BQ</given-names></name><name><surname>Schmidt</surname><given-names>HA</given-names></name><name><surname>Chernomor</surname><given-names>O</given-names></name><name><surname>Schrempf</surname><given-names>D</given-names></name><name><surname>Woodhams</surname><given-names>MD</given-names></name><name><surname>von Haeseler</surname><given-names>A</given-names></name><name><surname>Lanfear</surname><given-names>R</given-names></name></person-group><year iso-8601-date="2020">2020</year><article-title>IQ-TREE 2: New models and efficient methods for phylogenetic inference in the genomic era</article-title><source>Molecular Biology and Evolution</source><volume>37</volume><fpage>1530</fpage><lpage>1534</lpage><pub-id pub-id-type="doi">10.1093/molbev/msaa015</pub-id><pub-id pub-id-type="pmid">32011700</pub-id></element-citation></ref><ref id="bib37"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Mistry</surname><given-names>J</given-names></name><name><surname>Finn</surname><given-names>RD</given-names></name><name><surname>Eddy</surname><given-names>SR</given-names></name><name><surname>Bateman</surname><given-names>A</given-names></name><name><surname>Punta</surname><given-names>M</given-names></name></person-group><year iso-8601-date="2013">2013</year><article-title>Challenges in homology search: HMMER3 and convergent evolution of coiled-coil regions</article-title><source>Nucleic Acids Research</source><volume>41</volume><elocation-id>e121</elocation-id><pub-id pub-id-type="doi">10.1093/nar/gkt263</pub-id><pub-id pub-id-type="pmid">23598997</pub-id></element-citation></ref><ref id="bib38"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Needleman</surname><given-names>SB</given-names></name><name><surname>Wunsch</surname><given-names>CD</given-names></name></person-group><year iso-8601-date="1970">1970</year><article-title>A general method applicable to the search for similarities in the amino acid sequence of two proteins</article-title><source>Journal of Molecular Biology</source><volume>48</volume><fpage>443</fpage><lpage>453</lpage><pub-id pub-id-type="doi">10.1016/0022-2836(70)90057-4</pub-id><pub-id pub-id-type="pmid">5420325</pub-id></element-citation></ref><ref id="bib39"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Paradis</surname><given-names>E</given-names></name><name><surname>Schliep</surname><given-names>K</given-names></name></person-group><year iso-8601-date="2019">2019</year><article-title>ape 5.0: an environment for modern phylogenetics and evolutionary analyses in R</article-title><source>Bioinformatics</source><volume>35</volume><fpage>526</fpage><lpage>528</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/bty633</pub-id><pub-id pub-id-type="pmid">30016406</pub-id></element-citation></ref><ref id="bib40"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Pipes</surname><given-names>L</given-names></name><name><surname>Nielsen</surname><given-names>R</given-names></name></person-group><year iso-8601-date="2022">2022</year><article-title>AncestralClust: clustering of divergent nucleotide sequences by ancestral sequence reconstruction using phylogenetic trees</article-title><source>Bioinformatics</source><volume>38</volume><fpage>663</fpage><lpage>670</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btab723</pub-id><pub-id pub-id-type="pmid">34668516</pub-id></element-citation></ref><ref id="bib41"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Schirmer</surname><given-names>M</given-names></name><name><surname>Ijaz</surname><given-names>UZ</given-names></name><name><surname>D’Amore</surname><given-names>R</given-names></name><name><surname>Hall</surname><given-names>N</given-names></name><name><surname>Sloan</surname><given-names>WT</given-names></name><name><surname>Quince</surname><given-names>C</given-names></name></person-group><year iso-8601-date="2015">2015</year><article-title>Insight into biases and sequencing errors for amplicon sequencing with the Illumina MiSeq platform</article-title><source>Nucleic Acids Research</source><volume>43</volume><elocation-id>e37</elocation-id><pub-id pub-id-type="doi">10.1093/nar/gku1341</pub-id><pub-id pub-id-type="pmid">25586220</pub-id></element-citation></ref><ref id="bib42"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Sczyrba</surname><given-names>A</given-names></name><name><surname>Hofmann</surname><given-names>P</given-names></name><name><surname>Belmann</surname><given-names>P</given-names></name><name><surname>Koslicki</surname><given-names>D</given-names></name><name><surname>Janssen</surname><given-names>S</given-names></name><name><surname>Dröge</surname><given-names>J</given-names></name><name><surname>Gregor</surname><given-names>I</given-names></name><name><surname>Majda</surname><given-names>S</given-names></name><name><surname>Fiedler</surname><given-names>J</given-names></name><name><surname>Dahms</surname><given-names>E</given-names></name><name><surname>Bremges</surname><given-names>A</given-names></name><name><surname>Fritz</surname><given-names>A</given-names></name><name><surname>Garrido-Oter</surname><given-names>R</given-names></name><name><surname>Jørgensen</surname><given-names>TS</given-names></name><name><surname>Shapiro</surname><given-names>N</given-names></name><name><surname>Blood</surname><given-names>PD</given-names></name><name><surname>Gurevich</surname><given-names>A</given-names></name><name><surname>Bai</surname><given-names>Y</given-names></name><name><surname>Turaev</surname><given-names>D</given-names></name><name><surname>DeMaere</surname><given-names>MZ</given-names></name><name><surname>Chikhi</surname><given-names>R</given-names></name><name><surname>Nagarajan</surname><given-names>N</given-names></name><name><surname>Quince</surname><given-names>C</given-names></name><name><surname>Meyer</surname><given-names>F</given-names></name><name><surname>Balvočiūtė</surname><given-names>M</given-names></name><name><surname>Hansen</surname><given-names>LH</given-names></name><name><surname>Sørensen</surname><given-names>SJ</given-names></name><name><surname>Chia</surname><given-names>BKH</given-names></name><name><surname>Denis</surname><given-names>B</given-names></name><name><surname>Froula</surname><given-names>JL</given-names></name><name><surname>Wang</surname><given-names>Z</given-names></name><name><surname>Egan</surname><given-names>R</given-names></name><name><surname>Don Kang</surname><given-names>D</given-names></name><name><surname>Cook</surname><given-names>JJ</given-names></name><name><surname>Deltel</surname><given-names>C</given-names></name><name><surname>Beckstette</surname><given-names>M</given-names></name><name><surname>Lemaitre</surname><given-names>C</given-names></name><name><surname>Peterlongo</surname><given-names>P</given-names></name><name><surname>Rizk</surname><given-names>G</given-names></name><name><surname>Lavenier</surname><given-names>D</given-names></name><name><surname>Wu</surname><given-names>Y-W</given-names></name><name><surname>Singer</surname><given-names>SW</given-names></name><name><surname>Jain</surname><given-names>C</given-names></name><name><surname>Strous</surname><given-names>M</given-names></name><name><surname>Klingenberg</surname><given-names>H</given-names></name><name><surname>Meinicke</surname><given-names>P</given-names></name><name><surname>Barton</surname><given-names>MD</given-names></name><name><surname>Lingner</surname><given-names>T</given-names></name><name><surname>Lin</surname><given-names>H-H</given-names></name><name><surname>Liao</surname><given-names>Y-C</given-names></name><name><surname>Silva</surname><given-names>GGZ</given-names></name><name><surname>Cuevas</surname><given-names>DA</given-names></name><name><surname>Edwards</surname><given-names>RA</given-names></name><name><surname>Saha</surname><given-names>S</given-names></name><name><surname>Piro</surname><given-names>VC</given-names></name><name><surname>Renard</surname><given-names>BY</given-names></name><name><surname>Pop</surname><given-names>M</given-names></name><name><surname>Klenk</surname><given-names>H-P</given-names></name><name><surname>Göker</surname><given-names>M</given-names></name><name><surname>Kyrpides</surname><given-names>NC</given-names></name><name><surname>Woyke</surname><given-names>T</given-names></name><name><surname>Vorholt</surname><given-names>JA</given-names></name><name><surname>Schulze-Lefert</surname><given-names>P</given-names></name><name><surname>Rubin</surname><given-names>EM</given-names></name><name><surname>Darling</surname><given-names>AE</given-names></name><name><surname>Rattei</surname><given-names>T</given-names></name><name><surname>McHardy</surname><given-names>AC</given-names></name></person-group><year iso-8601-date="2017">2017</year><article-title>Critical Assessment of Metagenome Interpretation-a benchmark of metagenomics software</article-title><source>Nature Methods</source><volume>14</volume><fpage>1063</fpage><lpage>1071</lpage><pub-id pub-id-type="doi">10.1038/nmeth.4458</pub-id><pub-id pub-id-type="pmid">28967888</pub-id></element-citation></ref><ref id="bib43"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Siegwald</surname><given-names>L</given-names></name><name><surname>Touzet</surname><given-names>H</given-names></name><name><surname>Lemoine</surname><given-names>Y</given-names></name><name><surname>Hot</surname><given-names>D</given-names></name><name><surname>Audebert</surname><given-names>C</given-names></name><name><surname>Caboche</surname><given-names>S</given-names></name></person-group><year iso-8601-date="2017">2017</year><article-title>Assessment of common and emerging bioinformatics pipelines for targeted metagenomics</article-title><source>PLOS ONE</source><volume>12</volume><elocation-id>e0169563</elocation-id><pub-id pub-id-type="doi">10.1371/journal.pone.0169563</pub-id><pub-id pub-id-type="pmid">28052134</pub-id></element-citation></ref><ref id="bib44"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Sievers</surname><given-names>F</given-names></name><name><surname>Wilm</surname><given-names>A</given-names></name><name><surname>Dineen</surname><given-names>D</given-names></name><name><surname>Gibson</surname><given-names>TJ</given-names></name><name><surname>Karplus</surname><given-names>K</given-names></name><name><surname>Li</surname><given-names>W</given-names></name><name><surname>Lopez</surname><given-names>R</given-names></name><name><surname>McWilliam</surname><given-names>H</given-names></name><name><surname>Remmert</surname><given-names>M</given-names></name><name><surname>Söding</surname><given-names>J</given-names></name><name><surname>Thompson</surname><given-names>JD</given-names></name><name><surname>Higgins</surname><given-names>DG</given-names></name></person-group><year iso-8601-date="2011">2011</year><article-title>Fast, scalable generation of high-quality protein multiple sequence alignments using Clustal Omega</article-title><source>Molecular Systems Biology</source><volume>7</volume><elocation-id>539</elocation-id><pub-id pub-id-type="doi">10.1038/msb.2011.75</pub-id><pub-id pub-id-type="pmid">21988835</pub-id></element-citation></ref><ref id="bib45"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Stamatakis</surname><given-names>A</given-names></name></person-group><year iso-8601-date="2014">2014</year><article-title>RAxML version 8: a tool for phylogenetic analysis and post-analysis of large phylogenies</article-title><source>Bioinformatics</source><volume>30</volume><fpage>1312</fpage><lpage>1313</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btu033</pub-id><pub-id pub-id-type="pmid">24451623</pub-id></element-citation></ref><ref id="bib46"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Stephens</surname><given-names>ZD</given-names></name><name><surname>Hudson</surname><given-names>ME</given-names></name><name><surname>Mainzer</surname><given-names>LS</given-names></name><name><surname>Taschuk</surname><given-names>M</given-names></name><name><surname>Weber</surname><given-names>MR</given-names></name><name><surname>Iyer</surname><given-names>RK</given-names></name></person-group><year iso-8601-date="2016">2016</year><article-title>Simulating next-generation sequencing datasets from empirical mutation and sequencing models</article-title><source>PLOS ONE</source><volume>11</volume><elocation-id>e0167047</elocation-id><pub-id pub-id-type="doi">10.1371/journal.pone.0167047</pub-id><pub-id pub-id-type="pmid">27893777</pub-id></element-citation></ref><ref id="bib47"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Truong</surname><given-names>DT</given-names></name><name><surname>Franzosa</surname><given-names>EA</given-names></name><name><surname>Tickle</surname><given-names>TL</given-names></name><name><surname>Scholz</surname><given-names>M</given-names></name><name><surname>Weingart</surname><given-names>G</given-names></name><name><surname>Pasolli</surname><given-names>E</given-names></name><name><surname>Tett</surname><given-names>A</given-names></name><name><surname>Huttenhower</surname><given-names>C</given-names></name><name><surname>Segata</surname><given-names>N</given-names></name></person-group><year iso-8601-date="2015">2015</year><article-title>MetaPhlAn2 for enhanced metagenomic taxonomic profiling</article-title><source>Nature Methods</source><volume>12</volume><fpage>902</fpage><lpage>903</lpage><pub-id pub-id-type="doi">10.1038/nmeth.3589</pub-id><pub-id pub-id-type="pmid">26418763</pub-id></element-citation></ref><ref id="bib48"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Wood</surname><given-names>DE</given-names></name><name><surname>Lu</surname><given-names>J</given-names></name><name><surname>Langmead</surname><given-names>B</given-names></name></person-group><year iso-8601-date="2019">2019</year><article-title>Improved metagenomic analysis with Kraken 2</article-title><source>Genome Biology</source><volume>20</volume><elocation-id>257</elocation-id><pub-id pub-id-type="doi">10.1186/s13059-019-1891-0</pub-id><pub-id pub-id-type="pmid">31779668</pub-id></element-citation></ref><ref id="bib49"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Yang</surname><given-names>Z</given-names></name><name><surname>Kumar</surname><given-names>S</given-names></name><name><surname>Nei</surname><given-names>M</given-names></name></person-group><year iso-8601-date="1995">1995</year><article-title>A new method of inference of ancestral nucleotide and amino acid sequences</article-title><source>Genetics</source><volume>141</volume><fpage>1641</fpage><lpage>1650</lpage><pub-id pub-id-type="doi">10.1093/genetics/141.4.1641</pub-id><pub-id pub-id-type="pmid">8601501</pub-id></element-citation></ref><ref id="bib50"><element-citation publication-type="preprint"><person-group person-group-type="author"><name><surname>Zaharia</surname><given-names>M</given-names></name><name><surname>Bolosky</surname><given-names>WJ</given-names></name><name><surname>Curtis</surname><given-names>K</given-names></name><name><surname>Fox</surname><given-names>A</given-names></name><name><surname>Patterson</surname><given-names>D</given-names></name></person-group><year iso-8601-date="2011">2011</year><article-title>Faster and More Accurate Sequence Alignment with Snap</article-title><source>arXiv</source><ext-link ext-link-type="uri" xlink:href="https://arxiv.org/abs/1111.5572">https://arxiv.org/abs/1111.5572</ext-link></element-citation></ref></ref-list></back><sub-article article-type="editor-report" id="sa0"><front-stub><article-id pub-id-type="doi">10.7554/eLife.85794.sa0</article-id><title-group><article-title>Editor's evaluation</article-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>Moshiri</surname><given-names>Niema</given-names></name><role specific-use="editor">Reviewing Editor</role><aff><institution-wrap><institution-id institution-id-type="ror">https://ror.org/0168r3w48</institution-id><institution>University of California, San Diego</institution></institution-wrap><country>United States</country></aff></contrib></contrib-group><related-object id="sa0ro1" object-id-type="id" object-id="10.1101/2022.12.06.519402" link-type="continued-by" xlink:href="https://sciety.org/articles/activity/10.1101/2022.12.06.519402"/></front-stub><body><p>This important work presents a novel tool for performing phylogenetic assignment of DNA sequences. The manuscript is convincing, and the authors perform a standard benchmark experiment against current state-of-the-art tools using real + simulated datasets to demonstrate where the novel tool stands in the context of existing methods. This paper will be of great interest to bioinformaticians and evolutionary biologists interested in massively-scalable phylogenetic assignment.</p></body></sub-article><sub-article article-type="decision-letter" id="sa1"><front-stub><article-id pub-id-type="doi">10.7554/eLife.85794.sa1</article-id><title-group><article-title>Decision letter</article-title></title-group><contrib-group content-type="section"><contrib contrib-type="editor"><name><surname>Moshiri</surname><given-names>Niema</given-names></name><role>Reviewing Editor</role><aff><institution-wrap><institution-id institution-id-type="ror">https://ror.org/0168r3w48</institution-id><institution>University of California, San Diego</institution></institution-wrap><country>United States</country></aff></contrib></contrib-group><contrib-group><contrib contrib-type="reviewer"><name><surname>Moshiri</surname><given-names>Niema</given-names></name><role>Reviewer</role><aff><institution-wrap><institution-id institution-id-type="ror">https://ror.org/0168r3w48</institution-id><institution>University of California, San Diego</institution></institution-wrap><country>United States</country></aff></contrib><contrib contrib-type="reviewer"><name><surname>Goldman</surname><given-names>Nick</given-names></name><role>Reviewer</role><aff><institution-wrap><institution-id institution-id-type="ror">https://ror.org/02catss52</institution-id><institution>EMBL-European Bioinformatics Institute</institution></institution-wrap><country>United Kingdom</country></aff></contrib></contrib-group></front-stub><body><boxed-text id="sa2-box1"><p>Our editorial process produces two outputs: i) <ext-link ext-link-type="uri" xlink:href="https://sciety.org/articles/activity/10.1101/2022.12.06.519402">public reviews</ext-link> designed to be posted alongside <ext-link ext-link-type="uri" xlink:href="https://www.biorxiv.org/content/10.1101/2022.12.06.519402v1">the preprint</ext-link> for the benefit of readers; ii) feedback on the manuscript for the authors, including requests for revisions, shown below. We also include an acceptance summary that explains what the editors found interesting or important about the work.</p></boxed-text><p><bold>Decision letter after peer review:</bold></p><p>Thank you for submitting your article &quot;A rapid phylogeny-based method for accurate community profiling of large-scale metabarcoding datasets&quot; for consideration by <italic>eLife</italic>. Your article has been reviewed by 3 peer reviewers, including Niema Moshiri as the Reviewing Editor and Reviewer #1, and the evaluation has been overseen by Wendy Garrett as the Senior Editor. The following individual involved in review of your submission has agreed to reveal their identity: Nick Goldman (Reviewer #3).</p><p>The reviewers have discussed their reviews with one another, and the Reviewing Editor has drafted this to help you prepare a revised submission.</p><p>Essential revisions:</p><p>1) There were some concerns that the data sets that were chosen in the manuscript might not be well-aligned with real-world use cases for the tool, and that other data sets could be included that better represent real-world use cases; see Reviews below for specific comments. The realism of the chosen data sets should be justified, and/or datasets more representative of real-world scenarios could be included.</p><p>2) The manuscript includes some comparisons between Tronko and pplacer, and it excludes pplacer from the benchmark experiment due to pplacer's inability to scale to the necessary dataset sizes (which is perfectly reasonable). However, a recently published tool named APPLES (Balaban et al., 2020; https://doi.org/10.1093/sysbio/syz063) seems to be able to perform taxonomic classification using phylogenetic placement in a similar manner as pplacer (i.e., by feeding the output phylogenetic placement file to guppy to output taxonomic classifications). The following tutorial by the authors of APPLES seems to present this &quot;APPLES to guppy&quot; workflow:</p><p>https://github.com/smirarab/tutorials/blob/master/Skmer-APPLES-tutorial.md#run-actual-placement</p><p>The Reviewers were unsure about whether or not APPLES (as a potential substitute for pplacer) would be a reasonable alternative for Tronko. If APPLES is a reasonable alternative for Tronko, we request that it be included in any existing benchmarks in which Tronko was compared against pplacer. If APPLES is not a reasonable alternative for Tronko (and should thus not be included in the existing comparison), we request additional details in the introduction of the manuscript describing why APPLES is inappropriate for this task.</p><p>3) Some choices were made without clear justification (e.g. the use of specific dependency tools as well as parameter selection for those tools), and these choices require some form of justification and/or discussion/exploration; see Reviews below for specific comments.</p><p>4) There were technical issues/errors with the distribution of the tool that need to be fixed; see Reviews below for specific errors/scenarios as well as some potential suggestions.</p><p>5) There are minor issues with the writing of the manuscript itself that should be updated/corrected; see Reviews below for specific comments/suggestions.</p><p><italic>Reviewer #1 (Recommendations for the authors):</italic></p><p>First, some technical questions about the methodology:</p><p>How is the accuracy impacted by potential errors in the multiple sequence alignment (MSA) and phylogenetic inference procedure? For example, what if someone were to use e.g. MAFFT (Katoh et al., 2002) for MSA followed by FastTree 2 (Price et al., 2010) or IQ-TREE (Nguyen et al., 2015) or matOptimize (Ye et al., 2022) for phylogenetic inference instead of the Tronko-build approach? Or perhaps existing joint MSA + tree inference tools like PASTA (Mirarab et al., 2015)?</p><p>Why were existing phylogenetic placement tools excluded, such as UShER (Turakhia et al., 2021), APPLES (Balaban et al., 2019), SEPP (Mirarab et al., 2012), TIPP (Nguyen et al., 2014), or UPP (Nguyen et al., 2015)? The authors exclude pplacer due to runtime + memory intensity, but they did not provide rationale for providing the many other existing phylogenetic placement methods. My understanding is that UShER is supposed to be *extremely* fast and quite memory-efficient.</p><p>Tronko currently supports two BWA-MEM modes (Needleman-Wunsch and Wavefront Alignment), but rather than just supporting BWA-MEM, what about other potential aligners? For example, if one were to use Minimap2 to perform alignment instead, how would the results + runtime + memory requirements change?</p><p>The manuscript explains that the high memory usage is because of all of the things Tronko needs to store in memory the entire time, but (1) do all of those things really need to be stored in memory simultaneously, and (2) could some form of compressive encoding (e.g. 2-bit encoding for reference genomes) be used to reduce memory usage? 50 GB is reasonable for high-end modern servers, but I think it can be dramatically reduced with clever optimizations. I think the discussion of the peak memory requirements would benefit from more thorough exploration of what exactly is contributing to the large memory consumption (e.g. what proportion of it is from storing the trees, or the reference genomes, or the posterior probabilities, etc.).</p><p>Now, general comments about the paper:</p><p>The paper is generally well-written and reads fairly clearly, but my main concern is about some choices in the methodology that were (seemingly) somewhat arbitrarily chosen without providing justification. For example, BWA-MEM was chosen for mapping; why that choice rather than other mappers? And why are the default parameters appropriate? RAxML was chosen for phylogenetic inference; why that choice rather than other tree inference tools? And why default parameters with GTR+Γ model (rather than GTR+Γ+Invariant, or GTR+CAT, or GTR+CAT+Invariant, etc.)? In addition to my technical questions above about how changing these choices would impact results, my general comment here is that all choices should be motivated in some way within the text.</p><p>Both panels of Figure 6 should be log-scale: as they're currently presented in linear-scale, it's impossible to meaningfully discern differences between the smaller lines.</p><p><italic>Reviewer #2 (Recommendations for the authors):</italic></p><p>## Overall comments</p><p>The manuscript is hard to read top-to-bottom, and would be easier if you gave a little more of an overview of the method before giving results. The figure 1 caption, for example, can't really be understood without getting to P14. Figure 1 itself can't really be understood without understanding the cutoff parameter.</p><p>Please make it clear from the get-go that this is amplicon sequencing and not true metagenomics. The tool is compared to Kraken which does true metagenomics.</p><p>If I am understanding correctly, the database input for the method requires a tree annotated with taxonomic labels at all nodes of the tree. If that's right, what is the process for doing this labeling? What if the taxonomy and the tree disagree?</p><p>The paper doesn't compare to APPLES (reference 8) which is phylogenetic but distance-based and therefore should be faster, but is probably less accurate. This isn't necessary for a revision, but it would be interesting to understand if performance gaps are due to phylogeny or likelihood-based phylogeny.</p><p>## Details</p><p>Please number lines. This makes reviewing much easier.</p><p>P2 &quot;There are three…&quot;: I suggest using (1), (2), (3) in this sentence to make it clearer rather than just rely on commas.</p><p>P3 Tandy Warnow has worked on a number of approaches to scaling likelihood-based phylogenetic placement, e.g. https://www.biorxiv.org/content/10.1101/2022.10.26.513936v1.full.pdf which also uses a collection of trees.</p><p>P7 It seems like you are using a different cutoff for the different comparisons. Can you justify that?</p><p>P12 &quot;lenghts&quot; typo</p><p>P12 The two-pass algorithm is linear time, and this seems to me like the standard two-pass algorithm. We can get the required posterior probabilities from the upward and downward partial likelihood vectors. What am I missing? If there is something subtle, some more explanation and notation is needed.</p><p>P12 To get an assignment to node i, does i and its children need to get a given taxonomic assignment? The text reads as if only the children need taxonomic assignments.</p><p>P13 Why I and V? I know they are arbitrary but it seems like an odd choice.</p><p>P13 What is the intuition for the definition of variance? If we were to try to write this as the variance of a random variable, what would it be? It seems like this definition is similar to that for the centroid of the tree. If that's the case, why not use that more common object?</p><p>P14 Perhaps &quot;written&quot; rather than &quot;printed&quot;? Is there a specific format to this file, like JSON, or is it fully custom?</p><p>P15 Notation would be cleaner if you just used a single P for posterior probability, or \mathbb{P}. use &quot;\log&quot;. Suggest display equation for phylogenetic likelihood.</p><p>P16 Interesting that this classifies N as a gap. Sometimes Ns are ambiguous sequencing calls.</p><p>P16 What is m(1)?</p><p>Figure 2: I found &quot;error/polymorphism&quot; confusing, as at first I thought it was the ratio of the two. Suggest just &quot;error&quot; in the figure and caption, and note in the text that it could be in fact polymorphism. Also, there are lots of triangles for Tronko. Please introduce in the text what the cut-off is. You state that there is a cut-off on P4, and hopefully in one additional sentence you could give an intuition. Font is too small.</p><p>Figure 3: These &quot;rainbow&quot; schemes are now not in favor compared to color schemes like viridis and variants; see https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0199239</p><p>Figure 6: Please consider color scheme, the yellow is basically invisible.</p><p>Figure S4. I'm not sure what &quot;assignment rate&quot; is. Is the fraction of time the program produced any result? Could you label the Tronko lines with Tronko?</p><p>All Figure legends should identify the gene target and data set.</p><p><italic>Reviewer #3 (Recommendations for the authors):</italic></p><p>We have divided most of our considerations into three areas, regarding (a) the methods that this ms. introduces, (b) the results that they produce and (c) the Tronko software.</p><p>(a) The methods take familiar ground as their starting point, and then take a new direction in terms of approximations and shortcuts to implement something resembling a full probabilistic (maximum likelihood) inference technique, but fast enough and with low-enough memory requirement to be practical for modern-sized datasets (reference and sample). We need no convincing that this is a valid approach, and is sufficient for the methods proposed to be of value if they produce good-enough results.</p><p>That said, there were a few instances of other relevant work not being quoted that I think would be of interest to some readers. We don't think this ms. needs to address all these points in a detailed manner, but where other relevant work has not been cited then readers can reasonably ask whether Pipes and Nielsen are unaware or have simply decided not to incorporate some other existing ideas; or whether they tried to incorporate ideas that ultimately did not work; whether some alternative concepts are somehow incompatible with the approach they did take; or whether there is some other reason. Some specific examples we are curious about and would like to see discussed in this manuscript:</p><p>* what about methods that combine composition-based (kmer) and phylogenetic approaches, essentially replacing likelihood calculations with kmer statistics in a phylogenetic framework? See work like https://academic.oup.com/bioinformatics/article/35/18/3303/5303992 and others from that group, including recent work by Romashchenko</p><p>* since the ms. argues so strongly for the benefits of phylogenetic methods, it would be interesting to see how the authors consider Tronko to compare to phylogeny-based methods other than pplacer, for example papara and PAGAN and others e.g. mentioned in https://www.frontiersin.org/articles/10.3389/fbinf.2022.871393/full</p><p>(b) The results seem convincing and reasonable metrics were used for evaluation. However,</p><p>* since the method's highlight is incorporating phylogeny, it would be interesting to see some comparisons of results using a metric that takes phylogeny into account. For example, while calculating accuracy of taxonomic assignment, instead of using a binary score (correct/incorrect), could you calculate a distance between assignment and real value? A measure of how wrong incorrect assignments could be of relevance to many users in terms of biological interpretations. Arguably, a tool that misassigns to close species would be preferable over another that misassigns to further species</p><p>* very poor performances of some tools in mock community analyses might make readers ask if the default parameters of the tools were right or not for this comparison. For example, for Braukmann et al. data the authors say &quot;MEGAN did not assign any reads at the species or genus level&quot;</p><p>* some claims about other methods' results being dominated by Tronko based on the convex hull seem a bit overstated, when there has been no investigation of how the other methods' recall/misclassification response curves could appear if other parameter settings were used</p><p>(c) Tronko software is publically available on GitHub with clear documentation, example files, and working example commands. Nevertheless there is room for improvement for Tronko to be widely utilised by the community:</p><p>* The software installation and execution can be tested on a few different computers and ideally operating systems. We failed to install the software from the source but Singularity installation works fine.</p><p>* tronko-build input files are preprocessed with multiple softwares. Although the authors provide example files, there is not a guide on how to create those files for our own gene of interest. A couple of sentences (or maybe more, for users who are not so familiar with the data types and analyses involved) about how those files were prepared would be very helpful.</p><p>* tronko-build example files include some files with double extensions (e.g..fasta.ann). These are not mentioned in the readme. It is not clear what they are. They are not mentioned in the inputs of the command nor did they appear in the output directory when we ran it.</p></body></sub-article><sub-article article-type="reply" id="sa2"><front-stub><article-id pub-id-type="doi">10.7554/eLife.85794.sa2</article-id><title-group><article-title>Author response</article-title></title-group></front-stub><body><disp-quote content-type="editor-comment"><p>Essential revisions:</p><p>1) There were some concerns that the data sets that were chosen in the manuscript might not be well-aligned with real-world use cases for the tool, and that other data sets could be included that better represent real-world use cases; see Reviews below for specific comments. The realism of the chosen data sets should be justified, and/or datasets more representative of real-world scenarios could be included.</p></disp-quote><p>By ”real-world scenarios,” we interpreted this feedback to mean the inclusion of more heterogeneous bacterial data sets. In response, we have added more bacteria datasets including 9 missing out tests (Figures 5, S5, and S6) and an additional mock community dataset from Lluch et al. (2015) (Figures 6B and S9). For the missing out tests we include this description on how that dataset was made:</p><p>”In order to replicate real-world scenarios, we added a leave-one-species-out test using 16S from 2,323 bacterial species and 5,000 individual sequences (Figure 5). We selected the sequences for the 16S dataset by grouping the sequences by the class level in a random order, rotating that order, and randomly selecting an individual sequence from each group.”</p><p>Lluch et al. (2015) designed a mock community that was prepared by cloning the complete 16S rDNA gene of 14 different bacterial species. This inclusions aim to better represent practical applications and enhance the relevance of our method to real-world use cases.</p><disp-quote content-type="editor-comment"><p>2) The manuscript includes some comparisons between Tronko and pplacer, and it excludes pplacer from the benchmark experiment due to pplacer's inability to scale to the necessary dataset sizes (which is perfectly reasonable). However, a recently published tool named APPLES (Balaban et al., 2020; https://doi.org/10.1093/sysbio/syz063) seems to be able to perform taxonomic classification using phylogenetic placement in a similar manner as pplacer (i.e., by feeding the output phylogenetic placement file to guppy to output taxonomic classifications). The following tutorial by the authors of APPLES seems to present this &quot;APPLES to guppy&quot; workflow:</p><p>https://github.com/smirarab/tutorials/blob/master/Skmer-APPLES-tutorial.md#run-actual-placement</p><p>The Reviewers were unsure about whether or not APPLES (as a potential substitute for pplacer) would be a reasonable alternative for Tronko. If APPLES is a reasonable alternative for Tronko, we request that it be included in any existing benchmarks in which Tronko was compared against pplacer. If APPLES is not a reasonable alternative for Tronko (and should thus not be included in the existing comparison), we request additional details in the introduction of the manuscript describing why APPLES is inappropriate for this task.</p></disp-quote><p>In the revised version of the manuscript, we compare against pplacer and APPLES-2 for all datasets where it was feasible. We were not able to include these methods for comparisons in the mock community datasets for the reason that we were unable to construct a multiple sequence alignment that included the entire barcode’s database and the sequencing reads. We attempted to make a multiple sequence alignment for the COI barcode using PASTA (Mirarab et al., 2014) but we abandoned this attempt after the job ran for more than 2 weeks.</p><p>Tronko is able to construct a reference database for large databases (i.e., COI reference sequences) because it does not require aligned sequences. We use a method (AncestralClust) that we developed previously to first cluster the sequences, and we align sequences in each cluster. Tronko can take as input a series of trees rather than just one large tree. We describe exactly how these trees were constructed in the Methods in the section ’Custom 16S and COITronko-build reference database construction’.</p><p>We added a description of assigning taxonomy using pplacer in the Methods under ”Taxonomic assignment using pplacer”:</p><p>”To generate phylogenetic placements using pplacer, we first aligned sequencing reads to the reference sequences using hmmer. We then ran pplacer, rppr prep db, and guppy classify all using the default parameters in that order. Next, we used the R package BoSSA to merge the multiclass (which is a a data frame with the taxonomic assignments of each placement) and the placement table of pplace object (the output of pplacer) and only kept the ”best” type of placement for each read. For paired-end sequences, we assigned the taxonomy by the LCA of both pairs of reads.”</p><p>Additionally, we added a description of assigning taxonomy using APPLES-2 in the Methods under ”Taxonomic assignment using APPLES-2”:</p><p>”To generate phylogenetic placements using APPLES-2. We first aligned sequencing reads to the reference sequences using hmmer. We then converted the alignment output from Stockholm to FASTA format and then separated the reference sequences from the sequencing reads (an input requirement for APPLES-2) using in-house scripts. We then ran run_apples.py with the default parameters. In order to ensure that the tree that was output from APPLES-2 was strictly binary (a requirement to assign taxonomy), we extracted the tree from the jplace output and resolved polytomies using the multi2di function from the R package ape. Next, we ran run apples.py again using the output tree from ape (with option –tree=) and disabled reestimation of branch lengths (in order to keep the tree as strictly binary) by using the option –disable reestimation. To assign taxonomy we ran gappa examine assign from the Gappa toolkit using the options –per-query- results and –best-hit.”</p><p>We ended up having to run APPLES-2 twice (one time to obtain the tree that had consistent placements and the next time to have the placements on a strictly binary tree) because of the issue with the resulting polytomies. We reached out to the first author of ”Environmental DNA metabarcoding of Danish soil samples reveals new insight into the hidden diversity of eutardigrades in Denmark”, Frida Pust, to understand how they were able to obtain taxonomic assignments from APPLES-2. They stated ”I did the taxonomic assignment manually. When my tree had polytomies, I did not trust the placement and simple assigned to genus-level or above – manually. I only had around 100 sequences, so it was not too bad.”</p><p>In addition to adding pplacer and APPLES-2 comparisons whenever possible, we added a comparison of APPLES-2 in terms of its speed and memory in Figure S7.</p><p>When we included pplacer and APPLES-2 comparisons, we noticed that these methods perform worse than kraken2 for species level assignments (using a leave-one-individual-out test). As we looked closer at this unexpected issue, we have determined that it is due to choosing the placement in the tree with the highest likelihood, when there are many places in the tree with a similar likelihood. Therefore, the highest likelihood is random because of the optimization. Currently, there is no method that combines the likelihoods, realizes that they are the same, and calculates the LCA. We removed pplacer and APPLES-2 from the main figure (Figure 4) because of this issue of poor species level assignment we only show these results in Supplementary Figure S5. Additionally, we added this to the text:</p><p>”We believe it would be slightly misleading to display results for pplacer and APPLES-2 here due to the lack of an implementation to calculate the LCA on similar likelihoods.”</p><p>Similarly, with Figure 5G-I, we do not display APPLES-2 because of its poor performance, which we deem as misleading. The results for Figure 5 (paired-end, single-end 150bp, and 300bp) are not directly comparable. For this analysis using 300bp leave-one-species-out test, only 105 out of 2,310, number of species had a reference sequence that was &gt;=300bp in length. For reference sequences &lt;300bp, we could not perform leave-one-species-out. We added the following text:</p><p>”The simulations for 300bp single-end reads are not directly comparable to the 150bp single-end or paired-end reads because only 105 missing-out tests out of 2,310 were able to be performed because most reference sequence were &lt;300bp in length. We only display the results for 300bp single-end reads for APPLES-2 in the supplement, as we believe the results are not a good representation of the method. See Figure S6 for results for APPLES-2 using 300bp single-end reads along with results using the Wavefront alignment algorithm.”</p><disp-quote content-type="editor-comment"><p>3) Some choices were made without clear justification (e.g. the use of specific dependency tools as well as parameter selection for those tools), and these choices require some form of justification and/or discussion/exploration; see Reviews below for specific comments.</p></disp-quote><p>For tronko-build we use FAMSA and RAxML. Our justification for using FAMSA over other multiple sequence aligners is its speed. We added this text:</p><p>”FAMSA is used to optimize for speed since it is 1 to 2 orders of magnitude faster than Clustal or MAFFT with similar quality (see Deorowicz et al., 2016).”</p><p>We use FAMSA with its default parameters. As for the use of RAxML. We use this as the standard model in phylogenetics we used GTR+Γ and it is beyond the scope of the manuscript to explore general model fit. As the standard model in phylogenetics we used GTR+Γ but we realized that other models could also have been explored. And perhaps with different datasets what leads to the best phylogenetics accuracy depends on the amount of data and the particular details of the molecular evolution of the markers used and species. While the GTR+Γ models has proven to be identifiable, the original proofs of identifiably for the GTR+Γ+I model have been shown to be invalid and no such proof has been provided to date (Allman et al., 2016). We therefore choose the GTR+Γ model rather than the GTR+Γ+I model.</p><p>For tronko-assign, we use two alignment steps. At the first step, we use a short read mapper, bwa-mem, to find the best hit. In Heng Li’s ”Minimap2: pairwise alignment for nucleotide sequences”, he performs a comparison of Minimap2, bwamem, bowtie2, and snap. As demonstrated in Figure 1b of the manuscript, bwa-mem has the lowest error rate for the same amount of fractional mapped reads. The manuscript also states ”Minimap2 is more accurate on this simulated dataset than Bowtie2 and SNAP but less accurate than BWA-MEM”. We added this text:</p><p>”We use BWA-MEM as the original Minimap2 manuscript demonstrated that BWA-MEM had the lowest error rate for the same amount of fractional mapped reads when compared to Minimap2, SNAP, and bowtie2.”</p><p>Generally, which aligner to use is an interesting problem. As aligners improve in the future that will continue to be an active research problem but it is beyond the scope of this manuscript.</p><disp-quote content-type="editor-comment"><p>4) There were technical issues/errors with the distribution of the tool that need to be fixed; see Reviews below for specific errors/scenarios as well as some potential suggestions.</p></disp-quote><p>We address this in our responses to the specific comments below.</p><disp-quote content-type="editor-comment"><p>5) There are minor issues with the writing of the manuscript itself that should be updated/corrected; see Reviews below for specific comments/suggestions.</p></disp-quote><p>We address this in our responses to the specific comments below.</p><disp-quote content-type="editor-comment"><p>Reviewer #1 (Recommendations for the authors):</p><p>First, some technical questions about the methodology:</p><p>How is the accuracy impacted by potential errors in the multiple sequence alignment (MSA) and phylogenetic inference procedure? For example, what if someone were to use e.g. MAFFT (Katoh et al., 2002) for MSA followed by FastTree 2 (Price et al., 2010) or IQ-TREE (Nguyen et al., 2015) or matOptimize (Ye et al., 2022) for phylogenetic inference instead of the Tronko-build approach?</p></disp-quote><p>The reason for not using FastTree2 is that our taxonomic assignment algorithm is not designed to work on trees that contain polytomies. The reason for not using mat Optimize is that it is a maximum parsimony based tree optimization method. Maximum likelihood provides more accurate and reliable phylogenetic trees by incorporating detailed evolutionary models and probabilistic frameworks. IQ-TREE2 is considerably slower than RAxML. On just one of our missing out tests, IQ-TREE2 took 37 minutes and RAxML took just 11 minutes when running on a single thread.</p><p>Nevertheless, we have included an analysis Figure S3 where we tested different combinations of aligners and tree estimation methods. In this analysis, the impact of the choice of method was minimal.</p><disp-quote content-type="editor-comment"><p>Or perhaps existing joint MSA + tree inference tools like PASTA (Mirarab et al., 2015)?</p></disp-quote><p>As we previously mentioned, we attempted to use PASTA on our CO1 reference database of &gt;1.5 million sequences, but this job did not finish in any meaningful time.</p><disp-quote content-type="editor-comment"><p>Why were existing phylogenetic placement tools excluded, such as UShER (Turakhia et al., 2021), APPLES (Balaban et al., 2019), SEPP (Mirarab et al., 2012), TIPP (Nguyen et al., 2014), or UPP (Nguyen et al., 2015)? The authors exclude pplacer due to runtime + memory intensity, but they did not provide rationale for providing the many other existing phylogenetic placement methods. My understanding is that UShER is supposed to be *extremely* fast and quite memory-efficient.</p></disp-quote><p>UShER, unlike other placement methods, requires a VCF file as input. VCF format is designed to report variations relative to a single reference sequence (not many reference sequences like as in the case of a metabarcode). We now include APPLES-2 and pplacer whenever possible for all datasets examined. SEPP runs pplacer internally and thus has the same speed and memory limitations of pplacer. TIPP also has limitations in its ability to scale with reference sequences. It uses SATe which Liu et al. (2012) demonstrated that SATe-II took approximately 1 week to finish an iteration of the alignment algorithm for 27,643 sequences. Additionally, UPP is a multiple sequence aligner that is used in SEPP. For comparisons with IQ-TREE2 we added Figure S3 and the following text:</p><p>We explored different combinations of tree estimation methods (including IQ-TREE2), multiple sequence aligners, and global aligners (Figure S3). While most combinations of methods were quite similar (especially for the genus level), the use of FAMSA+RAxML+NW was optimal with regards to speed and accuracy. We ran IQ-TREE2 with the default settings using options -m GTR+G -nt 4 to be consistent with similar RAxML settings.</p><disp-quote content-type="editor-comment"><p>Tronko currently supports two BWA-MEM modes (Needleman-Wunsch and Wavefront Alignment), but rather than just supporting BWA-MEM, what about other potential aligners? For example, if one were to use Minimap2 to perform alignment instead, how would the results + runtime + memory requirements change?</p></disp-quote><p>Needleman-Wunsch and Wavefront Alignment are not modes of BWA-MEM. Please see the earlier response to ’Essential Revisions’ #3.</p><disp-quote content-type="editor-comment"><p>The manuscript explains that the high memory usage is because of all of the things Tronko needs to store in memory the entire time, but (1) do all of those things really need to be stored in memory simultaneously, and (2) could some form of compressive encoding (e.g. 2-bit encoding for reference genomes) be used to reduce memory usage? 50 GB is reasonable for high-end modern servers, but I think it can be dramatically reduced with clever optimizations. I think the discussion of the peak memory requirements would benefit from more thorough exploration of what exactly is contributing to the large memory consumption (e.g. what proportion of it is from storing the trees, or the reference genomes, or the posterior probabilities, etc.).</p></disp-quote><p>It is possible to store one tree at a time, which would greatly reduce that memory consumption of a large reference database such as COI, however, this would increase the run time as the memory for one tree (including its posterior probabilities) would need to be unloaded and then loaded into memory again. The vast majority of the memory consumption comes from having to store posterior probabilities. However, it is possible to store these probabilities using a tree compression algorithm from Larget &amp; Simon (1998) that may be implemented in a future version.</p><disp-quote content-type="editor-comment"><p>Now, general comments about the paper:</p><p>The paper is generally well-written and reads fairly clearly, but my main concern is about some choices in the methodology that were (seemingly) somewhat arbitrarily chosen without providing justification. For example, BWA-MEM was chosen for mapping; why that choice rather than other mappers? And why are the default parameters appropriate? RAxML was chosen for phylogenetic inference; why that choice rather than other tree inference tools? And why default parameters with GTR+Γ model (rather than GTR+Γ+Invariant, or GTR+CAT, or GTR+CAT+Invariant, etc.)? In addition to my technical questions above about how changing these choices would impact results, my general comment here is that all choices should be motivated in some way within the text.</p></disp-quote><p>We agree with the reviewer that all choices should be motivated. We explain in our response to ’Essential Revisions’ #3 the answers to these specific concerns.</p><disp-quote content-type="editor-comment"><p>Both panels of Figure 6 should be log-scale: as they're currently presented in linear-scale, it's impossible to meaningfully discern differences between the smaller lines.</p></disp-quote><p>This has been modified in the new draft of the manuscript.</p><disp-quote content-type="editor-comment"><p>Reviewer #2 (Recommendations for the authors):</p><p>## Overall comments</p><p>The manuscript is hard to read top-to-bottom, and would be easier if you gave a little more of an overview of the method before giving results. The figure 1 caption, for example, can't really be understood without getting to P14. Figure 1 itself can't really be understood without understanding the cutoff parameter.</p><p>Please make it clear from the get-go that this is amplicon sequencing and not true metagenomics. The tool is compared to Kraken which does true metagenomics.</p></disp-quote><p>The title of the manuscript is ’A rapid phylogeny-based method for accurate community profiling of large-scale metabarcoding datasets’.</p><disp-quote content-type="editor-comment"><p>If I am understanding correctly, the database input for the method requires a tree annotated with taxonomic labels at all nodes of the tree. If that's right, what is the process for doing this labeling? What if the taxonomy and the tree disagree?</p></disp-quote><p>Actually, this is not correct. The method only requires taxonomic labels for the leaf nodes of the tree. These taxonomic labels are gathered from the NCBI taxonomy database. We describe the algorithm in detail in the Methods section under ’Tronko-build reference database construction with a single tree’ in lines 257 to 263.</p><disp-quote content-type="editor-comment"><p>The paper doesn't compare to APPLES (reference 8) which is phylogenetic but distance-based and therefore should be faster, but is probably less accurate. This isn't necessary for a revision, but it would be interesting to understand if performance gaps are due to phylogeny or likelihood-based phylogeny.</p></disp-quote><p>We added comparisons to APPLES-2 to all applicable datasets. We described this in detail with our response to Essential Revision #2.</p><disp-quote content-type="editor-comment"><p>## Details</p><p>Please number lines. This makes reviewing much easier.</p></disp-quote><p>This was added.</p><disp-quote content-type="editor-comment"><p>P2 &quot;There are three…&quot;: I suggest using (1), (2), (3) in this sentence to make it clearer rather than just rely on commas.</p></disp-quote><p>This was added.</p><disp-quote content-type="editor-comment"><p>P3 Tandy Warnow has worked on a number of approaches to scaling likelihood-based phylogenetic placement, e.g. https://www.biorxiv.org/content/10.1101/2022.10.26.513936v1.full.pdf which also uses a collection of trees.</p></disp-quote><p>When we say that ”phylogeny-based method shave not scaled to handle the entirety of the rapidly growing reference databases of genome markers and the increasingly large amounts of NGS data”, we mean that these methods have not scaled to be able to simultaneously handle millions of reference sequences and millions of queries. Although BATCH-SCAMPP (Wedell et al., 2022) uses subtrees, it still requires as input 1 phylogenetic tree along with a multiple sequence alignment of both reference sequences and query sequences. In addition to this, there are a number of limiting factors in BATCH-SCAMMP. In Wedell et al. (2022), they recommend to limit the subtree size to 2,000 reference sequences and the largest backbone size they tested only had 50,000 reference sequences.</p><disp-quote content-type="editor-comment"><p>P7 It seems like you are using a different cutoff for the different comparisons. Can you justify that?</p></disp-quote><p>In all analyses we compared all methods to Tronko using 5 cut-offs 0, 5, 10, 15, and 20. In any case, we amended the text to compare with the other methods using a cut-off of 10:</p><p>”Using 150bp paired-end reads with 0% error (Figure 4D), Tronko had a misclassification rate at only 0.1% with a recall rate of 58.6% at the species level using a cut-off set to 10 while kraken2, MEGAN, and metaphlan2 had misclassification rates of 1.5%, 0.1%, and 11.0%, respectively, with recall rates of 85.4%, 60.7%, and 98.14%. ”</p><disp-quote content-type="editor-comment"><p>P12 &quot;lenghts&quot; typo</p></disp-quote><p>We amended: ”We first estimate the topology and branch-lengths of the tree using RAxML, although users of the method could use any tree estimation algorithm.”</p><p>To read: ”We first estimate the topology and branch-lengths of the tree using RAxML, although users of the method could use any tree estimation algorithm.”</p><disp-quote content-type="editor-comment"><p>P12 The two-pass algorithm is linear time, and this seems to me like the standard two-pass algorithm. We can get the required posterior probabilities from the upward and downward partial likelihood vectors. What am I missing? If there is something subtle, some more explanation and notation is needed.</p></disp-quote><p>Standard implementations of the two-pass algorithm requires this algorithm to be run for each node of the tree when posterior probabilities need to be calculated for all nodes. Our algorithm allows calculations to be done for all nodes using a single postorder traversal and a single inorder traversal. We have now added the following to the manuscript:</p><p>”…, as it calculates posterior probabilities for all nodes using a single postorder and inorder traversal without having to repeat the calculation for each node in the tree”.</p><p>As this is a fairly obvious idea, we are thinking that there might be other implementations of this, but we could not find references in the literature to this. If we have missed this and the reviewer is aware of a reference to this, we are happy to add this reference instead of our description.</p><disp-quote content-type="editor-comment"><p>P12 To get an assignment to node i, does i and its children need to get a given taxonomic assignment? The text reads as if only the children need taxonomic assignments.</p></disp-quote><p>Yes, <italic>i</italic> and its children need to have a taxonomic assignment. To clarify the algorithm further we changed:</p><p>”We then make taxonomic assignments for internal nodes, at all taxonomic levels (species, genus, etc), using a postorder traversal of the tree that assigns a taxonomic descriptor to node <italic>i</italic> if both children of node <italic>i</italic> have the same taxonomic assignment. Otherwise, node <italic>i</italic> does not have a taxonomic assignment at this taxonomic level. In other words, node <italic>i</italic> only gets a taxonomic assignment if the taxonomic assignments of both child nodes agree.”</p><p>To read:</p><p>”We then make taxonomic assignments for internal nodes, at all taxonomic levels (species, genus, &amp;c.), using a postorder traversal of the tree that assigns a taxonomic descriptor to node <italic>i</italic> if both children of node <italic>i</italic> have the same taxonomic assignment. Otherwise, node <italic>i</italic> does not have a taxonomic assignment at this taxonomic level and node <italic>i</italic> is given the next closest upwards taxonomic level where its children have the same taxonomic assignment.”</p><disp-quote content-type="editor-comment"><p>P13 Why I and V? I know they are arbitrary but it seems like an odd choice.</p></disp-quote><p>We are running out of letters for notation and we would like all notations to be distinct.</p><disp-quote content-type="editor-comment"><p>P13 What is the intuition for the definition of variance? If we were to try to write this as the variance of a random variable, what would it be? It seems like this definition is similar to that for the centroid of the tree. If that's the case, why not use that more common object?</p></disp-quote><p>A centroid is not necessarily unique. One tree might have multiple centroids. Using the variance is a natural way of identifying partitions of a tree of approximately equal size using an L2 penalty on large clusters.</p><disp-quote content-type="editor-comment"><p>P14 Perhaps &quot;written&quot; rather than &quot;printed&quot;? Is there a specific format to this file, like JSON, or is it fully custom?</p></disp-quote><p>It is a fully custom format specific to Tronko. We have changed:</p><p>”Finally, the trees, multiple sequence alignments, taxonomic information, and posterior probabilities are printed to one reference file which can be loaded for subsequent assignment of reads.”</p><p>To read:</p><p>”Finally, the trees, multiple sequence alignments, taxonomic information, and posterior probabilities are written to one reference file which can be loaded for subsequent assignment of reads.”</p><disp-quote content-type="editor-comment"><p>P15 Notation would be cleaner if you just used a single P for posterior probability, or <inline-formula><mml:math id="sa2m1"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mi mathvariant="double-struck">P</mml:mi></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula>. use &quot;<inline-formula><mml:math id="sa2m2"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>log</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula>&quot;. Suggest display equation for phylogenetic likelihood.</p></disp-quote><p>We amended this:</p><p>”In an ungapped alignment, the score for site <italic>j</italic> in node <italic>i</italic> is then the negative log of a function that depends on the posterior probability of the observed nucleotide in the query sequence, <italic>PP<sub>ij</sub></italic>(<italic>b<sub>j</sub></italic>), and the error rate:<disp-formula id="sa2equ1"><mml:math id="sa2m3"><mml:mrow><mml:mo>−</mml:mo><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>c</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mn>3</mml:mn><mml:mtext> </mml:mtext><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mn>4</mml:mn><mml:mi>c</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mn>3</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mtext>PP</mml:mtext><mml:mrow><mml:mtext>ij</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula></p><p>Assuming symmetric error rates, the probability of observing the base by error is (1 − <italic>PP<sub>ij</sub></italic>(<italic>b<sub>j</sub></italic>))<italic>c</italic>/3 and the probability of observing the base with no error is (1 − <italic>c</italic>) <italic>PP<sub>ij</sub></italic>(<italic>b<sub>j</sub></italic>). The sum of these two expressions equals the expression in the logarithm above. The score for all <italic>s</italic> sites in the read is defined as <inline-formula><mml:math id="sa2m4"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mo>−</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mi>c</mml:mi><mml:mn>3</mml:mn></mml:mfrac><mml:mo>+</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mn>4</mml:mn><mml:mrow><mml:mi>c</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mtext>PP</mml:mtext><mml:mrow><mml:mtext>ij</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula></p><p>Notice that the full phylogenetic likelihood for the entire tree, under standard models of molecular evolution with equal base frequencies and not accounting for errors is <inline-formula><mml:math id="sa2m5"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mo fence="false" stretchy="false">}</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mtext>PP</mml:mtext><mml:mrow><mml:mtext>ij</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>v</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>vbj</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula>, where <italic>P<sub>vbj</sub></italic>(<italic>t</italic>) is the time dependent transition probability from base <italic>v</italic> to base <italic>b<sub>j</sub></italic> in time <italic>t</italic>. This statement takes advantage of the fact that, under time-reversibility, the posterior for a base in an node is proportional to the fractional likelihood of that base in the node, if the tree is rooted in the node. For small values of <italic>t</italic>, <inline-formula><mml:math id="sa2m6"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> converges to log(<italic>PP<sub>ij</sub></italic>(<italic>b<sub>j</sub></italic>)).”</p><p>To read:</p><p>”In an ungapped alignment, the score for site <italic>j</italic> in node <italic>i</italic> is then the negative log of a function that depends on the posterior probability of the observed nucleotide in the query sequence, <italic>IP<sup>ij</sup></italic>(<italic>b<sub>j</sub></italic>), and the error rate:<disp-formula id="sa2equ2"><mml:math id="sa2m7"><mml:mrow><mml:mo>−</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>c</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mn>3</mml:mn><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mn>4</mml:mn><mml:mi>c</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mn>3</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo fence="false" stretchy="false">]</mml:mo><mml:msub><mml:mtext>IP</mml:mtext><mml:mrow><mml:mtext>ij</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula></p><p>Assuming symmetric error rates, the probability of observing the base by error is (1 – <italic>IP<sup>ij</sup></italic>(<italic>b<sub>j</sub></italic>)<italic>c</italic>/3) and the probability of observing the base with no error is (1 − <italic>c</italic>)<italic>IP<sup>ij</sup></italic>(<italic>bj</italic>). The sum of these two expressions equals the expression in the logarithm above. The score for all <italic>s</italic> sites in the read is defined as <inline-formula><mml:math id="sa2m8"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mo>−</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mi>c</mml:mi><mml:mn>3</mml:mn></mml:mfrac><mml:mo>+</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mn>4</mml:mn><mml:mrow><mml:mi>c</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mtext>PP</mml:mtext><mml:mrow><mml:mtext>ij</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula>.</p><p>Notice that the full phylogenetic likelihood for the entire tree, under standard models of molecular evolution with equal base frequencies and not accounting for errors is<disp-formula id="sa2equ3"><mml:math id="sa2m9"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mo fence="false" stretchy="false">}</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mtext>IP</mml:mtext><mml:mrow><mml:mtext>ij</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>v</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:msub><mml:mtext>vb</mml:mtext><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>where <italic>p<sub>vbj</sub></italic>(<italic>t</italic>) is the time dependent transition probability from base <italic>v</italic> to base <italic>b<sub>j</sub></italic> in time <italic>t</italic>.</p><p>This statement takes advantage of the fact that, under time-reversibility, the posterior for a base in an node is proportional to the fractional likelihood of that base in the node, if the tree is rooted in the node. For small values of <italic>t</italic>, <inline-formula><mml:math id="sa2m10"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> converges to log(<italic>IP<sup>ij</sup></italic>(<italic>b<sub>j</sub></italic>)).”</p><p>The equation for the phylogenetic likelihood is displayed in equation 7.</p><disp-quote content-type="editor-comment"><p>P16 Interesting that this classifies N as a gap. Sometimes Ns are ambiguous sequencing calls.</p></disp-quote><p>We cannot obtain the IP(<italic>N</italic>), therefore we classify it the same as a gap.</p><disp-quote content-type="editor-comment"><p>P16 What is m(1)?</p></disp-quote><p>Typo fixed.</p><disp-quote content-type="editor-comment"><p>Figure 2: I found &quot;error/polymorphism&quot; confusing, as at first I thought it was the ratio of the two. Suggest just &quot;error&quot; in the figure and caption, and note in the text that it could be in fact polymorphism. Also, there are lots of triangles for Tronko. Please introduce in the text what the cut-off is. You state that there is a cut-off on P4, and hopefully in one additional sentence you could give an intuition. Font is too small.</p></disp-quote><p>We added a sentence to explain ”error/polymorphism”:</p><p>We use the term ”error/polymorphism” to represent a simulated change in nucleotide that can be either an error in sequencing or a polymorphism.</p><p>We explain in the text what the cut-off means:</p><p>”After calculation of scores, the LCA of all of the lowest scoring nodes, using a user-defined cut-off parameter, is calculated. For example, if the cut-off parameter is 0, only the highest scoring node (or nodes with the same score as the highest scoring node) is used to calculate the LCA. If the cut-off parameter is 5, the highest scoring node along with all other nodes within a score of 5 of the highest scoring node are used to calculate the LCA.”</p><p>There are many points (triangles) for Tronko because we apply 5 cut-offs (0, 5, 10, 15, and 20). None of the other methods allow a similar comparison therefore all other methods only have a single point.</p><disp-quote content-type="editor-comment"><p>Figure 3: These &quot;rainbow&quot; schemes are now not in favor compared to color schemes like viridis and variants; see https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0199239</p></disp-quote><p>The color scheme that we use is a red to blue color scheme. If we were to use a different color scheme, it would be difficult to see the off-diagonal points.</p><disp-quote content-type="editor-comment"><p>Figure 6: Please consider color scheme, the yellow is basically invisible.</p></disp-quote><p>We changed the color scheme for the majority of the plots.</p><disp-quote content-type="editor-comment"><p>Figure S4. I'm not sure what &quot;assignment rate&quot; is. Is the fraction of time the program produced any result? Could you label the Tronko lines with Tronko?</p></disp-quote><p>Tronko is labeled in this figure. Additionally, we added the following to the text:</p><p>”Additionally, in terms of the species assignment rate (the percentage of queries that were assigned at the species level), Tronko assigns the most queries.”</p><disp-quote content-type="editor-comment"><p>All Figure legends should identify the gene target and data set.</p><p>Reviewer #3 (Recommendations for the authors):</p><p>We have divided most of our considerations into three areas, regarding (a) the methods that this ms. introduces, (b) the results that they produce and (c) the Tronko software.</p><p>(a) The methods take familiar ground as their starting point, and then take a new direction in terms of approximations and shortcuts to implement something resembling a full probabilistic (maximum likelihood) inference technique, but fast enough and with low-enough memory requirement to be practical for modern-sized datasets (reference and sample). We need no convincing that this is a valid approach, and is sufficient for the methods proposed to be of value if they produce good-enough results.</p><p>That said, there were a few instances of other relevant work not being quoted that I think would be of interest to some readers. We don't think this ms. needs to address all these points in a detailed manner, but where other relevant work has not been cited then readers can reasonably ask whether Pipes and Nielsen are unaware or have simply decided not to incorporate some other existing ideas; or whether they tried to incorporate ideas that ultimately did not work; whether some alternative concepts are somehow incompatible with the approach they did take; or whether there is some other reason. Some specific examples we are curious about and would like to see discussed in this manuscript:</p><p>* what about methods that combine composition-based (kmer) and phylogenetic approaches, essentially replacing likelihood calculations with kmer statistics in a phylogenetic framework? See work like https://academic.oup.com/bioinformatics/article/35/18/3303/5303992 and others from that group, including recent work by Romashchenko</p></disp-quote><p>In our revised manuscript, we add comparisons to two additional phylogenetic placement methods, pplacer and APPLES-2. Both RAPPAS (Linard et al., 2019) and the subsequent EPIK (Romashchenko et al. 2023) are compared to pplacer. RAPPAS, in particular, has worse accuracy than pplacer especially when errors are present (see Figure 4 of Linard et al. 2019). For EPIK, they demonstrate that it is similar in accuracy to pplacer. However, the benchmarking dataset PEWO (Linard at al., 2020) they use is a much smaller dataset (backbone tree of 900 species) than what we use in our manuscript. Additionally, they did not test for different error rates in Romashchenko et al.. (2023). In our revised manuscript, we show that our method is the same or better than pplacer on larger reference databases and with different error rates.</p><disp-quote content-type="editor-comment"><p>* since the ms. argues so strongly for the benefits of phylogenetic methods, it would be interesting to see how the authors consider Tronko to compare to phylogeny-based methods other than pplacer, for example papara and PAGAN and others e.g. mentioned in https://www.frontiersin.org/articles/10.3389/fbinf.2022.871393/full</p></disp-quote><p>Unlike the majority of phylogenetic placement methods, Tronko does not require the query sequences to be aligned with the reference sequences. PaPaRa and PAGAN are both phylogeny-aware alignment programs intended to align the query sequences to the reference sequences. In this manuscript, we show results for different alignment programs (MAFFT and FAMSA) for building the alignment of the reference sequences and Needleman-Wunsch and Wavefront Alignment algorithm for aligning the queries (Figure S6). All choices, withthe exception of Wavefront Alignment on short queries, showed similar results. Additionally, we show results for using different alignment programs, HMMER and MAFFT, for aligning the query sequences to the reference sequences to use with APPLES-2 and pplacer.</p><disp-quote content-type="editor-comment"><p>(b) The results seem convincing and reasonable metrics were used for evaluation. However,</p><p>* since the method's highlight is incorporating phylogeny, it would be interesting to see some comparisons of results using a metric that takes phylogeny into account. For example, while calculating accuracy of taxonomic assignment, instead of using a binary score (correct/incorrect), could you calculate a distance between assignment and real value? A measure of how wrong incorrect assignments could be of relevance to many users in terms of biological interpretations. Arguably, a tool that misassigns to close species would be preferable over another that misassigns to further species</p></disp-quote><p>We agree that this could be an interesting addition. However, the manuscript is already very large and we are struggling finding place for all figures and results. We consider this, which has so far not been done in the literature, to be a possible subject of future research.</p><disp-quote content-type="editor-comment"><p>* very poor performances of some tools in mock community analyses might make readers ask if the default parameters of the tools were right or not for this comparison. For example, for Braukmann et al. data the authors say &quot;MEGAN did not assign any reads at the species or genus level&quot;</p></disp-quote><p>There was an issue for our pipeline for this analysis. MEGAN had an 15% recall and 0% misclassification rate at the species level and a 50% recall and 0.5% misclassfication rate at the genus level for the Braukmann et al. dataset. We amended Figures 6D and S12 accordingly. For metaphlan2, it is not surprising that the default database does not assign COI reads as it was developed to assign microbial communities.</p><disp-quote content-type="editor-comment"><p>* some claims about other methods' results being dominated by Tronko based on the convex hull seem a bit overstated, when there has been no investigation of how the other methods' recall/misclassification response curves could appear if other parameter settings were used</p></disp-quote><p>We only compared against the default parameter settings of the other methods. (Ye at al. (2019) l/fulltext/S0092-8674(19)30775-5) showed that the biggest differences in results from different species assignment methods come from confounding effects of differences in the reference databases. We also see this, for example, when comparing kraken2-CRUX to kraken2-default for our mock community datasets. In every analysis in this manuscript, we have kept comparisons using a uniform database against all methods.</p><disp-quote content-type="editor-comment"><p>(c) Tronko software is publically available on GitHub with clear documentation, example files, and working example commands. Nevertheless there is room for improvement for Tronko to be widely utilised by the community:</p><p>* The software installation and execution can be tested on a few different computers and ideally operating systems. We failed to install the software from the source but Singularity installation works fine.</p></disp-quote><p>We have released a.zip package in Github Actions workflow. For Windows and Mac users, we recommend the Singularity installation.</p><disp-quote content-type="editor-comment"><p>* tronko-build input files are preprocessed with multiple softwares. Although the authors provide example files, there is not a guide on how to create those files for our own gene of interest. A couple of sentences (or maybe more, for users who are not so familiar with the data types and analyses involved) about how those files were prepared would be very helpful.</p></disp-quote><p>We provide two example datasets and a guide on how to run the species assignment (https://github.com/lpipes/ tronko?tab=readme-ov-file#tronko-build-example-datasets).</p><disp-quote content-type="editor-comment"><p>* tronko-build example files include some files with double extensions (e.g..fasta.ann). These are not mentioned in the readme. It is not clear what they are. They are not mentioned in the inputs of the command nor did they appear in the output directory when we ran it.</p></disp-quote><p>These files with double extensions are the bwa index files that are used for tronko-assign. The user can choose to build them before assignment or skip the build (with option -6) if the files are already there. The bwa index files are not required as input. We added the following text to the github page https://github.com/lpipes/tronko?tab=readme-ov-file#tronko-assign-usage:</p><p>You will also need a FASTA file (not gzipped) of all of your reference sequences in the reference database (use the option -a). tronko-assign will create a bwa index of the reference sequences with the extension of *.fasta.ann, &amp;c. If you already have the bwa index files present in the same directory and naming scheme as your reference sequences, you can choose skip the bwa index build use -6.</p></body></sub-article></article>