<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD with MathML3 v1.3 20210610//EN"  "JATS-archivearticle1-3-mathml3.dtd"><article xmlns:ali="http://www.niso.org/schemas/ali/1.0/" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article" dtd-version="1.3"><front><journal-meta><journal-id journal-id-type="nlm-ta">elife</journal-id><journal-id journal-id-type="publisher-id">eLife</journal-id><journal-title-group><journal-title>eLife</journal-title></journal-title-group><issn publication-format="electronic" pub-type="epub">2050-084X</issn><publisher><publisher-name>eLife Sciences Publications, Ltd</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="publisher-id">91597</article-id><article-id pub-id-type="doi">10.7554/eLife.91597</article-id><article-id pub-id-type="doi" specific-use="version">10.7554/eLife.91597.3</article-id><article-categories><subj-group subj-group-type="display-channel"><subject>Research Article</subject></subj-group><subj-group subj-group-type="heading"><subject>Cancer Biology</subject></subj-group><subj-group subj-group-type="heading"><subject>Computational and Systems Biology</subject></subj-group></article-categories><title-group><article-title>Optimal transport for automatic alignment of untargeted metabolomic data</article-title></title-group><contrib-group><contrib contrib-type="author" equal-contrib="yes" id="author-330142"><name><surname>Breeur</surname><given-names>Marie</given-names></name><contrib-id authenticated="true" contrib-id-type="orcid">https://orcid.org/0000-0003-1251-8360</contrib-id><xref ref-type="aff" rid="aff1">1</xref><xref ref-type="fn" rid="equal-contrib1">†</xref><xref ref-type="other" rid="fund5"/><xref ref-type="fn" rid="con1"/><xref ref-type="fn" rid="conf1"/></contrib><contrib contrib-type="author" equal-contrib="yes" id="author-330148"><name><surname>Stepaniants</surname><given-names>George</given-names></name><contrib-id authenticated="true" contrib-id-type="orcid">https://orcid.org/0000-0002-7834-7536</contrib-id><xref ref-type="aff" rid="aff2">2</xref><xref ref-type="fn" rid="equal-contrib1">†</xref><xref ref-type="other" rid="fund1"/><xref ref-type="fn" rid="con2"/><xref ref-type="fn" rid="conf1"/></contrib><contrib contrib-type="author" id="author-330709"><name><surname>Keski-Rahkonen</surname><given-names>Pekka</given-names></name><contrib-id authenticated="true" contrib-id-type="orcid">https://orcid.org/0000-0001-9437-3040</contrib-id><xref ref-type="aff" rid="aff1">1</xref><xref ref-type="fn" rid="con3"/><xref ref-type="fn" rid="conf1"/></contrib><contrib contrib-type="author" id="author-330710"><name><surname>Rigollet</surname><given-names>Philippe</given-names></name><xref ref-type="aff" rid="aff2">2</xref><xref ref-type="other" rid="fund2"/><xref ref-type="other" rid="fund3"/><xref ref-type="other" rid="fund4"/><xref ref-type="fn" rid="con4"/><xref ref-type="fn" rid="conf1"/></contrib><contrib contrib-type="author" corresp="yes" id="author-330711"><name><surname>Viallon</surname><given-names>Vivian</given-names></name><contrib-id authenticated="true" contrib-id-type="orcid">https://orcid.org/0000-0002-9799-4421</contrib-id><email>viallonv@iarc.who.int</email><xref ref-type="aff" rid="aff1">1</xref><xref ref-type="other" rid="fund5"/><xref ref-type="fn" rid="con5"/><xref ref-type="fn" rid="conf1"/></contrib><aff id="aff1"><label>1</label><institution-wrap><institution-id institution-id-type="ror">https://ror.org/00v452281</institution-id><institution>Nutrition and Metabolism Branch, International Agency for Research on Cancer</institution></institution-wrap><addr-line><named-content content-type="city">Lyon</named-content></addr-line><country>France</country></aff><aff id="aff2"><label>2</label><institution-wrap><institution-id institution-id-type="ror">https://ror.org/042nb2s44</institution-id><institution>Massachusetts Institute of Technology, Department of Mathematics</institution></institution-wrap><addr-line><named-content content-type="city">Boston</named-content></addr-line><country>United States</country></aff></contrib-group><contrib-group content-type="section"><contrib contrib-type="editor"><name><surname>Fernandez</surname><given-names>Paula</given-names></name><role>Reviewing Editor</role><aff><institution-wrap><institution-id institution-id-type="ror">https://ror.org/04wm52x94</institution-id><institution>INTA</institution></institution-wrap><country>Argentina</country></aff></contrib><contrib contrib-type="senior_editor"><name><surname>Choi</surname><given-names>Murim</given-names></name><role>Senior Editor</role><aff><institution-wrap><institution-id institution-id-type="ror">https://ror.org/04h9pn542</institution-id><institution>Seoul National University</institution></institution-wrap><country>Republic of Korea</country></aff></contrib></contrib-group><author-notes><fn fn-type="con" id="equal-contrib1"><label>†</label><p>These authors contributed equally to this work</p></fn></author-notes><pub-date publication-format="electronic" date-type="publication"><day>18</day><month>06</month><year>2024</year></pub-date><volume>12</volume><elocation-id>RP91597</elocation-id><history><date date-type="sent-for-review" iso-8601-date="2023-09-11"><day>11</day><month>09</month><year>2023</year></date></history><pub-history><event><event-desc>This manuscript was published as a preprint.</event-desc><date date-type="preprint" iso-8601-date="2023-09-13"><day>13</day><month>09</month><year>2023</year></date><self-uri content-type="preprint" xlink:href="https://doi.org/10.48550/arXiv.2306.03218"/></event><event><event-desc>This manuscript was published as a reviewed preprint.</event-desc><date date-type="reviewed-preprint" iso-8601-date="2023-12-11"><day>11</day><month>12</month><year>2023</year></date><self-uri content-type="reviewed-preprint" xlink:href="https://doi.org/10.7554/eLife.91597.1"/></event><event><event-desc>The reviewed preprint was revised.</event-desc><date date-type="reviewed-preprint" iso-8601-date="2024-04-09"><day>09</day><month>04</month><year>2024</year></date><self-uri content-type="reviewed-preprint" xlink:href="https://doi.org/10.7554/eLife.91597.2"/></event></pub-history><permissions><copyright-statement>© 2023, Breeur, Stepaniants et al</copyright-statement><copyright-year>2023</copyright-year><copyright-holder>Breeur, Stepaniants et al</copyright-holder><ali:free_to_read/><license xlink:href="http://creativecommons.org/licenses/by/4.0/"><ali:license_ref>http://creativecommons.org/licenses/by/4.0/</ali:license_ref><license-p>This article is distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution License</ext-link>, which permits unrestricted use and redistribution provided that the original author and source are credited.</license-p></license></permissions><self-uri content-type="pdf" xlink:href="elife-91597-v1.pdf"/><self-uri content-type="figures-pdf" xlink:href="elife-91597-figures-v1.pdf"/><abstract><p>Untargeted metabolomic profiling through liquid chromatography-mass spectrometry (LC-MS) measures a vast array of metabolites within biospecimens, advancing drug development, disease diagnosis, and risk prediction. However, the low throughput of LC-MS poses a major challenge for biomarker discovery, annotation, and experimental comparison, necessitating the merging of multiple datasets. Current data pooling methods encounter practical limitations due to their vulnerability to data variations and hyperparameter dependence. Here, we introduce GromovMatcher, a flexible and user-friendly algorithm that automatically combines LC-MS datasets using optimal transport. By capitalizing on feature intensity correlation structures, GromovMatcher delivers superior alignment accuracy and robustness compared to existing approaches. This algorithm scales to thousands of features requiring minimal hyperparameter tuning. Manually curated datasets for validating alignment algorithms are limited in the field of untargeted metabolomics, and hence we develop a dataset split procedure to generate pairs of validation datasets to test the alignments produced by GromovMatcher and other methods. Applying our method to experimental patient studies of liver and pancreatic cancer, we discover shared metabolic features related to patient alcohol intake, demonstrating how GromovMatcher facilitates the search for biomarkers associated with lifestyle risk factors linked to several cancer types.</p></abstract><kwd-group kwd-group-type="author-keywords"><kwd>untargeted metabolomics</kwd><kwd>LC-MS</kwd><kwd>optimal transport</kwd><kwd>Gromov-Wasserstein</kwd><kwd>data integration</kwd><kwd>cancer metabolism</kwd></kwd-group><kwd-group kwd-group-type="research-organism"><title>Research organism</title><kwd>Human</kwd></kwd-group><funding-group><award-group id="fund1"><funding-source><institution-wrap><institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/100000001</institution-id><institution>National Science Foundation</institution></institution-wrap></funding-source><award-id>Graduate Research Fellowship Program 1745302</award-id><principal-award-recipient><name><surname>Stepaniants</surname><given-names>George</given-names></name></principal-award-recipient></award-group><award-group id="fund2"><funding-source><institution-wrap><institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/100000001</institution-id><institution>National Science Foundation</institution></institution-wrap></funding-source><award-id>IIS-1838071</award-id><principal-award-recipient><name><surname>Rigollet</surname><given-names>Philippe</given-names></name></principal-award-recipient></award-group><award-group id="fund3"><funding-source><institution-wrap><institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/100000001</institution-id><institution>National Science Foundation</institution></institution-wrap></funding-source><award-id>DMS-2022448</award-id><principal-award-recipient><name><surname>Rigollet</surname><given-names>Philippe</given-names></name></principal-award-recipient></award-group><award-group id="fund4"><funding-source><institution-wrap><institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/100000001</institution-id><institution>National Science Foundation</institution></institution-wrap></funding-source><award-id>CCF-2106377</award-id><principal-award-recipient><name><surname>Rigollet</surname><given-names>Philippe</given-names></name></principal-award-recipient></award-group><award-group id="fund5"><funding-source><institution-wrap><institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/100013743</institution-id><institution>World Cancer Research Fund International</institution></institution-wrap></funding-source><award-id>IIG_FULL_2022_013</award-id><principal-award-recipient><name><surname>Breeur</surname><given-names>Marie</given-names></name><name><surname>Viallon</surname><given-names>Vivian</given-names></name></principal-award-recipient></award-group><funding-statement>The funders had no role in study design, data collection and interpretation, or the decision to submit the work for publication.</funding-statement></funding-group><custom-meta-group><custom-meta specific-use="meta-only"><meta-name>Author impact statement</meta-name><meta-value>A computational method based on optimal transport enables state-of-the-art alignment between untargeted metabolomic studies and is evaluated on cord blood and cancer datasets.</meta-value></custom-meta><custom-meta specific-use="meta-only"><meta-name>publishing-route</meta-name><meta-value>prc</meta-value></custom-meta></custom-meta-group></article-meta></front><body><sec id="s1" sec-type="intro"><title>Introduction</title><p>Untargeted metabolomics is a powerful analytical technique used to identify and measure a large number of metabolites in a biological sample without preselecting targets (<xref ref-type="bibr" rid="bib30">Patti, 2011</xref>). This approach allows for a comprehensive overview of an individual’s metabolic profile, provides insights into the biochemical processes involved in cellular and organismal physiology (<xref ref-type="bibr" rid="bib51">Wishart, 2019</xref>; <xref ref-type="bibr" rid="bib33">Pirhaji et al., 2016</xref>), and allows for the exploration of how environmental factors impact metabolism (<xref ref-type="bibr" rid="bib34">Rappaport et al., 2014</xref>; <xref ref-type="bibr" rid="bib5">Bedia, 2022</xref>). It creates new opportunities to investigate health-related conditions, including diabetes (<xref ref-type="bibr" rid="bib50">Wang et al., 2011</xref>), inflammatory bowel diseases <xref ref-type="bibr" rid="bib15">Franzosa et al., 2019</xref>, and various cancer types (<xref ref-type="bibr" rid="bib26">Loftfield et al., 2021</xref>; <xref ref-type="bibr" rid="bib24">Li et al., 2020</xref>). However, a major challenge in biomarker discovery, metabolic signature identification and other untargeted metabolomic analyses lies in the low throughput of experimental data, necessitating the development of efficient pooling algorithms capable of merging datasets from multiple sources (<xref ref-type="bibr" rid="bib26">Loftfield et al., 2021</xref>).</p><p>A common experimental technique in untargeted metabolomics is liquid chromatography-mass spectrometry (LC-MS) which assembles a list of thousands of unlabeled metabolic features characterized by their mass-to-charge ratio (<inline-formula><mml:math id="inf1"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mi>z</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula>), retention time (RT; <xref ref-type="bibr" rid="bib53">Zhou et al., 2012</xref>), and intensity across all biological samples. Combining LC-MS datasets from multiple experimental studies remains challenging due to variation in the <inline-formula><mml:math id="inf2"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mi>z</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> and RT of a feature from one study to another (<xref ref-type="bibr" rid="bib53">Zhou et al., 2012</xref>; <xref ref-type="bibr" rid="bib22">Ivanisevic and Want, 2019</xref>). This problem is further compounded by differing instruments and analytical protocols across laboratories, resulting in seemingly incompatible metabolomic datasets.</p><p>Manual matching of metabolic features can be a laborious and error-prone task (<xref ref-type="bibr" rid="bib26">Loftfield et al., 2021</xref>). To address this challenge, several automated methods have been developed for metabolic feature alignment. One such method is MetaXCMS, which matches LC-MS features based on user-defined <inline-formula><mml:math id="inf3"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mi>z</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> and RT thresholds (<xref ref-type="bibr" rid="bib47">Tautenhahn et al., 2011</xref>). More advanced tools use information on feature intensities measured in samples. For instance, PAIRUP-MS uses known shared metabolic features to impute the intensities of all features from one dataset to another <xref ref-type="bibr" rid="bib21">Hsu et al., 2019</xref>. MetabCombiner (<xref ref-type="bibr" rid="bib19">Habra et al., 2021</xref>) and M2S (<xref ref-type="bibr" rid="bib12">Climaco Pinto et al., 2022</xref>) compare average feature intensities, along with their <inline-formula><mml:math id="inf4"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mi>z</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> and RT values, to align datasets without requiring extensive knowledge of shared features. These automated alignment methods have accelerated our ability to pool and annotate datasets as well as extract biologically meaningful biomarkers. However, they demand substantial fine-tuning of user-defined parameters and ignore correlations among metabolic features which provide a wealth of additional information on shared features.</p><p>Here, we introduce GromovMatcher, a user-friendly flexible algorithm which automates the matching of metabolic features across experiments. The main technical innovation of GromovMatcher lies in its ability to incorporate the correlation information between metabolic feature intensities, building upon the powerful mathematical framework of computational optimal transport (OT; <xref ref-type="bibr" rid="bib32">Peyré and Cuturi, 2019</xref>; <xref ref-type="bibr" rid="bib49">Villani, 2021</xref>). OT has proven effective in solving various matching problems and has found applications in multiomics analysis (<xref ref-type="bibr" rid="bib14">Demetci et al., 2022</xref>), cell development (<xref ref-type="bibr" rid="bib38">Schiebinger et al., 2019</xref>; <xref ref-type="bibr" rid="bib52">Yang et al., 2020</xref>), and chromatogram alignment (<xref ref-type="bibr" rid="bib41">Skoraczyński et al., 2022</xref>). Here, we leverage the Gromov-Wasserstein (GW) method (<xref ref-type="bibr" rid="bib27">Mémoli, 2011</xref>; <xref ref-type="bibr" rid="bib44">Solomon et al., 2016</xref>), which matches datasets based on their distance structure and has been seminally applied to spatial reconstruction problems in genomics <xref ref-type="bibr" rid="bib29">Nitzan et al., 2019</xref>. GromovMatcher builds upon the GW algorithm to automatically uncover the shared correlation structure among metabolic feature intensities while also incorporating <inline-formula><mml:math id="inf5"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mi>z</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> and RT information in the final matching process.</p><p>To assess the performance of GromovMatcher, we systematically benchmark it on synthetic data with varying levels of noise, feature overlap, and data normalizations, outperforming prior state-of-the-art methods of metabCombiner (<xref ref-type="bibr" rid="bib19">Habra et al., 2021</xref>) and M2S (<xref ref-type="bibr" rid="bib12">Climaco Pinto et al., 2022</xref>). Next, we apply GromovMatcher to align experimental patient studies of liver and pancreatic cancer to a reference dataset and associate the shared metabolic features to each patient’s alcohol intake. Through these efforts, we demonstrate how GromovMatcher data pooling improves our ability to discover biomarkers of lifestyle risk factors associated with several types of cancer.</p></sec><sec id="s2" sec-type="results"><title>Results</title><sec id="s2-1"><title>GromovMatcher algorithm</title><p>GromovMatcher uses the mathematical framework of OT to find all matching metabolic features between two untargeted metabolomic datasets (<xref ref-type="fig" rid="fig1">Figure 1</xref>). It accepts two LC-MS datasets with possibly different numbers of metabolic features and samples. Each feature, <inline-formula><mml:math id="inf6"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mtext>fx</mml:mtext><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> in Dataset 1 and <inline-formula><mml:math id="inf7"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mtext>fy</mml:mtext><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> in Dataset 2, is identified by its <inline-formula><mml:math id="inf8"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mi>z</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula>, RT, and vector of feature intensities across samples (<xref ref-type="fig" rid="fig1">Figure 1a</xref>). The primary tenet of GromovMatcher is that shared metabolic features have similar correlation patterns in both datasets and can be matched based on the distance/correlations between their feature intensity vectors. Specifically, GromovMatcher computes the pairwise distances between the feature intensity vectors of each metabolic feature in a dataset and saves them into a distance matrix, one per dataset (<xref ref-type="fig" rid="fig1">Figure 1b</xref>). In practice, we use either the Euclidean distance or the cosine distance (negative of correlation) to perform this step (Materials and methods). The resulting distance matrices contain information about the feature intensity similarity within each study. Using optimal transport, we can deduce shared subsets of metabolic features in both datasets which have corresponding feature intensity distance structures.</p><fig id="fig1" position="float"><label>Figure 1.</label><caption><title>An optimal transport approach for combining untargeted metabolomics datasets (GromovMatcher).</title><p>(<bold>a</bold>) Inputs are two LC-MS datasets of unlabeled metabolic features (rows) identified by their <inline-formula><mml:math id="inf9"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mi>z</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula>, RT, and feature intensities across biospecimen samples. Both studies can have differing numbers of metabolic features and samples. (<bold>b</bold>) In both datasets, the intensities across samples of each metabolic feature are formed into a vector and Euclidean distances between these feature vectors are computed and stored in a distance matrix. (<bold>c</bold>) Based on the technique of optimal transport, the unbalanced GW algorithm learns a coupling matrix <inline-formula><mml:math id="inf10"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mover><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula> that places large weights <inline-formula><mml:math id="inf11"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mrow><mml:mover><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mstyle></mml:math></inline-formula> when <inline-formula><mml:math id="inf12"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mtext>fx</mml:mtext><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> and <inline-formula><mml:math id="inf13"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mtext>fy</mml:mtext><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> likely correspond to the same metabolic feature. It optimizes <inline-formula><mml:math id="inf14"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mover><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula> to match features with similar pairwise distances (red outlined boxes) whose <inline-formula><mml:math id="inf15"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mi>z</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> ratios are close. (<bold>d</bold>) The final step of GromovMatcher plots the retention times of features from both datasets against each other and fits a spline interpolation <inline-formula><mml:math id="inf16"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mover><mml:mi>f</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula> weighted by the estimated coupling weights <inline-formula><mml:math id="inf17"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mover><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula>. This retention time drift function is then used to set all entries <inline-formula><mml:math id="inf18"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mrow><mml:mover><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> to zero for those outlier pairs <inline-formula><mml:math id="inf19"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mtext>fx</mml:mtext><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mtext>fy</mml:mtext><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula> which exceed twice the median absolute deviation (MAD) around <inline-formula><mml:math id="inf20"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mover><mml:mi>f</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula> (green highlighted region). Finally, the coupling matrix <inline-formula><mml:math id="inf21"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mover><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula> is filtered and/or thresholded to obtain a refined coupling <inline-formula><mml:math id="inf22"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mover><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula> which is then binarized to obtain a one-to-one matching <inline-formula><mml:math id="inf23"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>M</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> between a subset of metabolite pairs in both datasets.</p></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-91597-fig1-v1.tif"/></fig><p>OT was originally developed to optimize the transportation of soil for the construction of forts (<xref ref-type="bibr" rid="bib28">Monge, 1781</xref>) and was later generalized through the language of probability theory and linear programming (<xref ref-type="bibr" rid="bib23">Kantorovich, 2006</xref>), leading to efficient numerical algorithms and direct applications to planning problems in economics. The ability of OT to efficiently match source to target locations found applications in data science for the alignment of distributions (<xref ref-type="bibr" rid="bib13">Courty et al., 2017</xref>; <xref ref-type="bibr" rid="bib4">Alvarez-Melis et al., 2019</xref>) and was generalized by the Gromov-Wasserstein (GW) method (<xref ref-type="bibr" rid="bib31">Peyré et al., 2016</xref>; <xref ref-type="bibr" rid="bib3">Alvarez-Melis and Jaakkola, 2018</xref>) to align datasets with features of differing dimensions.</p><p>In practice, a sizeable fraction of the metabolic features measured in one study may not be present in the other. Hence, in most cases only a subset of features in both datasets can be matched. Recent GW formulations for unbalanced matching problems (<xref ref-type="bibr" rid="bib40">Sejourne et al., 2021</xref>) allow for matching only subsets of metabolic features with similar intensity structures (<xref ref-type="fig" rid="fig1">Figure 1c</xref>). To incorporate additional feature information, we modify the optimization objective of unbalanced GW to penalize feature matches whose <inline-formula><mml:math id="inf24"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mi>z</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> differences exceed a fixed threshold (Materials and methods, Appendix 1). The optimization of this objective computes a <italic>coupling matrix</italic><inline-formula><mml:math id="inf25"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mover><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula> where each entry <inline-formula><mml:math id="inf26"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mrow><mml:mover><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mstyle></mml:math></inline-formula> indicates the level of confidence in matching metabolic feature <inline-formula><mml:math id="inf27"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mtext>fx</mml:mtext><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> in Dataset 1 to <inline-formula><mml:math id="inf28"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mtext>fy</mml:mtext><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> in Dataset 2.</p><p>Differences in experimental conditions can induce variations in RT between datasets that can be nonlinear and large in magnitude (<xref ref-type="bibr" rid="bib53">Zhou et al., 2012</xref>; <xref ref-type="bibr" rid="bib12">Climaco Pinto et al., 2022</xref>; <xref ref-type="bibr" rid="bib19">Habra et al., 2021</xref>). In the spirit of previous methods for LC-MS batch or dataset alignment (<xref ref-type="bibr" rid="bib43">Smith et al., 2006</xref>; <xref ref-type="bibr" rid="bib9">Brunius et al., 2016</xref>; <xref ref-type="bibr" rid="bib25">Liu et al., 2020</xref>; <xref ref-type="bibr" rid="bib48">Vaughan et al., 2012</xref>; <xref ref-type="bibr" rid="bib19">Habra et al., 2021</xref>; <xref ref-type="bibr" rid="bib12">Climaco Pinto et al., 2022</xref>; <xref ref-type="bibr" rid="bib41">Skoraczyński et al., 2022</xref>), the learned coupling <inline-formula><mml:math id="inf29"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mover><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula> is used to estimate a nonlinear map (drift function) between RTs of both datasets by weighted spline regression, which allows us to filter unlikely matches from the coupling matrix to obtain a refined coupling matrix <inline-formula><mml:math id="inf30"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mover><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula> (<xref ref-type="fig" rid="fig1">Figure 1d</xref>, Materials and methods). An optional thresholding step removes matches with small weights from the coupling matrix. The final output of GromovMatcher is a binary matching matrix <inline-formula><mml:math id="inf31"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>M</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> where <inline-formula><mml:math id="inf32"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> is equal to 1 if features <inline-formula><mml:math id="inf33"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mtext>fx</mml:mtext><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> and <inline-formula><mml:math id="inf34"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mtext>fy</mml:mtext><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> are matched and 0 otherwise. Throughout the paper, we refer to the two variants of GromovMatcher, with and without the optional thresholding step as GMT and GM respectively.</p></sec><sec id="s2-2"><title>Validation on ground-truth data</title><p>We first evaluate the performance of GromovMatcher using a real-world untargeted metabolomics study of cord blood across 499 newborns containing 4712 metabolic features characterized by their <inline-formula><mml:math id="inf35"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mi>z</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula>, RT, and feature intensities (<xref ref-type="bibr" rid="bib2">Alfano et al., 2020</xref>). To generate ground-truth data, we randomly divide the initial dataset into two smaller datasets sharing a subset of features (<xref ref-type="fig" rid="fig2">Figure 2</xref>). We simulate diverse acquisition conditions by adding noise to the <inline-formula><mml:math id="inf36"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mi>z</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> and RT of dataset 2, and to the feature intensities in both datasets. Moreover, we introduce an RT drift in dataset 2 to replicate the retention time variations observed in real LC-MS experiments (Materials and methods). For comparison, we also test M2S (<xref ref-type="bibr" rid="bib12">Climaco Pinto et al., 2022</xref>) and metabCombiner (<xref ref-type="bibr" rid="bib19">Habra et al., 2021</xref>), both of which use <inline-formula><mml:math id="inf37"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mi>z</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula>, RT, and median or mean feature intensities to match features (<xref ref-type="fig" rid="fig3">Figure 3</xref>). MetabCombiner is supplied with 100 known shared metabolic features to automatically set its hyperparameters, while M2S parameters are manually fine-tuned to optimize the F1-score in each scenario (Appendix 2). We assess the performance of GM, GMT, metabCombiner, and M2S across 20 randomly generated dataset pairs in terms of their precision (fraction of true matches among the detected matches) and recall/sensitivity (fraction of true matches detected) averaged across 20 dataset pairs.</p><fig id="fig2" position="float"><label>Figure 2.</label><caption><title>Simulated data for testing untargeted metabolomics alignment methods.</title><p>(<bold>a</bold>) Initial LC-MS dataset taken from the EXPOsOMICS project with <inline-formula><mml:math id="inf38"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mi>z</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula>, RT, and feature intensities of <inline-formula><mml:math id="inf39"><mml:mrow><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mn>712</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula> metabolites identified in cord blood across <inline-formula><mml:math id="inf40"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>499</mml:mn></mml:mrow></mml:mstyle></mml:math></inline-formula> newborns. (<bold>b</bold>) Newborns (rows) are split into two disjoint groups of sizes <inline-formula><mml:math id="inf41"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>249</mml:mn></mml:mrow></mml:mstyle></mml:math></inline-formula> and <inline-formula><mml:math id="inf42"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>250</mml:mn></mml:mrow></mml:mstyle></mml:math></inline-formula> respectively and metabolic features (columns) are split into two equal groups of size <inline-formula><mml:math id="inf43"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> with overlap <inline-formula><mml:math id="inf44"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>λ</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> where <inline-formula><mml:math id="inf45"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>λ</mml:mi><mml:mo>=</mml:mo><mml:mn>0.25</mml:mn><mml:mo>,</mml:mo><mml:mn>0.5</mml:mn><mml:mo>,</mml:mo><mml:mn>0.75</mml:mn></mml:mrow></mml:mstyle></mml:math></inline-formula> (Materials and methods). Datasets are perturbed by additive noise of magnitude <inline-formula><mml:math id="inf46"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>M</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>RT</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>FI</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula> and a nonlinear drift <inline-formula><mml:math id="inf47"><mml:mrow><mml:mi>f</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is applied to the RTs of dataset 2. (<bold>c</bold>) The two resulting datasets share <inline-formula><mml:math id="inf48"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>λ</mml:mi><mml:mo>=</mml:mo><mml:mn>25</mml:mn><mml:mi mathvariant="normal">%</mml:mi><mml:mo>,</mml:mo><mml:mn>50</mml:mn><mml:mi mathvariant="normal">%</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula>, or 75% of the original dataset’s metabolic features.</p></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-91597-fig2-v1.tif"/></fig><fig-group><fig id="fig3" position="float"><label>Figure 3.</label><caption><title>Comparison of MetabCombiner, M2S, and GromovMatcher on simulated data.</title><p>(<bold>a</bold>) Ground-truth matchings, and matchings inferred by metabCombiner, M2S, GM, and GMT. Pairs of datasets are generated for three levels of overlap (low, medium and high), with a medium noise level (Materials and methods). Matches correctly recovered (true positives) are represented in green. True matches that are not recovered (false negatives) are highlighted in grey. Incorrect matches (false positives) are plotted in red. Features in rows and columns of matching matrices are reordered for visual clarity. (<bold>b</bold>) Average precision and recall on 20 randomly generated pairs of datasets, for three levels of overlap (low, medium, and high) with a medium noise level.</p></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-91597-fig3-v1.tif"/></fig><fig id="fig3s1" position="float" specific-use="child-fig"><label>Figure 3—figure supplement 1.</label><caption><title>Average precision and recall obtained on simulated data, with fixed overlap <inline-formula><mml:math id="inf49"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>λ</mml:mi><mml:mo>=</mml:mo><mml:mn>0.5</mml:mn></mml:mrow></mml:mstyle></mml:math></inline-formula>.</title><p>The noise level corresponds to different values of <inline-formula><mml:math id="inf50"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>RT</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> and <inline-formula><mml:math id="inf51"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>FI</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula>. High, medium, and low noise level correspond to <inline-formula><mml:math id="inf52"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>RT</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>FI</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>0.2</mml:mn><mml:mo>,</mml:mo><mml:mn>0.1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>0.5</mml:mn><mml:mo>,</mml:mo><mml:mn>0.5</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula> and (1, 1) respectively. We run 20 simulations for each setting.</p></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-91597-fig3-figsupp1-v1.tif"/></fig><fig id="fig3s2" position="float" specific-use="child-fig"><label>Figure 3—figure supplement 2.</label><caption><title>Performance on centered and scaled data.</title><p>The feature intensities of both datasets are centered and scaled to have means of 0 and standard deviations of 1. The average precision and recall of the three methods are computed on 20 randomly generated pairs of datasets, for (<bold>a</bold>) three levels of overlap (low, medium and high corresponding to <inline-formula><mml:math id="inf53"><mml:mrow><mml:mi>λ</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mn>0.25</mml:mn><mml:mo>,</mml:mo><mml:mn>0.5</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula> and 0.75, respectively) with a medium noise level (<inline-formula><mml:math id="inf54"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>RT</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>FI</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>0.5</mml:mn><mml:mo>,</mml:mo><mml:mn>0.5</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula>), and (<bold>b</bold>) fixed medium overlap (<inline-formula><mml:math id="inf55"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>λ</mml:mi><mml:mo>=</mml:mo><mml:mn>0.5</mml:mn></mml:mrow></mml:mstyle></mml:math></inline-formula>) and three different noise levels (low, medium and high corresponding to <inline-formula><mml:math id="inf56"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>RT</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mrow><mml:mtext>FI</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>0.2</mml:mn><mml:mo>,</mml:mo><mml:mn>0.1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>0.5</mml:mn><mml:mo>,</mml:mo><mml:mn>0.5</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula> and (1, 1) respectively).</p></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-91597-fig3-figsupp2-v1.tif"/></fig></fig-group><p>To investigate how the number of shared features affects dataset alignment, we generate pairs of LC-MS datasets with low, medium, and high feature overlap (25%, 50%, and 75%), while maintaining a medium noise level (Materials and methods). Here, we find that GM and GMT generally outperform existing alignment methods, with a recall above 0.95 while metabCombiner and M2S tend to be less sensitive (<xref ref-type="fig" rid="fig3">Figure 3b</xref>). All methods drop in precision as the feature overlap is decreased, with GM and GMT still maintaining an average precision above 0.8.</p><p>Next we evaluate all four methods at low, moderate, and high noise levels for pairs of datasets with 50% overlap in their features (Materials and methods). Our results show that GMT, GM, and M2S maintain an average recall above 0.89, while metabCombiner’s recall drops below 0.6 for high noise. At large noise levels, RT drift estimation becomes more challenging, leading to a higher rate of false matches between metabolites (lower precision) for all four methods (<xref ref-type="fig" rid="fig3s1">Figure 3—figure supplement 1</xref>). Nevertheless, GMT obtains a high average precision and recall of 0.86 and 0.92, respectively.</p><p>A notable difference between GM, metabCombiner, and M2S lies in their use of feature intensities. MetabCombiner expects that the mean feature intensity rankings are identical across studies, while M2S assumes that shared features have similar median intensities. In contrast, GM uses both the mean feature intensities and their variances and covariances. In practice, differences in experimental assays or study populations can lead to greater variation in feature intensities, making matchings based on these statistics less reliable. Centering and scaling the feature intensities to unit variance avoids potential biases arising from inconsistent feature intensity magnitudes, but preserves correlations that GM leverages.</p><p>Exploring this further, we test how sensitive all four methods are to centering and scaling of feature intensities. MetabCombiner and M2S are tuned using the same methodology as for non-centered and non-scaled data. For M2S, we match features solely based on their <inline-formula><mml:math id="inf57"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mi>z</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> and RT. In this experiment (<xref ref-type="fig" rid="fig3s2">Figure 3—figure supplement 2</xref>), the absence of intensity magnitude information significantly affects metabCombiner’s performance and, to a lesser extent, M2S. GM and GMT still obtain accurate matchings, due to their use of correlation structures which are preserved under centering and scaling.</p></sec><sec id="s2-3"><title>Application to EPIC data</title><p>Next, we apply GM, metabCombiner and M2S to align datasets from the European Prospective Investigation into Cancer and Nutrition (EPIC) cohort, a prospective study conducted across 23 European centers. EPIC comprises more than 500,000 participants who provided blood samples at recruitment (<xref ref-type="bibr" rid="bib36">Riboli et al., 2002</xref>). Untargeted metabolomics data were successively acquired in several studies nested within the full cohort.</p><p>In the present work, we use LC-MS data from the EPIC cross-sectional (CS) study (<xref ref-type="bibr" rid="bib42">Slimani et al., 2003</xref>) and two matched case-control studies nested within EPIC, on hepatocellular carcinoma (HCC; <xref ref-type="bibr" rid="bib45">Stepien et al., 2016</xref>; <xref ref-type="bibr" rid="bib46">Stepien et al., 2021</xref>) and pancreatic cancer (PC; <xref ref-type="bibr" rid="bib16">Gasull et al., 2019</xref>). LC-MS untargeted metabolomic data were acquired at the International Agency for Research on Cancer, making use of the same platform and methodology (Materials and methods). The number of samples and features in each study is displayed in <xref ref-type="fig" rid="fig4">Figure 4a</xref>.</p><fig-group><fig id="fig4" position="float"><label>Figure 4.</label><caption><title>Application of GromovMatcher and comparison to existing methods on EPIC dataset.</title><p>(<bold>a</bold>) Dimensions of the three EPIC studies used. For each ionization mode, the cross-sectional (CS) study is aligned successively with the hepatocellular carcinoma (HCC) study and the pancreatic cancer (PC) study. (<bold>b</bold>) Demonstration of expert manual matching and GromovMatcher (GM) matching between the CS and HCC studies in positive mode. Experts manually match 90 features (<xref ref-type="table" rid="table1">Table 1</xref>) from <xref ref-type="bibr" rid="bib26">Loftfield et al., 2021</xref> and the correlation matrices of these features in both datasets have similar structure (bottom two matrices). GM discovers 996 shared features between the CS and HCC datasets which have similar correlation structure (top two matrices). We validate that 88 of the 90 features from the manually expert matched subset are contained in the set of features matched by GM. (<bold>c</bold>) Performance of metabCombiner (mC), M2S and GM in positive mode. Precisions and recalls are measured on a validation subset of 163 manually examined features, and 95% confidence intervals are computed using modified Wilson score intervals. (<bold>d</bold>) Performance of mC, M2S, and GM in negative mode. Precision and recall are measured on a validation subset of 42 manually examined features, and 95% confidence intervals are computed using modified Wilson score intervals. See <xref ref-type="table" rid="table2">Table 2</xref> and <xref ref-type="table" rid="table3">Table 3</xref> for exact precisions, recalls, and confidence intervals in positive and negative mode, respectively.</p></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-91597-fig4-v1.tif"/></fig><fig id="fig4s1" position="float" specific-use="child-fig"><label>Figure 4—figure supplement 1.</label><caption><title>Consistency of the mean feature intensities (FI) in EPIC.</title><p>Each scatter plot represents the mean feature intensities of manually matched features from the validation subset. Each dot represents a pair of manually matched features. The axis represent the mean feature intensities recorded in the two different studies.</p></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-91597-fig4-figsupp1-v1.tif"/></fig><fig id="fig4s2" position="float" specific-use="child-fig"><label>Figure 4—figure supplement 2.</label><caption><title>Overlap between the matching results obtained by metabCombiner, M2S and GromovMatcher in EPIC.</title><p>Venn diagrams are not up to scale.</p></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-91597-fig4-figsupp2-v1.tif"/></fig><fig id="fig4s3" position="float" specific-use="child-fig"><label>Figure 4—figure supplement 3.</label><caption><title>Estimated RT drift between the EPIC studies aligned in the main experiment.</title><p>Each dot correspond to a candidate matched pair after the first step of GM (<inline-formula><mml:math id="inf58"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mi>z</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> constrained GW matching), before the RT drift estimation and RT-based filtering.</p></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-91597-fig4-figsupp3-v1.tif"/></fig></fig-group><p><xref ref-type="bibr" rid="bib26">Loftfield et al., 2021</xref> previously matched features from the CS, HCC, and PC studies in EPIC for alcohol biomarker discovery. The authors first identified 205 features (163 in positive and 42 in negative mode) associated with alcohol intake in the CS study. These features were then manually matched by an expert to features in both the HCC and PC studies (Materials and methods, <xref ref-type="table" rid="table1">Table 1</xref>). In our analysis, we use these features as a validation set and compare each method’s matchings to the expert manual matchings on this subset. Due to the imbalance between the number of positive and negative mode features in the validation subset, our main analysis focuses on the alignment results of CS with HCC and CS with PC in positive mode (<xref ref-type="table" rid="table2">Table 2</xref>). We delegate the matching results between the negative mode studies (<xref ref-type="table" rid="table3">Table 3</xref>) to Appendix 4.</p><table-wrap id="table1" position="float"><label>Table 1.</label><caption><title>Results from the manual matching conducted for <xref ref-type="bibr" rid="bib26">Loftfield et al., 2021</xref>.</title><p>Features from the CS study (163 features in positive mode, 42 features in negative mode) were manually investigated for matches in the HCC and PC studies.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left" valign="bottom">Study</th><th align="left" valign="bottom">Manual matches found in positive mode</th><th align="left" valign="bottom">Manual matches found in negative mode</th></tr></thead><tbody><tr><td align="left" valign="bottom">Hepatocellular carcinoma (HCC)</td><td align="char" char="." valign="bottom">90</td><td align="char" char="." valign="bottom">19</td></tr><tr><td align="left" valign="bottom">Pancreatic cancer (PC)</td><td align="char" char="." valign="bottom">66</td><td align="char" char="." valign="bottom">28</td></tr></tbody></table></table-wrap><table-wrap id="table2" position="float"><label>Table 2.</label><caption><title>Precision and recall on the EPIC validation subset in positive mode.</title><p>95% confidence intervals were computed using modified Wilson score intervals (<xref ref-type="bibr" rid="bib8">Brown et al., 2001</xref>; <xref ref-type="bibr" rid="bib1">Agresti and Coull, 1998</xref>).</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left" valign="bottom"/><th align="left" valign="bottom" colspan="2"><inline-formula><mml:math id="inf59"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mtext mathvariant="bold">CS</mml:mtext></mml:mrow><mml:mo stretchy="false">⟷</mml:mo><mml:mrow><mml:mtext mathvariant="bold">HCC</mml:mtext></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula></th><th align="left" valign="bottom" colspan="2"><inline-formula><mml:math id="inf60"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mtext mathvariant="bold">CS</mml:mtext></mml:mrow><mml:mo stretchy="false">⟷</mml:mo><mml:mrow><mml:mtext mathvariant="bold">PC</mml:mtext></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula></th></tr></thead><tbody><tr><td align="left" valign="bottom">Method</td><td align="left" valign="bottom">Precision</td><td align="left" valign="bottom">Recall</td><td align="left" valign="bottom">Precision</td><td align="left" valign="bottom">Recall</td></tr><tr><td align="left" valign="bottom">GromovMatcher</td><td align="char" char="." valign="bottom">0.989 (0.939, 0.999)</td><td align="char" char="." valign="bottom">0.978 (0.923, 0.996)</td><td align="char" char="." valign="bottom">0.903 (0.813, 0.952)</td><td align="char" char="." valign="bottom">0.985 (0.919, 0.999)</td></tr><tr><td align="left" valign="bottom">M2S</td><td align="char" char="." valign="bottom">0.967 (0.908, 0.991)</td><td align="char" char="." valign="bottom">0.978 (0.923, 0.996)</td><td align="char" char="." valign="bottom">0.855 (0.759, 0.917)</td><td align="char" char="." valign="bottom">0.985 (0.919, 0.999)</td></tr><tr><td align="left" valign="bottom">metabCombiner</td><td align="char" char="." valign="bottom">0.961 (0.868, 0.993)</td><td align="char" char="." valign="bottom">0.544 (0.442, 0.643)</td><td align="char" char="." valign="bottom">0.967 (0.833, 0.998)</td><td align="char" char="." valign="bottom">0.439 (0.326, 0.559)</td></tr></tbody></table></table-wrap><table-wrap id="table3" position="float"><label>Table 3.</label><caption><title>Precision and recall on the EPIC validation subset in negative mode.</title><p>95% confidence intervals were computed using modified Wilson score intervals (<xref ref-type="bibr" rid="bib8">Brown et al., 2001</xref>; <xref ref-type="bibr" rid="bib1">Agresti and Coull, 1998</xref>).</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left" valign="bottom"/><th align="left" valign="bottom" colspan="2"><inline-formula><mml:math id="inf61"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mtext mathvariant="bold">CS</mml:mtext></mml:mrow><mml:mo stretchy="false">⟷</mml:mo><mml:mrow><mml:mtext mathvariant="bold">HCC</mml:mtext></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula></th><th align="left" valign="bottom" colspan="2"><inline-formula><mml:math id="inf62"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mtext mathvariant="bold">CS</mml:mtext></mml:mrow><mml:mo stretchy="false">⟷</mml:mo><mml:mrow><mml:mtext mathvariant="bold">PC</mml:mtext></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula></th></tr></thead><tbody><tr><td align="left" valign="bottom">Method</td><td align="left" valign="bottom">Precision</td><td align="left" valign="bottom">Recall</td><td align="left" valign="bottom">Precision</td><td align="left" valign="bottom">Recall</td></tr><tr><td align="left" valign="bottom">GromovMatcher</td><td align="char" char="." valign="bottom">0.950 (0.764, 0.997)</td><td align="char" char="." valign="bottom">1.000 (0.832, 1.000)</td><td align="char" char="." valign="bottom">0.929 (0.774, 0.987)</td><td align="char" char="." valign="bottom">0.929 (0.774, 0.987)</td></tr><tr><td align="left" valign="bottom">M2S</td><td align="char" char="." valign="bottom">1.000 (0.824, 1.000)</td><td align="char" char="." valign="bottom">0.947 (0.754, 0.997)</td><td align="char" char="." valign="bottom">0.931 (0.780, 0.988)</td><td align="char" char="." valign="bottom">0.964 (0.823, 0.998)</td></tr><tr><td align="left" valign="bottom">metabCombiner</td><td align="char" char="." valign="bottom">0.875 (0.529, 0.993)</td><td align="char" char="." valign="bottom">0.368 (0.191, 0.590)</td><td align="char" char="." valign="bottom">1.000 (0.845, 1.000)</td><td align="char" char="." valign="bottom">0.750 (0.566, 0.873)</td></tr></tbody></table></table-wrap><p>In this section, we use the same settings for GM as in our simulation study, and do not apply an additional thresholding step. The parameters of metabCombiner and M2S are calibrated using the validation subset as prior knowledge (Appendix 2).</p><p>Preliminary analysis of the validation subset reveals inconsistencies in the mean feature intensities (<xref ref-type="fig" rid="fig4s1">Figure 4—figure supplement 1</xref>), but <xref ref-type="fig" rid="fig4">Figure 4b</xref> shows that on centered and scaled data, the 90 expert matched features shared between the CS and HCC studies have similar correlation structures. Hence, to avoid potential errors we center and scale the feature intensities which improves the performance of all three methods tested below (Appendix 4, <xref ref-type="table" rid="app4table1">Appendix 4—table 1</xref>).</p><sec id="s2-3-1"><title>Hepatocellular carcinoma</title><p>Here, we analyze the quality of the matchings obtained by GM, M2S, and metabCombiner between the CS and HCC datasets in positive mode. Both GM and M2S identify approximately 1000 shared features while metabCombiner finds a smaller number of about 700 shared features. We refer the reader to <xref ref-type="fig" rid="fig4s2">Figure 4—figure supplement 2a</xref> for the precise matched feature sizes and details on the agreement between the feature matchings of all three methods.</p><p>We evaluate the performance of metabCombiner, M2S, and GM on the validation subset in positive mode (<xref ref-type="fig" rid="fig4">Figure 4c</xref>, <xref ref-type="table" rid="table2">Table 2</xref>), which consist of 90 features from the CS study manually matched to features from the HCC study and 73 features specific to the CS study. MetabCombiner demonstrates precise matching but lacks sensitivity. M2S’s precision and recall are comparable with GM, in contrast to its performance on simulated data. This can be attributed to the RT drift shape between the CS and HCC studies (Appendix 2), which is estimated to be close to linear (<xref ref-type="fig" rid="fig4s3">Figure 4—figure supplement 3</xref>). Because the parameters of M2S are fine-tuned in the validation subset, it is able to learn this linear drift and apply tight RT thresholds to achieve accurate matchings. In contrast to metabCombiner and M2S, the GM algorithm is not given any prior knowledge of the validation subset, and nevertheless demonstrates the highest precision and recall rates of the three methods (<xref ref-type="fig" rid="fig4">Figure 4c</xref>). <xref ref-type="fig" rid="fig4">Figure 4b</xref> shows how GM recovers the majority of the expert matched pairs by leveraging the shared correlations.</p></sec><sec id="s2-3-2"><title>Pancreatic cancer</title><p>Matching features between the CS and PC studies in positive mode, GM and M2S identify approximately 1000 common features, while metabCombiner detects approximately 600 matches (<xref ref-type="fig" rid="fig4s2">Figure 4—figure supplement 2b</xref>). We examine the performance of all three methods on the validation subset consisting of 66 manually matched features between CS and PC along with 97 features specific to the CS study. As before, GM and M2S have high recall while the recall of metabCombiner is less than 0.5.</p><p>A decrease in precision is observed for both GM and M2S compared to the previous CS-HCC matchings. We therefore manually inspect the false positive matches; the set of CS features matched by the method to the PC study but explicitly examined and left unmatched in the expert manual matching. Assessing the GM results, we identify seven false positive feature matches. Upon secondary inspection, three pairs are revealed as correct matches that were not initially identified in the expert matching. M2S finds 11 false positive matches which include the 7 false positives recovered by GM. Manual examination of the four remaining pairs reveals two clear mismatches. These results highlight the advantage of using automated methods for data alignment, as both GM and M2S detect correct matches that were not identified by experts, with GM being more precise than M2S.</p></sec><sec id="s2-3-3"><title>Illustration for alcohol biomarker discovery</title><p><xref ref-type="bibr" rid="bib26">Loftfield et al., 2021</xref> identified biomarkers of habitual alcohol intake by first performing a discovery step, where they examined the relationship between alcohol intake and metabolic features in the CS study. They then manually matched the significant features in CS to features from the HCC and PC studies, and repeated the analysis with samples from the HCC and PC studies to determine whether the association with alcohol intake persisted. This led to the identification of 10 features possibly associated with alcohol intake (<xref ref-type="fig" rid="fig5">Figure 5a</xref>).</p><fig id="fig5" position="float"><label>Figure 5.</label><caption><title>Comparison of GromovMatcher and <xref ref-type="bibr" rid="bib26">Loftfield et al., 2021</xref> analysis for alcohol biomarker discovery on EPIC data.</title><p>(<bold>a</bold>) Loftfield study implemented a discovery step, examining the relationship between alcohol intake and metabolic features in the CS study. The significant features in CS were manually matched to features from the HCC and PC and the analysis was repeated using samples from the HCC and PC studies. After this step, 10 features associated with alcohol intake were identified. (<bold>b</bold>) GromovMatcher analysis begins by matching features from CS study to HCC and PC studies respectively (top blue, yellow, and red boxes). Samples corresponding to each CS feature are combined with the samples of its matched feature in the HCC study, PC study, or both. This generates a larger pooled data matrix with the same number of features as the CS study but with more samples pooled across the three original studies (center matrix). Because some features in the CS study may not have matches in HCC or PC, the corresponding entries in the pooled matrix are set to NaN/missing values (white regions in matrix). Each column/feature in this matrix is statistically tested for association with alcohol intake (ignoring missing values) and an FDR or a stricter Bonferroni correction is performed to retain only a subset of features from the pooled study that have a strong association. (<bold>c</bold>) Venn diagrams show intersection of feature sets (in positive and negative mode) found to be associated with alcohol intake by one of the four different analyses.</p></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-91597-fig5-v1.tif"/></fig><p>To extend this analysis and illustrate the benefit of GM automatic matching for biomarker discovery, we use GM to pool features from the CS, HCC, and PC studies, and examine the relationship between metabolic features and alcohol intake in the pooled study (Materials and methods and <xref ref-type="fig" rid="fig5">Figure 5b</xref>).</p><p>Applying an FDR correction on the pooled study, we identify 243 features associated with alcohol intake, including 185 features consistent with the discovery step of <xref ref-type="bibr" rid="bib26">Loftfield et al., 2021</xref>, and 55 newly discovered features (<xref ref-type="fig" rid="fig5">Figure 5c</xref>). Using the more stringent Bonferroni correction on the pooled data, we identify 36 features shared by all three studies that are significantly associated with alcohol intake. These features include all 10 features identified in Loftfield et al. (<xref ref-type="fig" rid="fig5">Figure 5c</xref>). These findings highlight the potential benefits of using GM automatic matching for biomarker discovery in untargeted metabolomics data. Additional information regarding the methodology and findings of our GM and Loftfield et al. analyses can be found in Materials and methods and Appendix 4.</p></sec></sec></sec><sec id="s3" sec-type="discussion"><title>Discussion</title><p>LC-MS metabolomics has emerged as an increasingly powerful tool for biological and biomedical research, offering promising opportunities for epidemiological and clinical investigations. However, integrating data from different sources remains challenging. To address this issue, we introduce GromovMatcher, a method based on optimal transport that automatically aligns LC-MS data from pairs of studies. Our method exhibits superior performance on both simulated and real data when compared to existing approaches. Additionally, it presents a user-friendly interface with few hyperparameters.</p><p>While GromovMatcher is robust to noise and variations in data, it may face limitations when aligning LC-MS studies from populations with different characteristics, where the correlation structures between features may be inconsistent across studies. In this case, the base assumption of GromovMatcher can be relaxed by focusing on subsamples with similar characteristics, as exemplified in a recent study (<xref ref-type="bibr" rid="bib17">Gomari et al., 2022</xref>).</p><p>A current limitation is that GromovMatcher does not account for more than two datasets simultaneously, although this can be overcome by aligning multiple studies to a chosen reference dataset, as demonstrated in our biomarker experiments. The extension of Gromov-Wasserstein to multiple distributions (<xref ref-type="bibr" rid="bib6">Beier et al., 2022</xref>) is another promising approach for generalizing GromovMatcher to multiple dataset alignment. Further improvements can be made by incorporating existing knowledge about the studies being matched, such as known shared features, samples in common, or MS/MS data.</p><p>The results obtained from GromovMatcher are highly promising, opening the door for various analyses of metabolomic datasets acquired in different experimental laboratories. Here, we demonstrated the potential of GromovMatcher in expediting the combination and meta-analysis of data for biomarker and metabolic signature discovery. The matchings learned by GromovMatcher also allow for comparison between experimental protocols by assessing the drift in <inline-formula><mml:math id="inf63"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula>, RT, and feature intensities across studies. Finally, inter-institutional annotation efforts can directly benefit from incorporating this method to transfer annotations between aligned datasets. Bridging the gap between otherwise incompatible LC-MS data, GromovMatcher enables seamless comparison of untargeted metabolomics experiments.</p></sec><sec id="s4" sec-type="materials|methods"><title>Materials and methods</title><sec id="s4-1"><title>GromovMatcher method overview</title><p>GromovMatcher accepts as input two feature tables from separate LC-MS untargeted metabolomics studies. Each feature table for dataset 1 and dataset 2 consists of <inline-formula><mml:math id="inf64"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> biospecimen samples respectively and <inline-formula><mml:math id="inf65"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> metabolic features respectively detected in the study. Features in dataset 1 are given the label <inline-formula><mml:math id="inf66"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mtext>fx</mml:mtext><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> for <inline-formula><mml:math id="inf67"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula>. Every feature is characterized by a mass-to-charge ratio (<inline-formula><mml:math id="inf68"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mi>z</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula>) denoted by <inline-formula><mml:math id="inf69"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msubsup><mml:mi>m</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mstyle></mml:math></inline-formula>, a retention time (RT) denoted by <inline-formula><mml:math id="inf70"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>R</mml:mi><mml:msubsup><mml:mi>T</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mstyle></mml:math></inline-formula>, and a vector of intensities across all samples written as <inline-formula><mml:math id="inf71"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msup></mml:mrow></mml:math></inline-formula>. Similarly, features in dataset 2 are labeled as <inline-formula><mml:math id="inf72"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mtext>fy</mml:mtext><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> for <inline-formula><mml:math id="inf73"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> and are characterized by their <inline-formula><mml:math id="inf74"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mi>z</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula>, retention time <inline-formula><mml:math id="inf75"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>R</mml:mi><mml:msubsup><mml:mi>T</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>y</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mstyle></mml:math></inline-formula>, and a vector of intensities across all samples <inline-formula><mml:math id="inf76"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:mstyle></mml:math></inline-formula>.</p><p>Our goal is to identify pairs of indexes <inline-formula><mml:math id="inf77"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula> with <inline-formula><mml:math id="inf78"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo fence="false" stretchy="false">}</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula> and <inline-formula><mml:math id="inf79"><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi mathvariant="normal">…</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, such that <inline-formula><mml:math id="inf80"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mtext>fx</mml:mtext><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> and <inline-formula><mml:math id="inf81"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mtext>fy</mml:mtext><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> correspond to the same metabolic feature. More formally, we aim to identify a <italic>matching matrix</italic> <inline-formula><mml:math id="inf82"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>M</mml:mi><mml:mo>∈</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:msup><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:mstyle></mml:math></inline-formula> such that <inline-formula><mml:math id="inf83"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mstyle></mml:math></inline-formula> if <inline-formula><mml:math id="inf84"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mtext>fx</mml:mtext><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> and <inline-formula><mml:math id="inf85"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mtext>fy</mml:mtext><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> correspond to the same feature, hereafter referred to as <italic>matched</italic> features. Otherwise, we set <inline-formula><mml:math id="inf86"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mstyle></mml:math></inline-formula>.</p><p>Because the <inline-formula><mml:math id="inf87"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula> and RT values of metabolomic features are often noisy and subject to experimental bias, our matching algorithm leverages metabolite feature intensities <inline-formula><mml:math id="inf88"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> to produce accurate dataset alignments. The GromovMatcher method is based on the idea that signal intensities of the same metabolites measured in two different studies should exhibit similar correlation structures, in addition to having compatible <inline-formula><mml:math id="inf89"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mi>z</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> and RT values. Here, we define the Pearson correlation for vectors <inline-formula><mml:math id="inf90"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mstyle></mml:math></inline-formula> as<disp-formula id="equ1"><label>(1)</label><mml:math id="m1"><mml:mrow><mml:mtext>corr</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mo fence="false" stretchy="false">⟨</mml:mo><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mrow><mml:mover><mml:mi>u</mml:mi><mml:mo stretchy="false">¯</mml:mo></mml:mover></mml:mrow><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>−</mml:mo><mml:mrow><mml:mover><mml:mi>v</mml:mi><mml:mo stretchy="false">¯</mml:mo></mml:mover></mml:mrow><mml:mo fence="false" stretchy="false">⟩</mml:mo></mml:mrow><mml:mrow><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mrow><mml:mover><mml:mi>u</mml:mi><mml:mo stretchy="false">¯</mml:mo></mml:mover></mml:mrow><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mi>v</mml:mi><mml:mo>−</mml:mo><mml:mrow><mml:mover><mml:mi>v</mml:mi><mml:mo stretchy="false">¯</mml:mo></mml:mover></mml:mrow><mml:mo fence="false" stretchy="false">‖</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula></p><p>where we define<disp-formula id="equ2"><label>(2)</label><mml:math id="m2"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mover><mml:mi>u</mml:mi><mml:mo stretchy="false">¯</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:mfrac><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mspace width="1em"/><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mi>u</mml:mi><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mo>=</mml:mo><mml:msqrt><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:msubsup><mml:mi>u</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:msqrt><mml:mo>,</mml:mo><mml:mspace width="1em"/><mml:mo fence="false" stretchy="false">⟨</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo fence="false" stretchy="false">⟩</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>as the mean value, Euclidean norm and inner product respectively. If measurements <inline-formula><mml:math id="inf91"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> correspond to the same underlying feature, and similarly, measurements <inline-formula><mml:math id="inf92"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> share the same an underlying feature, we expect that<disp-formula id="equ3"><label>(3)</label><mml:math id="m3"><mml:mrow><mml:mtext>corr</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>≈</mml:mo><mml:mtext>corr</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p><p>This idea that the feature intensities of shared metabolites have the same correlation structure in both datasets also holds more generally for distances, under a suitable choice of distance. For example, the correlation coefficient <inline-formula><mml:math id="inf93"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mtext>corr</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula> can be turned into a dissimilarity metric by defining<disp-formula id="equ4"><label>(4)</label><mml:math id="m4"><mml:mrow><mml:msup><mml:mi>d</mml:mi><mml:mrow><mml:mtext>cos</mml:mtext></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msqrt><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mtext>corr</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:msqrt></mml:mrow></mml:math></disp-formula></p><p>commonly referred to as the <italic>cosine distance</italic>. Preservation of feature intensity correlations then trivially amounts to the preservation of cosine distances.</p><p>Another classical notion of distance between vectors <inline-formula><mml:math id="inf94"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mstyle></mml:math></inline-formula> is the normalized Euclidean distance<disp-formula id="equ5"><label>(5)</label><mml:math id="m5"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msup><mml:mi>d</mml:mi><mml:mrow><mml:mtext>euc</mml:mtext></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mfrac><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mi>v</mml:mi><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mo>=</mml:mo><mml:msqrt><mml:mfrac><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:mfrac><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:msqrt></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>which is equal to the cosine distance (up to constants) when the vectors <inline-formula><mml:math id="inf95"><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow></mml:math></inline-formula> are centered and scaled to have zero mean and a standard deviation of one. The Euclidean distance depends on the magnitude or mean intensity of metabolic features, and hence is a useful metric for matching metabolites as long as these mean feature intensities are reliably collected.</p><p>To summarize, the main tenant of GromovMatcher is that if measurements <inline-formula><mml:math id="inf96"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> correspond to the same feature and <inline-formula><mml:math id="inf97"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> correspond to the same feature, then for suitably chosen distances <inline-formula><mml:math id="inf98"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo>:</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msup><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msup><mml:mo stretchy="false">→</mml:mo><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula> and <inline-formula><mml:math id="inf99"><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mo>:</mml:mo><mml:mrow><mml:mrow><mml:msup><mml:mi>ℝ</mml:mi><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msup><mml:mo>×</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msup></mml:mrow><mml:mo>→</mml:mo><mml:mi>ℝ</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>, these distances are preserved<disp-formula id="equ6"><label>(6)</label><mml:math id="m6"><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>≈</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula></p><p>across both datasets. In this paper, the distances <inline-formula><mml:math id="inf100"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>y</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> are taken to be the normalized Euclidean distances in <xref ref-type="disp-formula" rid="equ5">Equation 5</xref>. We take care to specify those experiments where the metabolic features <inline-formula><mml:math id="inf101"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>X</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> and <inline-formula><mml:math id="inf102"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>Y</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> are centered and scaled. In these cases, implicitly the Euclidean distance between normalized feature vectors becomes the cosine distance <xref ref-type="disp-formula" rid="equ4">Equation 4</xref> between the original (unnormalized) feature vectors.</p><sec id="s4-1-1"><title>Unbalanced Gromov–Wasserstein</title><p>The goal of GromovMatcher is to learn a matching matrix <inline-formula><mml:math id="inf103"><mml:mrow><mml:mi>M</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">}</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> that gives an alignment between a subset of metabolites in both datasets. However, searching over the combinatorially large set of binary matrices would be an inefficient approach for dataset alignment. The mathematical framework of optimal transport <xref ref-type="bibr" rid="bib32">Peyré and Cuturi, 2019</xref> instead enlarges this space of binary matrices to the set of <italic>coupling matrices</italic> with real nonnegative entries <inline-formula><mml:math id="inf104"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:mstyle></mml:math></inline-formula>. The entries <inline-formula><mml:math id="inf105"><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> with large weights indicate that feature <inline-formula><mml:math id="inf106"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mtext>fx</mml:mtext><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> in dataset 1 and feature <inline-formula><mml:math id="inf107"><mml:msub><mml:mtext>fy</mml:mtext><mml:mi>j</mml:mi></mml:msub></mml:math></inline-formula> in dataset 2 are a likely match. Taking inspiration from <xref ref-type="disp-formula" rid="equ6">Equation 6</xref>, we minimize the following objective function<disp-formula id="equ7"><label>(7)</label><mml:math id="m7"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi mathvariant="script">E</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">|</mml:mo></mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">|</mml:mo></mml:mrow></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>to estimate the coupling matrix <inline-formula><mml:math id="inf108"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula>.</p><p>A standard approach is to optimize this objective over all coupling matrices <inline-formula><mml:math id="inf109"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> under exact marginal constraints <inline-formula><mml:math id="inf110"><mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>⁢</mml:mo><mml:msub><mml:mn>𝟏</mml:mn><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mfrac><mml:mo>⁢</mml:mo><mml:msub><mml:mn>𝟏</mml:mn><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msub></mml:mrow></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mrow><mml:msup><mml:mi mathvariant="normal">Π</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mo>⁢</mml:mo><mml:msub><mml:mn>𝟏</mml:mn><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mfrac><mml:mo>⁢</mml:mo><mml:msub><mml:mn>𝟏</mml:mn><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msub></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula>. Here, we define <inline-formula><mml:math id="inf111"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> is the ones vector of length <inline-formula><mml:math id="inf112"><mml:mi>n</mml:mi></mml:math></inline-formula>, and <inline-formula><mml:math id="inf113"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> denote the column and row sums of the coupling matrix. Objective <xref ref-type="disp-formula" rid="equ7">Equation 7</xref> under these exact marginal constraints defines a distance between the two sets of metabolic feature vectors <inline-formula><mml:math id="inf114"><mml:mrow><mml:msubsup><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msubsup></mml:mrow></mml:math></inline-formula> known as the Gromov–Wasserstein distance <xref ref-type="bibr" rid="bib27">Mémoli, 2011</xref>, a generalization of optimal transport to metric spaces. Note that for pairs <inline-formula><mml:math id="inf115"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> and <inline-formula><mml:math id="inf116"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> for which <inline-formula><mml:math id="inf117"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>≈</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula>, the entries <inline-formula><mml:math id="inf118"><mml:mrow><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>⁢</mml:mo><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> are penalized less and hence matches between features <inline-formula><mml:math id="inf119"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mtext>fx</mml:mtext><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mtext>fy</mml:mtext><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> and features <inline-formula><mml:math id="inf120"><mml:mrow><mml:msub><mml:mtext>fx</mml:mtext><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mtext>fy</mml:mtext><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> are more favored. In our optimization, we avoid enforcing exact marginal constraints on the marginal distributions <inline-formula><mml:math id="inf121"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> and <inline-formula><mml:math id="inf122"><mml:mrow><mml:msup><mml:mi mathvariant="normal">Π</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mo>⁢</mml:mo><mml:msub><mml:mn>𝟏</mml:mn><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msub></mml:mrow></mml:math></inline-formula> of our coupling matrix as this would enforce that all metabolites in both datasets are matched (Appendix 1). However, without any marginal constraints on the coupling <inline-formula><mml:math id="inf123"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula>, the objective function <xref ref-type="disp-formula" rid="equ7">Equation 7</xref> is trivially minimized by <inline-formula><mml:math id="inf124"><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>, leaving all metabolites in both datasets unmatched.</p><p>To account for this, we follow the ideas of unbalanced Gromov–Wasserstein (UGW) (<xref ref-type="bibr" rid="bib40">Sejourne et al., 2021</xref>) and add three regularization terms to our objective<disp-formula id="equ8"><label>(8)</label><mml:math id="m8"><mml:mrow><mml:mtable columnalign="left left" rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mrow><mml:mi mathvariant="script">L</mml:mi></mml:mrow><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mi mathvariant="script">E</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:mtd><mml:mtd><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⊗</mml:mo><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>a</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>⊗</mml:mo><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>⊗</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>⊗</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p><p>where <inline-formula><mml:math id="inf125"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mstyle></mml:math></inline-formula> and we define <inline-formula><mml:math id="inf126"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula>. Here ⊗ denotes the Kronecker product. We define <inline-formula><mml:math id="inf127"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> as the Kullback–Leibler (KL) divergence between two discrete distributions <inline-formula><mml:math id="inf128"><mml:mrow><mml:mrow><mml:mi>μ</mml:mi><mml:mo>,</mml:mo><mml:mi>ν</mml:mi></mml:mrow><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mi>p</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> by<disp-formula id="equ9"><label>(9)</label><mml:math id="m9"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo>,</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:munderover><mml:msub><mml:mi>μ</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mi>ln</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:mfrac><mml:msub><mml:mi>μ</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>ν</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mfrac><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:munderover><mml:msub><mml:mi>μ</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:munderover><mml:msub><mml:mi>ν</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>which measures the closeness of probability distributions.</p><p>The first two regularization terms in <xref ref-type="disp-formula" rid="equ8">Equation 8</xref> enforce that the row sums and column sums of the coupling matrix <inline-formula><mml:math id="inf129"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula> do not deviate too much from a uniform distribution, leading our optimization to match as many metabolic features as possible. The magnitude of the regularizer <inline-formula><mml:math id="inf130"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> roughly enforces the fraction of metabolites in both datasets that are matched where large <inline-formula><mml:math id="inf131"><mml:mi>ρ</mml:mi></mml:math></inline-formula> implies most metabolites are matched across datasets. The final regularization term <inline-formula><mml:math id="inf132"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>ε</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> in <xref ref-type="disp-formula" rid="equ8">Equation 8</xref> controls the smoothness (entropy) of the coupling matrix <inline-formula><mml:math id="inf133"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula> where larger values of <inline-formula><mml:math id="inf134"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>ε</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> encourage <inline-formula><mml:math id="inf135"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula> to put uniform weights on many of its entries, leading to less precision in the metabolite matches. However, increasing <inline-formula><mml:math id="inf136"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>ε</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> also leads to better numerical stability and a significant speedup of the alternating minimization algorithm used to optimize the objective function (Appendix 1). In our implementation, we set <inline-formula><mml:math id="inf137"><mml:mi>ρ</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="inf138"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>ϵ</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> to the lowest possible values under which our optimization converges, with <inline-formula><mml:math id="inf139"><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>=</mml:mo><mml:mn>0.05</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="inf140"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>ϵ</mml:mi><mml:mo>=</mml:mo><mml:mn>0.005</mml:mn></mml:mrow></mml:mstyle></mml:math></inline-formula>.</p><p>Our full optimization problem can now be written as<disp-formula id="equ10"><label>(10)</label><mml:math id="m10"><mml:mrow><mml:msub><mml:mtext>UGW</mml:mtext><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:munder><mml:mo form="prefix">min</mml:mo><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi mathvariant="script">L</mml:mi></mml:mrow><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p><p>The UGW objective function is optimized through alternating minimization based on the code of <xref ref-type="bibr" rid="bib40">Sejourne et al., 2021</xref> using the unbalanced Sinkhorn algorithm <xref ref-type="bibr" rid="bib39">Séjourné et al., 2019</xref> from optimal transport (Appendix 1).</p></sec><sec id="s4-1-2"><title>Constraint on <inline-formula><mml:math id="inf141"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula> ratios</title><p>Matched metabolic features must have compatible <inline-formula><mml:math id="inf142"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mi>z</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> so we enforce that <inline-formula><mml:math id="inf143"><mml:mrow><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> when <inline-formula><mml:math id="inf144"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:msubsup><mml:mi>m</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msubsup><mml:mo>−</mml:mo><mml:msubsup><mml:mi>m</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>y</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mo>&gt;</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mrow><mml:mtext>gap</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> where <inline-formula><mml:math id="inf145"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>m</mml:mi><mml:mrow><mml:mtext>gap</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> is a user-specified threshold. Based on prior literature (<xref ref-type="bibr" rid="bib26">Loftfield et al., 2021</xref>; <xref ref-type="bibr" rid="bib21">Hsu et al., 2019</xref>; <xref ref-type="bibr" rid="bib12">Climaco Pinto et al., 2022</xref>; <xref ref-type="bibr" rid="bib19">Habra et al., 2021</xref>; <xref ref-type="bibr" rid="bib10">Chen et al., 2021</xref>), we set  <inline-formula><mml:math id="inf146"><mml:msub><mml:mi>m</mml:mi><mml:mtext>gap</mml:mtext></mml:msub></mml:math></inline-formula> = 0.01 ppm. Note that <inline-formula><mml:math id="inf147"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>m</mml:mi><mml:mrow><mml:mtext>gap</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> is not explicitly used in <xref ref-type="disp-formula" rid="equ10">Equation 10</xref> but is rather enforced in each iteration of our alternating minimization algorithm for the UGW objective (Appendix 1).</p><p>Unlike the <inline-formula><mml:math id="inf148"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula> ratios discussed above, RTs often exhibit a non-linear deviation (drift) between studies so we cannot enforce compatibility of RTs directly in our optimization. Instead, in the following step of our pipeline we ensure matched metabolite pairs have compatible RTs by estimating the drift function and subsequently using it to filter out metabolite matches whose RT values are inconsistent with the estimated drift.</p></sec><sec id="s4-1-3"><title>Estimation of the RT drift and filtering</title><p>Estimating the drift between RTs of two studies is a crucial step in assessing the validity of metabolite matches and discarding those pairs which are incompatible with the estimated drift.</p><p>Let <inline-formula><mml:math id="inf149"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mover><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:mstyle></mml:math></inline-formula> be the minimizer of <xref ref-type="disp-formula" rid="equ10">Equation 10</xref> obtained after optimization. We seek to estimate the RT drift function <inline-formula><mml:math id="inf150"><mml:mrow><mml:mi>f</mml:mi><mml:mo>:</mml:mo><mml:mrow><mml:msub><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo></mml:msub><mml:mo>→</mml:mo><mml:msub><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> which relates the retention times of matched features between the two studies. Namely, if feature <inline-formula><mml:math id="inf151"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mtext>fx</mml:mtext><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> and feature <inline-formula><mml:math id="inf152"><mml:msub><mml:mtext>fy</mml:mtext><mml:mi>j</mml:mi></mml:msub></mml:math></inline-formula> correspond to the same metabolic feature, then we must have that <inline-formula><mml:math id="inf153"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>R</mml:mi><mml:msubsup><mml:mi>T</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>y</mml:mi></mml:mrow></mml:msubsup><mml:mo>≈</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:msubsup><mml:mi>T</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula>.</p><p>We propose to learn the drift <inline-formula><mml:math id="inf154"><mml:mi>f</mml:mi></mml:math></inline-formula> through the weighted spline regression<disp-formula id="equ11"><label>(11)</label><mml:math id="m11"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:munder><mml:mo form="prefix">min</mml:mo><mml:mrow><mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">B</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:munder><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mrow><mml:mover><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>R</mml:mi><mml:msubsup><mml:mi>T</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>R</mml:mi><mml:msubsup><mml:mi>T</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>y</mml:mi></mml:mrow></mml:msubsup></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>where <inline-formula><mml:math id="inf155"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">B</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> is the set of <inline-formula><mml:math id="inf156"><mml:mi>n</mml:mi></mml:math></inline-formula>-order B-splines with <inline-formula><mml:math id="inf157"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> knots. All pairs <inline-formula><mml:math id="inf158"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi>R</mml:mi><mml:mo>⁢</mml:mo><mml:msubsup><mml:mi>T</mml:mi><mml:mi>i</mml:mi><mml:mi>x</mml:mi></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mi>R</mml:mi><mml:mo>⁢</mml:mo><mml:msubsup><mml:mi>T</mml:mi><mml:mi>j</mml:mi><mml:mi>y</mml:mi></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in objective <xref ref-type="disp-formula" rid="equ11">Equation 11</xref> are weighted by the coefficients of <inline-formula><mml:math id="inf159"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mover><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula> so that larger weights are given to pairs identified with high confidence in the first step of our procedure. The order of the B-splines was set to <inline-formula><mml:math id="inf160"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula> by default, while the number of knots <inline-formula><mml:math id="inf161"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> was selected by 10-fold cross-validation.</p><p>Pairs identified as incompatible with the estimated RT drift are then discarded from the coupling matrix. To do this, we first take the estimated RT drift <inline-formula><mml:math id="inf162"><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:math></inline-formula>, and the set of pairs <inline-formula><mml:math id="inf163"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mo>=</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>≠</mml:mo><mml:mn>0</mml:mn><mml:mo fence="false" stretchy="false">}</mml:mo></mml:mrow></mml:mstyle></mml:math></inline-formula> recovered in <inline-formula><mml:math id="inf164"><mml:mover accent="true"><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:math></inline-formula>. We then define the residual associated with <inline-formula><mml:math id="inf165"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula> as<disp-formula id="equ12"><label>(12)</label><mml:math id="m12"><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mrow><mml:mover><mml:mi>f</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">|</mml:mo></mml:mrow><mml:mrow><mml:mover><mml:mi>f</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:msubsup><mml:mi>T</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>R</mml:mi><mml:msubsup><mml:mi>T</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>y</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">|</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p><p>The 95% prediction interval and the median absolute deviation (MAD) of these residuals are given by<disp-formula id="equ13"><label>(13)</label><mml:math id="m13"><mml:mrow><mml:mtable rowspacing="3pt" columnspacing="1em" displaystyle="true"><mml:mtr><mml:mtd><mml:mtext>PI</mml:mtext><mml:mo>=</mml:mo><mml:mn>1.96</mml:mn><mml:mo>×</mml:mo><mml:mtext>std</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mrow><mml:mover><mml:mi>f</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtext>MAD</mml:mtext><mml:mo>=</mml:mo><mml:mtext>median</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mrow><mml:mover><mml:mi>f</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mi>μ</mml:mi><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mi>μ</mml:mi><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mtext>median</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mrow><mml:mover><mml:mi>f</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p><p>where <inline-formula><mml:math id="inf166"><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mi class="ltx_font_mathcaligraphic">𝒮</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:math></inline-formula> is the size of <inline-formula><mml:math id="inf167"><mml:mi class="ltx_font_mathcaligraphic">𝒮</mml:mi></mml:math></inline-formula> and the functions std and median denote the standard deviation and median respectively. Similar to the approach in <xref ref-type="bibr" rid="bib12">Climaco Pinto et al., 2022</xref>, we create a new filtered coupling matrix <inline-formula><mml:math id="inf168"><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> given by<disp-formula id="equ14"><label>(14)</label><mml:math id="m14"><mml:mrow><mml:msub><mml:mrow><mml:mover><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mtable columnalign="left left" rowspacing=".2em" columnspacing="1em" displaystyle="false"><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mover><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:mtext>if</mml:mtext><mml:mtext> </mml:mtext><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mrow><mml:mover><mml:mi>f</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&lt;</mml:mo><mml:msub><mml:mi>μ</mml:mi><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mtext>thresh</mml:mtext></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mtext>otherwise</mml:mtext></mml:mtd></mml:mtr></mml:mtable><mml:mo fence="true" stretchy="true" symmetric="true"/></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p><p>where <inline-formula><mml:math id="inf169"><mml:msub><mml:mi>r</mml:mi><mml:mtext>thresh</mml:mtext></mml:msub></mml:math></inline-formula> is a given filtering threshold. Following <xref ref-type="bibr" rid="bib19">Habra et al., 2021</xref>, the estimation and outlier detection step can be repeated for multiple iterations, to remove pairs that deviate significantly from the estimated drift and improve the robustness of the drift estimation. In our main algorithm, we use two preliminary iterations where estimate the RT drift and discard outliers outside of the 95% prediction interval by setting <inline-formula><mml:math id="inf170"><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mtext>thresh</mml:mtext></mml:msub><mml:mo>=</mml:mo><mml:mtext>PI</mml:mtext></mml:mrow></mml:math></inline-formula>. We the re-estimate the drift and perform a final filtering step with the more stringent MAD by setting <inline-formula><mml:math id="inf171"><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mtext>thresh</mml:mtext></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mn>2</mml:mn><mml:mo>×</mml:mo><mml:mtext>MAD</mml:mtext></mml:mrow></mml:mrow></mml:math></inline-formula>.</p><p>At this stage, it is possible for <inline-formula><mml:math id="inf172"><mml:mover accent="true"><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:math></inline-formula> to still contain coefficients of very small magnitude. As an optional postprocessing step, we discard these coefficients by setting all entries smaller than <inline-formula><mml:math id="inf173"><mml:mrow><mml:mi>τ</mml:mi><mml:mo>⁢</mml:mo><mml:mtext>max</mml:mtext><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mover accent="true"><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> to zero, for some user-defined <inline-formula><mml:math id="inf174"><mml:mrow><mml:mi>τ</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. Lastly, a feature from either study could have multiple possible matches, since <inline-formula><mml:math id="inf175"><mml:mover accent="true"><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:math></inline-formula> can have more than one non-zero coefficient per row or column. Although reporting multiple matches can be helpful in an exploratory context, for the sake of simplicity in our analysis, the final output of GromovMatcher returns a one-to-one matching, as we only keep those metabolite pairs <inline-formula><mml:math id="inf176"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> where the entry <inline-formula><mml:math id="inf177"><mml:msub><mml:mover accent="true"><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> is largest in its corresponding row and column. All nonzero entries of <inline-formula><mml:math id="inf178"><mml:mover accent="true"><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:math></inline-formula> which do not satisfy this criterion are set to zero. Finally, we convert <inline-formula><mml:math id="inf179"><mml:mover accent="true"><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:math></inline-formula> into a binary matching matrix <inline-formula><mml:math id="inf180"><mml:mrow><mml:mi>M</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">}</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> with ones in place of its nonzero entries and this final output is returned to the user.</p><p>As a naming convention, we use the abbreviation GM for our GromovMatcher method, and use the abbreviation GMT when running GromovMatcher with the optional <inline-formula><mml:math id="inf181"><mml:mi>τ</mml:mi></mml:math></inline-formula>-thresholding step with <inline-formula><mml:math id="inf182"><mml:mrow><mml:mi>τ</mml:mi><mml:mo>=</mml:mo><mml:mn>0.3</mml:mn></mml:mrow></mml:math></inline-formula>.</p></sec></sec><sec id="s4-2"><title>Metrics for dataset alignment</title><p>Every alignment method studied in this paper returns a binary <italic>partial matching</italic> matrix <inline-formula><mml:math id="inf183"><mml:mrow><mml:mi>M</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">}</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> which has at most one nonzero entry in each row and column. Specifically, <inline-formula><mml:math id="inf184"><mml:mrow><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> if metabolic features <inline-formula><mml:math id="inf185"><mml:mi>i</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="inf186"><mml:mi>j</mml:mi></mml:math></inline-formula> in both datasets correspond to each other and <inline-formula><mml:math id="inf187"><mml:mrow><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> otherwise. In our simulated experiments, we compare the partial matching <inline-formula><mml:math id="inf188"><mml:mi>M</mml:mi></mml:math></inline-formula> to a known ground-truth partial matching matrix <inline-formula><mml:math id="inf189"><mml:mrow><mml:msup><mml:mi>M</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">}</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>.</p><p>To do this, we first compute the number of true positives, false positives, true negatives, and false negatives as<disp-formula id="equ15"><label>(15)</label><mml:math id="m15"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mtable columnalign="left left" rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd><mml:mtext>TP</mml:mtext><mml:mo>=</mml:mo><mml:munderover><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msubsup><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mo>∗</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtext>FP</mml:mtext><mml:mo>=</mml:mo><mml:munderover><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msubsup><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mo>∗</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtext>TN</mml:mtext><mml:mo>=</mml:mo><mml:munderover><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msubsup><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mo>∗</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtext>FN</mml:mtext><mml:mo>=</mml:mo><mml:munderover><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msubsup><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mo>∗</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>where <bold>1</bold> denotes the indicator function. Then we use these values to compute the precision and recall as<disp-formula id="equ16"><label>(16)</label><mml:math id="m16"><mml:mrow><mml:mtable columnalign="center center" rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd><mml:mrow><mml:mi mathvariant="normal">P</mml:mi><mml:mi mathvariant="normal">r</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">s</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">o</mml:mi><mml:mi mathvariant="normal">n</mml:mi></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">P</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">P</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:mi mathvariant="normal">F</mml:mi><mml:mi mathvariant="normal">P</mml:mi></mml:mrow></mml:mrow></mml:mfrac></mml:mtd></mml:mtr><mml:mtr><mml:mtd/></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">a</mml:mi><mml:mi mathvariant="normal">l</mml:mi><mml:mi mathvariant="normal">l</mml:mi></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">P</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">P</mml:mi></mml:mrow><mml:mo>+</mml:mo><mml:mrow><mml:mi mathvariant="normal">F</mml:mi><mml:mi mathvariant="normal">N</mml:mi></mml:mrow></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p><p>Precision measures the fraction of correctly found matches out of all discovered metabolite matches, while recall, also know as sensitivity, measures the fraction of correctly matched pairs out of all truly matched pairs. These two statistics can be summarized into one metric called the F1-score by taking their harmonic mean<disp-formula id="equ17"><label>(17)</label><mml:math id="m17"><mml:mrow><mml:mtext>F1</mml:mtext><mml:mo>=</mml:mo><mml:mrow><mml:mn>2</mml:mn><mml:mo>⋅</mml:mo><mml:mfrac><mml:mrow><mml:mtext>Precision</mml:mtext><mml:mo>⋅</mml:mo><mml:mtext>Recall</mml:mtext></mml:mrow><mml:mrow><mml:mtext>Precision</mml:mtext><mml:mo>+</mml:mo><mml:mtext>Recall</mml:mtext></mml:mrow></mml:mfrac></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>These three metrics, precision, recall, and the F1-score, are used throughout the paper to assess the performance of dataset alignment methods, both on simulated data where the ground-truth matching is known, and on the validation subset in EPIC, using results from the manual examination as the ground-truth benchmark.</p></sec><sec id="s4-3"><title>Validation on simulated data</title><p>To assess the performance of GromovMatcher and compare it to existing dataset alignment methods, we simulate realistic pairs of untargeted metabolomics feature with known ground-truth matchings. This allows us to analyze the dependence of alignment methods on the number of shared metabolites, dataset noise level, and feature intensity centering and scaling.</p><sec id="s4-3-1"><title>Dataset generation</title><p>Our pairs of synthetic feature tables are generated from one real untargeted metabolomics study of 500 newborns within the EXPOsOMICS project, which uses reversed phase liquid chromatography-quadrupole time-of-flight mass spectrometry (UHPLC-QTOF-MS) system in positive ion mode <xref ref-type="bibr" rid="bib2">Alfano et al., 2020</xref>. The original dataset is first preprocessed following the procedure detailed in <xref ref-type="bibr" rid="bib2">Alfano et al., 2020</xref>, resulting in p=4712 features measured in <inline-formula><mml:math id="inf190"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>499</mml:mn></mml:mrow></mml:math></inline-formula> samples available for subsequent analysis. Features and samples from the original study are then divided into two feature tables of respective size <inline-formula><mml:math id="inf191"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="inf192"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, with <inline-formula><mml:math id="inf193"><mml:mrow><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="inf194"><mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>≤</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula>. In order to do this, <inline-formula><mml:math id="inf195"><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">⌊</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow><mml:mo stretchy="false">⌋</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> randomly chosen samples from the original study are placed into dataset 1 and the remaining <inline-formula><mml:math id="inf196"><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">⌈</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow><mml:mo stretchy="false">⌉</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> samples from the original study are placed into dataset 2. Here, <inline-formula><mml:math id="inf197"><mml:mrow><mml:mo stretchy="false">⌊</mml:mo><mml:mo>⋅</mml:mo><mml:mo stretchy="false">⌋</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="inf198"><mml:mrow><mml:mo stretchy="false">⌈</mml:mo><mml:mo>⋅</mml:mo><mml:mo stretchy="false">⌉</mml:mo></mml:mrow></mml:math></inline-formula> denote integer floor and ceiling functions. The features of the original study are randomly assigned to dataset 1, dataset 2, or both, allowing the resulting studies to have both common and study-specific features (<xref ref-type="fig" rid="fig2">Figure 2</xref>). Specifically, for a fixed overlap parameter <inline-formula><mml:math id="inf199"><mml:mrow><mml:mi>λ</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, we assign a random subset of <inline-formula><mml:math id="inf200"><mml:mrow><mml:mi/><mml:mo>≈</mml:mo><mml:mrow><mml:mi>λ</mml:mi><mml:mo>⁢</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> features into both dataset 1 and dataset 2 while the remaining <inline-formula><mml:math id="inf201"><mml:mrow><mml:mi/><mml:mo>≈</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:mrow><mml:mi>λ</mml:mi><mml:mo>⁢</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> features are divided equally between the two studies such that <inline-formula><mml:math id="inf202"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>. We choose <inline-formula><mml:math id="inf203"><mml:mrow><mml:mi>λ</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mn>0.25</mml:mn><mml:mo>,</mml:mo><mml:mn>0.5</mml:mn><mml:mo>,</mml:mo><mml:mn>0.75</mml:mn><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> corresponding to low, medium and high overlap. For more detailed information on how the dataset split is performed and for additional validation experiments with unbalanced dataset splits (e.g. <inline-formula><mml:math id="inf204"><mml:mrow><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>≠</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>≠</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>) we refer the reader to Appendix 3.</p><p>After generating a pair of studies, random noise is added to the <inline-formula><mml:math id="inf205"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula>, RT and intensity levels of features in dataset 2 to mimic variations in data acquisition across two different experiments. The noise added to each <inline-formula><mml:math id="inf206"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula> value in study <bold>2</bold> is sampled from a uniform distribution on the interval <inline-formula><mml:math id="inf207"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:mo>-</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mtext>M</mml:mtext></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mtext>M</mml:mtext></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> with <inline-formula><mml:math id="inf208"><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mtext>M</mml:mtext></mml:msub><mml:mo>=</mml:mo><mml:mn>0.01</mml:mn></mml:mrow></mml:math></inline-formula> (<xref ref-type="bibr" rid="bib12">Climaco Pinto et al., 2022</xref>). The RTs of dataset 2 are first deviated by the function <inline-formula><mml:math id="inf209"><mml:mrow><mml:mrow><mml:mi>f</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mrow><mml:mn>1.1</mml:mn><mml:mo>⁢</mml:mo><mml:mi>x</mml:mi></mml:mrow><mml:mo>+</mml:mo><mml:mrow><mml:mn>1.3</mml:mn><mml:mo>⁢</mml:mo><mml:mrow><mml:mi>sin</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mn>1.2</mml:mn><mml:mo>⁢</mml:mo><mml:msqrt><mml:mi>x</mml:mi></mml:msqrt></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula>, corresponding to a systematic inter-dataset drift (<xref ref-type="bibr" rid="bib19">Habra et al., 2021</xref>; <xref ref-type="bibr" rid="bib12">Climaco Pinto et al., 2022</xref>; <xref ref-type="bibr" rid="bib9">Brunius et al., 2016</xref>). A uniformly distributed noise on the interval <inline-formula><mml:math id="inf210"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:mo>-</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mtext>RT</mml:mtext></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mtext>RT</mml:mtext></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is added to the deviated RTs of dataset 2, with <inline-formula><mml:math id="inf211"><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mtext>RT</mml:mtext></mml:msub><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mn>0.2</mml:mn><mml:mo>,</mml:mo><mml:mn>0.5</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> (in minutes) corresponding to low, moderate and high variations (<xref ref-type="bibr" rid="bib12">Climaco Pinto et al., 2022</xref>; <xref ref-type="bibr" rid="bib19">Habra et al., 2021</xref>; <xref ref-type="bibr" rid="bib48">Vaughan et al., 2012</xref>). Finally, we add a Gaussian noise <inline-formula><mml:math id="inf212"><mml:mrow><mml:mi class="ltx_font_mathcaligraphic">𝒩</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:msubsup><mml:mi>σ</mml:mi><mml:mtext>FI</mml:mtext><mml:mn>2</mml:mn></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> to the feature intensities of both studies where <inline-formula><mml:math id="inf213"><mml:msub><mml:mi>σ</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mo>⁢</mml:mo><mml:mi>I</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> is the scalar variance of the noise. This noise perturbs the correlation matrices of dataset 1 and dataset 2, making matching based on feature intensity correlations more challenging. We vary <inline-formula><mml:math id="inf214"><mml:msub><mml:mi>σ</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mo>⁢</mml:mo><mml:mi>I</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> over the set of values {0.1, 0.5, 1}.</p><p>Given this data generation process, we test the performance of the four alignment methods (M2S, metabCombiner, GM, and GMT) under the parameter settings described below.</p></sec><sec id="s4-3-2"><title>Dependence on overlap</title><p>We first assess how the performance of the four methods is affected by the number of metabolic features shared in both datasets. For each value of <inline-formula><mml:math id="inf215"><mml:mrow><mml:mi>λ</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mn>0.25</mml:mn><mml:mo>,</mml:mo><mml:mn>0.5</mml:mn><mml:mo>,</mml:mo><mml:mn>0.75</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula> (low, medium, and high overlap), we randomly generate 20 pairs of datasets with noise on the <inline-formula><mml:math id="inf216"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula>, RT and feature intensities set to <inline-formula><mml:math id="inf217"><mml:mrow><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mtext>M</mml:mtext></mml:msub><mml:mo>=</mml:mo><mml:mn>0.01</mml:mn></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mtext>RT</mml:mtext></mml:msub><mml:mo>=</mml:mo><mml:mn>0.5</mml:mn></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mtext>FI</mml:mtext></mml:msub><mml:mo>=</mml:mo><mml:mn>0.5</mml:mn></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula>. The precision and recall of each method at low, medium, and high overlap is recorded for each of the repetitions.</p></sec><sec id="s4-3-3"><title>Noise robustness</title><p>Next, we test the robustness to noise of each method by fixing the metabolite overlap fraction at <inline-formula><mml:math id="inf218"><mml:mrow><mml:mi>λ</mml:mi><mml:mo>=</mml:mo><mml:mn>0.5</mml:mn></mml:mrow></mml:math></inline-formula> and generating 20 random pairs of datasets at low (<inline-formula><mml:math id="inf219"><mml:mrow><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mtext>RT</mml:mtext></mml:msub><mml:mo>=</mml:mo><mml:mn>0.2</mml:mn></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mtext>FI</mml:mtext></mml:msub><mml:mo>=</mml:mo><mml:mn>0.1</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula>), medium (<inline-formula><mml:math id="inf220"><mml:mrow><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mtext>RT</mml:mtext></mml:msub><mml:mo>=</mml:mo><mml:mn>0.5</mml:mn></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mtext>FI</mml:mtext></mml:msub><mml:mo>=</mml:mo><mml:mn>0.5</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula>), and high (<inline-formula><mml:math id="inf221"><mml:mrow><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mtext>RT</mml:mtext></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mtext>FI</mml:mtext></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula>) noise levels. Similarly, the precision and recall of each method is saved for each noise level across the 20 repetitions.</p></sec><sec id="s4-3-4"><title>Feature intensity centering and scaling</title><p>In order to test how all four methods are affected when the mean feature intensities and variance are not comparable across studies, we assess their performance when the feature intensities in both studies are mean centered and standardized to have unit standard deviation across all samples. We again generate 20 random pairs of datasets with medium overlap and medium noise, normalize the feature intensities in each pair of datasets, and compute the precision and recall of each method across the 20 repetitions.</p></sec></sec><sec id="s4-4"><title>EPIC data</title><p>We also evaluate our method on data collected within the European Prospective Investigation into Cancer and Nutrition (EPIC) cohort, an ongoing multicentric prospective study with over 500,000 participants recruited between 1992 and 2000 from 23 centers in 10 European countries, and who provided blood samples at the inclusion in the study (<xref ref-type="bibr" rid="bib36">Riboli et al., 2002</xref>). In EPIC, untargeted metabolomics data were successively acquired in several studies nested within the full cohort.</p><p>In the present work, we use untargeted metabolomics data acquired in three studies nested in EPIC, namely the EPIC cross-sectional (CS) study (<xref ref-type="bibr" rid="bib42">Slimani et al., 2003</xref>) and two matched case-control studies nested within EPIC, on hepatocellular carcinoma (HCC; <xref ref-type="bibr" rid="bib45">Stepien et al., 2016</xref>; <xref ref-type="bibr" rid="bib46">Stepien et al., 2021</xref>) and pancreatic cancer (PC; <xref ref-type="bibr" rid="bib16">Gasull et al., 2019</xref>), respectively. All data were acquired at the International Agency for Research on Cancer, making use of the same plateform and methodology: UHPLC-QTOF-MS (1290 Binary Liquid chromatography system, 6550 quadrupole time-of-flight mass spectrometer, Agilent Technologies, Santa Clara, CA) using reversed phase chromatography and electrospray ionization in both positive and negative ionization mode.</p><p>In a previous analysis aiming at identifying biomarkers of habitual alcohol intake in EPIC, the 205 features associated with alcohol intake in the CS study were manually matched to features in both the HCC and PC studies <xref ref-type="bibr" rid="bib26">Loftfield et al., 2021</xref>. The results from this manual matching are presented in <xref ref-type="table" rid="table1">Table 1</xref>. This matching process was based on the proximity of <inline-formula><mml:math id="inf222"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula> and RT, using a matching tolerance of ± 15 ppm and ± 0.2 min, and on the comparison of the chromatograms of features in a quality control samples from both studies.</p><sec id="s4-4-1"><title>Preprocessing</title><p>In the HCC and PC studies, samples corresponding to participants selected as cases in either study (i.e. participants selected in the study because of a diagnosis of incident HCC or PC) are excluded. Indeed, the metabolic profiles of participants selected as controls are expected to be more comparable across studies than those of cases, especially if certain features are associated with the risk of HCC or PC. Apart from this additional exclusion criterion, the untargeted metabolomics data of each study is pre-processed following the steps described in <xref ref-type="bibr" rid="bib26">Loftfield et al., 2021</xref>, to eliminate unreliable features and samples, impute missing values and minimize technical variations in the feature intensity levels.</p></sec><sec id="s4-4-2"><title>Alcohol biomarker discovery</title><p><xref ref-type="bibr" rid="bib26">Loftfield et al., 2021</xref> used the untargeted metabolomics data of the CS, HCC and PC studies in their alcohol biomarker discovery study in EPIC, without being able to automatically match their common features and pool the three datasets. Instead, the authors first implemented a discovery step, examining the relationship between alcohol intake and metabolic features measured in the CS study and accounting for multiple testing using a false discovery rate (FDR) correction. This led to the identification of 205 features significantly associated with alcohol intake in the CS study. In order to gauge the robustness of these associations, the authors of <xref ref-type="bibr" rid="bib26">Loftfield et al., 2021</xref> then implemented a validation step using data from two independent test sets. The first test set was composed of data from the EPIC HCC and PC studies, while the second was derived from the Finnish Alpha-Tocopherol, Beta-Carotene Cancer Prevention (ATBC) study. The 205 features identified in the discovery step were manually investigated for matches in the EPIC test set, and 67 features were effectively matched to features in the HCC or PC study, or both. The authors then evaluated the association between alcohol intake and those 67 features, applying a more conservative Bonferroni correction to determine whether the association with alcohol intake persisted. This step led to the identification of 10 features associated with alcohol intake (Extended Data <xref ref-type="fig" rid="fig5">Figure 5a</xref>). The second test set was then used to determine whether those 10 features were also significant in the ATBC population, which was indeed the case.</p><p>To conduct a more in-depth investigation of the matchings produced by the GromovMatcher algorithm, we build upon the analysis previously conducted by <xref ref-type="bibr" rid="bib26">Loftfield et al., 2021</xref> by exploring potential alcohol biomarkers using a pooled dataset created from the CS, HCC, and PC studies. Our goal is to assess whether pooling the data leads to increased statistical power and allows for the detection of more features associated with alcohol intake. Namely, we generate the pooled dataset by aligning a chosen reference dataset (CS study) with the HCC and PC studies successively using the GM matchings computed in both positive and negative mode (Materials and methods and Extended Data <xref ref-type="fig" rid="fig5">Figure 5b</xref>). Features that are not detected in either the HCC or PC studies are designated as ‘missing’ in the final pooled dataset for samples belonging to the respective studies where the feature is not found.</p><p>To evaluate the potential relationship between alcohol consumption and pooled metabolic features, we use a methodology akin to that of <xref ref-type="bibr" rid="bib26">Loftfield et al., 2021</xref>. The self-reported alcohol intake data is adjusted for various demographic and lifestyle factors (age, sex, country, body-mass-index, smoking status and intensity, coffee consumption, and study) via the residual method in linear regression models. Feature intensities are also adjusted for technical variables (plate number and position within the plate) via linear mixed effect models. The significance of the association is assessed using correlation coefficients computed from the residuals for both self-reported alcohol intake and feature intensities. p-Values are corrected using either false discovery rate (FDR) or Bonferroni correction to account for multiple testing. Corrected p-values less than 5% are considered significant.</p></sec></sec><sec id="s4-5"><title>Materials and correspondence</title><p>All correspondence and material requests should be addressed to V.V.</p></sec><sec id="s4-6"><title>IARC disclaimer</title><p>Where authors are identified as personnel of the International Agency for Research on Cancer/World Health Organization, the authors alone are responsible for the views expressed in this article and they do not necessarily represent the decisions, policy, or views of the International Agency for Research on Cancer/World Health Organization.</p></sec></sec></body><back><sec sec-type="additional-information" id="s5"><title>Additional information</title><fn-group content-type="competing-interest"><title>Competing interests</title><fn fn-type="COI-statement" id="conf1"><p>No competing interests declared</p></fn></fn-group><fn-group content-type="author-contribution"><title>Author contributions</title><fn fn-type="con" id="con1"><p>Software, Formal analysis, Validation, Investigation, Visualization, Methodology, Writing - original draft, Writing - review and editing</p></fn><fn fn-type="con" id="con2"><p>Software, Formal analysis, Validation, Investigation, Visualization, Methodology, Writing - original draft, Writing - review and editing</p></fn><fn fn-type="con" id="con3"><p>Data curation, Writing - original draft, Writing - review and editing</p></fn><fn fn-type="con" id="con4"><p>Conceptualization, Resources, Supervision, Funding acquisition, Investigation, Methodology, Writing - original draft, Writing - review and editing</p></fn><fn fn-type="con" id="con5"><p>Conceptualization, Resources, Supervision, Funding acquisition, Investigation, Methodology, Writing - original draft, Writing - review and editing</p></fn></fn-group><fn-group content-type="ethics-information"><title>Ethics</title><fn fn-type="other"><p>The EPIC study, and in particular the three studies nested within EPIC, were conducted according to the Declaration of Helsinki and approved by the ethics committee at the International Agency for Research on Cancer (IARC) (IEC 10-16 for the HCC and pancreatic cancer studies, IEC 12-29 for the cross-sectional study). Written informed consent was obtained from all subjects involved in the study.</p></fn></fn-group></sec><sec sec-type="supplementary-material" id="s6"><title>Additional files</title><supplementary-material id="mdar"><label>MDAR checklist</label><media xlink:href="elife-91597-mdarchecklist1-v1.docx" mimetype="application" mime-subtype="docx"/></supplementary-material></sec><sec sec-type="data-availability" id="s7"><title>Data availability</title><p>The LC-MS data used to generate our simulated validation experiments can be downloaded at <ext-link ext-link-type="uri" xlink:href="https://www.ebi.ac.uk/metabolights/MTBLS1684/files">https://www.ebi.ac.uk/metabolights/MTBLS1684/files</ext-link> at the bottom of the &quot;Files&quot; section in under filename 'FILES/metabolomics\_normalized\_data.xlsx'. The EPIC data is considered sensitive data and is therefore not publicly available. It is centralised at IARC and can be analysed through the IARC Scientific IT platform after a Data Use Agreement has been signed. Access requests should be submitted to the IARC Steering Committee <ext-link ext-link-type="uri" xlink:href="https://epic.iarc.fr/access/index.php">https://epic.iarc.fr/access/index.php</ext-link>. All code for the data preprocessing, figure generation, as well as the GromovMatcher algorithm and its comparison to other methods are available at: <ext-link ext-link-type="uri" xlink:href="https://github.com/sgstepaniants/GromovMatcher">https://github.com/sgstepaniants/GromovMatcher</ext-link> (copy archived at <xref ref-type="bibr" rid="bib7">Breeur and Stepaniants, 2024</xref>). Instructions and examples for how to run the GromovMatcher method are provided in the Github repository. The metabCombiner implementation written by the original authors was taken from their Github codebase: <ext-link ext-link-type="uri" xlink:href="https://github.com/hhabra/metabCombiner">https://github.com/hhabra/metabCombiner</ext-link> (<xref ref-type="bibr" rid="bib20">Habra, 2024</xref>). The M2S implementation of the original authors was taken from their Github codebase: <ext-link ext-link-type="uri" xlink:href="https://github.com/rjdossan/M2S">https://github.com/rjdossan/M2S</ext-link> (<xref ref-type="bibr" rid="bib37">Rjdossan, 2024</xref>).</p><p>The following previously published dataset was used:</p><p><element-citation publication-type="data" specific-use="references" id="dataset1"><person-group person-group-type="author"><name><surname>Vineis</surname><given-names>P</given-names></name><name><surname>Alfano</surname><given-names>R</given-names></name><name><surname>Chadeau-Hyam</surname><given-names>M</given-names></name><name><surname>Keski-Rahkonen</surname><given-names>P</given-names></name><name><surname>Robinot</surname><given-names>N</given-names></name><name><surname>Scalbert</surname><given-names>A</given-names></name><name><surname>Robinson</surname><given-names>O</given-names></name><name><surname>Plusquin</surname><given-names>M</given-names></name></person-group><year iso-8601-date="2020">2020</year><data-title>A multi-omic analysis of birthweight in newborn cord blood reveals new underlying mechanisms related to cholesterol metabolism</data-title><source>MetaboLights</source><pub-id pub-id-type="accession" xlink:href="https://www.ebi.ac.uk/metabolights/editor/MTBLS1684/descriptors">MTBLS1684</pub-id></element-citation></p></sec><ack id="ack"><title>Acknowledgements</title><p>We thank Jörn Dunkel for helpful advice on our manuscript. We acknowledge the MIT SuperCloud and Lincoln Laboratory Supercomputing Center <xref ref-type="bibr" rid="bib35">Reuther et al., 2018</xref> for providing HPC resources that have contributed to the research results reported within this paper. GS acknowledges support through a National Science Foundation Graduate Research Fellowship under Grant No. 1745302. PR is supported by NSF grants IIS-1838071, DMS-2022448, and CCF-2106377. MB and VV acknowledge support from World Cancer Research Fund (UK) through the World Cancer Research Fund International grant program (grant number: IIG_FULL_2022_013). We are grateful to the Principal Investigators of each of the EPIC centers for sharing the data for our experimental application.</p></ack><ref-list><title>References</title><ref id="bib1"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Agresti</surname><given-names>A</given-names></name><name><surname>Coull</surname><given-names>BA</given-names></name></person-group><year iso-8601-date="1998">1998</year><article-title>Approximate is better than “exact” for interval estimation of binomial proportions</article-title><source>The American Statistician</source><volume>52</volume><fpage>119</fpage><lpage>126</lpage><pub-id pub-id-type="doi">10.1080/00031305.1998.10480550</pub-id></element-citation></ref><ref id="bib2"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Alfano</surname><given-names>R</given-names></name><name><surname>Chadeau-Hyam</surname><given-names>M</given-names></name><name><surname>Ghantous</surname><given-names>A</given-names></name><name><surname>Keski-Rahkonen</surname><given-names>P</given-names></name><name><surname>Chatzi</surname><given-names>L</given-names></name><name><surname>Perez</surname><given-names>AE</given-names></name><name><surname>Herceg</surname><given-names>Z</given-names></name><name><surname>Kogevinas</surname><given-names>M</given-names></name><name><surname>de Kok</surname><given-names>TM</given-names></name><name><surname>Nawrot</surname><given-names>TS</given-names></name><name><surname>Novoloaca</surname><given-names>A</given-names></name><name><surname>Patel</surname><given-names>CJ</given-names></name><name><surname>Pizzi</surname><given-names>C</given-names></name><name><surname>Robinot</surname><given-names>N</given-names></name><name><surname>Rusconi</surname><given-names>F</given-names></name><name><surname>Scalbert</surname><given-names>A</given-names></name><name><surname>Sunyer</surname><given-names>J</given-names></name><name><surname>Vermeulen</surname><given-names>R</given-names></name><name><surname>Vrijheid</surname><given-names>M</given-names></name><name><surname>Vineis</surname><given-names>P</given-names></name><name><surname>Robinson</surname><given-names>O</given-names></name><name><surname>Plusquin</surname><given-names>M</given-names></name></person-group><year iso-8601-date="2020">2020</year><article-title>A multi-omic analysis of birthweight in newborn cord blood reveals new underlying mechanisms related to cholesterol metabolism</article-title><source>Metabolism</source><volume>110</volume><elocation-id>154292</elocation-id><pub-id pub-id-type="doi">10.1016/j.metabol.2020.154292</pub-id><pub-id pub-id-type="pmid">32553738</pub-id></element-citation></ref><ref id="bib3"><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Alvarez-Melis</surname><given-names>D</given-names></name><name><surname>Jaakkola</surname><given-names>T</given-names></name></person-group><year iso-8601-date="2018">2018</year><article-title>Gromov-Wasserstein Alignment of Word Embedding Spaces</article-title><conf-name>EMNLP Brussels, Belgium: Association for Computational Linguistics</conf-name><fpage>1881</fpage><lpage>1889</lpage><pub-id pub-id-type="doi">10.18653/v1/D18-1214</pub-id></element-citation></ref><ref id="bib4"><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Alvarez-Melis</surname><given-names>D</given-names></name><name><surname>Jegelka</surname><given-names>S</given-names></name><name><surname>Jaakkola</surname><given-names>TS</given-names></name></person-group><year iso-8601-date="2019">2019</year><article-title>Towards optimal transport with global Invariances</article-title><conf-name>Proceedings of the Twenty-Second International Conference on Artificial Intelligence and Statistics</conf-name><fpage>1870</fpage><lpage>1879</lpage></element-citation></ref><ref id="bib5"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Bedia</surname><given-names>C</given-names></name></person-group><year iso-8601-date="2022">2022</year><article-title>Metabolomics in environmental toxicology: Applications and challenges</article-title><source>Trends in Environmental Analytical Chemistry</source><volume>34</volume><elocation-id>e00161</elocation-id><pub-id pub-id-type="doi">10.1016/j.teac.2022.e00161</pub-id></element-citation></ref><ref id="bib6"><element-citation publication-type="preprint"><person-group person-group-type="author"><name><surname>Beier</surname><given-names>F</given-names></name><name><surname>Beinert</surname><given-names>R</given-names></name><name><surname>Steidl</surname><given-names>G</given-names></name></person-group><year iso-8601-date="2022">2022</year><article-title>Multi-Marginal Gromov-Wasserstein Transport and Barycenters</article-title><source>arXiv</source><ext-link ext-link-type="uri" xlink:href="https://arxiv.org/abs/2205.06725">https://arxiv.org/abs/2205.06725</ext-link></element-citation></ref><ref id="bib7"><element-citation publication-type="software"><person-group person-group-type="author"><name><surname>Breeur</surname><given-names>M</given-names></name><name><surname>Stepaniants</surname><given-names>G</given-names></name></person-group><year iso-8601-date="2024">2024</year><data-title>Gromovmatcher</data-title><version designator="swh:1:rev:c38a56b55e8746d874f94e371c6cdd1074b28b74">swh:1:rev:c38a56b55e8746d874f94e371c6cdd1074b28b74</version><source>Software Heritage</source><ext-link ext-link-type="uri" xlink:href="https://archive.softwareheritage.org/swh:1:dir:50b50a1a6db39925adf98e2590b931405370ad0f;origin=https://github.com/sgstepaniants/GromovMatcher;visit=swh:1:snp:0aaffd41891c81ac2f957cc0ea084767876eb756;anchor=swh:1:rev:c38a56b55e8746d874f94e371c6cdd1074b28b74">https://archive.softwareheritage.org/swh:1:dir:50b50a1a6db39925adf98e2590b931405370ad0f;origin=https://github.com/sgstepaniants/GromovMatcher;visit=swh:1:snp:0aaffd41891c81ac2f957cc0ea084767876eb756;anchor=swh:1:rev:c38a56b55e8746d874f94e371c6cdd1074b28b74</ext-link></element-citation></ref><ref id="bib8"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Brown</surname><given-names>LD</given-names></name><name><surname>Cai</surname><given-names>TT</given-names></name><name><surname>DasGupta</surname><given-names>A</given-names></name></person-group><year iso-8601-date="2001">2001</year><article-title>Interval estimation for a binomial proportion</article-title><source>Statistical Science</source><volume>16</volume><elocation-id>133</elocation-id><pub-id pub-id-type="doi">10.1214/ss/1009213286</pub-id></element-citation></ref><ref id="bib9"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Brunius</surname><given-names>C</given-names></name><name><surname>Shi</surname><given-names>L</given-names></name><name><surname>Landberg</surname><given-names>R</given-names></name></person-group><year iso-8601-date="2016">2016</year><article-title>Large-scale untargeted LC-MS metabolomics data correction using between-batch feature alignment and cluster-based within-batch signal intensity drift correction</article-title><source>Metabolomics</source><volume>12</volume><elocation-id>173</elocation-id><pub-id pub-id-type="doi">10.1007/s11306-016-1124-4</pub-id><pub-id pub-id-type="pmid">27746707</pub-id></element-citation></ref><ref id="bib10"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Chen</surname><given-names>L</given-names></name><name><surname>Lu</surname><given-names>W</given-names></name><name><surname>Wang</surname><given-names>L</given-names></name><name><surname>Xing</surname><given-names>X</given-names></name><name><surname>Chen</surname><given-names>Z</given-names></name><name><surname>Teng</surname><given-names>X</given-names></name><name><surname>Zeng</surname><given-names>X</given-names></name><name><surname>Muscarella</surname><given-names>AD</given-names></name><name><surname>Shen</surname><given-names>Y</given-names></name><name><surname>Cowan</surname><given-names>A</given-names></name><name><surname>McReynolds</surname><given-names>MR</given-names></name><name><surname>Kennedy</surname><given-names>BJ</given-names></name><name><surname>Lato</surname><given-names>AM</given-names></name><name><surname>Campagna</surname><given-names>SR</given-names></name><name><surname>Singh</surname><given-names>M</given-names></name><name><surname>Rabinowitz</surname><given-names>JD</given-names></name></person-group><year iso-8601-date="2021">2021</year><article-title>Metabolite discovery through global annotation of untargeted metabolomics data</article-title><source>Nature Methods</source><volume>18</volume><fpage>1377</fpage><lpage>1385</lpage><pub-id pub-id-type="doi">10.1038/s41592-021-01303-3</pub-id></element-citation></ref><ref id="bib11"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Chizat</surname><given-names>L</given-names></name><name><surname>Peyré</surname><given-names>G</given-names></name><name><surname>Schmitzer</surname><given-names>B</given-names></name><name><surname>Vialard</surname><given-names>FX</given-names></name></person-group><year iso-8601-date="2018">2018</year><article-title>Unbalanced optimal transport: Dynamic and Kantorovich formulations</article-title><source>Journal of Functional Analysis</source><volume>274</volume><fpage>3090</fpage><lpage>3123</lpage><pub-id pub-id-type="doi">10.1016/j.jfa.2018.03.008</pub-id></element-citation></ref><ref id="bib12"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Climaco Pinto</surname><given-names>R</given-names></name><name><surname>Karaman</surname><given-names>I</given-names></name><name><surname>Lewis</surname><given-names>MR</given-names></name><name><surname>Hällqvist</surname><given-names>J</given-names></name><name><surname>Kaluarachchi</surname><given-names>M</given-names></name><name><surname>Graça</surname><given-names>G</given-names></name><name><surname>Chekmeneva</surname><given-names>E</given-names></name><name><surname>Durainayagam</surname><given-names>B</given-names></name><name><surname>Ghanbari</surname><given-names>M</given-names></name><name><surname>Ikram</surname><given-names>MA</given-names></name><name><surname>Zetterberg</surname><given-names>H</given-names></name><name><surname>Griffin</surname><given-names>J</given-names></name><name><surname>Elliott</surname><given-names>P</given-names></name><name><surname>Tzoulaki</surname><given-names>I</given-names></name><name><surname>Dehghan</surname><given-names>A</given-names></name><name><surname>Herrington</surname><given-names>D</given-names></name><name><surname>Ebbels</surname><given-names>T</given-names></name></person-group><year iso-8601-date="2022">2022</year><article-title>Finding correspondence between metabolomic features in untargeted liquid chromatography-mass spectrometry metabolomics datasets</article-title><source>Analytical Chemistry</source><volume>94</volume><fpage>5493</fpage><lpage>5503</lpage><pub-id pub-id-type="doi">10.1021/acs.analchem.1c03592</pub-id><pub-id pub-id-type="pmid">35360896</pub-id></element-citation></ref><ref id="bib13"><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Courty</surname><given-names>N</given-names></name><name><surname>Flamary</surname><given-names>R</given-names></name><name><surname>Habrard</surname><given-names>A</given-names></name><name><surname>Rakotomamonjy</surname><given-names>A</given-names></name></person-group><year iso-8601-date="2017">2017</year><article-title>Joint distribution optimal transportation for domain adaptation</article-title><conf-name>NIPS’17: Proceedings of the 31st International Conference on Neural Information Processing Systems</conf-name><fpage>3733</fpage><lpage>3742</lpage></element-citation></ref><ref id="bib14"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Demetci</surname><given-names>P</given-names></name><name><surname>Santorella</surname><given-names>R</given-names></name><name><surname>Sandstede</surname><given-names>B</given-names></name><name><surname>Noble</surname><given-names>WS</given-names></name><name><surname>Singh</surname><given-names>R</given-names></name></person-group><year iso-8601-date="2022">2022</year><article-title>SCOT: Single-Cell Multi-Omics Alignment with Optimal Transport</article-title><source>Journal of Computational Biology</source><volume>29</volume><fpage>3</fpage><lpage>18</lpage><pub-id pub-id-type="doi">10.1089/cmb.2021.0446</pub-id><pub-id pub-id-type="pmid">35050714</pub-id></element-citation></ref><ref id="bib15"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Franzosa</surname><given-names>EA</given-names></name><name><surname>Sirota-Madi</surname><given-names>A</given-names></name><name><surname>Avila-Pacheco</surname><given-names>J</given-names></name><name><surname>Fornelos</surname><given-names>N</given-names></name><name><surname>Haiser</surname><given-names>HJ</given-names></name><name><surname>Reinker</surname><given-names>S</given-names></name><name><surname>Vatanen</surname><given-names>T</given-names></name><name><surname>Hall</surname><given-names>AB</given-names></name><name><surname>Mallick</surname><given-names>H</given-names></name><name><surname>McIver</surname><given-names>LJ</given-names></name><name><surname>Sauk</surname><given-names>JS</given-names></name><name><surname>Wilson</surname><given-names>RG</given-names></name><name><surname>Stevens</surname><given-names>BW</given-names></name><name><surname>Scott</surname><given-names>JM</given-names></name><name><surname>Pierce</surname><given-names>K</given-names></name><name><surname>Deik</surname><given-names>AA</given-names></name><name><surname>Bullock</surname><given-names>K</given-names></name><name><surname>Imhann</surname><given-names>F</given-names></name><name><surname>Porter</surname><given-names>JA</given-names></name><name><surname>Zhernakova</surname><given-names>A</given-names></name><name><surname>Fu</surname><given-names>J</given-names></name><name><surname>Weersma</surname><given-names>RK</given-names></name><name><surname>Wijmenga</surname><given-names>C</given-names></name><name><surname>Clish</surname><given-names>CB</given-names></name><name><surname>Vlamakis</surname><given-names>H</given-names></name><name><surname>Huttenhower</surname><given-names>C</given-names></name><name><surname>Xavier</surname><given-names>RJ</given-names></name></person-group><year iso-8601-date="2019">2019</year><article-title>Gut microbiome structure and metabolic activity in inflammatory bowel disease</article-title><source>Nature Microbiology</source><volume>4</volume><fpage>293</fpage><lpage>305</lpage><pub-id pub-id-type="doi">10.1038/s41564-018-0306-4</pub-id><pub-id pub-id-type="pmid">30531976</pub-id></element-citation></ref><ref id="bib16"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gasull</surname><given-names>M</given-names></name><name><surname>Pumarega</surname><given-names>J</given-names></name><name><surname>Kiviranta</surname><given-names>H</given-names></name><name><surname>Rantakokko</surname><given-names>P</given-names></name><name><surname>Raaschou-Nielsen</surname><given-names>O</given-names></name><name><surname>Bergdahl</surname><given-names>IA</given-names></name><name><surname>Sandanger</surname><given-names>TM</given-names></name><name><surname>Goñi</surname><given-names>F</given-names></name><name><surname>Cirera</surname><given-names>L</given-names></name><name><surname>Donat-Vargas</surname><given-names>C</given-names></name><name><surname>Alguacil</surname><given-names>J</given-names></name><name><surname>Iglesias</surname><given-names>M</given-names></name><name><surname>Tjønneland</surname><given-names>A</given-names></name><name><surname>Overvad</surname><given-names>K</given-names></name><name><surname>Mancini</surname><given-names>FR</given-names></name><name><surname>Boutron-Ruault</surname><given-names>M-C</given-names></name><name><surname>Severi</surname><given-names>G</given-names></name><name><surname>Johnson</surname><given-names>T</given-names></name><name><surname>Kühn</surname><given-names>T</given-names></name><name><surname>Trichopoulou</surname><given-names>A</given-names></name><name><surname>Karakatsani</surname><given-names>A</given-names></name><name><surname>Peppa</surname><given-names>E</given-names></name><name><surname>Palli</surname><given-names>D</given-names></name><name><surname>Pala</surname><given-names>V</given-names></name><name><surname>Tumino</surname><given-names>R</given-names></name><name><surname>Naccarati</surname><given-names>A</given-names></name><name><surname>Panico</surname><given-names>S</given-names></name><name><surname>Verschuren</surname><given-names>M</given-names></name><name><surname>Vermeulen</surname><given-names>R</given-names></name><name><surname>Rylander</surname><given-names>C</given-names></name><name><surname>Nøst</surname><given-names>TH</given-names></name><name><surname>Rodríguez-Barranco</surname><given-names>M</given-names></name><name><surname>Molinuevo</surname><given-names>A</given-names></name><name><surname>Chirlaque</surname><given-names>M-D</given-names></name><name><surname>Ardanaz</surname><given-names>E</given-names></name><name><surname>Sund</surname><given-names>M</given-names></name><name><surname>Key</surname><given-names>T</given-names></name><name><surname>Ye</surname><given-names>W</given-names></name><name><surname>Jenab</surname><given-names>M</given-names></name><name><surname>Michaud</surname><given-names>D</given-names></name><name><surname>Matullo</surname><given-names>G</given-names></name><name><surname>Canzian</surname><given-names>F</given-names></name><name><surname>Kaaks</surname><given-names>R</given-names></name><name><surname>Nieters</surname><given-names>A</given-names></name><name><surname>Nöthlings</surname><given-names>U</given-names></name><name><surname>Jeurnink</surname><given-names>S</given-names></name><name><surname>Chajes</surname><given-names>V</given-names></name><name><surname>Matejcic</surname><given-names>M</given-names></name><name><surname>Gunter</surname><given-names>M</given-names></name><name><surname>Aune</surname><given-names>D</given-names></name><name><surname>Riboli</surname><given-names>E</given-names></name><name><surname>Agudo</surname><given-names>A</given-names></name><name><surname>Gonzalez</surname><given-names>CA</given-names></name><name><surname>Weiderpass</surname><given-names>E</given-names></name><name><surname>Bueno-de-Mesquita</surname><given-names>B</given-names></name><name><surname>Duell</surname><given-names>EJ</given-names></name><name><surname>Vineis</surname><given-names>P</given-names></name><name><surname>Porta</surname><given-names>M</given-names></name></person-group><year iso-8601-date="2019">2019</year><article-title>Methodological issues in a prospective study on plasma concentrations of persistent organic pollutants and pancreatic cancer risk within the EPIC cohort</article-title><source>Environmental Research</source><volume>169</volume><fpage>417</fpage><lpage>433</lpage><pub-id pub-id-type="doi">10.1016/j.envres.2018.11.027</pub-id></element-citation></ref><ref id="bib17"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gomari</surname><given-names>DP</given-names></name><name><surname>Schweickart</surname><given-names>A</given-names></name><name><surname>Cerchietti</surname><given-names>L</given-names></name><name><surname>Paietta</surname><given-names>E</given-names></name><name><surname>Fernandez</surname><given-names>H</given-names></name><name><surname>Al-Amin</surname><given-names>H</given-names></name><name><surname>Suhre</surname><given-names>K</given-names></name><name><surname>Krumsiek</surname><given-names>J</given-names></name></person-group><year iso-8601-date="2022">2022</year><article-title>Variational autoencoders learn transferrable representations of metabolomics data</article-title><source>Communications Biology</source><volume>5</volume><elocation-id>645</elocation-id><pub-id pub-id-type="doi">10.1038/s42003-022-03579-3</pub-id><pub-id pub-id-type="pmid">35773471</pub-id></element-citation></ref><ref id="bib18"><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Gromov</surname><given-names>M</given-names></name></person-group><year iso-8601-date="2001">2001</year><source>Metric Structures for Riemannian and Non-Riemannian Spaces</source><publisher-name>Birkhäuser Boston, Inc</publisher-name><pub-id pub-id-type="doi">10.1007/978-0-8176-4583-0</pub-id></element-citation></ref><ref id="bib19"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Habra</surname><given-names>H</given-names></name><name><surname>Kachman</surname><given-names>M</given-names></name><name><surname>Bullock</surname><given-names>K</given-names></name><name><surname>Clish</surname><given-names>C</given-names></name><name><surname>Evans</surname><given-names>CR</given-names></name><name><surname>Karnovsky</surname><given-names>A</given-names></name></person-group><year iso-8601-date="2021">2021</year><article-title><italic>metabCombiner</italic>: Paired Untargeted LC-HRMS Metabolomics Feature Matching and Concatenation of Disparately Acquired Data Sets</article-title><source>Analytical Chemistry</source><volume>93</volume><fpage>5028</fpage><lpage>5036</lpage><pub-id pub-id-type="doi">10.1021/acs.analchem.0c03693</pub-id><pub-id pub-id-type="pmid">33724799</pub-id></element-citation></ref><ref id="bib20"><element-citation publication-type="software"><person-group person-group-type="author"><name><surname>Habra</surname><given-names>H</given-names></name></person-group><year iso-8601-date="2024">2024</year><data-title>metabCombiner</data-title><version designator="d248824">d248824</version><source>GitHub</source><ext-link ext-link-type="uri" xlink:href="https://github.com/hhabra/metabCombiner">https://github.com/hhabra/metabCombiner</ext-link></element-citation></ref><ref id="bib21"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hsu</surname><given-names>YHH</given-names></name><name><surname>Churchhouse</surname><given-names>C</given-names></name><name><surname>Pers</surname><given-names>TH</given-names></name><name><surname>Mercader</surname><given-names>JM</given-names></name><name><surname>Metspalu</surname><given-names>A</given-names></name><name><surname>Fischer</surname><given-names>K</given-names></name><name><surname>Fortney</surname><given-names>K</given-names></name><name><surname>Morgen</surname><given-names>EK</given-names></name><name><surname>Gonzalez</surname><given-names>C</given-names></name><name><surname>Gonzalez</surname><given-names>ME</given-names></name><name><surname>Esko</surname><given-names>T</given-names></name><name><surname>Hirschhorn</surname><given-names>JN</given-names></name></person-group><year iso-8601-date="2019">2019</year><article-title>PAIRUP-MS: Pathway analysis and imputation to relate unknowns in profiles from mass spectrometry-based metabolite data</article-title><source>PLOS Computational Biology</source><volume>15</volume><elocation-id>e1006734</elocation-id><pub-id pub-id-type="doi">10.1371/journal.pcbi.1006734</pub-id><pub-id pub-id-type="pmid">30640898</pub-id></element-citation></ref><ref id="bib22"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Ivanisevic</surname><given-names>J</given-names></name><name><surname>Want</surname><given-names>EJ</given-names></name></person-group><year iso-8601-date="2019">2019</year><article-title>From Samples to Insights into Metabolism: Uncovering Biologically Relevant Information in LC-HRMS Metabolomics Data</article-title><source>Metabolites</source><volume>9</volume><elocation-id>308</elocation-id><pub-id pub-id-type="doi">10.3390/metabo9120308</pub-id><pub-id pub-id-type="pmid">31861212</pub-id></element-citation></ref><ref id="bib23"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kantorovich</surname><given-names>LV</given-names></name></person-group><year iso-8601-date="2006">2006</year><article-title>On the translocation of masses</article-title><source>Journal of Mathematical Sciences</source><volume>133</volume><fpage>1381</fpage><lpage>1382</lpage><pub-id pub-id-type="doi">10.1007/s10958-006-0049-2</pub-id></element-citation></ref><ref id="bib24"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>L</given-names></name><name><surname>Zheng</surname><given-names>X</given-names></name><name><surname>Zhou</surname><given-names>Q</given-names></name><name><surname>Villanueva</surname><given-names>N</given-names></name><name><surname>Nian</surname><given-names>W</given-names></name><name><surname>Liu</surname><given-names>X</given-names></name><name><surname>Huan</surname><given-names>T</given-names></name></person-group><year iso-8601-date="2020">2020</year><article-title>Metabolomics-based discovery of molecular signatures for triple negative breast cancer in asian female population</article-title><source>Scientific Reports</source><volume>10</volume><elocation-id>370</elocation-id><pub-id pub-id-type="doi">10.1038/s41598-019-57068-5</pub-id><pub-id pub-id-type="pmid">31941951</pub-id></element-citation></ref><ref id="bib25"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Liu</surname><given-names>Q</given-names></name><name><surname>Walker</surname><given-names>D</given-names></name><name><surname>Uppal</surname><given-names>K</given-names></name><name><surname>Liu</surname><given-names>Z</given-names></name><name><surname>Ma</surname><given-names>C</given-names></name><name><surname>Tran</surname><given-names>V</given-names></name><name><surname>Li</surname><given-names>S</given-names></name><name><surname>Jones</surname><given-names>DP</given-names></name><name><surname>Yu</surname><given-names>T</given-names></name></person-group><year iso-8601-date="2020">2020</year><article-title>Addressing the batch effect issue for LC/MS metabolomics data in data preprocessing</article-title><source>Scientific Reports</source><volume>10</volume><elocation-id>13856</elocation-id><pub-id pub-id-type="doi">10.1038/s41598-020-70850-0</pub-id><pub-id pub-id-type="pmid">32807888</pub-id></element-citation></ref><ref id="bib26"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Loftfield</surname><given-names>E</given-names></name><name><surname>Stepien</surname><given-names>M</given-names></name><name><surname>Viallon</surname><given-names>V</given-names></name><name><surname>Trijsburg</surname><given-names>L</given-names></name><name><surname>Rothwell</surname><given-names>JA</given-names></name><name><surname>Robinot</surname><given-names>N</given-names></name><name><surname>Biessy</surname><given-names>C</given-names></name><name><surname>Bergdahl</surname><given-names>IA</given-names></name><name><surname>Bodén</surname><given-names>S</given-names></name><name><surname>Schulze</surname><given-names>MB</given-names></name><name><surname>Bergman</surname><given-names>M</given-names></name><name><surname>Weiderpass</surname><given-names>E</given-names></name><name><surname>Schmidt</surname><given-names>JA</given-names></name><name><surname>Zamora-Ros</surname><given-names>R</given-names></name><name><surname>Nøst</surname><given-names>TH</given-names></name><name><surname>Sandanger</surname><given-names>TM</given-names></name><name><surname>Sonestedt</surname><given-names>E</given-names></name><name><surname>Ohlsson</surname><given-names>B</given-names></name><name><surname>Katzke</surname><given-names>V</given-names></name><name><surname>Kaaks</surname><given-names>R</given-names></name><name><surname>Ricceri</surname><given-names>F</given-names></name><name><surname>Tjønneland</surname><given-names>A</given-names></name><name><surname>Dahm</surname><given-names>CC</given-names></name><name><surname>Sánchez</surname><given-names>M-J</given-names></name><name><surname>Trichopoulou</surname><given-names>A</given-names></name><name><surname>Tumino</surname><given-names>R</given-names></name><name><surname>Chirlaque</surname><given-names>M-D</given-names></name><name><surname>Masala</surname><given-names>G</given-names></name><name><surname>Ardanaz</surname><given-names>E</given-names></name><name><surname>Vermeulen</surname><given-names>R</given-names></name><name><surname>Brennan</surname><given-names>P</given-names></name><name><surname>Albanes</surname><given-names>D</given-names></name><name><surname>Weinstein</surname><given-names>SJ</given-names></name><name><surname>Scalbert</surname><given-names>A</given-names></name><name><surname>Freedman</surname><given-names>ND</given-names></name><name><surname>Gunter</surname><given-names>MJ</given-names></name><name><surname>Jenab</surname><given-names>M</given-names></name><name><surname>Sinha</surname><given-names>R</given-names></name><name><surname>Keski-Rahkonen</surname><given-names>P</given-names></name><name><surname>Ferrari</surname><given-names>P</given-names></name></person-group><year iso-8601-date="2021">2021</year><article-title>Novel biomarkers of habitual alcohol intake and associations with risk of pancreatic and liver cancers and liver disease mortality</article-title><source>Journal of the National Cancer Institute</source><volume>113</volume><fpage>1542</fpage><lpage>1550</lpage><pub-id pub-id-type="doi">10.1093/jnci/djab078</pub-id><pub-id pub-id-type="pmid">34010397</pub-id></element-citation></ref><ref id="bib27"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Mémoli</surname><given-names>F</given-names></name></person-group><year iso-8601-date="2011">2011</year><article-title>Gromov–wasserstein distances and the metric approach to object matching</article-title><source>Foundations of Computational Mathematics</source><volume>11</volume><fpage>417</fpage><lpage>487</lpage><pub-id pub-id-type="doi">10.1007/s10208-011-9093-5</pub-id></element-citation></ref><ref id="bib28"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Monge</surname><given-names>G</given-names></name></person-group><year iso-8601-date="1781">1781</year><article-title>Mémoire sur la théorie des déblais et des remblais</article-title><source>Mem. Math. Phys. Acad. Royale Sci</source><fpage>666</fpage><lpage>704</lpage></element-citation></ref><ref id="bib29"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Nitzan</surname><given-names>M</given-names></name><name><surname>Karaiskos</surname><given-names>N</given-names></name><name><surname>Friedman</surname><given-names>N</given-names></name><name><surname>Rajewsky</surname><given-names>N</given-names></name></person-group><year iso-8601-date="2019">2019</year><article-title>Gene expression cartography</article-title><source>Nature</source><volume>576</volume><fpage>132</fpage><lpage>137</lpage><pub-id pub-id-type="doi">10.1038/s41586-019-1773-3</pub-id><pub-id pub-id-type="pmid">31748748</pub-id></element-citation></ref><ref id="bib30"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Patti</surname><given-names>GJ</given-names></name></person-group><year iso-8601-date="2011">2011</year><article-title>Separation strategies for untargeted metabolomics</article-title><source>Journal of Separation Science</source><volume>34</volume><fpage>3460</fpage><lpage>3469</lpage><pub-id pub-id-type="doi">10.1002/jssc.201100532</pub-id><pub-id pub-id-type="pmid">21972197</pub-id></element-citation></ref><ref id="bib31"><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Peyré</surname><given-names>G</given-names></name><name><surname>Cuturi</surname><given-names>M</given-names></name><name><surname>Solomon</surname><given-names>J</given-names></name></person-group><year iso-8601-date="2016">2016</year><article-title>Gromov-wasserstein averaging of kernel and distance matrices</article-title><conf-name>ICML</conf-name><fpage>2664</fpage><lpage>2672</lpage><pub-id pub-id-type="doi">10.5555/3045390.3045671</pub-id></element-citation></ref><ref id="bib32"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Peyré</surname><given-names>G</given-names></name><name><surname>Cuturi</surname><given-names>M</given-names></name></person-group><year iso-8601-date="2019">2019</year><article-title>Computational optimal transport: With applications to data science</article-title><source>Foundations and Trends in Machine Learning</source><volume>11</volume><fpage>355</fpage><lpage>607</lpage><pub-id pub-id-type="doi">10.1561/2200000073</pub-id></element-citation></ref><ref id="bib33"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Pirhaji</surname><given-names>L</given-names></name><name><surname>Milani</surname><given-names>P</given-names></name><name><surname>Leidl</surname><given-names>M</given-names></name><name><surname>Curran</surname><given-names>T</given-names></name><name><surname>Avila-Pacheco</surname><given-names>J</given-names></name><name><surname>Clish</surname><given-names>CB</given-names></name><name><surname>White</surname><given-names>FM</given-names></name><name><surname>Saghatelian</surname><given-names>A</given-names></name><name><surname>Fraenkel</surname><given-names>E</given-names></name></person-group><year iso-8601-date="2016">2016</year><article-title>Revealing disease-associated pathways by network integration of untargeted metabolomics</article-title><source>Nature Methods</source><volume>13</volume><fpage>770</fpage><lpage>776</lpage><pub-id pub-id-type="doi">10.1038/nmeth.3940</pub-id><pub-id pub-id-type="pmid">27479327</pub-id></element-citation></ref><ref id="bib34"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rappaport</surname><given-names>SM</given-names></name><name><surname>Barupal</surname><given-names>DK</given-names></name><name><surname>Wishart</surname><given-names>D</given-names></name><name><surname>Vineis</surname><given-names>P</given-names></name><name><surname>Scalbert</surname><given-names>A</given-names></name></person-group><year iso-8601-date="2014">2014</year><article-title>The blood exposome and its role in discovering causes of disease</article-title><source>Environmental Health Perspectives</source><volume>122</volume><fpage>769</fpage><lpage>774</lpage><pub-id pub-id-type="doi">10.1289/ehp.1308015</pub-id><pub-id pub-id-type="pmid">24659601</pub-id></element-citation></ref><ref id="bib35"><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Reuther</surname><given-names>A</given-names></name><name><surname>Kepner</surname><given-names>J</given-names></name><name><surname>Byun</surname><given-names>C</given-names></name><name><surname>Samsi</surname><given-names>S</given-names></name><name><surname>Arcand</surname><given-names>W</given-names></name><name><surname>Bestor</surname><given-names>D</given-names></name><name><surname>Bergeron</surname><given-names>B</given-names></name><name><surname>Gadepally</surname><given-names>V</given-names></name><name><surname>Houle</surname><given-names>M</given-names></name><name><surname>Hubbell</surname><given-names>M</given-names></name><name><surname>Jones</surname><given-names>M</given-names></name><name><surname>Klein</surname><given-names>A</given-names></name><name><surname>Milechin</surname><given-names>L</given-names></name><name><surname>Mullen</surname><given-names>J</given-names></name><name><surname>Prout</surname><given-names>A</given-names></name><name><surname>Rosa</surname><given-names>A</given-names></name><name><surname>Yee</surname><given-names>C</given-names></name><name><surname>Michaleas</surname><given-names>P</given-names></name></person-group><year iso-8601-date="2018">2018</year><article-title>Interactive Supercomputing on 40,000 Cores for Machine Learning and Data Analysis</article-title><conf-name>2018 IEEE High Performance Extreme Computing Conference</conf-name><fpage>1</fpage><lpage>6</lpage><pub-id pub-id-type="doi">10.1109/HPEC.2018.8547629</pub-id></element-citation></ref><ref id="bib36"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Riboli</surname><given-names>E</given-names></name><name><surname>Hunt</surname><given-names>KJ</given-names></name><name><surname>Slimani</surname><given-names>N</given-names></name><name><surname>Ferrari</surname><given-names>P</given-names></name><name><surname>Norat</surname><given-names>T</given-names></name><name><surname>Fahey</surname><given-names>M</given-names></name><name><surname>Charrondière</surname><given-names>UR</given-names></name><name><surname>Hémon</surname><given-names>B</given-names></name><name><surname>Casagrande</surname><given-names>C</given-names></name><name><surname>Vignat</surname><given-names>J</given-names></name><name><surname>Overvad</surname><given-names>K</given-names></name><name><surname>Tjønneland</surname><given-names>A</given-names></name><name><surname>Clavel-Chapelon</surname><given-names>F</given-names></name><name><surname>Thiébaut</surname><given-names>A</given-names></name><name><surname>Wahrendorf</surname><given-names>J</given-names></name><name><surname>Boeing</surname><given-names>H</given-names></name><name><surname>Trichopoulos</surname><given-names>D</given-names></name><name><surname>Trichopoulou</surname><given-names>A</given-names></name><name><surname>Vineis</surname><given-names>P</given-names></name><name><surname>Palli</surname><given-names>D</given-names></name><name><surname>Bueno-de-Mesquita</surname><given-names>HB</given-names></name><name><surname>Peeters</surname><given-names>PHM</given-names></name><name><surname>Lund</surname><given-names>E</given-names></name><name><surname>Engeset</surname><given-names>D</given-names></name><name><surname>González</surname><given-names>CA</given-names></name><name><surname>Barricarte</surname><given-names>A</given-names></name><name><surname>Berglund</surname><given-names>G</given-names></name><name><surname>Hallmans</surname><given-names>G</given-names></name><name><surname>Day</surname><given-names>NE</given-names></name><name><surname>Key</surname><given-names>TJ</given-names></name><name><surname>Kaaks</surname><given-names>R</given-names></name><name><surname>Saracci</surname><given-names>R</given-names></name></person-group><year iso-8601-date="2002">2002</year><article-title>European Prospective Investigation into Cancer and Nutrition (EPIC): study populations and data collection</article-title><source>Public Health Nutrition</source><volume>5</volume><fpage>1113</fpage><lpage>1124</lpage><pub-id pub-id-type="doi">10.1079/PHN2002394</pub-id></element-citation></ref><ref id="bib37"><element-citation publication-type="software"><person-group person-group-type="author"><collab>Rjdossan</collab></person-group><year iso-8601-date="2024">2024</year><data-title>M2S</data-title><version designator="aaedc0a">aaedc0a</version><source>GitHub</source><ext-link ext-link-type="uri" xlink:href="https://github.com/rjdossan/M2S">https://github.com/rjdossan/M2S</ext-link></element-citation></ref><ref id="bib38"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Schiebinger</surname><given-names>G</given-names></name><name><surname>Shu</surname><given-names>J</given-names></name><name><surname>Tabaka</surname><given-names>M</given-names></name><name><surname>Cleary</surname><given-names>B</given-names></name><name><surname>Subramanian</surname><given-names>V</given-names></name><name><surname>Solomon</surname><given-names>A</given-names></name><name><surname>Gould</surname><given-names>J</given-names></name><name><surname>Liu</surname><given-names>S</given-names></name><name><surname>Lin</surname><given-names>S</given-names></name><name><surname>Berube</surname><given-names>P</given-names></name><name><surname>Lee</surname><given-names>L</given-names></name><name><surname>Chen</surname><given-names>J</given-names></name><name><surname>Brumbaugh</surname><given-names>J</given-names></name><name><surname>Rigollet</surname><given-names>P</given-names></name><name><surname>Hochedlinger</surname><given-names>K</given-names></name><name><surname>Jaenisch</surname><given-names>R</given-names></name><name><surname>Regev</surname><given-names>A</given-names></name><name><surname>Lander</surname><given-names>ES</given-names></name></person-group><year iso-8601-date="2019">2019</year><article-title>Optimal-transport analysis of single-cell gene expression identifies developmental trajectories in reprogramming</article-title><source>Cell</source><volume>176</volume><fpage>928</fpage><lpage>943</lpage><pub-id pub-id-type="doi">10.1016/j.cell.2019.01.006</pub-id><pub-id pub-id-type="pmid">30712874</pub-id></element-citation></ref><ref id="bib39"><element-citation publication-type="preprint"><person-group person-group-type="author"><name><surname>Séjourné</surname><given-names>T</given-names></name><name><surname>Feydy</surname><given-names>J</given-names></name><name><surname>Vialard</surname><given-names>FX</given-names></name><name><surname>Trouvé</surname><given-names>A</given-names></name><name><surname>Peyré</surname><given-names>G</given-names></name></person-group><year iso-8601-date="2019">2019</year><article-title>Sinkhorn Divergences for Unbalanced Optimal Transport</article-title><source>arXiv</source><ext-link ext-link-type="uri" xlink:href="https://arxiv.org/abs/1910.12958">https://arxiv.org/abs/1910.12958</ext-link></element-citation></ref><ref id="bib40"><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Sejourne</surname><given-names>T</given-names></name><name><surname>Vialard</surname><given-names>FX</given-names></name><name><surname>Peyré</surname><given-names>G</given-names></name></person-group><year iso-8601-date="2021">2021</year><article-title>The unbalanced gromov wasserstein distance: Conic formulation and relaxation</article-title><conf-name>Advances in Neural Information Processing Systems 34</conf-name><fpage>8766</fpage><lpage>8779</lpage></element-citation></ref><ref id="bib41"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Skoraczyński</surname><given-names>G</given-names></name><name><surname>Gambin</surname><given-names>A</given-names></name><name><surname>Miasojedow</surname><given-names>B</given-names></name></person-group><year iso-8601-date="2022">2022</year><article-title>Alignstein: Optimal transport for improved LC-MS retention time alignment</article-title><source>GigaScience</source><volume>11</volume><elocation-id>giac101</elocation-id><pub-id pub-id-type="doi">10.1093/gigascience/giac101</pub-id><pub-id pub-id-type="pmid">36329619</pub-id></element-citation></ref><ref id="bib42"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Slimani</surname><given-names>N</given-names></name><name><surname>Bingham</surname><given-names>S</given-names></name><name><surname>Runswick</surname><given-names>S</given-names></name><name><surname>Ferrari</surname><given-names>P</given-names></name><name><surname>Day</surname><given-names>NE</given-names></name><name><surname>Welch</surname><given-names>AA</given-names></name><name><surname>Key</surname><given-names>TJ</given-names></name><name><surname>Miller</surname><given-names>AB</given-names></name><name><surname>Boeing</surname><given-names>H</given-names></name><name><surname>Sieri</surname><given-names>S</given-names></name><name><surname>Veglia</surname><given-names>F</given-names></name><name><surname>Palli</surname><given-names>D</given-names></name><name><surname>Panico</surname><given-names>S</given-names></name><name><surname>Tumino</surname><given-names>R</given-names></name><name><surname>Bueno-De-Mesquita</surname><given-names>B</given-names></name><name><surname>Ocké</surname><given-names>MC</given-names></name><name><surname>Clavel-Chapelon</surname><given-names>F</given-names></name><name><surname>Trichopoulou</surname><given-names>A</given-names></name><name><surname>Van Staveren</surname><given-names>WA</given-names></name><name><surname>Riboli</surname><given-names>E</given-names></name></person-group><year iso-8601-date="2003">2003</year><article-title>Group level validation of protein intakes estimated by 24-hour diet recall and dietary questionnaires against 24-hour urinary nitrogen in the European Prospective Investigation into Cancer and Nutrition (EPIC) calibration study</article-title><source>Cancer Epidemiology, Biomarkers &amp; Prevention</source><volume>12</volume><fpage>784</fpage><lpage>795</lpage><pub-id pub-id-type="pmid">12917211</pub-id></element-citation></ref><ref id="bib43"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Smith</surname><given-names>CA</given-names></name><name><surname>Want</surname><given-names>EJ</given-names></name><name><surname>O’Maille</surname><given-names>G</given-names></name><name><surname>Abagyan</surname><given-names>R</given-names></name><name><surname>Siuzdak</surname><given-names>G</given-names></name></person-group><year iso-8601-date="2006">2006</year><article-title>XCMS: processing mass spectrometry data for metabolite profiling using nonlinear peak alignment, matching, and identification</article-title><source>Analytical Chemistry</source><volume>78</volume><fpage>779</fpage><lpage>787</lpage><pub-id pub-id-type="doi">10.1021/ac051437y</pub-id><pub-id pub-id-type="pmid">16448051</pub-id></element-citation></ref><ref id="bib44"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Solomon</surname><given-names>J</given-names></name><name><surname>Peyré</surname><given-names>G</given-names></name><name><surname>Kim</surname><given-names>VG</given-names></name><name><surname>Sra</surname><given-names>S</given-names></name></person-group><year iso-8601-date="2016">2016</year><article-title>Entropic metric alignment for correspondence problems</article-title><source>ACM Transactions on Graphics</source><volume>35</volume><fpage>1</fpage><lpage>13</lpage><pub-id pub-id-type="doi">10.1145/2897824.2925903</pub-id></element-citation></ref><ref id="bib45"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Stepien</surname><given-names>M</given-names></name><name><surname>Duarte-Salles</surname><given-names>T</given-names></name><name><surname>Fedirko</surname><given-names>V</given-names></name><name><surname>Floegel</surname><given-names>A</given-names></name><name><surname>Barupal</surname><given-names>DK</given-names></name><name><surname>Rinaldi</surname><given-names>S</given-names></name><name><surname>Achaintre</surname><given-names>D</given-names></name><name><surname>Assi</surname><given-names>N</given-names></name><name><surname>Tjønneland</surname><given-names>A</given-names></name><name><surname>Overvad</surname><given-names>K</given-names></name><name><surname>Bastide</surname><given-names>N</given-names></name><name><surname>Boutron-Ruault</surname><given-names>M-C</given-names></name><name><surname>Severi</surname><given-names>G</given-names></name><name><surname>Kühn</surname><given-names>T</given-names></name><name><surname>Kaaks</surname><given-names>R</given-names></name><name><surname>Aleksandrova</surname><given-names>K</given-names></name><name><surname>Boeing</surname><given-names>H</given-names></name><name><surname>Trichopoulou</surname><given-names>A</given-names></name><name><surname>Bamia</surname><given-names>C</given-names></name><name><surname>Lagiou</surname><given-names>P</given-names></name><name><surname>Saieva</surname><given-names>C</given-names></name><name><surname>Agnoli</surname><given-names>C</given-names></name><name><surname>Panico</surname><given-names>S</given-names></name><name><surname>Tumino</surname><given-names>R</given-names></name><name><surname>Naccarati</surname><given-names>A</given-names></name><name><surname>Bueno-de-Mesquita</surname><given-names>HBA</given-names></name><name><surname>Peeters</surname><given-names>PH</given-names></name><name><surname>Weiderpass</surname><given-names>E</given-names></name><name><surname>Quirós</surname><given-names>JR</given-names></name><name><surname>Agudo</surname><given-names>A</given-names></name><name><surname>Sánchez</surname><given-names>M-J</given-names></name><name><surname>Dorronsoro</surname><given-names>M</given-names></name><name><surname>Gavrila</surname><given-names>D</given-names></name><name><surname>Barricarte</surname><given-names>A</given-names></name><name><surname>Ohlsson</surname><given-names>B</given-names></name><name><surname>Sjöberg</surname><given-names>K</given-names></name><name><surname>Werner</surname><given-names>M</given-names></name><name><surname>Sund</surname><given-names>M</given-names></name><name><surname>Wareham</surname><given-names>N</given-names></name><name><surname>Khaw</surname><given-names>K-T</given-names></name><name><surname>Travis</surname><given-names>RC</given-names></name><name><surname>Schmidt</surname><given-names>JA</given-names></name><name><surname>Gunter</surname><given-names>M</given-names></name><name><surname>Cross</surname><given-names>A</given-names></name><name><surname>Vineis</surname><given-names>P</given-names></name><name><surname>Romieu</surname><given-names>I</given-names></name><name><surname>Scalbert</surname><given-names>A</given-names></name><name><surname>Jenab</surname><given-names>M</given-names></name></person-group><year iso-8601-date="2016">2016</year><article-title>Alteration of amino acid and biogenic amine metabolism in hepatobiliary cancers: Findings from a prospective cohort study</article-title><source>International Journal of Cancer</source><volume>138</volume><fpage>348</fpage><lpage>360</lpage><pub-id pub-id-type="doi">10.1002/ijc.29718</pub-id><pub-id pub-id-type="pmid">26238458</pub-id></element-citation></ref><ref id="bib46"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Stepien</surname><given-names>M</given-names></name><name><surname>Keski-Rahkonen</surname><given-names>P</given-names></name><name><surname>Kiss</surname><given-names>A</given-names></name><name><surname>Robinot</surname><given-names>N</given-names></name><name><surname>Duarte-Salles</surname><given-names>T</given-names></name><name><surname>Murphy</surname><given-names>N</given-names></name><name><surname>Perlemuter</surname><given-names>G</given-names></name><name><surname>Viallon</surname><given-names>V</given-names></name><name><surname>Tjønneland</surname><given-names>A</given-names></name><name><surname>Rostgaard-Hansen</surname><given-names>AL</given-names></name><name><surname>Dahm</surname><given-names>CC</given-names></name><name><surname>Overvad</surname><given-names>K</given-names></name><name><surname>Boutron-Ruault</surname><given-names>M-C</given-names></name><name><surname>Mancini</surname><given-names>FR</given-names></name><name><surname>Mahamat-Saleh</surname><given-names>Y</given-names></name><name><surname>Aleksandrova</surname><given-names>K</given-names></name><name><surname>Kaaks</surname><given-names>R</given-names></name><name><surname>Kühn</surname><given-names>T</given-names></name><name><surname>Trichopoulou</surname><given-names>A</given-names></name><name><surname>Karakatsani</surname><given-names>A</given-names></name><name><surname>Panico</surname><given-names>S</given-names></name><name><surname>Tumino</surname><given-names>R</given-names></name><name><surname>Palli</surname><given-names>D</given-names></name><name><surname>Tagliabue</surname><given-names>G</given-names></name><name><surname>Naccarati</surname><given-names>A</given-names></name><name><surname>Vermeulen</surname><given-names>RCH</given-names></name><name><surname>Bueno-de-Mesquita</surname><given-names>HB</given-names></name><name><surname>Weiderpass</surname><given-names>E</given-names></name><name><surname>Skeie</surname><given-names>G</given-names></name><name><surname>Ramón Quirós</surname><given-names>J</given-names></name><name><surname>Ardanaz</surname><given-names>E</given-names></name><name><surname>Mokoroa</surname><given-names>O</given-names></name><name><surname>Sala</surname><given-names>N</given-names></name><name><surname>Sánchez</surname><given-names>M-J</given-names></name><name><surname>Huerta</surname><given-names>JM</given-names></name><name><surname>Winkvist</surname><given-names>A</given-names></name><name><surname>Harlid</surname><given-names>S</given-names></name><name><surname>Ohlsson</surname><given-names>B</given-names></name><name><surname>Sjöberg</surname><given-names>K</given-names></name><name><surname>Schmidt</surname><given-names>JA</given-names></name><name><surname>Wareham</surname><given-names>N</given-names></name><name><surname>Khaw</surname><given-names>K-T</given-names></name><name><surname>Ferrari</surname><given-names>P</given-names></name><name><surname>Rothwell</surname><given-names>JA</given-names></name><name><surname>Gunter</surname><given-names>M</given-names></name><name><surname>Riboli</surname><given-names>E</given-names></name><name><surname>Scalbert</surname><given-names>A</given-names></name><name><surname>Jenab</surname><given-names>M</given-names></name></person-group><year iso-8601-date="2021">2021</year><article-title>Metabolic perturbations prior to hepatocellular carcinoma diagnosis: Findings from a prospective observational cohort study</article-title><source>International Journal of Cancer</source><volume>148</volume><fpage>609</fpage><lpage>625</lpage><pub-id pub-id-type="doi">10.1002/ijc.33236</pub-id><pub-id pub-id-type="pmid">32734650</pub-id></element-citation></ref><ref id="bib47"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Tautenhahn</surname><given-names>R</given-names></name><name><surname>Patti</surname><given-names>GJ</given-names></name><name><surname>Kalisiak</surname><given-names>E</given-names></name><name><surname>Miyamoto</surname><given-names>T</given-names></name><name><surname>Schmidt</surname><given-names>M</given-names></name><name><surname>Lo</surname><given-names>FY</given-names></name><name><surname>McBee</surname><given-names>J</given-names></name><name><surname>Baliga</surname><given-names>NS</given-names></name><name><surname>Siuzdak</surname><given-names>G</given-names></name></person-group><year iso-8601-date="2011">2011</year><article-title>metaXCMS: second-order analysis of untargeted metabolomics data</article-title><source>Analytical Chemistry</source><volume>83</volume><fpage>696</fpage><lpage>700</lpage><pub-id pub-id-type="doi">10.1021/ac102980g</pub-id><pub-id pub-id-type="pmid">21174458</pub-id></element-citation></ref><ref id="bib48"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Vaughan</surname><given-names>AA</given-names></name><name><surname>Dunn</surname><given-names>WB</given-names></name><name><surname>Allwood</surname><given-names>JW</given-names></name><name><surname>Wedge</surname><given-names>DC</given-names></name><name><surname>Blackhall</surname><given-names>FH</given-names></name><name><surname>Whetton</surname><given-names>AD</given-names></name><name><surname>Dive</surname><given-names>C</given-names></name><name><surname>Goodacre</surname><given-names>R</given-names></name></person-group><year iso-8601-date="2012">2012</year><article-title>Liquid chromatography-mass spectrometry calibration transfer and metabolomics data fusion</article-title><source>Analytical Chemistry</source><volume>84</volume><fpage>9848</fpage><lpage>9857</lpage><pub-id pub-id-type="doi">10.1021/ac302227c</pub-id><pub-id pub-id-type="pmid">23072438</pub-id></element-citation></ref><ref id="bib49"><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Villani</surname><given-names>C</given-names></name></person-group><year iso-8601-date="2021">2021</year><source>Topics in Optimal Transportation</source><publisher-name>American Mathematical Soc</publisher-name></element-citation></ref><ref id="bib50"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Wang</surname><given-names>TJ</given-names></name><name><surname>Larson</surname><given-names>MG</given-names></name><name><surname>Vasan</surname><given-names>RS</given-names></name><name><surname>Cheng</surname><given-names>S</given-names></name><name><surname>Rhee</surname><given-names>EP</given-names></name><name><surname>McCabe</surname><given-names>E</given-names></name><name><surname>Lewis</surname><given-names>GD</given-names></name><name><surname>Fox</surname><given-names>CS</given-names></name><name><surname>Jacques</surname><given-names>PF</given-names></name><name><surname>Fernandez</surname><given-names>C</given-names></name><name><surname>O’Donnell</surname><given-names>CJ</given-names></name><name><surname>Carr</surname><given-names>SA</given-names></name><name><surname>Mootha</surname><given-names>VK</given-names></name><name><surname>Florez</surname><given-names>JC</given-names></name><name><surname>Souza</surname><given-names>A</given-names></name><name><surname>Melander</surname><given-names>O</given-names></name><name><surname>Clish</surname><given-names>CB</given-names></name><name><surname>Gerszten</surname><given-names>RE</given-names></name></person-group><year iso-8601-date="2011">2011</year><article-title>Metabolite profiles and the risk of developing diabetes</article-title><source>Nature Medicine</source><volume>17</volume><fpage>448</fpage><lpage>453</lpage><pub-id pub-id-type="doi">10.1038/nm.2307</pub-id><pub-id pub-id-type="pmid">21423183</pub-id></element-citation></ref><ref id="bib51"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Wishart</surname><given-names>DS</given-names></name></person-group><year iso-8601-date="2019">2019</year><article-title>Metabolomics for investigating physiological and pathophysiological processes</article-title><source>Physiological Reviews</source><volume>99</volume><fpage>1819</fpage><lpage>1875</lpage><pub-id pub-id-type="doi">10.1152/physrev.00035.2018</pub-id><pub-id pub-id-type="pmid">31434538</pub-id></element-citation></ref><ref id="bib52"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Yang</surname><given-names>KD</given-names></name><name><surname>Damodaran</surname><given-names>K</given-names></name><name><surname>Venkatachalapathy</surname><given-names>S</given-names></name><name><surname>Soylemezoglu</surname><given-names>AC</given-names></name><name><surname>Shivashankar</surname><given-names>GV</given-names></name><name><surname>Uhler</surname><given-names>C</given-names></name></person-group><year iso-8601-date="2020">2020</year><article-title>Predicting cell lineages using autoencoders and optimal transport</article-title><source>PLOS Computational Biology</source><volume>16</volume><elocation-id>e1007828</elocation-id><pub-id pub-id-type="doi">10.1371/journal.pcbi.1007828</pub-id><pub-id pub-id-type="pmid">32343706</pub-id></element-citation></ref><ref id="bib53"><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Zhou</surname><given-names>B</given-names></name><name><surname>Xiao</surname><given-names>JF</given-names></name><name><surname>Tuli</surname><given-names>L</given-names></name><name><surname>Ressom</surname><given-names>HW</given-names></name></person-group><year iso-8601-date="2012">2012</year><article-title>LC-MS-based metabolomics</article-title><source>Molecular bioSystems</source><volume>8</volume><fpage>470</fpage><lpage>481</lpage><pub-id pub-id-type="doi">10.1039/c1mb05350g</pub-id><pub-id pub-id-type="pmid">22041788</pub-id></element-citation></ref></ref-list><app-group><app id="appendix-1"><title>Appendix 1</title><p>In this paper, we study how to match metabolic features across two datasets where Dataset 1 has <italic>p</italic><sub>1</sub> metabolic features measured across <italic>n</italic><sub>1</sub> patients and Dataset 2 has <italic>p</italic><sub>2</sub> metabolic features measured across <italic>n</italic><sub>2</sub> patients. Our goal is to identify pairs of indexes <inline-formula><mml:math id="inf223"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> with <inline-formula><mml:math id="inf224"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi mathvariant="normal">…</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="inf225"><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi mathvariant="normal">…</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, such that feature <inline-formula><mml:math id="inf226"><mml:mi>i</mml:mi></mml:math></inline-formula> in Dataset 1 and feature <inline-formula><mml:math id="inf227"><mml:mi>j</mml:mi></mml:math></inline-formula> in Dataset 2 correspond to the same metabolic feature. More formally, we aim to identify a <italic>matching matrix</italic><inline-formula><mml:math id="inf228"><mml:mrow><mml:msup><mml:mi>M</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">}</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> such that <inline-formula><mml:math id="inf229"><mml:mrow><mml:msubsup><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> if features <inline-formula><mml:math id="inf230"><mml:mi>i</mml:mi></mml:math></inline-formula> in Dataset 1 and feature <inline-formula><mml:math id="inf231"><mml:mi>j</mml:mi></mml:math></inline-formula> in Dataset 2 correspond to the same feature, hereafter referred to as <italic>matched</italic> features. Otherwise we set <inline-formula><mml:math id="inf232"><mml:mrow><mml:msubsup><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> otherwise. We emphasize that a matching matrix <inline-formula><mml:math id="inf233"><mml:msup><mml:mi>M</mml:mi><mml:mo>*</mml:mo></mml:msup></mml:math></inline-formula> can have at most one nonzero entry in each row and column.</p><p>Both of the datasets we aim to match are obtained from liquid chromatography-mass spectrometry (LC-MS) experiments. Hence, for Dataset 1 each metabolite <inline-formula><mml:math id="inf234"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is labeled with a mass-to-charge (<inline-formula><mml:math id="inf235"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula>) ratio <inline-formula><mml:math id="inf236"><mml:msubsup><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msubsup></mml:math></inline-formula> as well as a retention time (RT) given by <inline-formula><mml:math id="inf237"><mml:mrow><mml:mi>R</mml:mi><mml:mo>⁢</mml:mo><mml:msubsup><mml:mi>T</mml:mi><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula>. Additionally, each metabolite has a vector of intensities across patients denoted by <inline-formula><mml:math id="inf238"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msup></mml:mrow></mml:math></inline-formula>. Similarly, each metabolite <inline-formula><mml:math id="inf239"><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> in Dataset 2 is labeled by its <inline-formula><mml:math id="inf240"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula> ratio <inline-formula><mml:math id="inf241"><mml:msubsup><mml:mi>m</mml:mi><mml:mi>j</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:math></inline-formula>, its retention time <inline-formula><mml:math id="inf242"><mml:mrow><mml:mi>R</mml:mi><mml:mo>⁢</mml:mo><mml:msubsup><mml:mi>T</mml:mi><mml:mi>j</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula> and its vector of intensities across samples <inline-formula><mml:math id="inf243"><mml:mrow><mml:msub><mml:mi>Y</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msup></mml:mrow></mml:math></inline-formula>.</p><sec sec-type="appendix" id="s8"><title>Correlations and distances between metabolomic features</title><p>Features cannot be aligned based on their <inline-formula><mml:math id="inf244"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula> and RT alone as they are often too inconsistent across studies. Our method is based on the idea that, in addition to their <inline-formula><mml:math id="inf245"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula> and RT being compatible, the signal intensities of metabolites measured in two different studies should exhibit similar correlation structures, or more generally exhibit similar distances between their intensity vectors. In other words, if feature intensity vectors <inline-formula><mml:math id="inf246"><mml:mrow><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msup></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mi>Y</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> correspond to the same underlying feature (<inline-formula><mml:math id="inf247"><mml:mrow><mml:msubsup><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>) and similarly if <inline-formula><mml:math id="inf248"><mml:mrow><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msup></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mi>Y</mml:mi><mml:mi>l</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> correspond to the same feature (<inline-formula><mml:math id="inf249"><mml:mrow><mml:msubsup><mml:mi>M</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>⁢</mml:mo><mml:mi>l</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>), then we expect that<disp-formula id="equ18"><label>(18)</label><mml:math id="m18"><mml:mrow><mml:mrow><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">o</mml:mi><mml:mi mathvariant="normal">r</mml:mi><mml:mi mathvariant="normal">r</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>≈</mml:mo><mml:mrow><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">o</mml:mi><mml:mi mathvariant="normal">r</mml:mi><mml:mi mathvariant="normal">r</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mspace width="1em"/><mml:mrow><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">f</mml:mi></mml:mrow><mml:mspace width="thinmathspace"/><mml:mspace width="thinmathspace"/><mml:mspace width="thinmathspace"/><mml:msubsup><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mo>∗</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msubsup><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mo>∗</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>1.</mml:mn></mml:mrow></mml:math></disp-formula></p><p>Here we define <inline-formula><mml:math id="inf250"><mml:mrow><mml:mtext>corr</mml:mtext><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> to be the Pearson correlation coefficient between two feature intensity vectors <inline-formula><mml:math id="inf251"><mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mi>n</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> by<disp-formula id="equ19"><label>(19)</label><mml:math id="m19"><mml:mrow><mml:mrow><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">o</mml:mi><mml:mi mathvariant="normal">r</mml:mi><mml:mi mathvariant="normal">r</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mo fence="false" stretchy="false">⟨</mml:mo><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mrow><mml:mover><mml:mi>u</mml:mi><mml:mo stretchy="false">¯</mml:mo></mml:mover></mml:mrow><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>−</mml:mo><mml:mrow><mml:mover><mml:mi>v</mml:mi><mml:mo stretchy="false">¯</mml:mo></mml:mover></mml:mrow><mml:mo fence="false" stretchy="false">⟩</mml:mo></mml:mrow><mml:mrow><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mrow><mml:mover><mml:mi>u</mml:mi><mml:mo stretchy="false">¯</mml:mo></mml:mover></mml:mrow><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mi>v</mml:mi><mml:mo>−</mml:mo><mml:mrow><mml:mover><mml:mi>v</mml:mi><mml:mo stretchy="false">¯</mml:mo></mml:mover></mml:mrow><mml:mo fence="false" stretchy="false">‖</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula></p><p>where we define<disp-formula id="equ20"><label>(20)</label><mml:math id="m20"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mover><mml:mi>u</mml:mi><mml:mo stretchy="false">¯</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:mfrac><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mspace width="1em"/><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mi>u</mml:mi><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mo>=</mml:mo><mml:msqrt><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:msubsup><mml:mi>u</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:msqrt><mml:mo>,</mml:mo><mml:mspace width="1em"/><mml:mo fence="false" stretchy="false">⟨</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo fence="false" stretchy="false">⟩</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>as the mean value, Euclidean norm and inner product respectively. More generally, with <italic>d</italic><sub><italic>x</italic></sub> and <italic>d</italic><sub><italic>y</italic></sub> denoting two given distances on <inline-formula><mml:math id="inf252"><mml:msup><mml:mi>ℝ</mml:mi><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msup></mml:math></inline-formula> and <inline-formula><mml:math id="inf253"><mml:msup><mml:mi>ℝ</mml:mi><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msup></mml:math></inline-formula> respectively, we expect that<disp-formula id="equ21"><label>(21)</label><mml:math id="m21"><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>≈</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mspace width="1em"/><mml:mrow><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">f</mml:mi></mml:mrow><mml:mspace width="1em"/><mml:msubsup><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mo>∗</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msubsup><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mo>∗</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>1.</mml:mn></mml:mrow></mml:math></disp-formula></p><p>Throughout this paper, we use the normalized Euclidean distance defined for any <inline-formula><mml:math id="inf254"><mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mi>n</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> as<disp-formula id="equ22"><label>(22)</label><mml:math id="m22"><mml:mrow><mml:msup><mml:mi>d</mml:mi><mml:mrow><mml:mtext>euc</mml:mtext></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mfrac><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mi>v</mml:mi><mml:mo fence="false" stretchy="false">‖</mml:mo></mml:mrow></mml:math></disp-formula></p><p>where for <italic>d</italic><sub><italic>x</italic></sub> and <italic>d</italic><sub><italic>y</italic></sub> we take <inline-formula><mml:math id="inf255"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> respectively. If the signal intensity vectors <inline-formula><mml:math id="inf256"><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow></mml:math></inline-formula> are mean centered and normalized by their standard deviation as<disp-formula id="equ23"><label>(23)</label><mml:math id="m23"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>u</mml:mi><mml:mo stretchy="false">↦</mml:mo><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt><mml:mo>⋅</mml:mo><mml:mfrac><mml:mrow><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:mfrac><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mrow><mml:mo symmetric="true" maxsize="1.623em" minsize="1.623em">‖</mml:mo></mml:mrow><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:mfrac><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo symmetric="true" maxsize="1.623em" minsize="1.623em">‖</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>and likewise for <inline-formula><mml:math id="inf257"><mml:mi>v</mml:mi></mml:math></inline-formula>, then it follows that<disp-formula id="equ24"><label>(24)</label><mml:math id="m24"><mml:mrow><mml:msup><mml:mi>d</mml:mi><mml:mrow><mml:mtext>euc</mml:mtext></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msqrt><mml:mn>2</mml:mn><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mtext>corr</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow></mml:msqrt><mml:mo>=</mml:mo><mml:msqrt><mml:mn>2</mml:mn></mml:msqrt><mml:msup><mml:mi>d</mml:mi><mml:mrow><mml:mtext>cos</mml:mtext></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula></p><p>where we denote <inline-formula><mml:math id="inf258"><mml:mrow><mml:mrow><mml:msup><mml:mi>d</mml:mi><mml:mtext>cos</mml:mtext></mml:msup><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:mrow><mml:mtext>corr</mml:mtext><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:msqrt></mml:mrow></mml:math></inline-formula> as the cosine distance. For the purposes of this paper, we will always assume that <italic>d</italic><sub><italic>x</italic></sub> and <italic>d</italic><sub><italic>y</italic></sub> denote the normalized Euclidean distance from <xref ref-type="disp-formula" rid="equ22">Equation 22</xref>. As shown above, this will be implicitly equal to the cosine distance from <xref ref-type="disp-formula" rid="equ24">Equation 24</xref> on centered and scaled data.</p><p>The goal of metabolomic feature matching is to learn the binary matching matrix <inline-formula><mml:math id="inf259"><mml:msup><mml:mi>M</mml:mi><mml:mo>*</mml:mo></mml:msup></mml:math></inline-formula> that aligns the distances between pairs of features in the most consistent way possible as shown in <xref ref-type="disp-formula" rid="equ21">Equation 21</xref>. To formalize this notion into a practical algorithm, we use the mathematical theory of optimal transport (<xref ref-type="bibr" rid="bib32">Peyré and Cuturi, 2019</xref>) which we discuss next.</p></sec><sec sec-type="appendix" id="s9"><title>Optimal transport</title><p>Optimal transport (OT) applies in the setting when the points <inline-formula><mml:math id="inf260"><mml:msubsup><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msubsup></mml:math></inline-formula> and <inline-formula><mml:math id="inf261"><mml:msubsup><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msubsup></mml:math></inline-formula> being matched live in the same dimensional space <inline-formula><mml:math id="inf262"><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>. It aims to find a matching between each point <inline-formula><mml:math id="inf263"><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula> and its corresponding point <inline-formula><mml:math id="inf264"><mml:msub><mml:mi>Y</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:math></inline-formula> such that the sum of distances between matches is minimized. Matches between each pair of points can be stored in a matching matrix <inline-formula><mml:math id="inf265"><mml:mrow><mml:mi>M</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">}</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> such that <inline-formula><mml:math id="inf266"><mml:mrow><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> if <inline-formula><mml:math id="inf267"><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula> and <inline-formula><mml:math id="inf268"><mml:msub><mml:mi>Y</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:math></inline-formula> are matched, and <inline-formula><mml:math id="inf269"><mml:mrow><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> otherwise. Again we note that <inline-formula><mml:math id="inf270"><mml:mi>M</mml:mi></mml:math></inline-formula> must have at most one nonzero entry in each row and column to be a valid matching matrix.</p><p>Instead of searching over this space of binary matching matrices, optimal transport places masses <inline-formula><mml:math id="inf271"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> at all points <inline-formula><mml:math id="inf272"><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula> for <inline-formula><mml:math id="inf273"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi mathvariant="normal">…</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> and masses <inline-formula><mml:math id="inf274"><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> at all points <inline-formula><mml:math id="inf275"><mml:msub><mml:mi>Y</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:math></inline-formula> for <inline-formula><mml:math id="inf276"><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi mathvariant="normal">…</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> and optimizes over the space of probabilistic <italic>couplings</italic> <inline-formula><mml:math id="inf277"><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> which move a <inline-formula><mml:math id="inf278"><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> amount of mass from <inline-formula><mml:math id="inf279"><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula> to <inline-formula><mml:math id="inf280"><mml:msub><mml:mi>Y</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:math></inline-formula>. We assume here for simplicity that the sum of masses in both datasets are equal to one <inline-formula><mml:math id="inf281"><mml:mrow><mml:mrow><mml:msubsup><mml:mo largeop="true" symmetric="true">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msubsup><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:msubsup><mml:mo largeop="true" symmetric="true">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msubsup><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> and that the coupling <inline-formula><mml:math id="inf282"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula> transports all mass from <inline-formula><mml:math id="inf283"><mml:mi>a</mml:mi></mml:math></inline-formula> into <inline-formula><mml:math id="inf284"><mml:mi>b</mml:mi></mml:math></inline-formula>. More formally, optimal transport optimizes over the constrained set of couplings<disp-formula id="equ25"><label>(25)</label><mml:math id="m25"><mml:mrow><mml:mrow><mml:mi mathvariant="bold">U</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msubsup><mml:mo>:</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>a</mml:mi><mml:mspace width="thinmathspace"/><mml:mrow><mml:mi mathvariant="normal">a</mml:mi><mml:mi mathvariant="normal">n</mml:mi><mml:mi mathvariant="normal">d</mml:mi></mml:mrow><mml:mspace width="thinmathspace"/><mml:msup><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>where <inline-formula><mml:math id="inf285"><mml:msub><mml:mn>𝟏</mml:mn><mml:mi>p</mml:mi></mml:msub></mml:math></inline-formula> denotes the all ones vector of length <inline-formula><mml:math id="inf286"><mml:mi>p</mml:mi></mml:math></inline-formula>. In practice, the points <inline-formula><mml:math id="inf287"><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula> and <inline-formula><mml:math id="inf288"><mml:msub><mml:mi>Y</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:math></inline-formula> in each dataset are all treated the same and the masses placed on the data are chosen to be uniform <inline-formula><mml:math id="inf289"><mml:mrow><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mfrac><mml:mo>⁢</mml:mo><mml:msub><mml:mn>𝟏</mml:mn><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="inf290"><mml:mrow><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mfrac><mml:mo>⁢</mml:mo><mml:msub><mml:mn>𝟏</mml:mn><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>.</p><p>The cost function which optimal transport minimizes is the sum of squared distances of its transported mass<disp-formula id="equ26"><label>(26)</label><mml:math id="m26"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi mathvariant="script">E</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>where <inline-formula><mml:math id="inf291"><mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:msup><mml:mi>d</mml:mi><mml:mtext>euc</mml:mtext></mml:msup><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mfrac><mml:mo>⁢</mml:mo><mml:mrow><mml:mo>∥</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>-</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>∥</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula> is the Euclidean distance. The distance matrix <inline-formula><mml:math id="inf292"><mml:mrow><mml:mi>d</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> in the OT objective can be replaced more generally with a cost matrix <inline-formula><mml:math id="inf293"><mml:mrow><mml:mi>C</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> that is not necessarily a distance matrix. In this case the cost function becomes<disp-formula id="equ27"><label>(27)</label><mml:math id="m27"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi mathvariant="script">E</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>When the transport cost <inline-formula><mml:math id="inf294"><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> is a distance, the OT optimization defines a valid distance metric known as the <italic>optimal transport distance</italic> between discrete distributions <inline-formula><mml:math id="inf295"><mml:msubsup><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">}</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msubsup></mml:math></inline-formula> and <inline-formula><mml:math id="inf296"><mml:msubsup><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">}</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msubsup></mml:math></inline-formula> in <inline-formula><mml:math id="inf297"><mml:msup><mml:mi>ℝ</mml:mi><mml:mi>n</mml:mi></mml:msup></mml:math></inline-formula> given by<disp-formula id="equ28"><label>(28)</label><mml:math id="m28"><mml:mrow><mml:mtext>OT</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mo form="prefix">min</mml:mo><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mi mathvariant="bold">U</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:mi mathvariant="script">E</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p><p>When <inline-formula><mml:math id="inf298"><mml:mrow><mml:mi>d</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is Euclidean, this OT distance is also referred to as the <inline-formula><mml:math id="inf299"><mml:msup><mml:mi>L</mml:mi><mml:mn>1</mml:mn></mml:msup></mml:math></inline-formula> optimal transport distance, the Wasserstein 1-distance, or the Earth mover’s distance. As formulated, the computation of the optimal transport objective involves an optimization over coupling matrices <inline-formula><mml:math id="inf300"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula> which can be solved by linear programming (<xref ref-type="bibr" rid="bib32">Peyré and Cuturi, 2019</xref>). The OT optimization problem becomes time consuming for problems with many points <inline-formula><mml:math id="inf301"><mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>≫</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. We show in the next section how augmenting this distance with a regularization term leads to a more efficient algorithm for learning the optimal coupling <inline-formula><mml:math id="inf302"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula>.</p></sec><sec sec-type="appendix" id="s10"><title>Entropic regularization</title><p>Define the Kullback–Leibler (KL) divergence between two positive vectors <inline-formula><mml:math id="inf303"><mml:mrow><mml:mrow><mml:mi>μ</mml:mi><mml:mo>,</mml:mo><mml:mi>ν</mml:mi></mml:mrow><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mi>p</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> as<disp-formula id="equ29"><label>(29)</label><mml:math id="m29"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo>,</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:munderover><mml:msub><mml:mi>μ</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mi>ln</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:mfrac><mml:msub><mml:mi>μ</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>ν</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mfrac><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:munderover><mml:msub><mml:mi>μ</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:munderover><mml:msub><mml:mi>ν</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>Given fixed marginals <inline-formula><mml:math id="inf304"><mml:mrow><mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msup></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="inf305"><mml:mrow><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msup></mml:mrow></mml:math></inline-formula> from the previous section, we can define the entropy of a coupling matrix <inline-formula><mml:math id="inf306"><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> with respect to these fixed marginals as<disp-formula id="equ30"><label>(30)</label><mml:math id="m30"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">K</mml:mi><mml:mi mathvariant="normal">L</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mi>ln</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:mfrac><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>where <inline-formula><mml:math id="inf307"><mml:mrow><mml:msub><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>⁢</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> denotes the outer product. This can be further simplified as<disp-formula id="equ31"><label>(31)</label><mml:math id="m31"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mtable columnalign="left left" rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd><mml:mtd><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mi>ln</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:mfrac><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mi mathvariant="normal">l</mml:mi><mml:mi mathvariant="normal">n</mml:mi></mml:mrow><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:mfrac><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd><mml:mo>=</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>ln</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>ln</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>where we define <inline-formula><mml:math id="inf308"><mml:mrow><mml:mi>H</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> by<disp-formula id="equ32"><label>(32)</label><mml:math id="m32"><mml:mrow><mml:mrow><mml:mrow><mml:mi>H</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:munderover><mml:mo largeop="true" movablelimits="false" symmetric="true">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:munderover><mml:mrow><mml:munderover><mml:mo largeop="true" movablelimits="false" symmetric="true">∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:munderover><mml:mrow><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mi>ln</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p><p>In the second line of the derivation above, we used the fact that the entries of <inline-formula><mml:math id="inf309"><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math id="inf310"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula> summed to one, and in the third line we used the fact that the marginals <inline-formula><mml:math id="inf311"><mml:mi>a</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="inf312"><mml:mi>b</mml:mi></mml:math></inline-formula> were uniform. Under these assumptions, we see that the KL divergence <inline-formula><mml:math id="inf313"><mml:mrow><mml:msub><mml:mi>D</mml:mi><mml:mtext>KL</mml:mtext></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is independent of the values of the marginals <inline-formula><mml:math id="inf314"><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:math></inline-formula> and is equal to <inline-formula><mml:math id="inf315"><mml:mrow><mml:mi>H</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> up to constants.</p><p>Although here the general definition of entropy through the KL divergence reduces to the simpler formula of <inline-formula><mml:math id="inf316"><mml:mrow><mml:mi>H</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, in the following sections we will need to extend our analysis to cases when <inline-formula><mml:math id="inf317"><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math id="inf318"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula> have positive values that do not sum to one (i.e. not distributions). In this context, we will no longer have that <inline-formula><mml:math id="inf319"><mml:mrow><mml:mrow><mml:msub><mml:mi>D</mml:mi><mml:mtext>KL</mml:mtext></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mrow><mml:mi>H</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>+</mml:mo><mml:mrow><mml:mi>c</mml:mi><mml:mo>⁢</mml:mo><mml:mi>o</mml:mi><mml:mo>⁢</mml:mo><mml:mi>n</mml:mi><mml:mo>⁢</mml:mo><mml:mi>s</mml:mi><mml:mo>⁢</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula> but we will still be able to use <inline-formula><mml:math id="inf320"><mml:mrow><mml:msub><mml:mi>D</mml:mi><mml:mtext>KL</mml:mtext></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> as a general notion of entropy for <inline-formula><mml:math id="inf321"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula>.</p><p>The entropy of a coupling <inline-formula><mml:math id="inf322"><mml:mrow><mml:msub><mml:mi>D</mml:mi><mml:mtext>KL</mml:mtext></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is an important notion because it quantifies how uniform or smooth <inline-formula><mml:math id="inf323"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula> is with respect to the product distribution <inline-formula><mml:math id="inf324"><mml:mrow><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:math></inline-formula>. In particular, if <inline-formula><mml:math id="inf325"><mml:mi>a</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="inf326"><mml:mi>b</mml:mi></mml:math></inline-formula> are set to uniform distributions as commonly done in practice, then <inline-formula><mml:math id="inf327"><mml:mrow><mml:msub><mml:mi>D</mml:mi><mml:mtext>KL</mml:mtext></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is small when <inline-formula><mml:math id="inf328"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula> has close to uniform entries and is large otherwise. This notion of smoothness allows us to use <inline-formula><mml:math id="inf329"><mml:mrow><mml:msub><mml:mi>D</mml:mi><mml:mtext>KL</mml:mtext></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> as a regularizer in our optimal transport distance as<disp-formula id="equ33"><label>(33)</label><mml:math id="m33"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mrow><mml:mi mathvariant="script">L</mml:mi></mml:mrow><mml:mrow><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>where <inline-formula><mml:math id="inf330"><mml:mi>ε</mml:mi></mml:math></inline-formula> is a small regularization parameter. Note that here we have denoted the transport cost matrix by <inline-formula><mml:math id="inf331"><mml:mrow><mml:mi>C</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> which is not necessarily a distance matrix. The introduction of the regularizer <inline-formula><mml:math id="inf332"><mml:mrow><mml:mi>ε</mml:mi><mml:mo>⁢</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mtext>KL</mml:mtext></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> gives us an efficient iterative algorithm known as the <italic>Sinkhorn algorithm</italic> for optimizing <inline-formula><mml:math id="inf333"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula> which we describe in the following sections.</p></sec><sec sec-type="appendix" id="s11"><title>Unbalanced optimal transport</title><p>Before we introduce the Sinkhorn algorithm, we introduce a final modification to our optimal transport distance that allows us to learn couplings between distributions <inline-formula><mml:math id="inf334"><mml:mrow><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mi>p</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> that do not preserve mass. In other words, the coupling <inline-formula><mml:math id="inf335"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula> is not required to perfectly satisfy the marginal constraints <inline-formula><mml:math id="inf336"><mml:mrow><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>⁢</mml:mo><mml:msub><mml:mn>𝟏</mml:mn><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mi>a</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="inf337"><mml:mrow><mml:mrow><mml:msup><mml:mi mathvariant="normal">Π</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mo>⁢</mml:mo><mml:msub><mml:mn>𝟏</mml:mn><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:math></inline-formula>. In our metabolite matching problem, this is particularly useful as not all metabolites in one dataset necessarily appear in the other dataset and hence should be left unmatched. This modification of optimal transport, known as unbalanced optimal transport (UOT) <xref ref-type="bibr" rid="bib11">Chizat et al., 2018</xref>, optimizes the following cost function<disp-formula id="equ34"><label>(34)</label><mml:math id="m34"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mrow><mml:mi mathvariant="script">L</mml:mi></mml:mrow><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>where we have added two KL terms with regularization parameter <inline-formula><mml:math id="inf338"><mml:mi>ρ</mml:mi></mml:math></inline-formula> to enforce that the marginals of the coupling <inline-formula><mml:math id="inf339"><mml:mrow><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>⁢</mml:mo><mml:msub><mml:mn>𝟏</mml:mn><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msup><mml:mi mathvariant="normal">Π</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mo>⁢</mml:mo><mml:msub><mml:mn>𝟏</mml:mn><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> are approximately close to the prescribed marginals <inline-formula><mml:math id="inf340"><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:math></inline-formula> respectively. We have also kept the smoothness/entropy regularizer <inline-formula><mml:math id="inf341"><mml:mrow><mml:mi>ε</mml:mi><mml:mo>⁢</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mtext>KL</mml:mtext></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> from the previous section.</p></sec><sec sec-type="appendix" id="s12"><title>Unbalanced Sinkhorn algorithm</title><p>Now we are ready to present the unbalanced Sinkhorn algorithm <xref ref-type="bibr" rid="bib32">Peyré and Cuturi, 2019</xref> for optimizing the unbalanced optimal transport cost defined above. First we rewrite our optimization as<disp-formula id="equ35"><mml:math id="m35"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mtable columnalign="left left" rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd><mml:munder><mml:mo form="prefix">min</mml:mo><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi mathvariant="script">L</mml:mi></mml:mrow><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd><mml:mtd><mml:mo>=</mml:mo><mml:munder><mml:mo form="prefix">min</mml:mo><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:munder><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd><mml:mo>=</mml:mo><mml:munder><mml:mo form="prefix">min</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:munder><mml:munder><mml:mo form="prefix">min</mml:mo><mml:mtable rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd columnalign="right"><mml:mstyle mathsize="0.7em"><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msubsup></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right"><mml:mstyle mathsize="0.7em"><mml:mi mathvariant="normal">Π</mml:mi><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:msup><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>v</mml:mi></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:munder><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>The inner minimization can be solved exactly by introducing dual variables <inline-formula><mml:math id="inf342"><mml:mrow><mml:mrow><mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msup></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mi>g</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> and writing out the Lagrange dual problem<disp-formula id="equ36"><mml:math id="m36"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mtable columnalign="left left" rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd><mml:munder><mml:mo form="prefix">min</mml:mo><mml:mstyle scriptlevel="1"><mml:mtable rowspacing="0.1em" columnspacing="0em" displaystyle="false"><mml:mtr><mml:mtd columnalign="right"><mml:mstyle mathsize="0.7em"><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msubsup></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right"><mml:mstyle mathsize="0.7em"><mml:mi mathvariant="normal">Π</mml:mi><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:msup><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>v</mml:mi></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:mstyle></mml:munder><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msup><mml:mi>f</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msup><mml:mi>g</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="2em"/><mml:mspace width="2em"/><mml:mo>=</mml:mo><mml:munder><mml:mo form="prefix">max</mml:mo><mml:mrow><mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:mi>g</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:munder><mml:munder><mml:mo form="prefix">min</mml:mo><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:munder><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msup><mml:mi>f</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msup><mml:mi>g</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>where we have removed the terms <inline-formula><mml:math id="inf343"><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>⁢</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mtext>KL</mml:mtext></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="inf344"><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>⁢</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mtext>KL</mml:mtext></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> since they do not depend on <inline-formula><mml:math id="inf345"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula>. Taking the gradient in <inline-formula><mml:math id="inf346"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula> in the inner minimization and setting it to zero we get<disp-formula id="equ37"><mml:math id="m37"><mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mrow><mml:mi>ε</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="160%" minsize="160%">(</mml:mo><mml:mstyle displaystyle="true"><mml:mfrac><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>⁢</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mstyle><mml:mo maxsize="160%" minsize="160%">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mrow><mml:mo>-</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></disp-formula></p><p>which implies that<disp-formula id="equ38"><mml:math id="m38"><mml:mrow><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>⁢</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="160%" minsize="160%">(</mml:mo><mml:mstyle displaystyle="true"><mml:mfrac><mml:mrow><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo>-</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>ε</mml:mi></mml:mfrac></mml:mstyle><mml:mo maxsize="160%" minsize="160%">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>Now we can substitute this expression for <inline-formula><mml:math id="inf347"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula> back into our Lagrange dual problem. First we compute<disp-formula id="equ39"><mml:math id="m39"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>ε</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>ε</mml:mi><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>which implies that<disp-formula id="equ40"><mml:math id="m40"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mtable columnalign="left left" rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msup><mml:mi>f</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msup><mml:mi>g</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="2em"/><mml:mspace width="2em"/><mml:mspace width="2em"/><mml:mspace width="2em"/><mml:mo>=</mml:mo><mml:msup><mml:mi>u</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:mi>f</mml:mi><mml:mo>+</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:mi>g</mml:mi><mml:mo>−</mml:mo><mml:mi>ε</mml:mi><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>ε</mml:mi></mml:mfrac><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>Hence, the outer maximization in our Lagrange dual problem for <inline-formula><mml:math id="inf348"><mml:mi>f</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="inf349"><mml:mi>g</mml:mi></mml:math></inline-formula> can now be written as<disp-formula id="equ41"><mml:math id="m41"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:munder><mml:mo form="prefix">max</mml:mo><mml:mrow><mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:mi>g</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:munder><mml:msup><mml:mi>u</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:mi>f</mml:mi><mml:mo>+</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:mi>g</mml:mi><mml:mo>−</mml:mo><mml:mi>ε</mml:mi><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>ε</mml:mi></mml:mfrac><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>where we have removed the last constant sum in <inline-formula><mml:math id="inf350"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>⁢</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. Finally we can rewrite our entire minimization from the start of this section as<disp-formula id="equ42"><mml:math id="m42"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mtable columnalign="left left" rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd><mml:munder><mml:mo form="prefix">min</mml:mo><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi mathvariant="script">L</mml:mi></mml:mrow><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd><mml:mtd><mml:mo>=</mml:mo><mml:munder><mml:mo form="prefix">min</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:munder><mml:munder><mml:mo form="prefix">min</mml:mo><mml:mstyle scriptlevel="1"><mml:mtable rowspacing="0.1em" columnspacing="0em" displaystyle="false"><mml:mtr><mml:mtd columnalign="right"><mml:mstyle mathsize="0.7em"><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msubsup></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right"><mml:mstyle mathsize="0.7em"><mml:mi mathvariant="normal">Π</mml:mi><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:msup><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>v</mml:mi></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:mstyle></mml:munder><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd><mml:mo>=</mml:mo><mml:munder><mml:mo form="prefix">min</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:munder><mml:munder><mml:mo form="prefix">max</mml:mo><mml:mrow><mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:mi>g</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:munder><mml:msup><mml:mi>u</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:mi>f</mml:mi><mml:mo>+</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:mi>g</mml:mi><mml:mo>−</mml:mo><mml:mi>ε</mml:mi><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>ε</mml:mi></mml:mfrac><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>By strong duality, we can interchange the minimum and maximum above to write<disp-formula id="equ43"><mml:math id="m43"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mtable columnalign="left left" rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd><mml:munder><mml:mo form="prefix">min</mml:mo><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi mathvariant="script">L</mml:mi></mml:mrow><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd><mml:mtd><mml:mo>=</mml:mo><mml:munder><mml:mo form="prefix">max</mml:mo><mml:mrow><mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:mi>g</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:munder><mml:munder><mml:mo form="prefix">min</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:munder><mml:msup><mml:mi>u</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:mi>f</mml:mi><mml:mo>+</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:mi>g</mml:mi><mml:mo>−</mml:mo><mml:mi>ε</mml:mi><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>ε</mml:mi></mml:mfrac><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd><mml:mo>=</mml:mo><mml:msup><mml:mi>U</mml:mi><mml:mrow><mml:mo>∗</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msup><mml:mi>V</mml:mi><mml:mrow><mml:mo>∗</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>ε</mml:mi><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>ε</mml:mi></mml:mfrac><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>where we define the functions<disp-formula id="equ44"><label>(35)</label><mml:math id="m44"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mtable columnalign="left left" rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd><mml:msup><mml:mi>U</mml:mi><mml:mrow><mml:mo>∗</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mo movablelimits="true" form="prefix">min</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:munder><mml:msup><mml:mi>u</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:mi>f</mml:mi><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msup><mml:mi>V</mml:mi><mml:mrow><mml:mo>∗</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mo movablelimits="true" form="prefix">min</mml:mo><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:munder><mml:msup><mml:mi>v</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:mi>g</mml:mi><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>In fact, we can solve the minimizations in <inline-formula><mml:math id="inf351"><mml:msup><mml:mi>U</mml:mi><mml:mo>*</mml:mo></mml:msup></mml:math></inline-formula> and <inline-formula><mml:math id="inf352"><mml:msup><mml:mi>V</mml:mi><mml:mo>*</mml:mo></mml:msup></mml:math></inline-formula> in closed form to get the minimizers <inline-formula><mml:math id="inf353"><mml:mrow><mml:msup><mml:mi>u</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>=</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>⊙</mml:mo><mml:mrow><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mo>-</mml:mo><mml:mrow><mml:mi>f</mml:mi><mml:mo>/</mml:mo><mml:mi>ρ</mml:mi></mml:mrow></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="inf354"><mml:mrow><mml:msup><mml:mi>v</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>=</mml:mo><mml:mrow><mml:mi>b</mml:mi><mml:mo>⊙</mml:mo><mml:mrow><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mo>-</mml:mo><mml:mrow><mml:mi>g</mml:mi><mml:mo>/</mml:mo><mml:mi>ρ</mml:mi></mml:mrow></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula> which we can substitute back in to get<disp-formula id="equ45"><mml:math id="m45"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mtable columnalign="left left" rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd><mml:msup><mml:mi>U</mml:mi><mml:mrow><mml:mo>∗</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd><mml:mtd><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msubsup><mml:mi>u</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo>∗</mml:mo></mml:mrow></mml:msubsup><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msubsup><mml:mi>u</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo>∗</mml:mo></mml:mrow></mml:msubsup><mml:mi>ln</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:mfrac><mml:msubsup><mml:mi>u</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo>∗</mml:mo></mml:mrow></mml:msubsup><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mfrac><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>ρ</mml:mi><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msubsup><mml:mi>u</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo>∗</mml:mo></mml:mrow></mml:msubsup><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msubsup><mml:mi>u</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo>∗</mml:mo></mml:mrow></mml:msubsup><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msubsup><mml:mi>u</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo>∗</mml:mo></mml:mrow></mml:msubsup><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>ρ</mml:mi><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mi>ρ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mi>ρ</mml:mi><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mi>ρ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>Likewise we can see that<disp-formula id="equ46"><mml:math id="m46"><mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mi>V</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mrow><mml:mo>-</mml:mo><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo largeop="true" movablelimits="false" symmetric="true">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:munderover></mml:mstyle><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mo>-</mml:mo><mml:mrow><mml:msub><mml:mi>g</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>/</mml:mo><mml:mi>ρ</mml:mi></mml:mrow></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:mrow><mml:mo>+</mml:mo><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo largeop="true" movablelimits="false" symmetric="true">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:munderover></mml:mstyle><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:mrow></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p><p>Thus, we can rewrite our full optimization as<disp-formula id="equ47"><mml:math id="m47"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mtable columnalign="left left" rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd><mml:munder><mml:mo form="prefix">min</mml:mo><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi mathvariant="script">L</mml:mi></mml:mrow><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd><mml:mtd><mml:mo>=</mml:mo><mml:munder><mml:mo form="prefix">max</mml:mo><mml:mrow><mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:mi>g</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:munder><mml:mo>−</mml:mo><mml:mi>ρ</mml:mi><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mi>ρ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>ρ</mml:mi><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mi>ρ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>ε</mml:mi><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>ε</mml:mi></mml:mfrac><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd><mml:mo>=</mml:mo><mml:munder><mml:mo form="prefix">min</mml:mo><mml:mrow><mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:mi>g</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:munder><mml:mi>ρ</mml:mi><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mi>ρ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mi>ρ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>ε</mml:mi></mml:mfrac><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>where we have removed the terms independent of <inline-formula><mml:math id="inf355"><mml:mi>f</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="inf356"><mml:mi>g</mml:mi></mml:math></inline-formula>.</p><p>Note that now we can optimize the cost function above by performing an alternating minimization on the dual variables <inline-formula><mml:math id="inf357"><mml:mi>f</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="inf358"><mml:mi>g</mml:mi></mml:math></inline-formula>. Taking the gradient in <inline-formula><mml:math id="inf359"><mml:mi>f</mml:mi></mml:math></inline-formula> and setting it to zero we see that<disp-formula id="equ48"><mml:math id="m48"><mml:mrow><mml:mrow><mml:mrow><mml:mo>-</mml:mo><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mo>-</mml:mo><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>/</mml:mo><mml:mi>ρ</mml:mi></mml:mrow></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mrow><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo largeop="true" movablelimits="false" symmetric="true">∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:munderover></mml:mstyle><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="160%" minsize="160%">(</mml:mo><mml:mstyle displaystyle="true"><mml:mfrac><mml:mrow><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo>-</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>ε</mml:mi></mml:mfrac></mml:mstyle><mml:mo maxsize="160%" minsize="160%">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></disp-formula></p><p>which implies that<disp-formula id="equ49"><mml:math id="m49"><mml:mrow><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>-</mml:mo><mml:mrow><mml:mstyle displaystyle="true"><mml:mfrac><mml:mrow><mml:mi>ε</mml:mi><mml:mo>⁢</mml:mo><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mi>ε</mml:mi><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi></mml:mrow></mml:mfrac></mml:mstyle><mml:mo>⁢</mml:mo><mml:mrow><mml:mi>ln</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="160%" minsize="160%">(</mml:mo><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo largeop="true" movablelimits="false" symmetric="true">∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:munderover></mml:mstyle><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="160%" minsize="160%">(</mml:mo><mml:mstyle displaystyle="true"><mml:mfrac><mml:mrow><mml:msub><mml:mi>g</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>ε</mml:mi></mml:mfrac></mml:mstyle><mml:mo maxsize="160%" minsize="160%">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mrow><mml:mo maxsize="160%" minsize="160%">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p><p>Similarly, we can write out<disp-formula id="equ50"><mml:math id="m50"><mml:mrow><mml:mrow><mml:msub><mml:mi>g</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>-</mml:mo><mml:mrow><mml:mstyle displaystyle="true"><mml:mfrac><mml:mrow><mml:mi>ε</mml:mi><mml:mo>⁢</mml:mo><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mi>ε</mml:mi><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi></mml:mrow></mml:mfrac></mml:mstyle><mml:mo>⁢</mml:mo><mml:mrow><mml:mi>ln</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="160%" minsize="160%">(</mml:mo><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo largeop="true" movablelimits="false" symmetric="true">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:munderover></mml:mstyle><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="160%" minsize="160%">(</mml:mo><mml:mstyle displaystyle="true"><mml:mfrac><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>ε</mml:mi></mml:mfrac></mml:mstyle><mml:mo maxsize="160%" minsize="160%">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mrow><mml:mo maxsize="160%" minsize="160%">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p><p>We are now ready to write out the full unbalanced Sinkhorn algorithm which performs an alternating minimization on the dual potentials <inline-formula><mml:math id="inf360"><mml:mrow><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:mi>g</mml:mi></mml:mrow></mml:math></inline-formula> as outlined above. We remind the reader that the coupling matrix can be recovered from the dual potentials by the formula<disp-formula id="equ51"><mml:math id="m51"><mml:mrow><mml:mrow><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>⁢</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="160%" minsize="160%">(</mml:mo><mml:mstyle displaystyle="true"><mml:mfrac><mml:mrow><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo>-</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>ε</mml:mi></mml:mfrac></mml:mstyle><mml:mo maxsize="160%" minsize="160%">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p><p>The unbalanced Sinkhorn algorithm proceeds as follows.</p><table-wrap id="inlinetable1" position="anchor"><table frame="hsides" rules="groups" id="AL1"><thead><tr><th align="left" valign="bottom">Algorithm 1. UnbalancedSinkhorn</th></tr></thead><tbody><tr><td align="left" valign="bottom"><bold>input</bold>: Transport cost <inline-formula><mml:math id="inf361"><mml:mi>C</mml:mi></mml:math></inline-formula>, marginals <inline-formula><mml:math id="inf362"><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:math></inline-formula>, marginal relaxation <inline-formula><mml:math id="inf363"><mml:mi>ρ</mml:mi></mml:math></inline-formula>, entropic regularization <inline-formula><mml:math id="inf364"><mml:mi>ε</mml:mi></mml:math></inline-formula><break/><bold>output</bold>: Return the coupling matrix <inline-formula><mml:math id="inf365"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula> <break/>Initialize <inline-formula><mml:math id="inf366"><mml:mrow><mml:mi>g</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula><break/><bold>while</bold> <inline-formula><mml:math id="inf367"><mml:mrow><mml:mo mathvariant="normal" stretchy="false">(</mml:mo><mml:mi>f</mml:mi><mml:mo mathvariant="normal">,</mml:mo><mml:mi>g</mml:mi><mml:mo mathvariant="normal" stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> has not converged <bold>do</bold><break/>  Set <inline-formula><mml:math id="inf368"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">←</mml:mo><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mi>ε</mml:mi><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mi>ε</mml:mi><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi></mml:mrow></mml:mfrac><mml:mi>ln</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>ε</mml:mi></mml:mfrac><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula> for <inline-formula><mml:math id="inf369"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula><break/>	   Set <inline-formula><mml:math id="inf370"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">←</mml:mo><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mi>ε</mml:mi><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mi>ε</mml:mi><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi></mml:mrow></mml:mfrac><mml:mi>ln</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>ε</mml:mi></mml:mfrac><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula> for <inline-formula><mml:math id="inf371"><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> <break/>Return the coupling matrix <inline-formula><mml:math id="inf372"><mml:mrow><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>⁢</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="160%" minsize="160%">(</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo>-</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>ε</mml:mi></mml:mfrac><mml:mo maxsize="160%" minsize="160%">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula> for <inline-formula><mml:math id="inf373"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="inf374"><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td></tr></tbody></table></table-wrap><p>The final output of the Sinkhorn algorithm optimization is a real-valued coupling matrix <inline-formula><mml:math id="inf375"><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>. In some cases, it is desirable to transform the coupling matrix into a binary-valued matching matrix <inline-formula><mml:math id="inf376"><mml:mrow><mml:mi>M</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">}</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> with possibly an added restriction that there is at most one nonzero element in each row and column (to obtain a valid partial matching). This can be done by either thresholding the real matrix <inline-formula><mml:math id="inf377"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula> or by assigning all maximal entries in each row (or column) to one and setting the remaining entries to zero. For our metabolomics matching problem, we describe our procedure for transforming our real-valued coupling into a binary matching matrix in the section on the GromovMatcher algorithm below.</p></sec><sec sec-type="appendix" id="s13"><title>Gromov–Wasserstein</title><p>Now that we have introduced the general formulation of unbalanced optimal transport and its corresponding Sinkhorn algorithm, we can extend this formulation to matching problems between distributions of points that live in different dimensional spaces. In our metabolomics setting, we aim to match two datasets of <italic>p</italic><sub>1</sub> and <italic>p</italic><sub>2</sub> metabolic features respectively where each feature in a dataset is associated with a feature intensity vector <inline-formula><mml:math id="inf378"><mml:mrow><mml:msubsup><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msubsup><mml:mo>⊂</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msup></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="inf379"><mml:mrow><mml:msubsup><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msubsup><mml:mo>⊂</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msup></mml:mrow></mml:math></inline-formula> respectively across samples. We assume that there exists a true matching matrix <inline-formula><mml:math id="inf380"><mml:mrow><mml:msup><mml:mi>M</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">}</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> with at most one nonzero entry in each row and column such that two metabolites <inline-formula><mml:math id="inf381"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> are matched if <inline-formula><mml:math id="inf382"><mml:mrow><mml:msubsup><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>.</p><p>We make the further assumption that if feature vectors <inline-formula><mml:math id="inf383"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> are matched and feature vectors <inline-formula><mml:math id="inf384"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> are matched under <inline-formula><mml:math id="inf385"><mml:msup><mml:mi>M</mml:mi><mml:mo>*</mml:mo></mml:msup></mml:math></inline-formula>, then we expect that<disp-formula id="equ52"><label>(36)</label><mml:math id="m52"><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>≈</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mspace width="1em"/><mml:mrow><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">f</mml:mi></mml:mrow><mml:mspace width="1em"/><mml:msubsup><mml:mi mathvariant="normal">M</mml:mi><mml:mrow><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">j</mml:mi></mml:mrow><mml:mrow><mml:mo>∗</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msubsup><mml:mi mathvariant="normal">M</mml:mi><mml:mrow><mml:mi mathvariant="normal">k</mml:mi><mml:mi mathvariant="normal">l</mml:mi></mml:mrow><mml:mrow><mml:mo>∗</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>1.</mml:mn></mml:mrow></mml:math></disp-formula></p><p>where <italic>d</italic><sub><italic>x</italic></sub> is a distance metric on <inline-formula><mml:math id="inf386"><mml:msup><mml:mi>ℝ</mml:mi><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msup></mml:math></inline-formula> and <italic>d</italic><sub><italic>y</italic></sub> is a distance metric n <inline-formula><mml:math id="inf387"><mml:msup><mml:mi>ℝ</mml:mi><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msup></mml:math></inline-formula>. In practice, we always choose these distance metrics to be the normalized Euclidean distance defined for any <inline-formula><mml:math id="inf388"><mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mi>n</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> as<disp-formula id="equ53"><label>(37)</label><mml:math id="m53"><mml:mrow><mml:msup><mml:mi>d</mml:mi><mml:mrow><mml:mtext>euc</mml:mtext></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mfrac><mml:mo fence="false" stretchy="false">‖</mml:mo><mml:mi>u</mml:mi><mml:mo>−</mml:mo><mml:mi>v</mml:mi><mml:mo fence="false" stretchy="false">‖</mml:mo></mml:mrow></mml:math></disp-formula></p><p>which is equal to the cosine distance <inline-formula><mml:math id="inf389"><mml:msup><mml:mi>d</mml:mi><mml:mtext>cos</mml:mtext></mml:msup></mml:math></inline-formula> (i.e. one minus the correlation) for centered and scaled data. Given these two distance matrices <inline-formula><mml:math id="inf390"><mml:mrow><mml:msup><mml:mi>D</mml:mi><mml:mi>x</mml:mi></mml:msup><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msubsup><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="inf391"><mml:mrow><mml:msup><mml:mi>D</mml:mi><mml:mi>y</mml:mi></mml:msup><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msubsup><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> we would like to infer the true matching matrix <inline-formula><mml:math id="inf392"><mml:msup><mml:mi>M</mml:mi><mml:mo>*</mml:mo></mml:msup></mml:math></inline-formula> by solving an optimization problem.</p><p>Consider the following objective function<disp-formula id="equ54"><label>(38)</label><mml:math id="m54"><mml:mrow><mml:mrow><mml:mrow><mml:mi class="ltx_font_mathcaligraphic">ℰ</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:munderover><mml:mo largeop="true" movablelimits="false" symmetric="true">∑</mml:mo><mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:munderover><mml:mrow><mml:munderover><mml:mo largeop="true" movablelimits="false" symmetric="true">∑</mml:mo><mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:munderover><mml:mrow><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>⁢</mml:mo><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>⁢</mml:mo><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo maxsize="160%" minsize="160%">|</mml:mo><mml:mrow><mml:msubsup><mml:mi>D</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msubsup><mml:mo>-</mml:mo><mml:msubsup><mml:mi>D</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>⁢</mml:mo><mml:mi>l</mml:mi></mml:mrow><mml:mi>y</mml:mi></mml:msubsup></mml:mrow><mml:mo maxsize="160%" minsize="160%">|</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p><p>where the matching matrices <inline-formula><mml:math id="inf393"><mml:mrow><mml:mi>M</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">}</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> we optimize over are constrained to satisfy marginal constraints <inline-formula><mml:math id="inf394"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mstyle></mml:math></inline-formula> and <inline-formula><mml:math id="inf395"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msup><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mstyle></mml:math></inline-formula>. These marginal constraints simply impose that there is at least one nonzero entry in each row and column (i.e. each metabolite in both datasets has at least one corresponding match). Searching for the <inline-formula><mml:math id="inf396"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula> minimizing <inline-formula><mml:math id="inf397"><mml:mrow><mml:msub><mml:mi class="ltx_font_mathcaligraphic">ℰ</mml:mi><mml:mrow><mml:mi>X</mml:mi><mml:mo>,</mml:mo><mml:mi>Y</mml:mi></mml:mrow></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> consists of putting the non-zero entries in <inline-formula><mml:math id="inf398"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula> such that the distance profiles of the matched features are similar, so that the minimizer of this criterion provides a good candidate estimate of <inline-formula><mml:math id="inf399"><mml:msup><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>*</mml:mo></mml:msup></mml:math></inline-formula>. This is closely related to the Gromov–Hausdorff distance <xref ref-type="bibr" rid="bib18">Gromov, 2001</xref>, an extension of optimal transport to the case where the sets to be coupled do not lie in the same metric space.</p><p>In practice, it is often desirable to optimize over a different set of matrices in order to make the optimization problem more tractable. Here we take intuition from optimal transport, and search over the set of coupling matrices with marginal constraints<disp-formula id="equ55"><label>(39)</label><mml:math id="m55"><mml:mrow><mml:mrow><mml:mrow><mml:mi>𝐔</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mo>:</mml:mo><mml:mrow><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>⁢</mml:mo><mml:msub><mml:mn>𝟏</mml:mn><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>⁢</mml:mo><mml:mtext> and </mml:mtext><mml:mo>⁢</mml:mo><mml:msup><mml:mi mathvariant="normal">Π</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mo>⁢</mml:mo><mml:msub><mml:mn>𝟏</mml:mn><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p><p>where as before, <inline-formula><mml:math id="inf400"><mml:mrow><mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="inf401"><mml:mrow><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msubsup></mml:mrow></mml:math></inline-formula> are desired marginals which are typically set to be uniform distributions <inline-formula><mml:math id="inf402"><mml:mrow><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mfrac><mml:mo>⁢</mml:mo><mml:msub><mml:mn>𝟏</mml:mn><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="inf403"><mml:mrow><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mfrac><mml:mo>⁢</mml:mo><mml:msub><mml:mn>𝟏</mml:mn><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. These marginal vectors can be interpreted as distributions of masses <italic>a</italic><sub><italic>i</italic></sub> and <italic>b</italic><sub><italic>j</italic></sub> on the feature vectors <inline-formula><mml:math id="inf404"><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula> and <inline-formula><mml:math id="inf405"><mml:msub><mml:mi>Y</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:math></inline-formula> respectively for <inline-formula><mml:math id="inf406"><mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula>.</p><p>Coupling matrices in <inline-formula><mml:math id="inf407"><mml:mrow><mml:mi mathvariant="bold">𝐔</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> transport the distribution of masses <inline-formula><mml:math id="inf408"><mml:mi>a</mml:mi></mml:math></inline-formula> in the first dataset to the distribution of masses <inline-formula><mml:math id="inf409"><mml:mi>b</mml:mi></mml:math></inline-formula> in the second dataset. Now we can formulate the Gromov–Wasserstein (GW) distance, introduced by <xref ref-type="bibr" rid="bib27">Mémoli, 2011</xref>, as<disp-formula id="equ56"><label>(40)</label><mml:math id="m56"><mml:mrow><mml:mtext>GW</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mo form="prefix">min</mml:mo><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mi mathvariant="bold">U</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:mi mathvariant="script">E</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula></p><p>By optimizing this objective, each entry <inline-formula><mml:math id="inf410"><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> now reflects the strength of the matched pair <inline-formula><mml:math id="inf411"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Optimizing <inline-formula><mml:math id="inf412"><mml:mrow><mml:mtext>GW</mml:mtext><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> then amounts to placing larger entries in <inline-formula><mml:math id="inf413"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula> whose paired features have similar distance profiles. Before we develop an algorithm to optimize this objective, we first modify it to allow for unbalanced matchings where marginal constraints are not enforced exactly (e.g. features in both datasets can remain unmatched).</p></sec><sec sec-type="appendix" id="s14"><title>Unbalanced Gromov–Wasserstein</title><p>In an untargeted context, all features measured in one study are not necessarily observed in another, either because these features are truly not shared or because of measurement error. However, the constraint <inline-formula><mml:math id="inf414"><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mi mathvariant="bold">𝐔</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula> in the original GW optimization criterion <xref ref-type="disp-formula" rid="equ56">Equation 40</xref> ensures that all the mass is transported from one set to another, resulting in all features being matched across studies. In order to discard study-specific features during the GW computation, we use the unbalanced Gromov–Wasserstein (UGW) distance with an additional entropic regularization for computational purposes, described in <xref ref-type="bibr" rid="bib40">Sejourne et al., 2021</xref>. The optimization problem therefore reads<disp-formula id="equ57"><label>(41)</label><mml:math id="m57"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mtable columnalign="left left" rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi mathvariant="script">L</mml:mi></mml:mrow><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mi mathvariant="script">E</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd><mml:mtd><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>⊗</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>a</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>⊗</mml:mo><mml:msup><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>⊗</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>⊗</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:mstyle></mml:mrow></mml:math></disp-formula><disp-formula id="equ58"><label>(42)</label><mml:math id="m58"><mml:mrow><mml:msub><mml:mtext>UGW</mml:mtext><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:munder><mml:mo form="prefix">min</mml:mo><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi mathvariant="script">L</mml:mi></mml:mrow><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula></p><p>with <inline-formula><mml:math id="inf415"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mstyle></mml:math></inline-formula>. Here <inline-formula><mml:math id="inf416"><mml:msub><mml:mi>D</mml:mi><mml:mtext>KL</mml:mtext></mml:msub></mml:math></inline-formula> is the Kullback–Leibler divergence defined in the previous sections and we define the tensor product <inline-formula><mml:math id="inf417"><mml:mrow><mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>P</mml:mi><mml:mo>⊗</mml:mo><mml:mi>P</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>⁢</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. Here we set the desired marginal constraints to <inline-formula><mml:math id="inf418"><mml:mrow><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mfrac><mml:mo>⁢</mml:mo><mml:msub><mml:mn>𝟏</mml:mn><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="inf419"><mml:mrow><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mfrac><mml:mo>⁢</mml:mo><mml:msub><mml:mn>𝟏</mml:mn><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> as before.</p><p>As in the case of unbalanced optimal transport (<xref ref-type="bibr" rid="bib11">Chizat et al., 2018</xref>), the regularization <inline-formula><mml:math id="inf420"><mml:mi>ρ</mml:mi></mml:math></inline-formula> times the Kullback–Leibler divergences allows for the relaxation of the marginal constraints <inline-formula><mml:math id="inf421"><mml:mrow><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>⁢</mml:mo><mml:msub><mml:mn>𝟏</mml:mn><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mi>a</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="inf422"><mml:mrow><mml:mrow><mml:msup><mml:mi mathvariant="normal">Π</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mo>⁢</mml:mo><mml:msub><mml:mn>𝟏</mml:mn><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:math></inline-formula>. The value of <inline-formula><mml:math id="inf423"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mstyle></mml:math></inline-formula> controls the extent to which we allow for mass destruction. Smaller values of <inline-formula><mml:math id="inf424"><mml:mi>ρ</mml:mi></mml:math></inline-formula> tend to lessen the constraint on the marginals of <inline-formula><mml:math id="inf425"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula>, while balanced GW is recovered when <inline-formula><mml:math id="inf426"><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>→</mml:mo><mml:mrow><mml:mo>+</mml:mo><mml:mi mathvariant="normal">∞</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>. As proposed in the original paper (<xref ref-type="bibr" rid="bib40">Sejourne et al., 2021</xref>), our UGW cost modifies the UOT formulation by using the quadratic Kullback-Leibler divergence in <inline-formula><mml:math id="inf427"><mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>⁢</mml:mo><mml:msub><mml:mn>𝟏</mml:mn><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msub></mml:mrow><mml:mo>⊗</mml:mo><mml:mi mathvariant="normal">Π</mml:mi></mml:mrow><mml:mo>⁢</mml:mo><mml:msub><mml:mn>𝟏</mml:mn><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="inf428"><mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mi mathvariant="normal">Π</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mo>⁢</mml:mo><mml:msub><mml:mn>𝟏</mml:mn><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msub></mml:mrow><mml:mo>⊗</mml:mo><mml:msup><mml:mi mathvariant="normal">Π</mml:mi><mml:mi>T</mml:mi></mml:msup></mml:mrow><mml:mo>⁢</mml:mo><mml:msub><mml:mn>𝟏</mml:mn><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msub></mml:mrow></mml:math></inline-formula> instead, hence preserving the quadratic form of the GW cost function <inline-formula><mml:math id="inf429"><mml:mrow><mml:mi class="ltx_font_mathcaligraphic">ℰ</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>.</p><p>The term <inline-formula><mml:math id="inf430"><mml:mrow><mml:mi>ϵ</mml:mi><mml:mo>⁢</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mo>⁢</mml:mo><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>⊗</mml:mo><mml:mi mathvariant="normal">Π</mml:mi></mml:mrow><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi/><mml:mo>⊗</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> serves as an entropic regularization, inspired again by optimal transport. Adding such a penalty is a standard way to compute an approximate solution to the optimal transport problem using the Sinkhorn algorithm as we shall show in the following section. Here again, we modify the entropic penalty in UGW to have a quadratic form in <inline-formula><mml:math id="inf431"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>⊗</mml:mo><mml:mi mathvariant="normal">Π</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula> to agree with the quadratic form of the GW cost <inline-formula><mml:math id="inf432"><mml:mrow><mml:mi class="ltx_font_mathcaligraphic">ℰ</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. The parameter <inline-formula><mml:math id="inf433"><mml:mi>ε</mml:mi></mml:math></inline-formula> controls the smoothness (entropy) of the coupling matrix <inline-formula><mml:math id="inf434"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula> where larger values of <inline-formula><mml:math id="inf435"><mml:mi>ε</mml:mi></mml:math></inline-formula> encourage <inline-formula><mml:math id="inf436"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula> to put uniform weights on many of its entries, leading to less precision in the feature matches. However, increasing <inline-formula><mml:math id="inf437"><mml:mi>ε</mml:mi></mml:math></inline-formula> also leads to better numerical stability and a significant speedup of the alternating Sinkhorn algorithm used to optimize the objective function described below.</p></sec><sec sec-type="appendix" id="s15"><title>UGW optimization algorithm</title><p>Now we are ready to write out an algorithm to optimize the UGW objective in <xref ref-type="disp-formula" rid="equ58">Equation 42</xref>. First write our objective as<disp-formula id="equ59"><label>(43)</label><mml:math id="m59"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mtable columnalign="left left" rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi mathvariant="script">L</mml:mi></mml:mrow><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">|</mml:mo></mml:mrow><mml:msubsup><mml:mi>D</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msubsup><mml:mo>−</mml:mo><mml:msubsup><mml:mi>D</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mi>y</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">|</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>⊗</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>a</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>⊗</mml:mo><mml:msup><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>⊗</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>⊗</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>Using the quadratic nature of our cost function, we aim to perform an alternating minimization in the two copies of <inline-formula><mml:math id="inf438"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula>. For the moment, let’s differentiate these two copies by <inline-formula><mml:math id="inf439"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="inf440"><mml:mi mathvariant="normal">Γ</mml:mi></mml:math></inline-formula> and write the new cost<disp-formula id="equ60"><label>(44)</label><mml:math id="m60"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mtable columnalign="left left" rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi mathvariant="normal">Γ</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">|</mml:mo></mml:mrow><mml:msubsup><mml:mi>D</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msubsup><mml:mo>−</mml:mo><mml:msubsup><mml:mi>D</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mi>y</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">|</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>⊗</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>⊗</mml:mo><mml:msup><mml:mi mathvariant="normal">Γ</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>⊗</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mo>⊗</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>Before we expand this cost, we introduce the notation <inline-formula><mml:math id="inf441"><mml:mrow><mml:mi>m</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> to denote the sum of the elements of <inline-formula><mml:math id="inf442"><mml:mi>π</mml:mi></mml:math></inline-formula> which can be a vector, matrix or tensor. In general, for four positive distributions <inline-formula><mml:math id="inf443"><mml:mrow><mml:mrow><mml:mi>π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi></mml:mrow><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mi>p</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="inf444"><mml:mrow><mml:mrow><mml:mi>γ</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mi>q</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> we have that the KL satisfies the tensorization property<disp-formula id="equ61"><label>(45)</label><mml:math id="m61"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mtable columnalign="left left" rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>π</mml:mi><mml:mo>⊗</mml:mo><mml:mi>γ</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd><mml:mtd><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>q</mml:mi></mml:mrow></mml:munderover><mml:msub><mml:mi>π</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>γ</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mi>ln</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>π</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>γ</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>q</mml:mi></mml:mrow></mml:munderover><mml:msub><mml:mi>π</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>γ</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>q</mml:mi></mml:mrow></mml:munderover><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>γ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:munderover><mml:msub><mml:mi>π</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mi>ln</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:mfrac><mml:msub><mml:mi>π</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mfrac><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>q</mml:mi></mml:mrow></mml:munderover><mml:msub><mml:mi>γ</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mi>ln</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:mfrac><mml:msub><mml:mi>γ</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mfrac><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>γ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>γ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>π</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>γ</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>γ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>Specifically, if we remove those terms that do not depend on <inline-formula><mml:math id="inf445"><mml:mi>γ</mml:mi></mml:math></inline-formula> we are left with<disp-formula id="equ62"><label>(46)</label><mml:math id="m62"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>π</mml:mi><mml:mo>⊗</mml:mo><mml:mi>γ</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>γ</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>γ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:munderover><mml:msub><mml:mi>π</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mi>ln</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:mfrac><mml:msub><mml:mi>π</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mfrac><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mo>.</mml:mo></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>This allows us to write for the marginal constraints <inline-formula><mml:math id="inf446"><mml:mrow><mml:mrow><mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> and couplings <inline-formula><mml:math id="inf447"><mml:mrow><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi></mml:mrow><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> that<disp-formula id="equ63"><mml:math id="m63"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mtable columnalign="center center" rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>⊗</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mi>ln</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:mfrac><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mfrac><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mo>.</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>⊗</mml:mo><mml:msup><mml:mi mathvariant="normal">Γ</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi mathvariant="normal">Γ</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mi>ln</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:mfrac><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mfrac><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mo>.</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>⊗</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mo>⊗</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mi>ln</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:mfrac><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>where in the expansions above we have removed all terms that are independent of <inline-formula><mml:math id="inf448"><mml:mi mathvariant="normal">Γ</mml:mi></mml:math></inline-formula>. Finally, expanding out <inline-formula><mml:math id="inf449"><mml:mrow><mml:msub><mml:mi class="ltx_font_mathcaligraphic">ℱ</mml:mi><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and keeping only those terms that depend on <inline-formula><mml:math id="inf450"><mml:mi mathvariant="normal">Γ</mml:mi></mml:math></inline-formula> we get<disp-formula id="equ64"><label>(47)</label><mml:math id="m64"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi mathvariant="normal">Γ</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mi>C</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi></mml:mrow></mml:msubsup><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi mathvariant="normal">Γ</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mtext>KL</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>where the cost matrix <inline-formula><mml:math id="inf451"><mml:mrow><mml:msup><mml:mi>C</mml:mi><mml:mi mathvariant="normal">Π</mml:mi></mml:msup><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> is defined as<disp-formula id="equ65"><label>(48)</label><mml:math id="m65"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msubsup><mml:mi>C</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">|</mml:mo></mml:mrow><mml:msubsup><mml:mi>D</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msubsup><mml:mo>−</mml:mo><mml:msubsup><mml:mi>D</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mi>y</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">|</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mi>ln</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:mfrac><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mfrac><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>ρ</mml:mi><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mi>ln</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:mfrac><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mfrac><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>ε</mml:mi><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mi>ln</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:mfrac><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>where we have hidden the dependence of <inline-formula><mml:math id="inf452"><mml:msup><mml:mi>C</mml:mi><mml:mi mathvariant="normal">Π</mml:mi></mml:msup></mml:math></inline-formula> on the distance matrices <inline-formula><mml:math id="inf453"><mml:mrow><mml:msup><mml:mi>D</mml:mi><mml:mi>x</mml:mi></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mi>D</mml:mi><mml:mi>y</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, the marginals <inline-formula><mml:math id="inf454"><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:math></inline-formula>, and the regularization parameters <inline-formula><mml:math id="inf455"><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:math></inline-formula> for ease of notation.</p><p>Remarkably, the cost above in <inline-formula><mml:math id="inf456"><mml:mi mathvariant="normal">Γ</mml:mi></mml:math></inline-formula> for fixed <inline-formula><mml:math id="inf457"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula> is in the form of an unbalanced optimal transport problem which can be solved through unbalanced Sinkhorn iterations (Algorithm 1). Note that in our derivation above, it did not matter whether we optimized <inline-formula><mml:math id="inf458"><mml:mi mathvariant="normal">Γ</mml:mi></mml:math></inline-formula> with <inline-formula><mml:math id="inf459"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula> fixed or vice versa because the cost <inline-formula><mml:math id="inf460"><mml:mrow><mml:msub><mml:mi class="ltx_font_mathcaligraphic">ℱ</mml:mi><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is symmetric in both of its arguments.</p><p>Our iterative algorithm for solving the unbalanced GW problem will proceed at each iteration by optimizing <inline-formula><mml:math id="inf461"><mml:mi mathvariant="normal">Γ</mml:mi></mml:math></inline-formula> to minimize the cost above using the unbalanced Sinkhorn method, setting <inline-formula><mml:math id="inf462"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula> equal to <inline-formula><mml:math id="inf463"><mml:mi mathvariant="normal">Γ</mml:mi></mml:math></inline-formula> and repeating. With each iteration, we expect this iterative procedure to make smaller and smaller updates to <inline-formula><mml:math id="inf464"><mml:mi mathvariant="normal">Γ</mml:mi></mml:math></inline-formula> until convergence. By definition, at the end of each iteration we assign <inline-formula><mml:math id="inf465"><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi></mml:mrow></mml:math></inline-formula> so the minimizer of <inline-formula><mml:math id="inf466"><mml:mrow><mml:msub><mml:mi class="ltx_font_mathcaligraphic">ℱ</mml:mi><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> we converge to should also be a minimizer of the original UGW cost <inline-formula><mml:math id="inf467"><mml:mrow><mml:msub><mml:mi class="ltx_font_mathcaligraphic">ℒ</mml:mi><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> in the sense that the relaxation of <inline-formula><mml:math id="inf468"><mml:mrow><mml:msub><mml:mi class="ltx_font_mathcaligraphic">ℒ</mml:mi><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> to <inline-formula><mml:math id="inf469"><mml:mrow><mml:msub><mml:mi class="ltx_font_mathcaligraphic">ℱ</mml:mi><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is tight. This is proven rigorously under strict mathematical assumptions in <xref ref-type="bibr" rid="bib40">Sejourne et al., 2021</xref>. We state the full UGW optimization algorithm below.</p><table-wrap id="inlinetable2" position="anchor"><table frame="hsides" rules="groups" id="AL2"><thead><tr><th align="left" valign="bottom">Algorithm 2. UnbalancedGromovWasserstein</th></tr></thead><tbody><tr><td align="left" valign="bottom"><bold>input</bold>: Distance matrices <inline-formula><mml:math id="inf470"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msup><mml:mi>D</mml:mi><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mi>D</mml:mi><mml:mrow><mml:mi>y</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mstyle></mml:math></inline-formula>, marginals a, b marginal relaxation <inline-formula><mml:math id="inf471"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula>, entropic regularization <inline-formula><mml:math id="inf472"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>ε</mml:mi></mml:mrow></mml:mstyle></mml:math></inline-formula><break/><bold>output</bold>: Return the coupling matrix <inline-formula><mml:math id="inf473"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula> <break/>Initialize <inline-formula><mml:math id="inf474"><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mrow><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>/</mml:mo><mml:msqrt><mml:mrow><mml:mi>m</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>⁢</mml:mo><mml:mi>m</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:msqrt></mml:mrow></mml:mrow></mml:math></inline-formula><break/><bold>while</bold> <inline-formula><mml:math id="inf475"><mml:mrow><mml:mo mathvariant="normal" stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo mathvariant="normal">,</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi><mml:mo mathvariant="normal" stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> has not converged <bold>do</bold><break/>  Update <inline-formula><mml:math id="inf476"><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>←</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi></mml:mrow></mml:math></inline-formula><break/>  Update <inline-formula><mml:math id="inf477"><mml:mrow><mml:mi mathvariant="normal">Γ</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mtext>UnbalancedSinkhorn</mml:mtext><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>C</mml:mi><mml:mi mathvariant="normal">Π</mml:mi></mml:msup><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>⁢</mml:mo><mml:mi>m</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mi>ε</mml:mi><mml:mo>⁢</mml:mo><mml:mi>m</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula><break/>  Rescale <inline-formula><mml:math id="inf478"><mml:mrow><mml:mi mathvariant="normal">Γ</mml:mi><mml:mo>←</mml:mo><mml:mrow><mml:msqrt><mml:mrow><mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>/</mml:mo><mml:mi>m</mml:mi></mml:mrow><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:msqrt><mml:mo>⁢</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> <break/>Update <inline-formula><mml:math id="inf479"><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>←</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi></mml:mrow></mml:math></inline-formula> <break/>Return <inline-formula><mml:math id="inf480"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula>.</td></tr></tbody></table></table-wrap><p>Following the implementation of the UGW algorithm in <xref ref-type="bibr" rid="bib40">Sejourne et al., 2021</xref>, we initialize both <inline-formula><mml:math id="inf481"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="inf482"><mml:mi mathvariant="normal">Γ</mml:mi></mml:math></inline-formula> to be the product distribution of the marginals <inline-formula><mml:math id="inf483"><mml:mrow><mml:mrow><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>/</mml:mo><mml:msqrt><mml:mrow><mml:mi>m</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>⁢</mml:mo><mml:mi>m</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:msqrt></mml:mrow></mml:math></inline-formula> before we begin the optimization. Also, we note that if <inline-formula><mml:math id="inf484"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is a minimizer of our UGW objective <inline-formula><mml:math id="inf485"><mml:mrow><mml:msub><mml:mi class="ltx_font_mathcaligraphic">ℱ</mml:mi><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi></mml:mrow></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, then so is <inline-formula><mml:math id="inf486"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mi>s</mml:mi></mml:mfrac><mml:mo>⁢</mml:mo><mml:mi mathvariant="normal">Π</mml:mi></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mi>s</mml:mi><mml:mo>⁢</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for any scale factor <inline-formula><mml:math id="inf487"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>s</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mstyle></mml:math></inline-formula>. Hence, we can set <inline-formula><mml:math id="inf488"><mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mi>s</mml:mi></mml:mfrac><mml:mo>⁢</mml:mo><mml:mi mathvariant="normal">Π</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mi>m</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi>s</mml:mi><mml:mo>⁢</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula> by choosing <inline-formula><mml:math id="inf489"><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>/</mml:mo><mml:mi>m</mml:mi></mml:mrow><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:msqrt></mml:mrow></mml:math></inline-formula>. This motivates the final step in the while loop of the UGW algorithm where the rescaling of <inline-formula><mml:math id="inf490"><mml:mi mathvariant="normal">Γ</mml:mi></mml:math></inline-formula> by the factor <inline-formula><mml:math id="inf491"><mml:msqrt><mml:mrow><mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>/</mml:mo><mml:mi>m</mml:mi></mml:mrow><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:msqrt></mml:math></inline-formula> leads to mass equality <inline-formula><mml:math id="inf492"><mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mi>m</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula> and also stabilizes the convergence of the algorithm.</p><p>Returning to our metabolomics matching problem, we further guide our UGW optimization procedure by discouraging it from matching metabolic feature pairs whose mass-to-charge ratios are incompatible. Namely, we choose a value <inline-formula><mml:math id="inf493"><mml:msub><mml:mi>m</mml:mi><mml:mtext>gap</mml:mtext></mml:msub></mml:math></inline-formula> such that for all pairs <inline-formula><mml:math id="inf494"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> with <inline-formula><mml:math id="inf495"><mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula> and mass-to-charge ratios <inline-formula><mml:math id="inf496"><mml:mrow><mml:msubsup><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>x</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mi>m</mml:mi><mml:mi>j</mml:mi><mml:mi>y</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> we enforce that<disp-formula id="equ66"><label>(49)</label><mml:math id="m66"><mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:msubsup><mml:mi>m</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msubsup><mml:mo>−</mml:mo><mml:msubsup><mml:mi>m</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>y</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mo>&gt;</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mrow><mml:mtext>gap</mml:mtext></mml:mrow></mml:msub><mml:mspace width="thickmathspace"/><mml:mo stretchy="false">⟹</mml:mo><mml:mspace width="thickmathspace"/><mml:msub><mml:mi mathvariant="normal">Π</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0.</mml:mn></mml:mrow></mml:math></disp-formula></p><p>In practice, this is done by taking the optimal transport cost <inline-formula><mml:math id="inf497"><mml:msup><mml:mi>C</mml:mi><mml:mi mathvariant="normal">Π</mml:mi></mml:msup></mml:math></inline-formula> in every iteration of the UGW algorithm and premultiplying it elementwise by a factor <inline-formula><mml:math id="inf498"><mml:mrow><mml:mi>W</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> given by<disp-formula id="equ67"><label>(50)</label><mml:math id="m67"><mml:mrow><mml:msup><mml:mi>C</mml:mi><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">→</mml:mo><mml:mi>W</mml:mi><mml:mo>⊙</mml:mo><mml:msup><mml:mi>C</mml:mi><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mspace width="1em"/><mml:msub><mml:mi>W</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>99</mml:mn><mml:mo>⋅</mml:mo><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:msubsup><mml:mi>m</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msubsup><mml:mo>−</mml:mo><mml:msubsup><mml:mi>m</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>y</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mo>&gt;</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mrow><mml:mtext>gap</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo fence="false" stretchy="false">}</mml:mo></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></disp-formula></p><p>where <inline-formula><mml:math id="inf499"><mml:msub><mml:mn>𝟏</mml:mn><mml:mi class="ltx_font_mathcaligraphic">𝒳</mml:mi></mml:msub></mml:math></inline-formula> denotes the indicator function that is one when the condition <inline-formula><mml:math id="inf500"><mml:mi class="ltx_font_mathcaligraphic">𝒳</mml:mi></mml:math></inline-formula> is satisfied and zero otherwise. Such a prefactor changes the transport cost to be very large for feature matches with incompatible mass-to-charge ratio times, and hence, the entries of <inline-formula><mml:math id="inf501"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula> set small weights at these entries. Our weighted UGW algorithm is rewritten below.</p><table-wrap id="inlinetable3" position="anchor"><table frame="hsides" rules="groups" id="AL3"><thead><tr><th align="left" valign="bottom">Algorithm 3. WeightedUnbalancedGromovWasserstein</th></tr></thead><tbody><tr><td align="left" valign="bottom"><bold>input</bold> : Distance matrices <inline-formula><mml:math id="inf502"><mml:mrow><mml:msup><mml:mi>D</mml:mi><mml:mi>x</mml:mi></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mi>D</mml:mi><mml:mi>y</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, marginals <inline-formula><mml:math id="inf503"><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:math></inline-formula>, marginal relaxation <inline-formula><mml:math id="inf504"><mml:mi>ρ</mml:mi></mml:math></inline-formula>, entropic regularization <inline-formula><mml:math id="inf505"><mml:mi>ε</mml:mi></mml:math></inline-formula>,<break/>   mass-to-charge ratios <inline-formula><mml:math id="inf506"><mml:mrow><mml:msup><mml:mi>m</mml:mi><mml:mi>x</mml:mi></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mi>m</mml:mi><mml:mi>y</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, mass-to-charge ratio gap <inline-formula><mml:math id="inf507"><mml:msub><mml:mi>m</mml:mi><mml:mtext>gap</mml:mtext></mml:msub></mml:math></inline-formula><break/><bold>output</bold>: Return the coupling matrix <inline-formula><mml:math id="inf508"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula> <break/>Initialize <inline-formula><mml:math id="inf509"><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mrow><mml:mi>a</mml:mi><mml:mo>⊗</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>/</mml:mo><mml:msqrt><mml:mrow><mml:mi>m</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>⁢</mml:mo><mml:mi>m</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:msqrt></mml:mrow></mml:mrow></mml:math></inline-formula> <break/>Set <inline-formula><mml:math id="inf510"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>W</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>99</mml:mn><mml:mo>⋅</mml:mo><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:msubsup><mml:mi>m</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msubsup><mml:mo>−</mml:mo><mml:msubsup><mml:mi>m</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>y</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mo>&gt;</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mrow><mml:mtext>gap</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo fence="false" stretchy="false">}</mml:mo></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mstyle></mml:math></inline-formula> for <inline-formula><mml:math id="inf511"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="inf512"><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> <break/><bold>while</bold> <inline-formula><mml:math id="inf513"><mml:mrow><mml:mo mathvariant="normal" stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo mathvariant="normal">,</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi><mml:mo mathvariant="normal" stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> has not converged <bold>do</bold><break/>  Update <inline-formula><mml:math id="inf514"><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>←</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi></mml:mrow></mml:math></inline-formula><break/>  Update <inline-formula><mml:math id="inf515"><mml:mrow><mml:mi mathvariant="normal">Γ</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mtext>UnbalancedSinkhorn</mml:mtext><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi>W</mml:mi><mml:mo>⊙</mml:mo><mml:msup><mml:mi>C</mml:mi><mml:mi mathvariant="normal">Π</mml:mi></mml:msup></mml:mrow><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>⁢</mml:mo><mml:mi>m</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mi>ε</mml:mi><mml:mo>⁢</mml:mo><mml:mi>m</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula><break/>  Rescale <inline-formula><mml:math id="inf516"><mml:mrow><mml:mi mathvariant="normal">Γ</mml:mi><mml:mo>←</mml:mo><mml:mrow><mml:msqrt><mml:mrow><mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>/</mml:mo><mml:mi>m</mml:mi></mml:mrow><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:msqrt><mml:mo>⁢</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> <break/>Update <inline-formula><mml:math id="inf517"><mml:mrow><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>←</mml:mo><mml:mi mathvariant="normal">Γ</mml:mi></mml:mrow></mml:math></inline-formula> <break/>Return <inline-formula><mml:math id="inf518"><mml:mi mathvariant="normal">Π</mml:mi></mml:math></inline-formula>.</td></tr></tbody></table></table-wrap><p>As mentioned before, the coupling matrix returned by our weighted UGW algorithm is a real-valued matrix rather than a binary matching matrix. In the next section, we describe how we incorporate metabolite retention time information to filter out unlikely pairs in our coupling matrix and transform it into a valid one-to-one matching of features across two datasets.</p></sec><sec sec-type="appendix" id="s16"><title>Retention time drift estimation and filtering</title><p>To filter out unlikely matches from the coupling matrix returned by Algorithm 3 above, we use the retention times (RTs) of the metabolites in both datasets. We remind the reader that RTs were not incorporated into the weighted UGW algorithm since they often exhibit a non-linear deviation between datasets, and hence are not directly comparable. However, using the metabolite coupling <inline-formula><mml:math id="inf519"><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> obtained from Algorithm 3, it is possible to estimate this RT drift. The estimated RT drift <inline-formula><mml:math id="inf520"><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mo>:</mml:mo><mml:mrow><mml:msub><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo></mml:msub><mml:mo>→</mml:mo><mml:msub><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> allows us to assess the plausibility of the pairs recovered by the restricted UGW coupling <inline-formula><mml:math id="inf521"><mml:mover accent="true"><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:math></inline-formula>, and discard pairs incompatible with the estimated drift.</p><p>We propose to learn the drift <inline-formula><mml:math id="inf522"><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:math></inline-formula> through the weighted spline regression<disp-formula id="equ68"><label>(51)</label><mml:math id="m68"><mml:mrow><mml:mstyle displaystyle="true" scriptlevel="0"><mml:munder><mml:mo form="prefix">min</mml:mo><mml:mrow><mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">B</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:munder><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msub><mml:mrow><mml:mover><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>R</mml:mi><mml:msubsup><mml:mi>T</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>R</mml:mi><mml:msubsup><mml:mi>T</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>y</mml:mi></mml:mrow></mml:msubsup></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mstyle></mml:mrow></mml:math></disp-formula></p><p>where <inline-formula><mml:math id="inf523"><mml:msub><mml:mi class="ltx_font_mathcaligraphic">ℬ</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> is the set of <inline-formula><mml:math id="inf524"><mml:mi>n</mml:mi></mml:math></inline-formula>-order B-splines with <inline-formula><mml:math id="inf525"><mml:mi>k</mml:mi></mml:math></inline-formula> knots. All pairs <inline-formula><mml:math id="inf526"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi>R</mml:mi><mml:mo>⁢</mml:mo><mml:msubsup><mml:mi>T</mml:mi><mml:mi>i</mml:mi><mml:mi>x</mml:mi></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mi>R</mml:mi><mml:mo>⁢</mml:mo><mml:msubsup><mml:mi>T</mml:mi><mml:mi>j</mml:mi><mml:mi>y</mml:mi></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in objective <xref ref-type="disp-formula" rid="equ68">Equation 51</xref> are weighted by the coefficients of <inline-formula><mml:math id="inf527"><mml:mover accent="true"><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:math></inline-formula> so that larger weights are given to pairs identified with high confidence in the first step of our procedure.</p><p>Pairs identified as incompatible with the estimated RT drift are then discarded from the coupling matrix. To do this, we first take the estimated RT drift <inline-formula><mml:math id="inf528"><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:math></inline-formula>, and the set of pairs <inline-formula><mml:math id="inf529"><mml:mrow><mml:mi class="ltx_font_mathcaligraphic">𝒮</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>:</mml:mo><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>≠</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> recovered in <inline-formula><mml:math id="inf530"><mml:mover accent="true"><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:math></inline-formula> with nonzero entries. We then define the residual associated with <inline-formula><mml:math id="inf531"><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>∈</mml:mo><mml:mi class="ltx_font_mathcaligraphic">𝒮</mml:mi></mml:mrow></mml:math></inline-formula> as<disp-formula id="equ69"><label>(52)</label><mml:math id="m69"><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mrow><mml:mover><mml:mi>f</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mrow><mml:mover><mml:mi>f</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:msubsup><mml:mi>T</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>R</mml:mi><mml:msubsup><mml:mi>T</mml:mi><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>y</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p><p>The 95% prediction interval and the median absolute deviation (MAD) of these residuals are given by<disp-formula id="equ70"><label>(53)</label><mml:math id="m70"><mml:mtable displaystyle="true" rowspacing="0pt"><mml:mtr><mml:mtd columnalign="center"><mml:mrow><mml:mtext>PI</mml:mtext><mml:mo>=</mml:mo><mml:mrow><mml:mrow><mml:mn>1.96</mml:mn><mml:mo>×</mml:mo><mml:mtext>std</mml:mtext></mml:mrow><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>∈</mml:mo><mml:mi class="ltx_font_mathcaligraphic">𝒮</mml:mi></mml:mrow><mml:mo stretchy="false">}</mml:mo></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center"><mml:mrow><mml:mtext>MAD</mml:mtext><mml:mo>=</mml:mo><mml:mrow><mml:mtext>median</mml:mtext><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mrow><mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mrow><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>-</mml:mo><mml:msub><mml:mi>μ</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>∈</mml:mo><mml:mi class="ltx_font_mathcaligraphic">𝒮</mml:mi></mml:mrow><mml:mo stretchy="false">}</mml:mo></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center"><mml:mrow><mml:msub><mml:mi>μ</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mtext>median</mml:mtext><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mrow><mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:msub><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>∈</mml:mo><mml:mi class="ltx_font_mathcaligraphic">𝒮</mml:mi></mml:mrow><mml:mo stretchy="false">}</mml:mo></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p>where <inline-formula><mml:math id="inf532"><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mi class="ltx_font_mathcaligraphic">𝒮</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:math></inline-formula> is the size of <inline-formula><mml:math id="inf533"><mml:mi class="ltx_font_mathcaligraphic">𝒮</mml:mi></mml:math></inline-formula> and the functions std, median denote the standard deviation and median respectively. Following <xref ref-type="bibr" rid="bib19">Habra et al., 2021</xref>, we then create a new filtered coupling matrix <inline-formula><mml:math id="inf534"><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> given by<disp-formula id="equ71"><label>(54)</label><mml:math id="m71"><mml:mrow><mml:msub><mml:mrow><mml:mover><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mtable columnalign="left left" rowspacing=".2em" columnspacing="1em" displaystyle="false"><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mover><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:mtext>if</mml:mtext><mml:mtext> </mml:mtext><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mrow><mml:mover><mml:mi>f</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&lt;</mml:mo><mml:msub><mml:mi>μ</mml:mi><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mtext>thresh</mml:mtext></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mtext>otherwise</mml:mtext></mml:mtd></mml:mtr></mml:mtable><mml:mo fence="true" stretchy="true" symmetric="true"/></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p><p>where <inline-formula><mml:math id="inf535"><mml:msub><mml:mi>r</mml:mi><mml:mtext>thresh</mml:mtext></mml:msub></mml:math></inline-formula> is a given filtering threshold. The procedure of estimating the drift function <inline-formula><mml:math id="inf536"><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:math></inline-formula> in <xref ref-type="disp-formula" rid="equ68">Equation 51</xref> and filtering the coupling can be repeated for multiple iterations, to improve the drift and coupling estimation. In our main algorithm, we use two preliminary iterations where we estimate the RT drift and discard outliers with <inline-formula><mml:math id="inf537"><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mtext>thresh</mml:mtext></mml:msub><mml:mo>=</mml:mo><mml:mtext>PI</mml:mtext></mml:mrow></mml:math></inline-formula>, defined as points falling outside of the 95% prediction interval. We the re-estimate the drift and perform a final filtering step with the more stringent MAD by setting <inline-formula><mml:math id="inf538"><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mtext>thresh</mml:mtext></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mn>2</mml:mn><mml:mo>×</mml:mo><mml:mtext>MAD</mml:mtext></mml:mrow></mml:mrow></mml:math></inline-formula>.</p><p>At this stage, it is possible for <inline-formula><mml:math id="inf539"><mml:mover accent="true"><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:math></inline-formula> to still contain coefficients of very small magnitude. As an optional postprocessing step, we discard these coefficients by setting all entries smaller than <inline-formula><mml:math id="inf540"><mml:mrow><mml:mi>τ</mml:mi><mml:mo>⁢</mml:mo><mml:mtext>max</mml:mtext><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mover accent="true"><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> to zero for some scaling constant <inline-formula><mml:math id="inf541"><mml:mrow><mml:mi>τ</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. Lastly, a feature from either study could have multiple possible matches, since <inline-formula><mml:math id="inf542"><mml:mover accent="true"><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:math></inline-formula> can have more than one non-zero coefficient per row or column. Although reporting multiple matches can be helpful in an exploratory context, for the sake of simplicity in our analysis, the final output of GromovMatcher returns a one-to-one matching. Consequently, we only keep those metabolite pairs <inline-formula><mml:math id="inf543"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> where the entry <inline-formula><mml:math id="inf544"><mml:msub><mml:mover accent="true"><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> is largest in its corresponding row and column. All nonzero entries of <inline-formula><mml:math id="inf545"><mml:mover accent="true"><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:math></inline-formula> which do not satisfy this criterion are set to zero. Finally, we convert <inline-formula><mml:math id="inf546"><mml:mover accent="true"><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:math></inline-formula> into a binary matching matrix <inline-formula><mml:math id="inf547"><mml:mrow><mml:mi>M</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">}</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> with ones in place of its nonzero entries and this final output is returned to the user.</p><p>As a naming convention, we use the abbreviation GM for our GromovMatcher method, and use the abbreviation GMT when running GromovMatcher with the optional <inline-formula><mml:math id="inf548"><mml:mi>τ</mml:mi></mml:math></inline-formula>-thresholding step.</p></sec><sec sec-type="appendix" id="s17"><title>GromovMatcher algorithm summary</title><p>In summary, our full GromovMatcher algorithm consists of (1) UGW optimization followed by (2) retention time drift estimation and filtering.</p><p>The tuning of <inline-formula><mml:math id="inf549"><mml:mi>ρ</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="inf550"><mml:mi>ϵ</mml:mi></mml:math></inline-formula> was computationally driven and the two parameters were set as low as possible, with <inline-formula><mml:math id="inf551"><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>=</mml:mo><mml:mn>0.05</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="inf552"><mml:mrow><mml:mi>ϵ</mml:mi><mml:mo>=</mml:mo><mml:mn>0.005</mml:mn></mml:mrow></mml:math></inline-formula>. Based on literature (<xref ref-type="bibr" rid="bib26">Loftfield et al., 2021</xref>; <xref ref-type="bibr" rid="bib21">Hsu et al., 2019</xref>; <xref ref-type="bibr" rid="bib12">Climaco Pinto et al., 2022</xref>; <xref ref-type="bibr" rid="bib19">Habra et al., 2021</xref>; <xref ref-type="bibr" rid="bib10">Chen et al., 2021</xref>) and what is considered to be a plausible variation of a feature’s <inline-formula><mml:math id="inf553"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula>, we set  <inline-formula><mml:math id="inf554"><mml:msub><mml:mi>m</mml:mi><mml:mtext>gap</mml:mtext></mml:msub></mml:math></inline-formula> = 0.01 ppm. For RT drift estimation, the order of the B-splines was set to <inline-formula><mml:math id="inf555"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula> by default, while the number of knots <inline-formula><mml:math id="inf556"><mml:mi>k</mml:mi></mml:math></inline-formula> was selected by 10-fold cross-validation. If the optional thresholding step was applied in GMT, we set <inline-formula><mml:math id="inf557"><mml:mrow><mml:mi>τ</mml:mi><mml:mo>=</mml:mo><mml:mn>0.3</mml:mn></mml:mrow></mml:math></inline-formula>. Otherwise, we let <inline-formula><mml:math id="inf558"><mml:mrow><mml:mi>τ</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> which gives the unthresholded GM algorithm.</p><table-wrap id="inlinetable4" position="anchor"><table frame="hsides" rules="groups" id="AL4"><thead><tr><th align="left" valign="bottom">Algorithm 4. GromovMatcher</th></tr></thead><tbody><tr><td align="left" valign="bottom"><bold>input</bold> : Distance matrices <inline-formula><mml:math id="inf559"><mml:mrow><mml:msup><mml:mi>D</mml:mi><mml:mi>x</mml:mi></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mi>D</mml:mi><mml:mi>y</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, marginals <inline-formula><mml:math id="inf560"><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:math></inline-formula>, marginal relaxation <inline-formula><mml:math id="inf561"><mml:mi>ρ</mml:mi></mml:math></inline-formula>, entropic regularization <inline-formula><mml:math id="inf562"><mml:mi>ε</mml:mi></mml:math></inline-formula>,<break/>   mass-to-charge ratios <inline-formula><mml:math id="inf563"><mml:mrow><mml:msup><mml:mi>m</mml:mi><mml:mi>x</mml:mi></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mi>m</mml:mi><mml:mi>y</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, mass-to-charge ratio gap <inline-formula><mml:math id="inf564"><mml:msub><mml:mi>m</mml:mi><mml:mtext>gap</mml:mtext></mml:msub></mml:math></inline-formula>,<break/>   retention times <inline-formula><mml:math id="inf565"><mml:mrow><mml:mrow><mml:mi>R</mml:mi><mml:mo>⁢</mml:mo><mml:msup><mml:mi>T</mml:mi><mml:mi>x</mml:mi></mml:msup></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mi>R</mml:mi><mml:mo>⁢</mml:mo><mml:msup><mml:mi>T</mml:mi><mml:mi>y</mml:mi></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>, B-spline order <inline-formula><mml:math id="inf566"><mml:mi>n</mml:mi></mml:math></inline-formula>, filtering threshold <inline-formula><mml:math id="inf567"><mml:mi>τ</mml:mi></mml:math></inline-formula><break/><bold>output</bold>: Return the matching matrix <inline-formula><mml:math id="inf568"><mml:mi>M</mml:mi></mml:math></inline-formula> and the retention time drift <inline-formula><mml:math id="inf569"><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:math></inline-formula><break/># Step 1: Weighted UGW optimization<break/>Compute <inline-formula><mml:math id="inf570"><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mrow><mml:mtext>WeightedUnbalancedGromovWasserstein</mml:mtext><mml:mo>⁢</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>D</mml:mi><mml:mi>x</mml:mi></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mi>D</mml:mi><mml:mi>y</mml:mi></mml:msup><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>,</mml:mo><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>ε</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mi>m</mml:mi><mml:mi>x</mml:mi></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mi>m</mml:mi><mml:mi>y</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula><break/># Step 2: Retention time drift estimation and filtering<break/><bold>for</bold> <inline-formula><mml:math id="inf571"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mstyle mathsize="0.85em"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>:</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle></mml:math></inline-formula> <bold>do</bold><break/>  Perform weighted spline regression <xref ref-type="disp-formula" rid="equ68">Equation 51</xref> for RT drift <inline-formula><mml:math id="inf572"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mover><mml:mi>f</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">B</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> where <italic>k</italic> is chosen by 10-fold cross validation<break/>  Initialize <inline-formula><mml:math id="inf573"><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mtext>thresh</mml:mtext></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula><break/><bold>  if</bold> <inline-formula><mml:math id="inf574"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:mstyle></mml:math></inline-formula> <bold>then</bold><break/>    Set <inline-formula><mml:math id="inf575"><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mtext>thresh</mml:mtext></mml:msub><mml:mo>=</mml:mo><mml:mtext>PI</mml:mtext></mml:mrow></mml:math></inline-formula> from <xref ref-type="disp-formula" rid="equ70">Equation 53</xref><break/><bold>  else</bold><break/>    Set <inline-formula><mml:math id="inf576"><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mtext>thresh</mml:mtext></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mn>2</mml:mn><mml:mo>×</mml:mo><mml:mtext>MAD</mml:mtext></mml:mrow></mml:mrow></mml:math></inline-formula> from <xref ref-type="disp-formula" rid="equ70">Equation 53</xref><break/>  Set <inline-formula><mml:math id="inf577"><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> <break/>Compute <inline-formula><mml:math id="inf578"><mml:mrow><mml:mi class="ltx_font_mathcaligraphic">𝒰</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mi>max</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mover accent="true"><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula> <break/>Set <inline-formula><mml:math id="inf579"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> if <inline-formula><mml:math id="inf580"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mrow><mml:mover><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>&lt;</mml:mo><mml:mi>τ</mml:mi><mml:mrow><mml:mi mathvariant="script">U</mml:mi></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula> for  <inline-formula><mml:math id="inf581"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="inf582"><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> <break/>Set <inline-formula><mml:math id="inf583"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mi>i</mml:mi><mml:mo>⁢</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> if <inline-formula><mml:math id="inf584"><mml:mrow><mml:mi>i</mml:mi><mml:mo>≠</mml:mo><mml:mrow><mml:msub><mml:mtext>argmax</mml:mtext><mml:mi>k</mml:mi></mml:msub><mml:mo>⁢</mml:mo><mml:msub><mml:mover accent="true"><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> or <inline-formula><mml:math id="inf585"><mml:mrow><mml:mi>j</mml:mi><mml:mo>≠</mml:mo><mml:mrow><mml:msub><mml:mtext>argmax</mml:mtext><mml:mi>k</mml:mi></mml:msub><mml:mo>⁢</mml:mo><mml:msub><mml:mover accent="true"><mml:mi mathvariant="normal">Π</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> for <inline-formula><mml:math id="inf586"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="inf587"><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> <break/>Define the binarized matching <inline-formula><mml:math id="inf588"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:mo fence="false" stretchy="false">{</mml:mo><mml:msub><mml:mrow><mml:mover><mml:mi mathvariant="normal">Π</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn><mml:mo fence="false" stretchy="false">}</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:math></inline-formula> <break/>Return <inline-formula><mml:math id="inf589"><mml:mi>M</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="inf590"><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:math></inline-formula>.</td></tr></tbody></table></table-wrap></sec></app><app id="appendix-2"><title>Appendix 2</title><p>Here we discuss existing metabolomic alignments methods and the hyperparameter experiments we perform on these methods. We consider two existing alignment methods for comparison, metabCombiner (<xref ref-type="bibr" rid="bib19">Habra et al., 2021</xref>) and M2S (<xref ref-type="bibr" rid="bib12">Climaco Pinto et al., 2022</xref>). Both of them take the same kind of input as GromovMatcher, i.e. feature tables with features identified with their <inline-formula><mml:math id="inf591"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula>, RT, and intensities across samples.</p><sec sec-type="appendix" id="s18"><title>MetabCombiner hyperparameter experiments</title><p>MetabCombiner (<xref ref-type="bibr" rid="bib19">Habra et al., 2021</xref>) is a three-step process that begins by grouping features based on their <inline-formula><mml:math id="inf592"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula> within user-specified bins. This creates a search space for potential feature pairs. In the second step, MetabCombiner estimates the RT drift using the potential feature pairs identified in the first step, and eliminates outlying pairs over several iterations. This step can incorporate prior knowledge by identifying shared features and marking them as anchors, which are not discarded. In the final step, MetabCombiner scores the remaining feature pairs based on their <inline-formula><mml:math id="inf593"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula>, RT, and relative intensity compatibility to discriminate between multiple matches for one feature. The scoring system relies on weights assigned to <inline-formula><mml:math id="inf594"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula>, RT, and feature intensities, with the magnitude of those weights reflecting the reliability of the corresponding measurements across studies.</p><p>MetabCombiner (<xref ref-type="bibr" rid="bib19">Habra et al., 2021</xref>) includes adjustable parameters throughout the pipeline. We set most of them to default values unless otherwise stated. MetabCombiner first establishes candidate pairs by binning features in the <inline-formula><mml:math id="inf595"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula> dimension with a width of binGap, and pairing the features sorted by relative intensities. The ‘binGap’ parameter sets the <inline-formula><mml:math id="inf596"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula> tolerance of metabCombiner, similar to <inline-formula><mml:math id="inf597"><mml:msub><mml:mi>m</mml:mi><mml:mtext>gap</mml:mtext></mml:msub></mml:math></inline-formula> in GromovMatcher. We used the same value of 0.01 as in GromovMatcher.</p><p>MetabCombiner then estimates the RT drift using basis splines, and removes pairs associated with a high residual (twice the mean model error) from the candidate set.</p><p>In our main experiment, the RT drift is estimated exclusively using candidate pairs selected by the pipeline. However, it is also possible to include known ground truth pairs as ’anchors’ to estimate the RT drift. We choose not to rely on prior knowledge for drift estimation as <xref ref-type="bibr" rid="bib19">Habra et al., 2021</xref> show their drift estimation to be efficient and robust, even without prior knowledge. To confirm this claim, we conduct a sensitivity analysis comparing the results obtained in our main experiment with those obtained when supplying metabCombiner with known shared metabolites to anchor the RT drift estimation. We randomly select 100 anchors from the ground truth matching and compute the metabCombiner matchings with otherwise identical settings as in our main experiment. The results from this analysis (reported in <xref ref-type="fig" rid="app2fig1">Appendix 2—figure 1</xref>) show that the unsupervised RT drift estimation (using anchors selected by the pipeline only) performs as well as the supervised RT drift estimation, showing the drift estimation to be very consistent, with or without shared entities.</p><p>After establishing candidate pairs and filtering out those that contradict the estimated RT drift, metabCombiner discriminates between multiple matches using a scoring system that considers <inline-formula><mml:math id="inf598"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula>, RT, and rankings of the median feature intensities. Each dimension has a specific weight that can be left at default, manually adjusted, or automatically tuned using known matched pairs. <xref ref-type="bibr" rid="bib19">Habra et al., 2021</xref> provide qualitative guidelines for tuning the weights manually, mainly based on the experimental conditions and visual inspection of the RT drift plot. Since this approach is difficult to implement in the various settings we consider for our simulation study, we rely on the quantitative tuning function included in the metabCombiner pipeline. This function takes into account known shared features and tunes the weights to optimize the scores of those known matches. We randomly select 100 known true matches to define the objective function metabCombiner maximizes. We search over the recommended range of values, with the <inline-formula><mml:math id="inf599"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula> weight <inline-formula><mml:math id="inf600"><mml:mrow><mml:mi>A</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>50</mml:mn><mml:mo>,</mml:mo><mml:mn>150</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, the RT weight <inline-formula><mml:math id="inf601"><mml:mrow><mml:mi>B</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo><mml:mn>20</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and the feature intensities weight <inline-formula><mml:math id="inf602"><mml:mrow><mml:mi>C</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. <xref ref-type="fig" rid="app2fig1">Appendix 2—figure 1</xref> presents the results obtained with the weights set at default values (<inline-formula><mml:math id="inf603"><mml:mrow><mml:mrow><mml:mi>A</mml:mi><mml:mo>=</mml:mo><mml:mn>100</mml:mn></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mrow><mml:mi>B</mml:mi><mml:mo>=</mml:mo><mml:mn>15</mml:mn></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mi>C</mml:mi><mml:mo>=</mml:mo><mml:mn>0.5</mml:mn></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula>), as a sensitivity analysis.</p><fig id="app2fig1" position="float"><label>Appendix 2—figure 1.</label><caption><title>Performance of metabCombiner with the different parameter settings.</title><p>The first setting, labelled ‘Scores’ correspond to the design of our main analysis, where 100 randomly selected true pairs are supplied to metabCombiner to set the scoring weights automatically, but are not otherwise used. In the second setting, labelled ‘Scores + RT’, metabCombiner is allowed to use the 100 true pairs not only to set the scoring weights, but also to estimate the RT drift. Finally, in the third ‘Default’ setting, we do not use any prior knowledge for the RT drift estimation and keep the scoring weights’ default values.</p></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-91597-app2-fig1-v1.tif"/></fig></sec><sec sec-type="appendix" id="s19"><title>M2S hyperparameter experiments</title><p><xref ref-type="bibr" rid="bib12">Climaco Pinto et al., 2022</xref> introduce M2S as a more versatile alternative to metabCombiner, while still adhering to most of its core principles. Like metabCombiner, M2S follows a three-step process. First it searches for matches within user-defined thresholds for <inline-formula><mml:math id="inf604"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula>, retention time, and mean feature intensity. Next, M2S estimates <inline-formula><mml:math id="inf605"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula>, RT and feature intensity drifts between datasets and removes any outlier pairs. Finally, M2S selects the best match using a scoring system that weighs each measurement, similar to metabCombiner. M2S notably stands out by providing greater flexibility in the methods and measurements used at each step of the procedure, resulting however in a larger number of parameters that require manual fine-tuning. To address this, we adopt two different approaches for the simulation study and the EPIC study alignment. In the simulation study, we set the initial thresholds to oracle values and investigate technical parameters. For the EPIC study alignment, we use the combination of technical parameters with the best average F1-score in the simulation study and select the best threshold values based on the performance on the validation subset.</p><p>More precisely, M2S first matches all pairs of metabolic features whose absolute difference in <inline-formula><mml:math id="inf606"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula>, RT, and median of <inline-formula><mml:math id="inf607"><mml:mrow><mml:mi>l</mml:mi><mml:mo>⁢</mml:mo><mml:mi>o</mml:mi><mml:mo>⁢</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mn>10</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> FI are within the user-defined thresholds ‘MZ_intercept’, ‘RT_intercept’ and ‘log10FI_intercept’. On simulated data experiments, we set these thresholds to MZ_intercept = 0.01, RT_intercept = 3.5 and log10FI_intercept = 0.2 which are large enough to not exclude any true feature matches in any of the scenarios for our simulated data under low, medium, and high overlap/noise (see Methods). M2S also offers more detailed options to match features whose absolute difference stays within two lower and upper bound lines with a given slope where the intercepts of these lines are defined using the values above. In our analysis, we set the slopes of these linear boundaries to zero so as to not remove any true matches. Because the reference and target studies we are matching in the simulated analysis are on the same scale, we set the FI adjust method to ‘none’.</p><p>The second step of M2S involves calculating penalization scores for every pair of matches which are used to determine the best set of matches between metabolic features of both datasets. This step depends on a set of hyperparameters which we perform a grid search over to optimize the performance of M2S. For estimating the <inline-formula><mml:math id="inf608"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula>, RT, and FI drift, the hyperparameters are the percentage of neighbors ‘nrNeighbors‘, the neighborhood shape ‘neighMethod’, and the LOESS span percentage ‘pctPointsLoess’ used to smooth the estimated drift functions. After the drifts are estimated, they are normalized using a method specified by ‘residPercentile’ that puts the <inline-formula><mml:math id="inf609"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula>, RT, and FI residuals on the same scale. We always fix residPercentile = NaN which defaults to the standard 2 × MAD normalization. Next, for every remaining metabolic feature match, the residuals/drifts of the <inline-formula><mml:math id="inf610"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula>, RT, and FI are added together by taking the weighted square root sum of squares. For unnormalized data where feature intensity magnitudes are important, we weight all three drifts equally using <inline-formula><mml:math id="inf611"><mml:mrow><mml:mi>W</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and for data with normalized feature intensities we set the FI drift weight to zero such that <inline-formula><mml:math id="inf612"><mml:mrow><mml:mi>W</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. Finally, using these weighted penalization scores, M2S selects the best matched pair within a multiple match cluster to obtain a one-to-one matching between datasets.</p><p>The third and final step of M2S involves removing those remaining matches which have large differences in <inline-formula><mml:math id="inf613"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula>, RT, or FI. This can be performed using several methods indicated by the hyperparameter ‘methodType’. Each method excludes those matched pairs whose differences in <inline-formula><mml:math id="inf614"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula>, RT, or FI exceed a certain number of median absolute deviations indicated by the parameter ‘nrMAD’. The remaining one-to-one metabolic feature matches are returned as the final result of the M2S algorithm.</p><p>To optimally tune M2S on our simulated experiments, we determine the optimal M2S parameter combination for each individual simulation setting (low, medium, high overlap and noise) by performing a grid search over the product of parameter lists</p><list list-type="bullet"><list-item><p>nrNeighbors = [0.01, 0.05, 0.1, 0.5, 1]</p></list-item><list-item><p>neighMethod = [‘cross’, ‘circle’]</p></list-item><list-item><p>pctPointsLoess = [0, 0.1, 0.5]</p></list-item><list-item><p>methodType = [‘none’, ‘scores’, ‘byBins’, ‘trend_mad’, ‘residuals_mad’]</p></list-item><list-item><p>nrMAD = [1, 3, 5]</p></list-item></list><p>Each parameter combination for M2S is tested across 20 randomly generated datasets at the same overlap and noise settings. For each setting, the combination of parameters above with the best average F1-score across these 20 trials is used as the optimal parameter choice.</p><p>M2S applies initial RT thresholds to search for candidate pairs, which may favor settings where the RT drift follows a linear trend. Therefore, as a sensitivity analysis, we apply M2S to simulated data with a linear drift. The simulation process is identical to that of our main simulation study, except for the deviation of the RT in dataset 2. Specifically, for a given overlap value, we divide the original real-world dataset into two smaller datasets and introduce random noise to the <inline-formula><mml:math id="inf615"><mml:mrow><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula>, RT and intensities of the features, without introducing a systematic deviation to the RT in dataset 2. M2S parameters are kept identical to the ones used in our main analysis in comparable settings. The results obtained by M2S on three pairs of datasets generated for three overlap values (0.25, 0.5 and 0.75) and a medium noise level are reported in <xref ref-type="table" rid="app2table1">Appendix 2—table 1</xref>. While the results obtained in a high overlap setting are close to those obtained in our main analysis M2S demonstrates better performance in a low overlap setting when the RT drift is linear than in our main analysis. This observation is consistent with the results obtained by M2S on EPIC data, considering the relatively low estimated overlap between the aligned EPIC studies in our main analysis.</p><table-wrap id="app2table1" position="float"><label>Appendix 2—table 1.</label><caption><title>Performance of M2S in a setting where the RT drift between studies is linear.</title></caption><table frame="hsides" rules="groups"><thead><tr><th align="left" valign="bottom">Metric</th><th align="left" valign="bottom">Low overlap</th><th align="left" valign="bottom">Medium overlap</th><th align="left" valign="bottom">High overlap</th></tr></thead><tbody><tr><td align="left" valign="bottom">Precision</td><td align="char" char="." valign="bottom">0.831</td><td align="char" char="." valign="bottom">0.917</td><td align="char" char="." valign="bottom">0.947</td></tr><tr><td align="left" valign="bottom">Recall</td><td align="char" char="." valign="bottom">0.934</td><td align="char" char="." valign="bottom">0.933</td><td align="char" char="." valign="bottom">0.939</td></tr></tbody></table></table-wrap><p>For the EPIC data, we select the parameter combination that yields the highest F1-score across all simulated settings. However, due to the unavailability of oracle values for setting initial thresholds, we perform a search over several MZ intercept values (0.01, 0.05, and 0.1), RT intercept values (0.1, 0.5, 1, and 5), and logFI intercept values (1, 10, and 100).</p></sec></app><app id="appendix-3"><title>Appendix 3</title><p>In this section, we study the sensitivity of all three alignment methods GMT, M2S, and mC to the validation dataset split when creating two validation studies for matching. As described in the section &quot;Validation on ground-truth data&quot; and depicted in <xref ref-type="fig" rid="fig2">Figure 2</xref> of the main text, we generate two datasets to be matched by splitting an initial LC-MS dataset with <inline-formula><mml:math id="inf616"><mml:mi>p</mml:mi></mml:math></inline-formula> features and <inline-formula><mml:math id="inf617"><mml:mi>n</mml:mi></mml:math></inline-formula> samples into two smaller overlapping datasets. The first dataset has <italic>p</italic><sub>1</sub> features and <italic>n</italic><sub>1</sub> samples while the second dataset has <italic>p</italic><sub>2</sub> features and <italic>n</italic><sub>2</sub> samples. The sets of samples in both datasets are disjoint such that <inline-formula><mml:math id="inf618"><mml:mrow><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>. However, the dataset split is constructed such that both datasets share <inline-formula><mml:math id="inf619"><mml:mrow><mml:mi/><mml:mo>≈</mml:mo><mml:mrow><mml:mi>λ</mml:mi><mml:mo>⁢</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> of their features where <inline-formula><mml:math id="inf620"><mml:mrow><mml:mi>λ</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is an overlap fraction. Namely, this is done by defining the dataset feature sizes as<disp-formula id="equ72"><label>(55)</label><mml:math id="m72"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">⌊</mml:mo></mml:mrow><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:mi>λ</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mi>λ</mml:mi><mml:mrow><mml:mi>f</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>λ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow><mml:mi>p</mml:mi><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">⌋</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mspace width="1em"/><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">⌊</mml:mo></mml:mrow><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">(</mml:mo></mml:mrow><mml:mi>λ</mml:mi><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>λ</mml:mi><mml:mrow><mml:mi>f</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>λ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">)</mml:mo></mml:mrow><mml:mi>p</mml:mi><mml:mrow><mml:mo maxsize="1.623em" minsize="1.623em">⌋</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>and the dataset sample sizes as<disp-formula id="equ73"><label>(56)</label><mml:math id="m73"><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo fence="false" stretchy="false">⌊</mml:mo><mml:msub><mml:mi>λ</mml:mi><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mi>n</mml:mi><mml:mo fence="false" stretchy="false">⌋</mml:mo><mml:mo>,</mml:mo><mml:mspace width="1em"/><mml:msub><mml:mi>n</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mo fence="false" stretchy="false">⌊</mml:mo><mml:msub><mml:mi>λ</mml:mi><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mi>n</mml:mi><mml:mo fence="false" stretchy="false">⌋</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p><p>As before, <inline-formula><mml:math id="inf621"><mml:mrow><mml:mo stretchy="false">⌊</mml:mo><mml:mo>⋅</mml:mo><mml:mo stretchy="false">⌋</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="inf622"><mml:mrow><mml:mo stretchy="false">⌈</mml:mo><mml:mo>⋅</mml:mo><mml:mo stretchy="false">⌉</mml:mo></mml:mrow></mml:math></inline-formula> denote integer floor and ceiling functions. Then taking the original LC-MS dataset and randomly permuting its samples and features, the first <italic>p</italic><sub>1</sub> features and first <italic>n</italic><sub>1</sub> samples are placed into dataset 1 while the last <italic>p</italic><sub>2</sub> features and last <italic>n</italic><sub>2</sub> samples are placed into dataset 2. It is indeed easy to check here that with such a splitting procedure, the feature overlap between both datasets is <inline-formula><mml:math id="inf623"><mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>-</mml:mo><mml:mi>p</mml:mi></mml:mrow><mml:mo>≈</mml:mo><mml:mrow><mml:mi>λ</mml:mi><mml:mo>⁢</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>.</p><p>Here <inline-formula><mml:math id="inf624"><mml:mrow><mml:msub><mml:mi>λ</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>0.5</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> controls the fraction of features in dataset 1 that is not shared with dataset 2 and <inline-formula><mml:math id="inf625"><mml:mrow><mml:msub><mml:mi>λ</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> controls the fraction of samples in dataset 1 vs. dataset 2. In particular, if <inline-formula><mml:math id="inf626"><mml:mrow><mml:msub><mml:mi>λ</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> then the features in dataset 2 are entirely a subset of those in dataset 1. In the experiments described in the main text, we always set <inline-formula><mml:math id="inf627"><mml:mrow><mml:msub><mml:mi>λ</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>λ</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>0.5</mml:mn></mml:mrow></mml:math></inline-formula> as to balance the number of features and samples in both resulting datasets.</p><p>Now we study how the performance of all three alignment methods changes when <inline-formula><mml:math id="inf628"><mml:mrow><mml:msub><mml:mi>λ</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>λ</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and the feature overlap <inline-formula><mml:math id="inf629"><mml:mi>λ</mml:mi></mml:math></inline-formula> are varied. Here we vary the feature overlap <inline-formula><mml:math id="inf630"><mml:mrow><mml:mi>λ</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mn>0.25</mml:mn><mml:mo>,</mml:mo><mml:mn>0.5</mml:mn><mml:mo>,</mml:mo><mml:mn>0.75</mml:mn><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, the feature fraction <inline-formula><mml:math id="inf631"><mml:mrow><mml:msub><mml:mi>λ</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mn>0.5</mml:mn><mml:mo>,</mml:mo><mml:mn>0.6</mml:mn><mml:mo>,</mml:mo><mml:mn>0.7</mml:mn><mml:mo>,</mml:mo><mml:mn>0.8</mml:mn><mml:mo>,</mml:mo><mml:mn>0.9</mml:mn><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, and the sample fraction <inline-formula><mml:math id="inf632"><mml:mrow><mml:msub><mml:mi>λ</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mn>0.1</mml:mn><mml:mo>,</mml:mo><mml:mn>0.2</mml:mn><mml:mo>,</mml:mo><mml:mi mathvariant="normal">…</mml:mi><mml:mo>,</mml:mo><mml:mn>0.9</mml:mn><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. In <xref ref-type="fig" rid="app3fig1">Appendix 3—figures 1</xref>–<xref ref-type="fig" rid="app3fig3">3</xref> we show how the precision and recall of GMT, M2S, and mC depend on these parameters. Here we use the same unnormalized validation data and experimental setup as decribed in the main text section &quot;Validation on ground-truth data&quot; and in the Methods and Materials section &quot;Validation on simulated data&quot;. For each triple <inline-formula><mml:math id="inf633"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>λ</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>λ</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>λ</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> we randomly generate 20 dataset splits with these parameters and show the average precision and recall for each method over these trials. Our method GMT (thresholded GromovMatcher) is applied out-of-box with the default hyperparameter settings. The algorithm hyperparameters for mC and M2S are chosen optimally for each individual triple of dataset parameters <inline-formula><mml:math id="inf634"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>λ</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>λ</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>λ</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to maximize the average F1 score in each setting. The hyperparameters searched over when optimizing mC and M2S are described in detail in Appendix 2.</p><p>Consistent with prior validation experiments, we find that GromovMatcher outperforms both mC and M2S in all dataset regimes, for low overlap and high overlap <inline-formula><mml:math id="inf635"><mml:mi>λ</mml:mi></mml:math></inline-formula> as well as for varying balances of features <inline-formula><mml:math id="inf636"><mml:msub><mml:mi>λ</mml:mi><mml:mi>f</mml:mi></mml:msub></mml:math></inline-formula> and samples <inline-formula><mml:math id="inf637"><mml:msub><mml:mi>λ</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:math></inline-formula>. Remarkably, all three methods exhibit the same sensitivity to variations of <inline-formula><mml:math id="inf638"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>λ</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>λ</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>λ</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. All methods exhibit a monotonic decrease in their precision as <inline-formula><mml:math id="inf639"><mml:msub><mml:mi>λ</mml:mi><mml:mi>f</mml:mi></mml:msub></mml:math></inline-formula> drops from 0.9 to 0.5. In other words, the most challenging setting for matching both datasets is when dataset 1 and dataset 2 both have an equal number of unshared features (e.g. <inline-formula><mml:math id="inf640"><mml:mrow><mml:msub><mml:mi>λ</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>0.5</mml:mn></mml:mrow></mml:math></inline-formula>). Likewise, the simplest setting for matching is when the features in dataset 2 are exactly a subset of the features in dataset 1 (e.g. <inline-formula><mml:math id="inf641"><mml:mrow><mml:msub><mml:mi>λ</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>). Sensitivity to this parameter <inline-formula><mml:math id="inf642"><mml:msub><mml:mi>λ</mml:mi><mml:mi>f</mml:mi></mml:msub></mml:math></inline-formula> is most noticeable at low feature overlap <inline-formula><mml:math id="inf643"><mml:mrow><mml:mi>λ</mml:mi><mml:mo>=</mml:mo><mml:mn>0.25</mml:mn></mml:mrow></mml:math></inline-formula>.</p><fig id="app3fig1" position="float"><label>Appendix 3—figure 1.</label><caption><title>Sensitivity of thresholded GromovMatcher (GMT) to feature overlap fraction <inline-formula><mml:math id="inf644"><mml:mi>λ</mml:mi></mml:math></inline-formula>, feature imbalance fraction <inline-formula><mml:math id="inf645"><mml:msub><mml:mi>λ</mml:mi><mml:mi>f</mml:mi></mml:msub></mml:math></inline-formula>, and sample imbalance fraction <inline-formula><mml:math id="inf646"><mml:msub><mml:mi>λ</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:math></inline-formula> between two datasets being matched.</title></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-91597-app3-fig1-v1.tif"/></fig><fig id="app3fig2" position="float"><label>Appendix 3—figure 2.</label><caption><title>Sensitivity of M2S to feature overlap fraction <inline-formula><mml:math id="inf647"><mml:mi>λ</mml:mi></mml:math></inline-formula>, feature imbalance fraction <inline-formula><mml:math id="inf648"><mml:msub><mml:mi>λ</mml:mi><mml:mi>f</mml:mi></mml:msub></mml:math></inline-formula>, and sample imbalance fraction <inline-formula><mml:math id="inf649"><mml:msub><mml:mi>λ</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:math></inline-formula> between two datasets being matched.</title></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-91597-app3-fig2-v1.tif"/></fig><fig id="app3fig3" position="float"><label>Appendix 3—figure 3.</label><caption><title>Sensitivity of metabCombiner (mC) to feature overlap fraction <inline-formula><mml:math id="inf650"><mml:mi>λ</mml:mi></mml:math></inline-formula>, feature imbalance fraction <inline-formula><mml:math id="inf651"><mml:msub><mml:mi>λ</mml:mi><mml:mi>f</mml:mi></mml:msub></mml:math></inline-formula>, and sample imbalance fraction <inline-formula><mml:math id="inf652"><mml:msub><mml:mi>λ</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:math></inline-formula> between two datasets being matched.</title></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-91597-app3-fig3-v1.tif"/></fig></app><app id="appendix-4"><title>Appendix 4</title><p>Here we describe additional preprocessing details and analyses of the EPIC data.</p><sec sec-type="appendix" id="s20"><title>Centered and scaled data - Negative mode</title><p>In this section, we present the results obtained on centered and scaled EPIC data in negative mode, shown in <xref ref-type="fig" rid="fig4">Figure 4</xref> of our main paper. However, due to the smaller size of the validation subset (42 features examined in negative mode compared to 163 in positive mode), the evaluation of the performance of the three methods may be less reliable than in positive mode.</p><p>First, we align the CS and HCC studies in negative mode and detect a total of 449, 492, and 180 matches with GM, M2S, and metabCombiner, respectively. Similar to the positive mode analysis, we evaluate the precision and recall of the three methods on the 42 feature validation subset, of which 19 were manually matched. GM and M2S demonstrate identical F1-scores of 0.98, while metabCombiner performs poorly in comparison. GM is able to recover all 19 true matches and identified only 1 false positive, while M2S recovers no false positives but missed 1 true positive.</p><p>Next, we align the CS and PC studies in negative mode and detect a total of 485, 569, and 314 matches with GM, M2S, and metabCombiner, respectively. Again, we evaluate the precision and recall of the three methods on the 42 feature validation subset, of which 26 were manually matched. MetabCombiner performs better than in the other EPIC pairings with an F1-score of 0.857, but is still outperformed by the other two methods. GM is slightly outperformed by M2S in this setting, with an almost identical precision of 0.93, but a slightly higher recall for M2S due to detecting 1 additional true positive. However, this remains a good performance for GM since M2S was optimally tuned using the validation subset itself.</p></sec><sec sec-type="appendix" id="s21"><title>Non-centered and non-scaled data</title><p>As a sensitivity analysis, we apply the three methods to EPIC data that has not been centered or scaled. The detailed results can be found in <xref ref-type="table" rid="app4table1">Appendix 4—table 1</xref>.</p><table-wrap id="app4table1" position="float"><label>Appendix 4—table 1.</label><caption><title>Precision and recall on the EPIC validation subset for unnormalized data in (a) positive mode, and (b) negative mode.</title><p>95% confidence intervals were computed using modified Wilson score intervals <xref ref-type="bibr" rid="bib8">Brown et al., 2001</xref>; <xref ref-type="bibr" rid="bib1">Agresti and Coull, 1998</xref>.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left" valign="bottom"/><th align="left" valign="bottom" colspan="2"><inline-formula><mml:math id="inf653"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mtext mathvariant="bold">CS</mml:mtext></mml:mrow><mml:mo stretchy="false">⟷</mml:mo><mml:mrow><mml:mtext mathvariant="bold">HCC</mml:mtext></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula></th><th align="left" valign="bottom" colspan="2"><inline-formula><mml:math id="inf654"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mtext mathvariant="bold">CS</mml:mtext></mml:mrow><mml:mo stretchy="false">⟷</mml:mo><mml:mrow><mml:mtext mathvariant="bold">PC</mml:mtext></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula></th></tr></thead><tbody><tr><td align="left" valign="bottom">Method</td><td align="left" valign="bottom">Precision</td><td align="left" valign="bottom">Recall</td><td align="left" valign="bottom">Precision</td><td align="left" valign="bottom">Recall</td></tr><tr><td align="left" valign="bottom">GromovMatcher</td><td align="char" char="." valign="bottom">0.988 (0.937, 0.999)</td><td align="char" char="." valign="bottom">0.944 (0.876, 0.997)</td><td align="char" char="." valign="bottom">0.873 (0.776, 0.932)</td><td align="char" char="." valign="bottom">0.939 (0.854, 0.976)</td></tr><tr><td align="left" valign="bottom">M2S</td><td align="char" char="." valign="bottom">0.967 (0.908, 0.991)</td><td align="char" char="." valign="bottom">0.978 (0.923, 0.996)</td><td align="char" char="." valign="bottom">0.855 (0.759, 0.917)</td><td align="char" char="." valign="bottom">0.985 (0.919, 0.999)</td></tr><tr><td align="left" valign="bottom">metabCombiner</td><td align="char" char="." valign="bottom">0.979 (0.889, 0.999)</td><td align="char" char="." valign="bottom">0.511 (0.410, 0.612)</td><td align="char" char="." valign="bottom">0.926 (0.766, 0.987)</td><td align="char" char="." valign="bottom">0.379 (0.271, 0.499)</td></tr><tr><td align="left" valign="bottom">(a) Positive mode</td><td align="left" valign="bottom"/><td align="left" valign="bottom"/><td align="left" valign="bottom"/><td align="left" valign="bottom"/></tr><tr><td align="left" valign="bottom"/><td align="left" valign="bottom" colspan="2"><inline-formula><mml:math id="inf655"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mtext mathvariant="bold">CS</mml:mtext></mml:mrow><mml:mo stretchy="false">⟷</mml:mo><mml:mrow><mml:mtext mathvariant="bold">HCC</mml:mtext></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula></td><td align="left" valign="bottom" colspan="2"><inline-formula><mml:math id="inf656"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow><mml:mtext mathvariant="bold">CS</mml:mtext></mml:mrow><mml:mo stretchy="false">⟷</mml:mo><mml:mrow><mml:mtext mathvariant="bold">PC</mml:mtext></mml:mrow></mml:mrow></mml:mstyle></mml:math></inline-formula></td></tr><tr><td align="left" valign="bottom">Method</td><td align="left" valign="bottom">Precision</td><td align="left" valign="bottom">Recall</td><td align="left" valign="bottom">Precision</td><td align="left" valign="bottom">Recall</td></tr><tr><td align="left" valign="bottom">GromovMatcher</td><td align="char" char="." valign="bottom">0.950 (0.764, 0.997)</td><td align="char" char="." valign="bottom">1.000 (0.832, 1.000)</td><td align="char" char="." valign="bottom">0.964 (0.823, 0.998)</td><td align="char" char="." valign="bottom">0.964 (0.823, 0.998)</td></tr><tr><td align="left" valign="bottom">M2S</td><td align="char" char="." valign="bottom">1.000 (0.824, 1.000)</td><td align="char" char="." valign="bottom">0.947 (0.754, 0.997)</td><td align="char" char="." valign="bottom">0.931 (0.780, 0.988)</td><td align="char" char="." valign="bottom">0.964 (0.823, 0.998)</td></tr><tr><td align="left" valign="bottom">metabCombiner</td><td align="char" char="." valign="bottom">1.000 (0.566, 1.000)</td><td align="char" char="." valign="bottom">0.263 (0.118, 0.488)</td><td align="char" char="." valign="bottom">1.000 (0.785, 1.000)</td><td align="char" char="." valign="bottom">0.500 (0.326, 0.674)</td></tr><tr><td align="left" valign="bottom">(b) Negative mode</td><td align="left" valign="bottom"/><td align="left" valign="bottom"/><td align="left" valign="bottom"/><td align="left" valign="bottom"/></tr></tbody></table></table-wrap><p>M2S was tuned manually on the validation subset to ignore feature intensities in both cases. As a result, it maintains its performance compared to our main experiment. On the other hand, the performance of GM and metabCombiner is affected by the lack of consistency in feature intensities. MetabCombiner’s recall drops slightly but its precision remains comparable to that of our main experiment, with the method clearly favoring the latter. Although GM’s recall decreases slightly in positive mode, it remains more precise than the optimally tuned M2S, and it balances precision and recall better than metabCombiner. Interestingly, GM’s results in negative mode are improved compared to our main experiment, and it outperforms both mC and M2S. However, since the validation subset in negative mode is relatively small, these differences may not be significant. Nonetheless, GM maintains a good performance, similar to that of the optimally tuned M2S.</p><p>Similar to the analysis we conducted on centered and scaled data, we find a high number of false positives when aligning the CS study and the PC study in positive mode. Therefore, we manually examine the matches recovered by GM. Our examination reveals 2 false positives, 4 unclear matches, and 3 additional good matches that GM also identifies in our main analysis. This demonstrates that the lack of centering and scaling results in two additional false positives for GM that are not present in our main results.</p></sec><sec sec-type="appendix" id="s22"><title>Illustration for alcohol biomarker discovery</title><p><xref ref-type="bibr" rid="bib26">Loftfield et al., 2021</xref> identified 205 features associated with alcohol intake in the CS study, using a false discovery rate (FDR) correction to account for multiple testing. By applying an FDR correction in our pooled analysis, we identify 243 features associated with alcohol intake. Out of those 243 features, 185 are consistent with the features identified in the discovery step of <xref ref-type="bibr" rid="bib26">Loftfield et al., 2021</xref>, while 55 features are newly discovered (<xref ref-type="fig" rid="fig5">Figure 5c</xref>). We examine the 20 features identified as significant in Loftfield et al.’s discovery analysis but that are not significant in our pooled analysis. Both manual and GM matching yield identical results for these features, indicating that the loss of significance is not due to incorrect matching. Upon further investigation, we find that these features do not demonstrate a meaningful association with alcohol intake in the HCC and PC studies. This observation is reinforced by the fact that none of these features are among the 10 features that persisted after the validation step in Loftfield et al.</p><p>Out of the 205 features initially discovered in <xref ref-type="bibr" rid="bib26">Loftfield et al., 2021</xref>, 10 are replicated in the EPIC HCC and PC studies using the more stringent Bonferroni correction. When using a Bonferroni correction in our pooled analysis, we find significant association between alcohol intake and 92 features, 36 of which are effectively shared by the three studies. Notably, these features include all 10 features that were retained in Loftfield et al. (<xref ref-type="fig" rid="fig5">Figure 5c</xref>).</p><p>This analysis illustrates how GromovMatcher can be used in the context of biomarker discovery, and its potential to allow for increased statistical power.</p></sec></app><app id="appendix-5"><title>Appendix 5</title><p>Here we investigate how the choice of the reference dataset influences the discovery of metabolites shared across the CS, HCC and PC EPIC studies by GromovMatcher. All three methods considered in this paper, GromovMatcher, M2S, and metabCombiner, are limited to the comparison of two datasets. However, they can still be used to compare and pool multiple datasets using a multi-step procedure. Namely, this can be done by designating a ‘reference’ dataset and aligning all studies to it one by one. We take this exact approach in our analysis when aligning the CS, HCC, and PC studies of the EPIC data in positive mode. Namely, the HCC and PC studies are both aligned to the CS study (see main text <xref ref-type="fig" rid="fig5">Figure 5b</xref>). However, this method raises two critical questions: (<italic>i</italic>) how does the use of a reference dataset affect matching results, and (<italic>ii</italic>) how is the matching affected by the choice of reference dataset.</p><p>To address these questions, we compare the features identified as common to the three studies using two different studies as references: the CS study used as reference in the main analysis, and the HCC study. For simplicity, let’s denote <inline-formula><mml:math id="inf657"><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mtext>study 1</mml:mtext><mml:mo>,</mml:mo><mml:mtext>study 2</mml:mtext></mml:mrow></mml:msub></mml:math></inline-formula> the matching matrix obtained when aligning study 1 and study 2.</p><sec sec-type="appendix" id="s23"><title>Changes in matching results when reference dataset is used</title><p>Concerning question (i), we compare two matchings: HCC to CS to PC (the matrix product <inline-formula><mml:math id="inf658"><mml:mrow><mml:msubsup><mml:mi>M</mml:mi><mml:mrow><mml:mtext>CS</mml:mtext><mml:mo>,</mml:mo><mml:mtext>HCC</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msubsup><mml:mo>⁢</mml:mo><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mtext>CS</mml:mtext><mml:mo>,</mml:mo><mml:mtext>PC</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>) which we will refer to as the reference matching, and the direct matching of PC to HCC (<inline-formula><mml:math id="inf659"><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mtext>HCC</mml:mtext><mml:mo>,</mml:mo><mml:mtext>PC</mml:mtext></mml:mrow></mml:msub></mml:math></inline-formula>). Note that these matchings are not fully comparable as the former considers only features found in CS, potentially missing unique HCC and PC matches. We can however compare the two matchings on the subset of 706 features common to all three studies, as determined by the reference matching. We find that the direct matching supports 683 out of them, indicating that the matching via a reference still yields good results compared to the direct matching (see <xref ref-type="fig" rid="app5fig1">Appendix 5—figure 1</xref>).</p><fig id="app5fig1" position="float"><label>Appendix 5—figure 1.</label><caption><title>Overlap between the 706 features common to the HCC and PC studies found via reference matching, and the 938 features common to HCC and PC found by direct matching.</title></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-91597-app5-fig1-v1.tif"/></fig></sec><sec sec-type="appendix" id="s24"><title>Effect of reference dataset choice on matching results</title><p>Concerning question (<italic>ii</italic>), we compare the features identified as common to the three studies using two different studies as references: the CS study used in the paper, and the HCC study. We find that they identify 706 and 708 common features respectively, with an overlap of 640 features (see <xref ref-type="fig" rid="app5fig2">Appendix 5—figure 2</xref>). This highlights that the choice of reference does matter to some extent. In the paper, choosing CS as a reference was informed by CS’s sample size, and study population.</p><fig id="app5fig2" position="float"><label>Appendix 5—figure 2.</label><caption><title>Overlap between the features identified as common to the three EPIC studies using either the CS study or the HCC study as a reference.</title></caption><graphic mimetype="image" mime-subtype="tiff" xlink:href="elife-91597-app5-fig2-v1.tif"/></fig></sec></app></app-group></back><sub-article article-type="editor-report" id="sa0"><front-stub><article-id pub-id-type="doi">10.7554/eLife.91597.3.sa0</article-id><title-group><article-title>eLife assessment</article-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>Fernandez</surname><given-names>Paula</given-names></name><role specific-use="editor">Reviewing Editor</role><aff><institution>INTA</institution><country>Argentina</country></aff></contrib></contrib-group><kwd-group kwd-group-type="evidence-strength"><kwd>Convincing</kwd></kwd-group><kwd-group kwd-group-type="claim-importance"><kwd>Important</kwd></kwd-group></front-stub><body><p>The authors describe an <bold>important</bold> tool, GromovMatcher, that can be used to compare proteomic data from various experimental approaches. The underlying method is innovative, the algorithm is clearly described, and the validation that is presented is <bold>convincing</bold>.</p></body></sub-article><sub-article article-type="referee-report" id="sa1"><front-stub><article-id pub-id-type="doi">10.7554/eLife.91597.3.sa1</article-id><title-group><article-title>Reviewer #1 (Public Review):</article-title></title-group><contrib-group><contrib contrib-type="author"><anonymous/><role specific-use="referee">Reviewer</role></contrib></contrib-group></front-stub><body><p>Summary:</p><p>The authors have implemented Optimal Transport algorithm in GromovMatcher for comparing LC/MS features from different datasets. This paper gains significance in the proteomics field for performing meta-analysis of LC/MS data.</p><p>Strengths:</p><p>The main strength is that GromovMatcher acheives significant performance metrics compared to other existing methods. The authors have done extensive comparisons to claim that GromovMatcher performs well.</p><p>Weaknesses:</p><p>The authors might need to add the limitation of datasets and thus have tested/validated their tool using simulated data in the abstract as well.</p></body></sub-article><sub-article article-type="referee-report" id="sa2"><front-stub><article-id pub-id-type="doi">10.7554/eLife.91597.3.sa2</article-id><title-group><article-title>Reviewer #2 (Public Review):</article-title></title-group><contrib-group><contrib contrib-type="author"><anonymous/><role specific-use="referee">Reviewer</role></contrib></contrib-group></front-stub><body><p>Summary</p><p>The goal of untargeted metabolomics is to identify differences between metabolomes of different biological samples.</p><p>Untargeted metabolomics identifies features with specific mass-to-charge-ratio (m/z) and retention time (RT). Matching those to specific metabolites based on the model compounds from databases is laborious and not always possible, which is why methods for comparing samples on the level of unmatched features are crucial.</p><p>The main purpose of the GromovMatcher method presented here is to merge and compare untargeted metabolomes from different experiments. These larger datasets could then be used to advance biological analyses, for example, for identification of metabolic disease markers.</p><p>The main problem that complicates merging different experiments is that m/z and RT vary slightly for the same feature (metabolite).</p><p>The main idea behind the GromovMatcher is built on the assumption that if two features match between two datasets (that feature i from dataset 1 matches feature j from dataset 2, and feature k from dataset 1 matches feature l from dataset 2), then the correlations or distances between the two features within each of the datasets (i and k, and j and l) will be similar. The authors then use the Gromov-Wasserstein method to find the best matches matrix from these data.</p><p>The variation in m/z between the same features in different experiments is a user-defined value and it is initially set to 0.01 ppm. There is no clear limit for RT deviations, so the method estimates a non-linear deviation (drift) of RT between two studies. GromovMatcher estimates the drift between two studies, and then discards the matching pairs where the drift would deviate significantly from the estimate. It learns the drift from a weighted spline regression.</p><p>The authors validate the performance of their GromovMatcher method using a dataset of cord blood. They use 20 different splits and compare the GromovMatcher (both its GM and GMT iterations, whereby GMT version uses the deviation from estimated RT drift to filter the matching matrix) with two other matching methods: M2S and metabCombiner.</p><p>The second validation was done using a (scaled and centered) dataset of metabolics from cancer datasets from the EPIC cohort that were manually matched by an expert. This dataset was also used to show that using automated methods can identify more features that are associated with a particular group of samples than what was found by manual matching. Specifically, the authors identify additional features connected to alcohol consumption.</p><p>Strengths:</p><p>I see the main strength of this work in its combination of all levels of information (m/z, RT, and higher-order information on correlations between features) and using each of the types of information in a way that is appropriate for the measure. The most innovative aspect is using the Gromov-Wasserstein method to match the features based on distance matrices.</p><p>The authors of the paper identify two main shortcomings with previously established methods that attempt to match features from different experiments: (a) all other methods require fine-tuning of user-defined parameters, and, more importantly, (b) do not consider correlations between features. The main strength of the GromovMatcher is that it incorporates the information on distances between the features (in addition to also using m/z and RT).</p><p>Weaknesses:</p><p>The main weakness is that there seem not to be enough manually curated datasets that could be used for validation. It will, therefore, be important, for the authors, and the field in general to keep validating and improving their methods if more datasets become available.</p><p>The second weakness, as emphasized by the authors in the discussion is that the method as it is set up now can be directly used only to compare two datasets. I am confident that the authors will successfully implement novel algorithms to address this issue in the future.</p></body></sub-article><sub-article article-type="author-comment" id="sa3"><front-stub><article-id pub-id-type="doi">10.7554/eLife.91597.3.sa3</article-id><title-group><article-title>Author response</article-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>Breeur</surname><given-names>Marie</given-names></name><role specific-use="author">Author</role><aff><institution>International Agency For Research On Cancer</institution><addr-line><named-content content-type="city">Lyon</named-content></addr-line><country>France</country></aff></contrib><contrib contrib-type="author"><name><surname>Stepaniants</surname><given-names>George</given-names></name><role specific-use="author">Author</role><aff><institution>Massachusetts Institute of Technology</institution><addr-line><named-content content-type="city">Boston</named-content></addr-line><country>United States</country></aff></contrib><contrib contrib-type="author"><name><surname>Keski-Rahkonen</surname><given-names>Pekka</given-names></name><role specific-use="author">Author</role><aff><institution>International Agency For Research On Cancer</institution><addr-line><named-content content-type="city">Lyon</named-content></addr-line><country>France</country></aff></contrib><contrib contrib-type="author"><name><surname>Rigollet</surname><given-names>Philippe</given-names></name><role specific-use="author">Author</role><aff><institution>Massachusetts Institute of Technology</institution><addr-line><named-content content-type="city">Boston</named-content></addr-line><country>United States</country></aff></contrib><contrib contrib-type="author"><name><surname>Viallon</surname><given-names>Vivian</given-names></name><role specific-use="author">Author</role><aff><institution>International Agency For Research On Cancer</institution><addr-line><named-content content-type="city">Lyon</named-content></addr-line><country>France</country></aff></contrib></contrib-group></front-stub><body><p>The following is the authors’ response to the original reviews.</p><disp-quote content-type="editor-comment"><p>eLife assessment</p><p>This paper represents important findings when identifying untargeted metabolomics and its differences between metabolomes of different biological samples. GromovMatcher is the fantasy name for the soft development. The main idea behind it is built on the assumption of featuring and matching complex datasets. Although the manuscript reflects a solid analysis, it remains incomplete for validation with putative non-curated datasets.</p></disp-quote><p>We are grateful to the eLife editor for taking the time and effort to assess our manuscript.</p><p>We are however unsure of what the editor means by “it remains incomplete for validation with putative non-curated datasets”. As noted by Reviewer 2, manually curated datasets that could be used for validation are scarce. Most publicly available datasets do not contain sufficient information to establish a ground truth matching on which GromovMatcher, M2S, or metabCombiner can be tested. Even in the case where such a ground truth matching can be established, it must be performed by-hand through a manual matching process which is extremely time-consuming and requires very specific expertise. This, in our opinion, only highlights the need for automatic alignment methods such as metabCombiner, M2S or GromovMatcher.</p><p>We do agree that the performance of GromovMatcher (and its competitors) needs to be validated further, and we plan to continue validating GromovMatcher as additional data becomes available in EPIC and other cohorts. With that in mind, the lack of publicly available validation data is the reason why we conducted such an extensive simulation study, arguably more comprehensive than previous validations, exploring challenging settings that we believe reflect real-life scenarios (main text “Validation on ground-truth data” and Appendix 3). We would like to stress that this allows us to highlight previously ignored limitations of the previously published methods, metabCombiner and M2S.</p><p>We wish to thank the editor and reviewers for their time and efforts in reviewing our manuscript which led to many significant additions to our paper. Namely we:</p><p>• Performed an additional sensitivity analysis (Appendix 3) exploring how an imbalance in the number of features or samples between two studies being matched (e.g. the dataset split), affects the quality of matchings found by GromovMatcher, metabCombiner, and M2S.</p><p>• Investigated how changing or removing the reference dataset (Appendix 5) in the EPIC study (main text “Application to EPIC data”), affects the results of GromovMatcher.</p><p>• Improved alignment matrix visualizations in Fig. 3a for all four methods tested on the validation data, to highlight more clearly which feature matches were correctly identified or missed.</p><p>The revised paper is uploaded as the file “main_elife_revision.pdf” where all revisions are highlighted in blue as well as a copy “main_elife_revision_nohighlights.pdf” where revisions are not highlighted.</p><disp-quote content-type="editor-comment"><p><bold>Public Reviews:</bold></p><p><bold>Reviewer #1 (Public Review):</bold></p></disp-quote><p>Summary:</p><disp-quote content-type="editor-comment"><p>The authors have implemented the Optimal Transport algorithm in GromovMatcher for comparing LC/MS features from different datasets. This paper gains significance in the proteomics field for performing meta-analysis of LC/MS data.</p><p>Strengths:</p><p>The main strength is that GromovMatcher achieves significant performance metrics compared to other existing methods. The authors have done extensive comparisons to claim that GromovMatcher performs well.</p><p>Weaknesses:</p><p>There are two weaknesses.</p><p>(1) When the number of features is reduced the precision drops to ~0.8.</p></disp-quote><p>We would like to clarify that this drop in precision occurs in the challenging setting where only a small proportion of metabolites are shared between both datasets (e.g., the overlap – or proportion of shared features - was 25% in our simulation study). When two untargeted metabolic datasets share only 25% of their features, this is a challenging setting for any automated matching method as the vast majority 75% of the features in both datasets must remain unmatched.</p><p>In such settings, the reviewer correctly observes that the precision of GromovMatcher algorithms (GM and GMT) drops within the range of 0.80 - 0.85 (Figure 3b, top left panel). Such a precision of 0.8 or larger is still competitive compared with the alternative methods MetabCombiner (mC) and M2S whose precisions drop below 0.8 (see main text Fig. 3b, top left panel).</p><p>Precision is measured as the number of metabolite pairs correctly matched divided by all matches identified by a method. In other words, even in the challenging setting when the number of shared features (true matches) between both datasets is small (e.g. low 25% overlap), upwards of 80% of the feature matches found by GromovMatcher are correct which is a very encouraging result.</p><disp-quote content-type="editor-comment"><p>(2) How applicable is the method for other non-human datasets?</p></disp-quote><p>We thank the reviewer for raising this question. The crux of the matter concerning the application to animal data revolves around the hypothesis that correlations between metabolites in two different studies are preserved. Theoretically, the metabolome operates under similar principles in humans, governed by an underlying network of biochemical reactions. Consequently, in comparable human populations, the GM hypothesis is likely to hold to some extent.</p><p>However, in practice, application to animal data is more complicated. Animal studies tend to have smaller sample sizes and often stem from intervention-driven scenarios, such as mice subjected to specific diets or chemicals. This results in deliberate alterations in metabolic structures which makes finding two comparable animal studies less likely. To investigate the reviewer’s question, we have searched through the two predominant LC-MS dataset repositories (MetaboLights and NIH Metabolomics Workbench) but did not find any pairs of comparable animal studies due to the reasons mentioned above. One potential strategy to navigate this issue could entail regressing the metabolic intensities against the variables that notably differ between the two animal populations and running GM using the residual intensities. This would be an interesting direction for future research and additional validation would be needed to test the robustness of GM in this setting.</p><disp-quote content-type="editor-comment"><p><bold>Reviewer #2 (Public Review):</bold></p><p>Summary:</p><p>The goal of untargeted metabolomics is to identify differences between metabolomes of different biological samples. Untargeted metabolomics identifies features with specific mass-to-charge ratio (m/z) and retention time (RT). Matching those to specific metabolites based on the model compounds from databases is laborious and not always possible, which is why methods for comparing samples on the level of unmatched features are crucial.</p><p>The main purpose of the GromovMatcher method presented here is to merge and compare untargeted metabolomes from different experiments. These larger datasets could then be used to advance biological analyses, for example, for the identification of metabolic disease markers. The main problem that complicates merging different experiments is m/z and RT vary slightly for the same feature (metabolite).</p><p>The main idea behind the GromovMatcher is built on the assumption that if two features match between two datasets (that feature I from dataset 1 matches feature j from dataset 2, and feature k from dataset 1 matches feature l from dataset 2), then the correlations or distances between the two features within each of the datasets (i and k, and j and l) will be similar. The authors then use the Gromov-Wasserstein method to find the best matches matrix from these data.</p><p>The variation in m/z between the same features in different experiments is a user-defined value and it is initially set to 0.01 ppm. There is no clear limit for RT deviations, so the method estimates a non-linear deviation (drift) of RT between two studies. GromovMatcher estimates the drift between the two studies and then discards the matching pairs where the drift would deviate significantly from the estimate. It learns the drift from a weighted spline regression.</p><p>The authors validate the’performance of their GromovMatcher method by a validation experiment using a dataset of cord blood. They use 20 different splits and compare the GromovMatcher (both its GM and GMT iterations, whereby the GMT version uses the deviation from estimated RT drift to filter the matching matrix) with two other matching methods: M2S and metabCombiner.</p><p>The second validation was done using a (scaled and centered) dataset of metabolics from cancer datasets from the EPIC cohort that was manually matched by an expert. This dataset was also used to show that using automatic methods can identify more features that are associated with a particular group of samples than what was found by manual matching. Specifically, the authors identify additional features connected to alcohol consumption.</p><p>Strengths:</p><p>I see the main strength of this work in its combination of all levels of information (m/z, RT, and higher-order information on correlations between features) and using each of the types of information in a way that is appropriate for the measure. The most innovative aspect is using the Gromov-Wasserstein method to match the features based on distance matrices.</p></disp-quote><p>We thank the reviewer for acknowledging this strength of our proposed GromovMatcher method.</p><disp-quote content-type="editor-comment"><p>The authors of the paper identify two main shortcomings with previously established methods that attempt to match features from different experiments: (a) all other methods require fine-tuning of user-defined parameters, and, more importantly, (b) do not consider correlations between features. The main strength of the GromovMatcher is that it incorporates the information on distances between the features (in addition to also using m/z and RT).</p><p>Weaknesses:</p><p>The first, minor, weakness I could identify is that there seem not to be plenty of manually curated datasets that could be used for validation.</p></disp-quote><p>We thank the reviewer for raising this issue concerning manually curated validation data.</p><p>Manually curated datasets available for validation purposes are indeed scarce. This stems from the laborious nature of matching features across diverse studies, hence the need for automatic matching methods. Our future strategy involves further validation of the GromovMatcher approach as more data becomes accessible in EPIC and other cohorts.</p><p>The scarcity of real-life publicly available datasets that can be used for validation purpose is the reason why we conducted an extensive simulation study (main text “Validation on ground-truth data” and Appendix 3). It is notably thorough, arguably more comprehensive than previous validations, utilizes real-life untargeted data, and imitates situations where data originates from distinct untargeted metabolomics studies, complete with realistic noise parameters encompassing RT, mz, and feature intensities. Our validation study comprehensively explores the performance of GromovMatcher, M2S, and metabCombiner, including in challenging realistic settings where there is a nonlinear drift in retention times, varying levels of feature overlaps between studies, normalizations of feature intensities, as well as imbalances in the number of features and samples present in the studies being matched.</p><disp-quote content-type="editor-comment"><p>The second is also emphasized by the authors in the discussion. Namely, the method as it is set up now can be directly used only to compare two datasets.</p></disp-quote><p>This is indeed a limitation that is common to all three methods considered in this paper. However, all these methods, GromovMatcher, M2S, and metabCombiner, can still be used to compare and pool multiple datasets using a multi-step procedure. Namely, this can be done by designating a 'reference' dataset and aligning all studies to it one by one. We take this exact approach in our paper when aligning the CS, HCC, and PC studies of the EPIC data in positive mode (main text “Application to EPIC data”). Namely, the HCC and PC studies are both aligned to the CS study by running GromovMatcher twice, and after obtaining these matchings, our analysis is restricted to those features in HCC and PC that are present in the CS study.</p><p>After the reviewer’s comment, we have added an additional sensitivity analysis in Appendix 5, to compare the results produced by GromovMatcher depending on the choice of the reference study. Namely, setting the reference study to either the CS study or the HCC study, GromovMatcher identified 706 and 708 common features respectively, with an overlap of 640 features. This highlights that the choice of reference does matter to some extent. In our original analysis of the EPIC data, choosing CS as the reference was motivated by the fact that CS had the largest sample size (compared to HCC and PC) and a subset of features in HCC and PC were already matched by experts to the CS study which we could use for validation (see Loftfield et al. (2021). J Natl Cancer Inst.).</p><p>As mentioned in the discussion section of our manuscript, the recently proposed multimarginal Gromov-Wasserstein algorithm (Beier, F., Beinert, R., &amp; Steidl, G. (2023). Information and Inference) could potentially allow multiple metabolomic studies to be matched using one optimization routine (e.g. without the designation of a ‘reference study’ for matching). We have not explored this possibility in depth yet as fast numerical methods for multimarginal GW are still in their infancy. Also, such multimarginal methods rely on the computation and storage of coupling or matching matrices that are tensors where the number of dimensions is equal to the number of datasets being matched. Therefore, multimarginal methods have large memory costs, which currently precludes their application for the matching of multiple metabolomics datasets.</p><disp-quote content-type="editor-comment"><p><bold>Reviewer #2 (Recommendations For The Authors):</bold></p><p>(1) I was struggling with the representation used in Figure 3a. The gray points overlayed over the green points on a straight line are difficult to visually quantify. I found that my eyes mainly focused on the pattern of the red dots.</p></disp-quote><p>Figure 3a has been modified to improve visual clarity. Namely we have consistently reordered the rows and columns of the coupling matrices such that the true positive matches (green points) are spatially separated from the false negative matches (red points). Now the fraction of true positive and false negative matches can be appreciated much more clearly by eye in Figure 3a.</p><disp-quote content-type="editor-comment"><p>(2) I would also like to add the caveat that I cannot judge whether the authors used the other two methods that they compare with GromovMatcher (the M2S and metabCombiner) optimally. But I also do not see any evidence that they did not. Hopefully one of the other reviewers can address that.</p></disp-quote><p>We appreciate the reviewer for highlighting the comparison of our approach GromovMatcher to the other existing methods M2S and MetabCombiner (mC). Both M2S and mC depend on tens of hyperparameters each with a discrete or continuous set of values that must be properly optimized to infer accurate matchings between dataset features. We detail in Appendix 2 how the hyperparameters of the M2S and mC methods are optimally tuned to achieve the best possible performance on the validation ground-truth data. Namely, both in the simulation study and on EPIC data, we grid-search over all important hyperparameters in the M2S and mC methods and choose those parameter combinations that result in the highest F1 score, averaged over 20 random trials. We remark that no such hyperparameter optimization was performed for our GromovMatcher method. As shown in Figures 3 and 4 of the main text, we find that GromovMatcher outperforms M2S and mC even in these cases when the hyperparameters of M2S and mC are tuned to predict optimal feature matchings.</p><p>Given the large combinatorial space of hyperparameter choices, we believe we have thoroughly tested the important hyperparameter combinations that users of M2S and mC would be likely to explore in their own research.</p><disp-quote content-type="editor-comment"><p>(3) Validation</p><p>(3a) The first validation is done on a split cord blood dataset. I could not clearly see from the paper how sensitive the result is to the dataset split.</p></disp-quote><p>We are grateful for the reviewer’s question and have included new experiments in Appendix 3 which show how the results of GromovMatcher, M2S, and MetabCombiner are affected by the dataset split. In our original manuscript, our validation ground-truth experiment began with an untargeted metabolomic dataset consisting of n = 499 samples and p = 4,712 metabolic features which is split equally into two datasets consisting of an equal number of samples n1 = n2 and an equal number of metabolic features p1 = p2. The features of these equal-sized datasets would then be matched by our method.</p><p>Now in Appendix 3 (Figs. 1-3) we show the sensitivity of all three alignment methods (GromovMatcher, M2S, and MetabCombiner) when we vary the fraction of samples in dataset 1 over dataset 2 given by n1/ n2, the overlap in shared features between both datasets, and the fraction of metabolic features in dataset 1 that are not present in dataset 2 which affects the feature sizes of both datasets p1/ p2. We find that all alignment methods are able to maintain a consistent precision and recall score when these three dataset split parameters are varied. GromovMatcher achieves a higher precision and recall than M2S and MetabCombiner for all choices of dataset split, agreeing with the validation experiment results from the main text (see main text Fig. 3). All three methods tested decrease in precision (without dropping in recall) when dataset 1 and dataset 2 contain an equal number of unshared features (e.g. when p1 = p2). Therefore, these sensitivity experiments in Appendix 3 show that our results in the main text are performed in the most challenging setting for the dataset split.</p><disp-quote content-type="editor-comment"><p>(3b) The second validation was done using a (scaled and centered) dataset of metabolics from cancer datasets from the EPIC cohort that was manually matched by an expert. Here the authors observe that metabCombiner has good precision, but lags in recall. And M2S has a very similar performance to GromovMatcher. The authors explain this by the fact that the drift in RT between the two experiments is mostly linear and thus does not affect the M2S performance. Can the authors find a different validation dataset where the drift in RT is not linear? If yes, it would be interesting to add it to the paper.</p></disp-quote><p>We thank the reviewer for raising this question. As mentioned above, curated validation datasets such as the EPIC study analyzed in our paper are very rare and we do not currently have a validation study with a nonlinear retention time drift.</p><p>Nevertheless, we performed an additional analysis of simulated data (reported in Appendix 2 – “M2S hyperparameter experiments” and Appendix 2 – Table 1) that demonstrates the decrease in M2S performance when the simulated drift is nonlinear. As presented in Appendix 2 – Table 1, in a low overlap setting with a linear drift which corresponds to the EPIC data, precision and recall were 0.831 and 0.934 respectively, instead of 0.769 and 0.905 in the main analysis where the drift was nonlinear.</p></body></sub-article></article>